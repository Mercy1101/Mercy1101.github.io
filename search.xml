<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客品控手册</title>
      <link href="/2025/01/22/2025-01-22-%E5%8D%9A%E5%AE%A2%E5%93%81%E6%8E%A7%E6%89%8B%E5%86%8C/"/>
      <url>/2025/01/22/2025-01-22-%E5%8D%9A%E5%AE%A2%E5%93%81%E6%8E%A7%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/resource/avtar.jpeg"></p><p>《博客品控手册》旨在建立系统化技术写作流程，提升个人博客质量与持续性。</p><span id="more"></span><h2 id="Changlog"><a href="#Changlog" class="headerlink" title="Changlog"></a>Changlog</h2><h3 id="李建聪-2023-01-21-MVP-版本"><a href="#李建聪-2023-01-21-MVP-版本" class="headerlink" title="李建聪 2023-01-21 MVP 版本"></a>李建聪 2023-01-21 MVP 版本</h3><ul><li>最小可行产品（MVP）版本</li><li>以“专业且不失亲和力”为主线，梳理写作目标、受众及品控流程</li></ul><p>（补充说明：本版本作为基础雏形，持续迭代。）</p><h2 id="本手册愿景"><a href="#本手册愿景" class="headerlink" title="本手册愿景"></a>本手册愿景</h2><p>通过本手册手册，建立系统化、可持续的技术输出方法，指导个人的博客写作，提升产出质量与持续性。</p><h2 id="本手册价值"><a href="#本手册价值" class="headerlink" title="本手册价值"></a>本手册价值</h2><ol><li>建立系统化、可持续的技术输出方法，指导个人的博客写作，提升产出质量与持续性。</li><li>有了清晰的标准和流程，可以专注于内容本身的价值，减少发布前反复纠结或疏漏。</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>每篇博客既是个人知识体系的沉淀，也能为他人提供实用指引</li><li>梳理知识盲区，构建可追溯、可复用的个人知识体系</li><li>通过写作倒逼深度思考，记录技术成长轨迹</li></ul><h2 id="读者-受众"><a href="#读者-受众" class="headerlink" title="读者&#x2F;受众"></a>读者&#x2F;受众</h2><ul><li>自己 + 同事 + 行内开发者</li><li>志同道合的学习者</li></ul><h2 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h2><ul><li>专业且不失亲和力</li></ul><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><ul><li>技术类分享</li><li>AI 应用或其他领域知识见闻</li><li>遇到的技术问题与解决思路</li><li>PMP&#x2F;ACP 等管理类知识总结</li></ul><h2 id="标准操作流程-SOP"><a href="#标准操作流程-SOP" class="headerlink" title="标准操作流程 SOP"></a>标准操作流程 SOP</h2><p>TODO</p><h2 id="质量基线"><a href="#质量基线" class="headerlink" title="质量基线"></a>质量基线</h2><p>TODO</p>]]></content>
      
      
      
        <tags>
            
            <tag> 品控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++线程知识简介</title>
      <link href="/2024/03/27/2024-03-19-C++%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/03/27/2024-03-19-C++%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>假设我们使用的是多核 CPU，且无法避免使用多线程。站在产品的稳定性和性能优化的角度，对线程知识进行简介。</p><span id="more"></span><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>假设我们使用的是多核 CPU，且无法避免使用多线程。站在产品的稳定性和性能优化的角度，对线程知识进行简介。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>为了在多线程的编程环境中，更好发挥多核CPU的性能，并对多线程相关的缺陷加以了解并进行规避。着重于讲<code>并行</code>而非<code>并发</code>的情况。</p><p>并行(<code>Parallel</code>)与并发(<code>Concurrent</code>):</p><ul><li>并行: 单线程。</li><li>并发: 多线程。</li></ul><p>并发:</p><table><thead><tr><th align="center">任务1</th><th align="center">任务2</th></tr></thead><tbody><tr><td align="center">执行语句1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">执行语句2</td></tr><tr><td align="center">执行语句3</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">执行语句4</td></tr></tbody></table><p>并行:</p><table><thead><tr><th align="center">任务1</th><th align="center">任务2</th></tr></thead><tbody><tr><td align="center">执行语句1</td><td align="center">执行语句2</td></tr></tbody></table><h2 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h2><ol><li>一个数据如果一个时刻是只读的，那么在这个时刻该数据是线程安全的。</li><li>一个数据被多个线程同时读写，那么该数据是线程不安全的。</li><li>在同一个线程中，对一个普通互斥量加锁两次，会发生死锁。</li><li><code>int</code>、<code>unsigned</code>、<code>char</code>、<code>double</code> 等基本类型，均为线程不安全的。</li><li>互斥量的创建、加锁和解锁操作本身，并不耗时。</li></ol><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h3><p>场景举例:</p><ol><li><img src="/resource/2024-03-19-thread/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B-%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png"></li><li>通信线程之间同步消息序列号。</li><li>ATS线程写入列车信息，其他线程读取。</li></ol><ul><li>C++ STL 互斥量版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">....</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure><ul><li>C++ STL 读写锁版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_mutex mutex;</span><br><span class="line"><span class="type">int</span> sharedData = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readerThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writerThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    sharedData += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">写入线程</th><th align="center">读取线程1</th><th align="center">读取线程2</th></tr></thead><tbody><tr><td align="center"></td><td align="center">readerThread()</td><td align="center">readerThread()</td></tr><tr><td align="center">writerThread()</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>C++ STL 原子变量版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 线程安全</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 线程安全</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Windows API 版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hMutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建互斥量</span></span><br><span class="line">hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hMutex == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭互斥量</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hMutex);</span><br></pre></td></tr></table></figure><ul><li>Windows 临界区版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"><span class="comment">// 初始化临界区</span></span><br><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="comment">// 删除临界区</span></span><br><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure><p>注: <code>EnterCriticalSection</code> 和 <code>WaitForSingleObject</code> 的区别:</p><ol><li><code>WaitForSingleObject</code> 因为涉及到 用户态和内核态的切换，更慢。</li><li><code>WaitForSingleObject</code> 可以用于进程间的同步，而 <code>EnterCriticalSection</code> 不能。</li><li><code>WaitForSingleObject</code> 可以达到超时等待的效果，而 <code>EnterCriticalSection</code> 会一直等待。</li><li>在同一线程中多次调用 <code>WaitForSingleObject</code> 和 <code>EnterCriticalSection</code> 都不会产生死锁。</li></ol><ul><li>pthread 版本</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><ul><li>注:<code>pthread_mutex_t</code> 默认是不可被同一线程加锁两次的，即不可重入。如果想要可以重入则需要设置属性。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line"><span class="built_in">pthread_mutexattr_init</span>(&amp;mutex_attr);</span><br><span class="line"><span class="built_in">pthread_mutexattr_settype</span>(&amp;mutex_attr, PTHREAD_MUTEX_RECURSIVE); <span class="comment">// 设置为可重入</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex, &amp;mutex_attr); <span class="comment">// 使用属性，初始化互斥量</span></span><br></pre></td></tr></table></figure><ul><li>gos 库版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HANDLE mutex_ = <span class="built_in">gos_mutex_init</span>();</span><br><span class="line"><span class="built_in">gos_mutex</span>(mutex_);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">gos_unmutex</span>(mutex_);</span><br><span class="line"><span class="built_in">gos_mutex_free</span>(mutex_);</span><br></pre></td></tr></table></figure><p>注:</p><ol><li>gos 库版本的互斥量，在 <code>window</code> 下是可重入的, 在 <code>linux</code> 下是不可重入的。</li></ol><h3 id="后台运行周期性任务"><a href="#后台运行周期性任务" class="headerlink" title="后台运行周期性任务"></a>后台运行周期性任务</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NTPClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 进行NTP同步, 后台线程周期运行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ntp_sync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/// 获取NTP是否成功, 业务线程调用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get_ntp_valid</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>C++ STL 标准库版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NTPClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntp_sync_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        client.<span class="built_in">ntp_sync</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(ntp_sync_thread)</span></span>;</span><br><span class="line"><span class="comment">/// 分离线程</span></span><br><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><ul><li>pthread 版本:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span>      stAttr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设置 pthread 属性</span></span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;stAttr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;stAttr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化线程</span></span><br><span class="line"><span class="type">pthread_t</span> thread_id;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;thread_id, <span class="literal">NULL</span>, threadFunction, &amp;client);</span><br></pre></td></tr></table></figure><ul><li>windows 版本:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 1. Windows API:</span></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, threadFunction, &amp;client, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 分离线程</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2. Vistual C++ CRT 版本</span></span><br><span class="line"><span class="type">uintptr_t</span> hThread = _beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, threadFunction, &amp;client, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>为什么选择 <code>_beginthreadex</code> 而不是 <code>CreateThread</code>?</p><p><code>_beginthreadex</code> 为每个线程分配自己的<code>tiddata</code>内存结构, 其中保存了 C 语言中的全局变量, 如 <code>errno</code>。</p><p>参考资料: <a href="https://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022036.html">windows 多线程： CreateThread、_beginthread、_beginthreadex、AfxBeginThread 的区别</a></p><ul><li>gos 库版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NTPClientThread</span>: <span class="keyword">public</span> GThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">NTPClientThread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GOS_THREAD_RET <span class="title">ThreadEntry</span><span class="params">(<span class="type">void</span>* pPara)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            client.<span class="built_in">ntp_sync</span>();</span><br><span class="line">            GThread::<span class="built_in">Sleep</span>(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NTPClient client;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后台运行耗时任务-一次性任务"><a href="#后台运行耗时任务-一次性任务" class="headerlink" title="后台运行耗时任务(一次性任务)"></a>后台运行耗时任务(一次性任务)</h3><p>场景举例:</p><ol><li>耗时函数放到后台运行，结果想要获取时再主动获取。</li><li>两个执行时间非常长的函数，并行执行可节省时间。</li><li>等待打印机打印的同时，继续执行其他任务。</li></ol><p>实现思路:</p><ol><li>启动一个线程，运行一个函数，函数运行结束，线程退出。</li><li>业务线程: 创建后台线程。</li><li>后台线程: 运行函数，函数结束后退出。</li><li>业务线程: 等待后台线程结束后，取得函数结果。</li></ol><ul><li>C++ STL 标准库版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([&amp;i]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    i = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>C++ STL 异步版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::async 在后台执行函数并获取结果</span></span><br><span class="line"><span class="keyword">auto</span> future = std::<span class="built_in">async</span>(std::launch::async, [&amp;i]() &#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束并获取结果</span></span><br><span class="line">i = future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>Windows API 版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">f</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, f, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程句柄</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>pthread 版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> t;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;t, <span class="literal">NULL</span>, f, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束</span></span><br><span class="line"><span class="built_in">pthread_join</span>(t, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h2 id="线程主动停止与资源释放"><a href="#线程主动停止与资源释放" class="headerlink" title="线程主动停止与资源释放"></a>线程主动停止与资源释放</h2><p>线程正在运行时，对线程进行销毁(free, delete)，可能会访问到已经被释放的内存，导致程序崩溃。</p><p>因此，线程停止时需要等待线程结束后再释放资源。</p><p>对于 <code>joinable</code> 的线程，需要调用 <code>join</code> 函数等待线程结束后再释放资源。</p><p>但对于 <code>detach</code> 的线程，如何知晓线程函数执行完毕。</p><p>场景举例: 视频播放线程的主动停止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPlayAndRec</span> : <span class="keyword">public</span> GThread</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">ThreadPlayAndRec* p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">p-&gt;<span class="built_in">Start</span>();</span><br><span class="line">...</span><br><span class="line">p-&gt;<span class="built_in">Stop</span>();</span><br><span class="line"><span class="comment">/// 通知线程结束后需要等待多久，线程函数才会结束</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>解决办法: 设置结束标识位来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ThreadPlayAndRec::Free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ulThreadState = THREAD_STATE_CLOSING;</span><br><span class="line">    <span class="built_in">Stop</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_ulThreadState == THREAD_STATE_FREE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">gos_sleep_1ms</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPlayAndRec* p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">p-&gt;<span class="built_in">Start</span>(); <span class="comment">///&lt; 通知线程开始</span></span><br><span class="line">...</span><br><span class="line">p-&gt;<span class="built_in">Stop</span>(); <span class="comment">///&lt; 通知线程结束</span></span><br><span class="line">p-&gt;<span class="built_in">Free</span>(); <span class="comment">///&lt; 阻塞等待线程结束</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p><img src="/resource/2024-03-19-thread/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B-%E6%B5%81%E7%A8%8B%E5%9B%BE-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9C%BA.drawio.png"></p><p>温州S2项目对 GThread 的改动:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">p-&gt;<span class="built_in">Start</span>(); <span class="comment">///&lt; 通知线程开始</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">///&lt; 等待线程结束后, 释放资源</span></span><br></pre></td></tr></table></figure><h2 id="线程唤醒（线程池）"><a href="#线程唤醒（线程池）" class="headerlink" title="线程唤醒（线程池）"></a>线程唤醒（线程池）</h2><p>场景举例: 线程池中的线程，在任务队列出现任务时，唤醒一个线程进行处理。</p><ul><li>Linux 信号量举例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 初始化</span></span><br><span class="line"><span class="built_in">sem_init</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 等待信号量唤醒</span></span><br><span class="line"><span class="built_in">sem_wait</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 信号量唤醒</span></span><br><span class="line"><span class="built_in">sem_post</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 回收资源</span></span><br><span class="line"><span class="built_in">sem_destroy</span>()</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">生产者线程</th><th align="center">业务线程1</th><th align="center">业务线程2</th></tr></thead><tbody><tr><td align="center">初始化 sem_init()</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">等待唤醒 sem_wait()</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">等待唤醒 sem_wait()</td></tr><tr><td align="center">消息入列 sem_post()</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">被唤醒后, 取出消息并处理</td><td align="center"></td></tr><tr><td align="center">回收资源 sem_destroy()</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>pthread 条件变量版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunction</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread received signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, threadFunction, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 主线程等待一段时间后发送信号</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 唤醒线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++ STL 风格代码举例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="comment">/// 这个封装好的函数放入任务列表中</span></span><br><span class="line">    tasks.<span class="built_in">emplace</span>(&amp;f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通知一个阻塞中的线程，任务队列中有任务了</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">    <span class="comment">/// 阻塞等待直到函数返回 true</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">    <span class="comment">/// 从任务队列中拿出来一个任务</span></span><br><span class="line">    task = <span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">生产者线程</th><th align="center">业务线程1</th><th align="center">业务线程2</th></tr></thead><tbody><tr><td align="center"></td><td align="center">条件变量阻塞等待(<code>wait()</code>)</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">条件变量阻塞等待(<code>wait()</code>)</td></tr><tr><td align="center">消息入列</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">唤醒线程(<code>notify_one()</code>)</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">被唤醒(条件变量停止阻塞)</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">获取消息并执行业务</td><td align="center"></td></tr></tbody></table><h2 id="线程安全中所涉及的问题"><a href="#线程安全中所涉及的问题" class="headerlink" title="线程安全中所涉及的问题"></a>线程安全中所涉及的问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>情况1:</li></ul><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">获取互斥量1</td><td align="center">获取互斥量2</td></tr><tr><td align="center">获取互斥量2</td><td align="center">获取互斥量1</td></tr></tbody></table><p>解决办法：</p><ol><li>一次只获取一个互斥量。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 STL 的语法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mutex1, mutex2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread acquired locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情况2:</li></ul><table><thead><tr><th align="center">线程1</th></tr></thead><tbody><tr><td align="center">获取互斥量1</td></tr><tr><td align="center">获取互斥量1</td></tr></tbody></table><p>解决办法:</p><ol><li>使用带有可重入属性的互斥量。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// STL</span></span><br><span class="line">std::recursive_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// pthread</span></span><br><span class="line"><span class="built_in">pthread_mutexattr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_mutexattr_settype</span>(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// window API</span></span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure><ul><li>情况3:</li></ul><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">等待线程2 join</td><td align="center">等待线程1 join</td></tr></tbody></table><p>解决办法:</p><ol><li>在同一线程创建其他线程，也在同一线程进行 join。</li></ol><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">查询余额, 并存储进变量 i</td><td align="center">查询余额, 并存储进变量 i</td></tr><tr><td align="center">if(i &gt;&#x3D; 50)</td><td align="center">if(i &gt;&#x3D; 50)</td></tr><tr><td align="center">i &#x3D; i - 50;</td><td align="center">i &#x3D; i - 50;</td></tr><tr><td align="center">更新余额为 50</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新余额为 50</td></tr></tbody></table><p>解决办法:</p><ol><li>串行执行</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">|          线程<span class="number">1</span>           |          线程<span class="number">2</span>           |</span><br><span class="line">| :----------------------: | :----------------------: |</span><br><span class="line">|     获取互斥量 mtx1      |     获取互斥量 mtx1      |</span><br><span class="line">|      获取互斥量成功      |                          |</span><br><span class="line">| 查询余额, 并存储进变量 i |                          |</span><br><span class="line">|       <span class="keyword">if</span>(i &gt;= <span class="number">50</span>)        |                          |</span><br><span class="line">|       i = i - <span class="number">50</span>;        |                          |</span><br><span class="line">|      更新余额为 <span class="number">50</span>       |                          |</span><br><span class="line">|        释放互斥量        |                          |</span><br><span class="line">|                          |      获取互斥量成功      |</span><br><span class="line">|                          | 查询余额, 并存储进变量 i |</span><br><span class="line">|                          |       <span class="keyword">if</span>(i &gt;= <span class="number">100</span>)       |</span><br><span class="line">|                          |       i = i - <span class="number">50</span>;        |</span><br><span class="line">|                          |      更新余额为 <span class="number">50</span>       |</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 使用 <span class="built_in">CAS</span>(Compare And Swap) 的方法</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">|                        线程<span class="number">1</span>                         |                        线程<span class="number">2</span>                         |</span><br><span class="line">| :--------------------------------------------------: | :--------------------------------------------------: |</span><br><span class="line">|               查询余额, 并存储进变量 i               |               查询余额, 并存储进变量 i               |</span><br><span class="line">|                     <span class="keyword">if</span>(i == <span class="number">100</span>)                     |                     <span class="keyword">if</span>(i == <span class="number">100</span>)                     |</span><br><span class="line">|                     i = i - <span class="number">50</span>;                      |                     i = i - <span class="number">50</span>;                      |</span><br><span class="line">| 如果当前值为 <span class="number">100</span> 则更新约为 <span class="number">50</span>(compare_and_exchange) |                                                      |</span><br><span class="line">|                  更新成功，事务结束                  |                                                      |</span><br><span class="line">|                                                      | 如果当前值为 <span class="number">100</span> 则更新约为 <span class="number">50</span>(compare_and_exchange) |</span><br><span class="line">|                                                      |                  更新失败，事务结束                  |</span><br></pre></td></tr></table></figure><h3 id="初始化单例"><a href="#初始化单例" class="headerlink" title="初始化单例"></a>初始化单例</h3><p>C++11之前以下全局变量，线程不安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec g_ThreadPlayAndRec; <span class="comment">///&lt; 全局变量,在程序启动时线程不安全</span></span><br></pre></td></tr></table></figure><ul><li>错误的做法1:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">if(!p)</td><td align="center">if(!p)</td></tr><tr><td align="center">new ThreadPlayAndRec();</td><td align="center">new ThreadPlayAndRec();</td></tr><tr><td align="center">p 被赋值</td><td align="center">p 被赋值</td></tr></tbody></table><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">if(!p)</td><td align="center"></td></tr><tr><td align="center">new ThreadPlayAndRec();</td><td align="center">if(!p)</td></tr><tr><td align="center">p 被赋值</td><td align="center">new ThreadPlayAndRec();</td></tr><tr><td align="center"></td><td align="center">p 被赋值</td></tr></tbody></table><ul><li>错误的做法2:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p) <span class="comment">// 第一次检查</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="comment">// 第二次检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常流程:</p><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">if(!p)  第一次检查</td><td align="center">if(!p)  第一次检查</td></tr><tr><td align="center">尝试获取互斥量</td><td align="center">尝试获取互斥量</td></tr><tr><td align="center">获取互斥量成功</td><td align="center"></td></tr><tr><td align="center">if(!p) 再次判断是否为空</td><td align="center"></td></tr><tr><td align="center">new ThreadPlayAndRec();</td><td align="center"></td></tr><tr><td align="center">p 被赋值</td><td align="center"></td></tr><tr><td align="center">释放互斥量</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">获取互斥量成功</td></tr><tr><td align="center"></td><td align="center">if(!p) 再次判断是否为空</td></tr><tr><td align="center"></td><td align="center">p 不为空，流程结束</td></tr></tbody></table><p>错误流程:</p><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">if(!p)  第一次检查</td><td align="center"></td></tr><tr><td align="center">尝试获取互斥量</td><td align="center"></td></tr><tr><td align="center">获取互斥量成功</td><td align="center"></td></tr><tr><td align="center">if(!p) 再次判断是否为空</td><td align="center"></td></tr><tr><td align="center">new ThreadPlayAndRec();</td><td align="center"></td></tr><tr><td align="center">p 被赋值</td><td align="center">if(!p)  第一次检查</td></tr></tbody></table><p>最后一步产生了读写竞争。</p><ul><li>解决办法:</li></ul><ol><li>在 C++11 标准下使用 全局&#x2F;静态变量。</li><li>使用 C++11 中提供的 <code>std::call_once</code> 保证初始化函数只被调用一次。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::once_flag flag;</span><br><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line">std::<span class="built_in">call_once</span>(flag, []() &#123; p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>(); &#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用互斥量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在 C++11 之前，使用 <code>Linux API</code> 或者 <code>Windows API</code> 函数。</li></ol><p>linux:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialization function executed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只会执行一次</span></span><br><span class="line"><span class="built_in">pthread_once</span>(&amp;once_control, init_function);</span><br></pre></td></tr></table></figure><p>windows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="keyword">if</span> (!initialized)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init_function</span>();</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure><ol start="5"><li><p>不管, 成本最低也是最适合我们的方法。</p></li><li><p>使用 <code>gos::singleton</code>, 其实现思路是 C++11 之前使用 double-check lock 的方法， C++11 之后使用 <code>std::call_once</code>。</p></li></ol><h3 id="多个线程同时开始"><a href="#多个线程同时开始" class="headerlink" title="多个线程同时开始"></a>多个线程同时开始</h3><p>测试线程需要被测试函数同时并行执行。</p><ul><li>C++ STL 条件变量实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex_;</span><br><span class="line">std::condition_variable cv_;</span><br><span class="line"><span class="type">bool</span> ready_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::jthread <span class="title">j</span><span class="params">([<span class="keyword">this</span>]() <span class="keyword">mutable</span></span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::unique_lock&lt;std::mutex&gt; mutex(mutex_);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">/// 等待同步开始</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    cv_.wait(mutex, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> ready_; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">/// 执行函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    f();</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;)</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 锁定互斥量，以修改 ready_</span></span><br><span class="line">mutex_.<span class="built_in">lock</span>();</span><br><span class="line">ready_ = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/// 发送给所有的线程，可以开始运行</span></span><br><span class="line">cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">mutex_.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure><h3 id="隐藏的多线程问题"><a href="#隐藏的多线程问题" class="headerlink" title="隐藏的多线程问题"></a>隐藏的多线程问题</h3><ul><li><p>场景1: 在通信线程，直接使用修改界面的语句。<br>注: 界面有自己的线程调度，如果在其他线程中直接修改界面，可能会导致界面崩溃。</p></li><li><p>场景2: 在回调函数中使用共享变量(全局、静态或类成员变量)。<br>注: 回调函数一定在其他线程中执行，如果在回调函数中使用共享变量，可能会导致线程不安全。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Issue 规范化建议</title>
      <link href="/2023/11/09/2023-11-09-Issue%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%AE/"/>
      <url>/2023/11/09/2023-11-09-Issue%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>使用 <code>Issue</code> 对软件工程的过程进行记录，对软件工程各种议题进行流程记录，方便复盘和分析统计。</p><span id="more"></span><h2 id="目的-Objective"><a href="#目的-Objective" class="headerlink" title="目的(Objective)"></a>目的(Objective)</h2><p>使用 <code>Issue</code> 对软件工程的过程进行记录，对软件工程各种议题进行流程记录，方便复盘和分析统计。</p><p>本次不对以下议题进行讨论:</p><ol><li>缺陷管理流程</li><li>缺陷描述技巧</li><li>缺陷解决方法</li></ol><h2 id="要求-Requirements"><a href="#要求-Requirements" class="headerlink" title="要求(Requirements)"></a>要求(Requirements)</h2><h3 id="内容-Content"><a href="#内容-Content" class="headerlink" title="内容(Content)"></a>内容(Content)</h3><p>必备元素:</p><ol><li>问题描述</li><li>相关日志</li></ol><p>最好有复现的图片、动图或视频</p><p>以下是温州二号线 <code>Bug Issue</code> 模版:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 概要</span></span><br><span class="line"></span><br><span class="line">(简明扼要的描述你遇到的BUG)</span><br><span class="line"></span><br><span class="line"><span class="section">## 相关方</span></span><br><span class="line"></span><br><span class="line">(抄送给谁)</span><br><span class="line"></span><br><span class="line"><span class="section">## 运行环境描述</span></span><br><span class="line"></span><br><span class="line">(如服务器运行在哪台机器，数据库用的是哪个，分别都是什么操作系统，ip 都是什么)</span><br><span class="line"></span><br><span class="line"><span class="section">## 复现步骤</span></span><br><span class="line"></span><br><span class="line">复现概率: 100%</span><br><span class="line"></span><br><span class="line">(怎么样让这个问题复现以及概率？ 非常重要！)</span><br><span class="line"></span><br><span class="line"><span class="section">## 期待的正确现象是什么?</span></span><br><span class="line"></span><br><span class="line">(该功能正常运行的现象是什么)</span><br><span class="line"></span><br><span class="line"><span class="section">## 相关日志、截图</span></span><br><span class="line"></span><br><span class="line">(把相关日志粘贴在这里， 请使用代码块格式(<span class="code">```)来显示命令行输出或日志)</span></span><br></pre></td></tr></table></figure><p>以下是温州二号线 <code>Feature Issue</code> 模版:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 描述理想的解决方案或功能请求</span></span><br><span class="line"></span><br><span class="line">(对功能进行清晰简洁的描述)</span><br><span class="line"></span><br><span class="line"><span class="section">### 难度、影响评估</span></span><br><span class="line"></span><br><span class="line">(实现难度与对目前功能或代码的影响)</span><br><span class="line"></span><br><span class="line"><span class="section">### 使用频率评估</span></span><br><span class="line"></span><br><span class="line">(该功能使用频率)</span><br><span class="line"></span><br><span class="line"><span class="section">### 需求追踪</span></span><br><span class="line"></span><br><span class="line">(添加更多关于谁提出这个需求，即公司，个人(以及其身份)，他们付给我们多少钱，他们的等级是什么。)</span><br></pre></td></tr></table></figure><h3 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签(Label)"></a>标签(Label)</h3><p>对项目总结， Issue 大致分为:</p><ol><li>缺陷(Bug)</li><li>需求(Feature)</li><li>其他: 运维(Ops), 问题(Question)</li></ol><p>大部分为缺陷。</p><p>对于缺陷，我们关注以下几点:</p><ol><li>是否是业主上报</li><li>是否导致现场功能不可用</li><li>是否是实验室人员上报</li><li>导致缺陷的原因是什么</li><li>导致缺陷的人是谁</li></ol><p>对于需求，我们关注以下几点:</p><ol><li>是否是必须实现的</li><li>是否是业主提出的</li><li>是否是内部提出的优化项</li></ol><p>所以提议对 Issue 标签(Label)的具体结构进行设计:</p><ul><li><p>缺陷</p></li><li><p>来源: 现场</p></li><li><p>来源: 内部</p></li><li><p>缺陷关闭: 逻辑错误</p></li><li><p>缺陷关闭: 环境&#x2F;操作问题</p></li><li><p>缺陷关闭: 误报</p></li><li><p>缺陷关闭: 无法复现</p></li><li><p>缺陷关闭: 重复</p></li><li><p>缺陷关闭: 其他</p></li><li><p>失误: 研发人员1</p></li><li><p>失误: 研发人员2</p></li><li><p>需求: 必须</p></li><li><p>需求: 优化</p></li></ul><ol><li><code>来源: 现场</code>: 包括来源为现场实施人员和外部输入（标书、业主人员、总包人员、对接厂商人员）。</li><li>标签为<code>需求: xxx</code>或 <code>缺陷</code> 需要标识对应的<code>来源: xxx</code>。</li><li>标签为<code>来源: 现场</code>在关闭时，需要标识对应<code>缺陷关闭: xxx</code>。</li><li>标签为<code>缺陷关闭: 逻辑错误</code>的，需要标识对应的<code>失误: xxx</code>。</li></ol><p>Label 应拥有统一的配色。</p><ul><li><p>缺陷(#ff0000)</p></li><li><p>来源: 现场(#ff0000)</p></li><li><p>来源: 内部(#AD4363)</p></li><li><p>缺陷关闭: 逻辑错误(#ff0000)</p></li><li><p>缺陷关闭: 环境&#x2F;操作问题(#5843AD)</p></li><li><p>缺陷关闭: 误报(#5843AD)</p></li><li><p>缺陷关闭: 无法复现(#5843AD)</p></li><li><p>缺陷关闭: 重复(#5843AD)</p></li><li><p>缺陷关闭: 其他(#5843AD)</p></li><li><p>失误: 研发人员1(#AD8D43)</p></li><li><p>失误: 研发人员2(#AD8D43)</p></li><li><p>需求: 必须(#007FFF)</p></li><li><p>需求: 优化(#44AD8E)</p></li></ul><p>配色效果如下：</p><p><img src="/../resource/2023-11-09-Issue%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%AE/Snipaste_2023-11-09_15-24-28.png"></p><p><img src="/../resource/2023-11-09-Issue%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%AE/Snipaste_2023-11-09_15-26-07.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++证明为什么operator==不能用memcmp实现</title>
      <link href="/2023/09/22/2023-09-22-C++%E8%AF%81%E6%98%8E%E4%B8%BA%E4%BB%80%E4%B9%88operator==%E4%B8%8D%E8%83%BD%E7%94%A8memcmp%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/09/22/2023-09-22-C++%E8%AF%81%E6%98%8E%E4%B8%BA%E4%BB%80%E4%B9%88operator==%E4%B8%8D%E8%83%BD%E7%94%A8memcmp%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文主要讨论结构体重载 <code>operator==</code> 能否直接使用 <code>memcmp</code> 实现。</p><span id="more"></span><p>问： 结构体重载 <code>operator==</code> 能否直接使用 <code>memcmp</code> 实现？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 这样实现是否正确</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> obj&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">memcmp</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(other)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先说结论：不可以。</p><p>理由为：</p><ol><li>非 <code>POD</code> 类型的结构体，拥有容器类型的成员中可能存在动态内存，其地址肯定不一样，但内容可能一样，因此不能直接使用 <code>memcmp</code> 来比较。</li><li><code>POD</code> 类型，数组中没有被赋值的垃圾值，会影响内存比较结果。如果保存了指针又想要比较指针指向的内容是否一致，则也不能直接使用 <code>memcmp</code> 来比较。</li></ol><p>见如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> obj&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">memcmp</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(other)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> ulUserID;</span><br><span class="line">    <span class="type">char</span> acName[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> ulDCType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj st;</span><br><span class="line">    obj st1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(st == st1);  <span class="comment">///&lt; 无法通过</span></span><br><span class="line"></span><br><span class="line">    st.ulUserID = <span class="number">1</span>;</span><br><span class="line">    st.ulDCType = <span class="number">1</span>;</span><br><span class="line">    st.acName[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    st<span class="number">1.</span>ulUserID = <span class="number">1</span>;</span><br><span class="line">    st<span class="number">1.</span>ulDCType = <span class="number">1</span>;</span><br><span class="line">    st<span class="number">1.</span>acName[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert</span>(st == st1);  <span class="comment">///&lt; 无法通过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>C++11 以前：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> obj&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ulUserID == other.ulUserID</span><br><span class="line">            &amp;&amp; ulDCType == other.ulDCType</span><br><span class="line">            &amp;&amp; <span class="built_in">strcmp</span>(acName, other.acName, <span class="built_in">sizeof</span>(acName)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> ulUserID;</span><br><span class="line">    <span class="type">char</span> acName[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> ulDCType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++11 以后 C++20 以前：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> obj&amp; other) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> ulUserID;</span><br><span class="line">    <span class="type">char</span> acName[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> ulDCType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++20 以后：</p><pre><code class="language-c++">struct obj&#123;    auto operator&lt;=&gt;(const obj&amp;) const = default;    unsigned ulUserID;    char acName[32];    unsigned ulDCType;&#125;;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++打印结构体的方法</title>
      <link href="/2023/09/20/2023-09-20-C++%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/09/20/2023-09-20-C++%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>通常在 C++ 语言中，我们无法直接对结构体打印，但是可以通过某种方式来打印结构体。</p><span id="more"></span><p>通常在 C++ 语言中，我们无法直接对结构体打印，但是可以通过某种方式来打印结构体。</p><h2 id="使用友元函数打印"><a href="#使用友元函数打印" class="headerlink" title="使用友元函数打印"></a>使用友元函数打印</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::string s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span>  my_class&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; obj.i &lt;&lt; <span class="string">&quot; s: &quot;</span> &lt;&lt; obj.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_class obj;</span><br><span class="line">    obj.i = <span class="number">1</span>;</span><br><span class="line">    obj.s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; obj &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用宏定义简化定义流程"><a href="#使用宏定义简化定义流程" class="headerlink" title="使用宏定义简化定义流程"></a>使用宏定义简化定义流程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FRIEND_STREAM_1(type, x1)                                           \</span></span><br><span class="line"><span class="meta">    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const type&amp; type_obj) \</span></span><br><span class="line"><span class="meta">    &#123;                                                                       \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #type &lt;&lt; <span class="string">&quot;: this(&quot;</span> &lt;&lt; &amp;type_obj &lt;&lt; <span class="string">&quot;), &quot;</span>;                     \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #x1 &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; type_obj.x1 &lt;&lt; <span class="string">&quot;)&quot;</span>;                             \</span></span><br><span class="line"><span class="meta">        return os;                                                          \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRIEND_STREAM_2(type, x1, x2)                                       \</span></span><br><span class="line"><span class="meta">    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const type&amp; type_obj) \</span></span><br><span class="line"><span class="meta">    &#123;                                                                       \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #type &lt;&lt; <span class="string">&quot;: this(&quot;</span> &lt;&lt; &amp;type_obj &lt;&lt; <span class="string">&quot;), &quot;</span>;                     \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #x1 &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; type_obj.x1 &lt;&lt; <span class="string">&quot;), &quot;</span>;                           \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #x2 &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; type_obj.x2 &lt;&lt; <span class="string">&quot;) &quot;</span>;                            \</span></span><br><span class="line"><span class="meta">        return os;                                                          \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRIEND_STREAM_3(type, x1, x2, x3)                                   \</span></span><br><span class="line"><span class="meta">    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const type&amp; type_obj) \</span></span><br><span class="line"><span class="meta">    &#123;                                                                       \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #type &lt;&lt; <span class="string">&quot;: this(&quot;</span> &lt;&lt; &amp;type_obj &lt;&lt; <span class="string">&quot;), &quot;</span>;                     \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #x1 &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; type_obj.x1 &lt;&lt; <span class="string">&quot;), &quot;</span>;                           \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #x2 &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; type_obj.x2 &lt;&lt; <span class="string">&quot;), &quot;</span>;                           \</span></span><br><span class="line"><span class="meta">        os &lt;&lt; #x3 &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; type_obj.x3 &lt;&lt; <span class="string">&quot;) &quot;</span>;                            \</span></span><br><span class="line"><span class="meta">        return os;                                                          \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::string s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FRIEND_STREAM_2</span>(my_class, i, s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MsgPack简介</title>
      <link href="/2023/09/15/2023-09-15-MsgPack%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/09/15/2023-09-15-MsgPack%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>MsgPack 是一个序列化库，可以将对象序列化为二进制数据，也可以将二进制数据反序列化为对象。</p><span id="more"></span><p>MsgPack 是一个序列化库，可以将对象序列化为二进制数据，也可以将二进制数据反序列化为对象。</p><p>与其他数据序列化格式（如JSON和XML）相比，MsgPack 具有更高的性能和更小的序列化大小。它的序列化和反序列化过程非常快速，并且生成的二进制数据体积小，节省带宽和存储空间。</p><p>MsgPack 提供了多种语言的实现，包括但不限于 C&#x2F;C++、Java、Python、JavaScript、Ruby、Go、C#、PHP 等，使得不同语言的应用程序可以方便地进行数据交换和通信。</p><p>MsgPack 的官方网站：<a href="https://msgpack.org/">https://msgpack.org/</a></p><p><a href="https://github.com/msgpack/msgpack-c/tree/cpp_master">MsgPack C++ 版本开源代码库</a></p><h2 id="官网简单示例"><a href="#官网简单示例" class="headerlink" title="官网简单示例"></a>官网简单示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msgpack.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// serializes this object.</span></span><br><span class="line">        std::vector&lt;std::string&gt; vec;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;MessagePack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// serialize it into simple buffer.</span></span><br><span class="line">        msgpack::sbuffer sbuf;</span><br><span class="line">        msgpack::<span class="built_in">pack</span>(sbuf, vec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deserialize it.</span></span><br><span class="line">        msgpack::object_handle oh =</span><br><span class="line">            msgpack::<span class="built_in">unpack</span>(sbuf.<span class="built_in">data</span>(), sbuf.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print the deserialized object.</span></span><br><span class="line">        msgpack::object obj = oh.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; obj &lt;&lt; std::endl;  <span class="comment">//=&gt; [&quot;Hello&quot;, &quot;MessagePack&quot;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert it into statically typed object.</span></span><br><span class="line">        std::vector&lt;std::string&gt; rvec;</span><br><span class="line">        obj.<span class="built_in">convert</span>(rvec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Ipath_to_msgpack/include hello.cc -o hello</span><br><span class="line">$ ./hello</span><br><span class="line">[<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;MessagePack&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="流式序列化"><a href="#流式序列化" class="headerlink" title="流式序列化"></a>流式序列化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msgpack.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// serializes multiple objects using msgpack::packer.</span></span><br><span class="line">        msgpack::sbuffer buffer;</span><br><span class="line"></span><br><span class="line">        <span class="function">msgpack::packer&lt;msgpack::sbuffer&gt; <span class="title">pk</span><span class="params">(&amp;buffer)</span></span>;</span><br><span class="line">        pk.<span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Log message ... 1&quot;</span>));</span><br><span class="line">        pk.<span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Log message ... 2&quot;</span>));</span><br><span class="line">        pk.<span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Log message ... 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deserializes these objects using msgpack::unpacker.</span></span><br><span class="line">        msgpack::unpacker pac;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// feeds the buffer.</span></span><br><span class="line">        pac.<span class="built_in">reserve_buffer</span>(buffer.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">memcpy</span>(pac.<span class="built_in">buffer</span>(), buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>());</span><br><span class="line">        pac.<span class="built_in">buffer_consumed</span>(buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now starts streaming deserialization.</span></span><br><span class="line">        msgpack::object_handle oh;</span><br><span class="line">        <span class="keyword">while</span>(pac.<span class="built_in">next</span>(oh)) &#123;</span><br><span class="line">            std::cout &lt;&lt; oh.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// results:</span></span><br><span class="line">        <span class="comment">// $ g++ -Ipath_to_msgpack/include stream.cc -o stream</span></span><br><span class="line">        <span class="comment">// $ ./stream</span></span><br><span class="line">        <span class="comment">// &quot;Log message ... 1&quot;</span></span><br><span class="line">        <span class="comment">// &quot;Log message ... 2&quot;</span></span><br><span class="line">        <span class="comment">// &quot;Log message ... 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化-array-与-map"><a href="#序列化-array-与-map" class="headerlink" title="序列化 array 与 map"></a>序列化 <code>array</code> 与 <code>map</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msgpack.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// serializes multiple objects into one message containing an array using msgpack::packer.</span></span><br><span class="line">        msgpack::sbuffer buffer;</span><br><span class="line"></span><br><span class="line">        <span class="function">msgpack::packer&lt;msgpack::sbuffer&gt; <span class="title">pk</span><span class="params">(&amp;buffer)</span></span>;</span><br><span class="line">        pk.<span class="built_in">pack_array</span>(<span class="number">3</span>);</span><br><span class="line">        pk.<span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Log message ... 1&quot;</span>));</span><br><span class="line">        pk.<span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Log message ... 2&quot;</span>));</span><br><span class="line">        pk.<span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Log message ... 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// serializes multiple objects into one message containing a map using msgpack::packer.</span></span><br><span class="line">        msgpack::sbuffer buffer2;</span><br><span class="line"></span><br><span class="line">        <span class="function">msgpack::packer&lt;msgpack::sbuffer&gt; <span class="title">pk2</span><span class="params">(&amp;buffer2)</span></span>;</span><br><span class="line">        pk<span class="number">2.</span><span class="built_in">pack_map</span>(<span class="number">2</span>);</span><br><span class="line">        pk<span class="number">2.</span><span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;x&quot;</span>));</span><br><span class="line">        pk<span class="number">2.</span><span class="built_in">pack</span>(<span class="number">3</span>);</span><br><span class="line">        pk<span class="number">2.</span><span class="built_in">pack</span>(std::<span class="built_in">string</span>(<span class="string">&quot;y&quot;</span>));</span><br><span class="line">        pk<span class="number">2.</span><span class="built_in">pack</span>(<span class="number">3.4321</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化自定义类型"><a href="#序列化自定义类型" class="headerlink" title="序列化自定义类型"></a>序列化自定义类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msgpack.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_str;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; m_vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MSGPACK_DEFINE</span>(m_str, m_vec);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::vector&lt;myclass&gt; vec;</span><br><span class="line">        <span class="comment">// add some elements into vec...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// you can serialize myclass directly</span></span><br><span class="line">        msgpack::sbuffer sbuf;</span><br><span class="line">        msgpack::<span class="built_in">pack</span>(sbuf, vec);</span><br><span class="line"></span><br><span class="line">        msgpack::object_handle oh =</span><br><span class="line">            msgpack::<span class="built_in">unpack</span>(sbuf.<span class="built_in">data</span>(), sbuf.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        msgpack::object obj = oh.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// you can convert object to myclass directly</span></span><br><span class="line">        std::vector&lt;myclass&gt; rvec;</span><br><span class="line">        obj.<span class="built_in">convert</span>(rvec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装序列化函数"><a href="#封装序列化函数" class="headerlink" title="封装序列化函数"></a>封装序列化函数</h2><h3 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msgpack.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取随机整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetRandomInt</span><span class="params">(<span class="type">int</span> min = <span class="number">0</span>, <span class="type">int</span> max = <span class="number">1000000</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::random_device rd;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="type">static</span> std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(min, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dis</span>(gen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取随机字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">GetRandomString</span><span class="params">(<span class="type">size_t</span> len = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::random_device rd;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="type">static</span> std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        str.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + <span class="built_in">dis</span>(gen));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 序列化函数基类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgPackSerialization</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MsgPackSerialization</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MsgPackSerialization&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 序列化</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">Serialization</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        msgpack::sbuffer sbuf;</span><br><span class="line">        msgpack::<span class="built_in">pack</span>(sbuf, *(<span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)));</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">vec</span><span class="params">(sbuf.data(), sbuf.data() + sbuf.size())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 反序列化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Deserialization</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        msgpack::object_handle oh = msgpack::<span class="built_in">unpack</span>(vec.<span class="built_in">data</span>(), vec.<span class="built_in">size</span>());</span><br><span class="line">        msgpack::object obj = oh.<span class="built_in">get</span>();</span><br><span class="line">        obj.<span class="built_in">convert</span>(*(<span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 集成序列化类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> : <span class="keyword">public</span> MsgPackSerialization&lt;myclass&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> myclass&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">    myclass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> myclass&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            m_str = rhs.m_str;</span><br><span class="line">            m_vec = rhs.m_vec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取随机对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> myclass <span class="title">GetRandomObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        myclass obj;</span><br><span class="line">        obj.m_str = <span class="built_in">GetRandomString</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">auto</span> num = <span class="built_in">GetRandomInt</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            obj.m_vec.<span class="built_in">push_back</span>(<span class="built_in">GetRandomInt</span>(<span class="number">0</span>, <span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 为 msgpack 定义序列化和反序列化的字段</span></span><br><span class="line">    <span class="built_in">MSGPACK_DEFINE</span>(m_str, m_vec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_str;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; m_vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 获取随机对象</span></span><br><span class="line">    <span class="keyword">auto</span> obj = myclass::<span class="built_in">GetRandomObj</span>();</span><br><span class="line">    <span class="keyword">decltype</span>(obj) obj2;</span><br><span class="line">    <span class="comment">/// 序列化</span></span><br><span class="line">    <span class="keyword">auto</span> vec = obj.<span class="built_in">Serialization</span>();</span><br><span class="line">    <span class="comment">/// 反序列化</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">Deserialization</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj2 == obj)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj2 == obj&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj2 != obj&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用更加复杂的类进行序列化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myclass2</span> : <span class="keyword">public</span> MsgPackSerialization&lt;myclass2&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> myclass2&amp;) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_str == m_str &amp;&amp; m_vec == m_vec</span><br><span class="line">            &amp;&amp; m_class == m_class &amp;&amp; m_vec_class == m_vec_class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取本类的随机对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> myclass2 <span class="title">GetRandomObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        myclass2 obj;</span><br><span class="line">        obj.m_str = <span class="built_in">GetRandomString</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">auto</span> num = <span class="built_in">GetRandomInt</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            obj.m_vec.<span class="built_in">push_back</span>(<span class="built_in">GetRandomInt</span>(<span class="number">0</span>, <span class="number">1000</span>));</span><br><span class="line">            obj.m_vec_class.<span class="built_in">push_back</span>(myclass::<span class="built_in">GetRandomObj</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        obj.m_class = myclass::<span class="built_in">GetRandomObj</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 为 msgpack 定义序列化和反序列化的字段</span></span><br><span class="line">    <span class="built_in">MSGPACK_DEFINE</span>(m_str, m_vec, m_class, m_vec_class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_str;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; m_vec;</span><br><span class="line">    myclass m_class;</span><br><span class="line">    std::vector&lt;myclass&gt; m_vec_class;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 获取随机对象</span></span><br><span class="line">    <span class="keyword">auto</span> obj = myclass2::<span class="built_in">GetRandomObj</span>();</span><br><span class="line">    <span class="keyword">decltype</span>(obj) obj2;</span><br><span class="line">    <span class="comment">/// 序列化</span></span><br><span class="line">    <span class="keyword">auto</span> vec = obj.<span class="built_in">Serialization</span>();</span><br><span class="line">    <span class="comment">/// 反序列化</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">Deserialization</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj2 == obj)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj2 == obj&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj2 != obj&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合的方式"><a href="#组合的方式" class="headerlink" title="组合的方式"></a>组合的方式</h2><p>在 <code>MSGPACK_DEFINE</code> 宏定义的下面添加如下两个函数，即可拥有序列化和反序列化的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSGPACK_DEFINE(...) ...\</span></span><br><span class="line"><span class="meta">    std::shared_ptr<span class="string">&lt;std::vector&lt;char&gt;</span>&gt; Serialization()                                      \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                       \</span></span><br><span class="line"><span class="meta">        msgpack::sbuffer sbuf;                                                              \</span></span><br><span class="line"><span class="meta">        msgpack::pack(sbuf, *this);                                                         \</span></span><br><span class="line"><span class="meta">        return std::make_shared<span class="string">&lt;std::vector&lt;char&gt;</span>&gt;(sbuf.data(), sbuf.data() + sbuf.size()); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                                       \</span></span><br><span class="line"><span class="meta">    void Deserialization(const std::shared_ptr<span class="string">&lt;std::vector&lt;char&gt;</span>&gt;&amp; vec)                     \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                       \</span></span><br><span class="line"><span class="meta">        msgpack::object_handle oh = msgpack::unpack(vec-&gt;data(), vec-&gt;size());               \</span></span><br><span class="line"><span class="meta">        msgpack::object obj = oh.get();                                                     \</span></span><br><span class="line"><span class="meta">        obj.convert(*this);                                                                  \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++简单定时器事件实现</title>
      <link href="/2023/09/04/2023-09-04-C++%E7%AE%80%E5%8D%95%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/09/04/2023-09-04-C++%E7%AE%80%E5%8D%95%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>使用 C++ 来实现定时器事件，可以使用 <code>std::thread</code> 来实现，也可以使用 <code>std::async</code> 来实现。</p><span id="more"></span><p>使用 C++ 来实现定时器事件，可以使用 <code>std::thread</code> 来实现，也可以使用 <code>std::async</code> 来实现。</p><h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 线程从主线程分离</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 阻止主线程退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../resource/2023-09-04-timer-event/WechatIMG186.jpg" alt="image"></p><h2 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 函数对象递归调用自己</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="comment">/// 休息1秒</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">f</span>(i);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">async</span>(std::launch::async, f, <span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 阻止主线程退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../resource/2023-09-04-timer-event/WechatIMG185.jpg" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志文件查看技巧</title>
      <link href="/2023/09/01/2023-09-01-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/09/01/2023-09-01-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>日志文件通常包含大量打印，如何快速定位问题，是每个程序员所需要掌握的技能。</p><p>本篇文章教你使用 VSCode 及其插件来查看日志。</p><span id="more"></span><h2 id="日志文件查看"><a href="#日志文件查看" class="headerlink" title="日志文件查看"></a>日志文件查看</h2><h3 id="多日志文件查看"><a href="#多日志文件查看" class="headerlink" title="多日志文件查看"></a>多日志文件查看</h3><p>通常一个问题包含多个文件，所以多文件搜索变得很重要。</p><p>我通常会使用 issue 号的名称来创建专门的日志文件夹，如下图：</p><p><img src="/../resource/2023-09-01-log-skills/Snipaste_2023-09-01_18-55-40.png" alt="image"></p><p>在文件夹内使用 VSCode 打开即可在文件夹内查看日志, 搜索也是可以默认搜索文件夹内所有文件</p><p><img src="/../resource/2023-09-01-log-skills/Snipaste_2023-09-01_18-59-48.png" alt="image"></p><h3 id="错误日志太多-难以搜索真正错误"><a href="#错误日志太多-难以搜索真正错误" class="headerlink" title="错误日志太多, 难以搜索真正错误"></a>错误日志太多, 难以搜索真正错误</h3><p>我们经常遇到一个 error 日志打印出来其实并不意味着错误(首先我们应该先把错误日志改为警告等级，或者直接删除该条打印)，但该条日志疯狂打印，导致掩盖了原有的信息。</p><p>如果我们把刷屏的日志删除掉就可以直接搜索 error，来查看真正的错误信息了。</p><p>那我们有办法删除它么？当然有，使用正则表达式来选中这些日志</p><p>正则表达式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^.*你想要匹配的字符串.*\r?\n?</span><br><span class="line"></span><br><span class="line">例:</span><br><span class="line">^.*retry send app msg failed.*\r?\n?</span><br><span class="line">^.*Find no position.*\r?\n?</span><br><span class="line">^.*SetRegisterStatus: strLongNum.*\r?\n?</span><br></pre></td></tr></table></figure><p>在 VsCode 中勾选<strong>正则表达式查找</strong>，<strong>替换所有</strong>找到的日志为空字符串，即可达到删除重复日志的目的。</p><p><img src="/../resource/2023-09-01-log-skills/Snipaste_2023-09-01_19-15-49.png" alt="image"></p><h3 id="想要突出显示特定的日志"><a href="#想要突出显示特定的日志" class="headerlink" title="想要突出显示特定的日志"></a>想要突出显示特定的日志</h3><p>可以使用日志高亮插件 “Log File Highlighter”, 在 VSCode 插件商店搜索安装即可。</p><p>该插件可以使用配置来制定高亮的日志：</p><p><img src="/../resource/2023-09-01-log-skills/Snipaste_2023-09-04_13-28-42.png" alt="image"></p><p><img src="/../resource/2023-09-01-log-skills/Snipaste_2023-09-04_13-30-08.png" alt="image"></p><p>使用如下配置：</p><p>可以让 ERROR， error 等文本，在日志文件中被显示为红色</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;logFileHighlighter.customPatterns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/// 错误，必须处理的信息</span></span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ERROR|error|FATAL|fatal|critical|FAILED&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FF0000&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>使用效果：</p><p><img src="/../resource/2023-09-01-log-skills/Snipaste_2023-09-04_13-26-04.png" alt="image"></p><p>根据我自己的使用习惯，我把日志的高亮进行分类：</p><ol><li>错误，必须处理的信息</li><li>警告，必须注意的信息</li><li>信息，值得注意的问题</li><li>调试，用于调试程序的信息</li><li>详细信息，可以忽略的信息</li><li>当前关注的信息（需要每次更新）</li></ol><p>以下是我的配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;logFileHighlighter.customPatterns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/// 错误，必须处理的问题</span></span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ERROR|error|FATAL|fatal|critical|FAILED&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FF0000&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/// 警告，必须注意的信息</span></span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WARN|warn|warning|percent: 99.|percent: 100|\\b(?:9\\d(?:\\.\\d&#123;1,2&#125;)?|100(?:\\.0&#123;1,2&#125;)?)%|\\(s\\)&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFF00&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/// 信息，值得注意的信息</span></span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(\&quot;DCCapacityPos\&quot;:｜get APP request call|INFO  |info |RUN|OK|PASSED|Send DC handle req call which have ulDCCapaCity|spPID-&gt;usInstID|spPID-&gt;usTaskID|link auth successful, client|RequestCallReq|Dialling is handle as link call.|Function Avg Time:|frequency count|get SA msg:|server_close_connect|OnServerDisconnectClient usClientID|tcp_send: send failed, Socket|SetButtonStatus|get request call|is not need save link group call|handle auto pick up group|Dialling is handle as group call.|eSDK_SendSMS|Skip not auto pick up group|is not auto pick up!|get app request call|Group Call Speaker Change:|OnRequestCallReq|\\(31\\)|\\(34\\)|\\(36\\))&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#42B883&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/// 调试，用于调试程序的信息</span></span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug|Debug|DEBUG|Spend Time|Memory Change|Total Time|interval_time_factory&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#007FFF&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/// 详细信息，可以忽略的信息</span></span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DETAIL|detail&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#2F90B9&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/// 当前关注的信息（需要每次更新）</span></span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6021102&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#19F334&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SIL2 认证工作总结</title>
      <link href="/2023/09/01/2023-09-01-SIL2%E8%AE%A4%E8%AF%81%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2023/09/01/2023-09-01-SIL2%E8%AE%A4%E8%AF%81%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><code>SIL2（Safety Integrity Level 2）</code> 是一种安全完整性级别，用于评估和确定安全相关系统的可靠性和性能。SIL是根据国际标准IEC 61508（功能安全）和相关行业标准（如IEC 61511、ISO 26262等）定义的。</p><p><code>SIL2</code>认证是指通过对特定系统或设备进行评估和验证，确认其满足SIL2级别的要求。SIL2级别通常适用于具有中等安全风险的系统，要求系统在设计、实施和操作过程中采取特定的安全措施和功能，以确保其能够达到预期的安全性能。</p><span id="more"></span><p>本次我参与的 <code>SIL2</code> 认证是只做软件部分的认证，其中设计的标准为 <code>EN50128-2011</code>。</p><p>目前 <code>SIL2</code> 认证工作已经基本完成，现总结此次认证工作的经验。</p><h2 id="EN50128-整体脉络"><a href="#EN50128-整体脉络" class="headerlink" title="EN50128 整体脉络"></a>EN50128 整体脉络</h2><p>EN50128 更多的是在强调软件质量保障。</p><p>软件质量保障是以计划为指导，计划指导实践。</p><p>EN50128 推荐&#x2F;要求的整体流程为：</p><ol><li>计划阶段</li><li>需求阶段</li><li>架构与设计阶段</li><li>组件设计阶段</li><li>组件实现与测试阶段</li><li>集成阶段</li><li>总体测试与最后确认阶段</li><li>软件部署</li><li>软件维护</li></ol><p>其中 2 ～ 7 作为软件研发的主要流程，1和8 ～ 9 作为软件工程管理过程。</p><h3 id="计划阶段"><a href="#计划阶段" class="headerlink" title="计划阶段"></a>计划阶段</h3><p>所有计划的制定，独立于研发过程。</p><h3 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h3><p>研发的第一个过程，准确定义需求和需求对应的测试。</p><h3 id="架构与设计阶段"><a href="#架构与设计阶段" class="headerlink" title="架构与设计阶段"></a>架构与设计阶段</h3><p>对整个系统进行定义，分为哪几个组件，网络拓扑怎么搭建，使用什么硬件，使用什么数据库。</p><p>定义组件之间的接口。</p><h3 id="组件实现与测试阶段"><a href="#组件实现与测试阶段" class="headerlink" title="组件实现与测试阶段"></a>组件实现与测试阶段</h3><p>编码与调试阶段。</p><h3 id="集成阶段"><a href="#集成阶段" class="headerlink" title="集成阶段"></a>集成阶段</h3><p>对软件组件进行集成，对真实的硬件进行集成。</p><h3 id="总体测试与最后确认"><a href="#总体测试与最后确认" class="headerlink" title="总体测试与最后确认"></a>总体测试与最后确认</h3><p>对已经集成好的整体系统，对照软件需求测试用例进行测试并记录。发行说明，总体测试报告与软件确认报告。</p><h3 id="软件部署"><a href="#软件部署" class="headerlink" title="软件部署"></a>软件部署</h3><p>软件发布计划隶属于配置管理计划，规定了每个基线版本包含什么功能，什么时候发布。</p><p>而跟随着软件发布的就是软件部署。</p><p>软件部署分为：部署计划、部署操作手册、部署记录、部署记录报告。</p><h3 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h3><p>运维阶段（升级）。</p><p>软件维护计划、软件变更记录、软件维护记录。</p><h2 id="此次认证过程得到的收获"><a href="#此次认证过程得到的收获" class="headerlink" title="此次认证过程得到的收获"></a>此次认证过程得到的收获</h2><p>西方主导思想：计划指导实践。</p><p>但是在没有计划时，没有构思后面工作流程的能力。</p><p>在计划不成熟或不合理时，经常会出现无视规定，灵活应对。</p><p>那有的人有心，在实施后会更新计划。但更多的人没有能力将自己的经验推广给每个部门内的人，也没有管理者来主导更新流程。</p><p>甚至有人没有责任心，回来不更新计划，完全按照后面自己的意思去实施。</p><p>那计划本身已经被弱化，后续逐渐被丢弃。</p><p>所以我认为在一个没有经验的项目上，一上来的计划没有必要急着写，而是先写个框架，后续慢慢补充细节。</p><p>就比如如上的生命周期，各个阶段完全可以顺序打乱去处理。</p><p>需求规范的制定，保证了测试用例的诞生，有依据，</p><p>确定了软件架构的设计的。</p><p>判断一个人的工作是否完成，应该以计划中的规定来判定，比如测试通过了，那是如何通过的。</p><p>版本发布了，那版本中有哪些功能，那些缺陷，那些更改。</p><p>软件部署了，部署的什么版本，哪些升级，哪些没有升级。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只讲 SIL2 的要求，给出生命周期，以及要干的事情。</p><p>压缩 SIL2 的要求到我们的生命周期中。</p><p>为每个周期设立检查点。</p><p>对部分代码的查看总结</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark使用技巧</title>
      <link href="/2023/09/01/2023-09-01-Wireshark%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/09/01/2023-09-01-Wireshark%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Wireshark 是一款开源的网络协议分析工具，用于捕获和分析网络数据包。它可以在各种操作系统上运行，包括Windows、Mac和Linux。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Wireshark 的主要功能包括：</p><ol><li><p>数据包捕获：Wireshark 可以捕获计算机网络上的数据包，包括传输层和网络层的数据。它可以监听网络接口，捕获经过该接口的数据包，并显示它们的详细信息。</p></li><li><p>数据包分析：Wireshark 可以解析捕获的数据包，并以易于理解的方式显示各个协议层的字段和值。它支持多种协议，包括以太网、IP、TCP、UDP、HTTP、DNS等。通过分析数据包，可以检查网络通信中的问题、识别潜在的安全漏洞，并进行性能优化。</p></li><li><p>过滤和搜索：Wireshark 提供了强大的过滤和搜索功能，以帮助用户快速定位感兴趣的数据包。用户可以使用过滤器来过滤特定协议、源&#x2F;目标IP地址、端口号等。此外，Wireshark 还提供了高级搜索功能，可以根据特定的字段值或表达式搜索数据包。</p></li><li><p>统计和报告：Wireshark 可以生成各种统计信息和报告，以帮助用户分析网络流量和性能。它可以提供关于数据包数量、协议分布、流量图表、响应时间等方面的统计数据，并支持导出报告到不同的格式。</p></li></ol><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="报文着色"><a href="#报文着色" class="headerlink" title="报文着色"></a>报文着色</h3><p>我们可以自定义报文的颜色高亮，操作如下：</p><p>点击 <code>视图</code> -&gt; <code>着色规则</code></p><p><img src="/../resource/2023-09-01-wireshark-skills/Snipaste_2023-09-01_16-30-58.png" alt="image"></p><p>见到如下界面, 点击新建着色规则</p><p><img src="/../resource/2023-09-01-wireshark-skills/Snipaste_2023-09-01_16-34-11.png" alt="image"></p><p>输入对应的过滤规则，则可以看到对应的报文着色</p><p>过滤规则与过滤报文规则相同，例如：</p><ol><li><code>tcp.port == 62001</code>, 查看使用 <code>62001</code> 端口的 <code>tcp</code> 协议的报文</li><li><code>frame contain &quot;MsgID: 112&quot;</code>: 查看包含字符串 <code>MsgID: 112</code> 的报文</li></ol><p><img src="/../resource/2023-09-01-wireshark-skills/Snipaste_2023-09-01_16-40-21.png" alt="image"></p><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><p>我们可以使用 <code>lua</code> 插件来实现 <code>wireshark</code> 自动解析二进制报文的功能，见如下操作：</p><p>其中需要编写 <a href="../resource/2023-09-01-wireshark-skills/PROJECT_TEST.lua"><code>PROJECT_TEST.lua</code></a> 文件放置到<code>wireshark</code>的 <code>plugin</code> 目录下(例如: <code>C:\Program Files\Wireshark\plugins</code>)</p><p><img src="/../resource/2023-09-01-wireshark-skills/Snipaste_2023-09-01_18-00-37.png" alt="image"></p><p>可以对照文件修改对应的私有协议，方便现场抓包分析</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ filesystem 库介绍</title>
      <link href="/2023/08/01/2023-08-01-C++_filesystem%E5%BA%93%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/08/01/2023-08-01-C++_filesystem%E5%BA%93%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><code>std::filesystem</code> 是 C++17 中引入的标准库，用于处理文件系统操作。它提供了一组类和函数，用于执行文件和目录的创建、删除、遍历、重命名、复制等操作，以及获取文件和目录的属性信息。</p><span id="more"></span><h2 id="std-filesystem-path-核心概念解释"><a href="#std-filesystem-path-核心概念解释" class="headerlink" title="std::filesystem::path 核心概念解释"></a>std::filesystem::path 核心概念解释</h2><p><code>std::filesystem::path</code> 类用于表示文件系统路径。它提供了一组函数，用于获取路径的各个部分，以及将路径转换为字符串。</p><p>该对象把 <code>linux</code> 与 <code>windows</code> 中的路径进行统一的封装，规避掉了不同系统下的路径分隔符不同的问题。</p><p>该对象可以方便的通过 <code>std::string</code> 进行构造，可以方便的转换为 <code>std::string</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p1</span><span class="params">(<span class="string">&quot;C:\\Windows\\System32\\drivers\\etc\\hosts&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p2</span><span class="params">(<span class="string">&quot;C:/Windows/System32/drivers/etc/hosts&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p3</span><span class="params">(<span class="string">&quot;C:&quot;</span>, std::filesystem::path::format::generic_format)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p4</span><span class="params">(<span class="string">&quot;Windows/System32/drivers/etc/hosts&quot;</span>, std::filesystem::path::format::generic_format)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p5</span><span class="params">(<span class="string">&quot;hosts&quot;</span>, std::filesystem::path::format::generic_format)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p6</span><span class="params">(<span class="string">&quot;C:\\Windows\\System32\\drivers\\etc\\hosts&quot;</span>, std::filesystem::path::format::native_format)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p7</span><span class="params">(<span class="string">&quot;C:/Windows/System32/drivers/etc/hosts&quot;</span>, std::filesystem::path::format::native_format)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p8</span><span class="params">(<span class="string">&quot;C:&quot;</span>, std::filesystem::path::format::native_format)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p9</span><span class="params">(<span class="string">&quot;Windows/System32/drivers/etc/hosts&quot;</span>, std::filesystem::path::format::native_format)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p10</span><span class="params">(<span class="string">&quot;hosts&quot;</span>, std::filesystem::path::format::native_format)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p6 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p7 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p8 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p9 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p10 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p<span class="number">1.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">2.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">3.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">4.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">5.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">6.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">7.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">8.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">9.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">10.</span><span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="获取当前路径"><a href="#获取当前路径" class="headerlink" title="获取当前路径"></a>获取当前路径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::filesystem::path p = std::filesystem::<span class="built_in">current_path</span>();</span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> str = p.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取绝对路径"><a href="#获取绝对路径" class="headerlink" title="获取绝对路径"></a>获取绝对路径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::filesystem::path p = std::filesystem::<span class="built_in">absolute</span>(<span class="string">&quot;hosts&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> str = p.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断文件或文件夹是否存在"><a href="#判断文件或文件夹是否存在" class="headerlink" title="判断文件或文件夹是否存在"></a>判断文件或文件夹是否存在</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;hosts&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::filesystem::<span class="built_in">exists</span>(p))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;not exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">/// 递归创建文件夹</span></span><br><span class="line">    <span class="keyword">if</span> (std::filesystem::<span class="built_in">create_directories</span>(p))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create directory success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create directory failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>std::filesystem::create_directory</code> 与 <code>std::filesystem::create_directories</code> 的区别<br><code>std::filesystem::create_directory</code> 用于创建单个目录，如果目录已经存在，则函数会抛出 <code>std::filesystem::filesystem_error</code> 异常。<br><code>std::filesystem::create_directories</code> 用于创建多级目录，如果目录已经存在，则函数不会抛出异常。<br>因此，如果你需要创建多级目录，可以使用 <code>std::filesystem::create_directories</code>，如果你只需要创建单个目录，则可以使用 <code>std::filesystem::create_directory</code>。</p></blockquote><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::filesystem::<span class="built_in">create_directory</span>(p))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create file success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create file failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取当前磁盘容量"><a href="#获取当前磁盘容量" class="headerlink" title="获取当前磁盘容量"></a>获取当前磁盘容量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;C:&quot;</span>)</span></span>;</span><br><span class="line">    std::filesystem::space_info info = std::filesystem::<span class="built_in">space</span>(p);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; info.capacity &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;free: &quot;</span> &lt;&lt; info.free &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;available: &quot;</span> &lt;&lt; info.available &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;hosts&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;file size: &quot;</span> &lt;&lt; std::filesystem::<span class="built_in">file_size</span>(p) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取文件夹下所有文件"><a href="#获取文件夹下所有文件" class="headerlink" title="获取文件夹下所有文件"></a>获取文件夹下所有文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">get_directory_files</span><span class="params">(<span class="type">const</span> std::string&amp; path, <span class="type">const</span> std::regex&amp; reg = std::regex(<span class="string">&quot;(.*)&quot;</span>), <span class="type">bool</span> is_recursive = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::filesystem::<span class="built_in">path</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(p.<span class="built_in">string</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; dir_entry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fp = dir_entry.<span class="built_in">path</span>();</span><br><span class="line">        <span class="comment">/// 过滤文件夹</span></span><br><span class="line">        <span class="keyword">if</span> (!std::filesystem::<span class="built_in">is_directory</span>(std::filesystem::<span class="built_in">status</span>(fp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> file_name = fp.<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">            <span class="comment">/// 正则匹配</span></span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(file_name, reg))</span><br><span class="line">            &#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(fp.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_recursive)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 递归查找</span></span><br><span class="line">        std::ranges::for_each(std::filesystem::recursive_directory_iterator&#123;p&#125;, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 非递归查找</span></span><br><span class="line">        std::ranges::for_each(std::filesystem::directory_iterator&#123;p&#125;, f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ranges::<span class="built_in">sort</span>(vec);</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 默认情况下，查找所有文件, 非递归</span></span><br><span class="line">    <span class="keyword">auto</span> c0 = <span class="built_in">get_directory_files</span>(dir<span class="number">1.</span><span class="built_in">string</span>());</span><br><span class="line">    <span class="comment">/// 非递归，查找所有文件</span></span><br><span class="line">    <span class="keyword">auto</span> c1 = <span class="built_in">get_directory_files</span>(dir<span class="number">1.</span><span class="built_in">string</span>(), std::<span class="built_in">regex</span>(<span class="string">&quot;(.*)&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 非递归，查找特定文件 .log</span></span><br><span class="line">    <span class="keyword">auto</span> c2 = <span class="built_in">get_directory_files</span>(dir<span class="number">1.</span><span class="built_in">string</span>(), std::<span class="built_in">regex</span>(<span class="string">&quot;(.*\\.log)&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 递归，查找所有文件</span></span><br><span class="line">    <span class="keyword">auto</span> c3 = <span class="built_in">get_directory_files</span>(dir<span class="number">1.</span><span class="built_in">string</span>(), std::<span class="built_in">regex</span>(<span class="string">&quot;(.*)&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/// 递归，查找特定文件 .log</span></span><br><span class="line">    <span class="keyword">auto</span> c4 = <span class="built_in">get_directory_files</span>(dir<span class="number">1.</span><span class="built_in">string</span>(), std::<span class="built_in">regex</span>(<span class="string">&quot;(.*\\.log)&quot;</span>), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;hosts&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">new_p</span><span class="params">(<span class="string">&quot;hosts_new&quot;</span>)</span></span>;</span><br><span class="line">    std::filesystem::<span class="built_in">rename</span>(p, new_p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;hosts_new_copy&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">new_p</span><span class="params">(<span class="string">&quot;hosts_new_copy_move&quot;</span>)</span></span>;</span><br><span class="line">    std::filesystem::<span class="built_in">rename</span>(p, new_p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;hosts_new&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="function">filesystem::path <span class="title">new_p</span><span class="params">(<span class="string">&quot;hosts_new_copy&quot;</span>)</span></span>;</span><br><span class="line">    std::filesystem::<span class="built_in">copy</span>(p, new_p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝文件夹"><a href="#拷贝文件夹" class="headerlink" title="拷贝文件夹"></a>拷贝文件夹</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">copy_directory</span><span class="params">(<span class="type">const</span> std::string&amp; from, <span class="type">const</span> std::string&amp; to)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!std::filesystem::<span class="built_in">is_directory</span>(from))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(from))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::filesystem::<span class="built_in">exists</span>(to))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 文件存在的情况下则更新，文件递归拷贝</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> copy_options = std::filesystem::copy_options::update_existing | std::filesystem::copy_options::recursive;</span><br><span class="line"></span><br><span class="line">    std::error_code code;</span><br><span class="line">    std::filesystem::<span class="built_in">copy</span>(from, to, copy_options, code);</span><br><span class="line">    <span class="keyword">return</span> !code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI 辅助工具探索</title>
      <link href="/2023/07/27/2023-07-27-AI%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E6%8E%A2%E7%B4%A2/"/>
      <url>/2023/07/27/2023-07-27-AI%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了多种AI工具，涵盖问答类、工具类和开源类产品。问答类工具包括ChatGPT（支持GPT-3.5和GPT-4）、New Bing（提供答案来源）、Google Bard、HuggingChat、Claude、文心一言、通义千问和讯飞星火，各有优缺点，如ChatGPT回答正确率高但需翻墙，New Bing免费但依赖特定浏览器。工具类产品如Github Copilot（代码补全）和ChatPDF（基于PDF问答），功能强大但存在限制。开源类工具如ChatGLM（中文优化）、GPT4ALL（轻量化部署）和ChatLaw（法律问答），适合本地部署和特定领域应用。总体而言，各类AI工具在不同场景下表现各异，用户可根据需求选择。</p><span id="more"></span><h2 id="各类-AI-工具介绍"><a href="#各类-AI-工具介绍" class="headerlink" title="各类 AI 工具介绍"></a>各类 AI 工具介绍</h2><h3 id="问答类产品"><a href="#问答类产品" class="headerlink" title="问答类产品"></a>问答类产品</h3><h4 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a><a href="https://chat.openai.com/">ChatGPT</a></h4><p>聊天互动式工具（<a href="https://openai.com/">OpenAI 官网</a>）</p><p>该工具是由 <code>OpenAI</code> 公司，基于 <code>GPT-3</code> 模型，开发的一个聊天互动式工具。</p><p>目前应用最广的 AI 工具，个人认为回答正确率最高的AI工具。</p><p>其分为 ChatGPT-3.5、ChatGPT-4。</p><p>ChatGPT-4: ChatGPT-3.5 升级版产品（<a href="https://openai.com/research/gpt-4">官网介绍</a>)</p><p>官方宣传提升了逻辑推理能力，提高了回答正确率（<a href="https://cdn.openai.com/papers/gpt-4.pdf">GPT-4 Technical Report</a>)</p><p>个人体验下来没有感觉到其回答正确率的提升（比如<code>GPT-3.5</code>回答正确率为<code>60%</code>，<code>GPT-4</code>回答正确率类比为<code>70%</code>）</p><p>优点：</p><ol><li>免费使用(ChatGPT-3.5)</li><li>回答正确率高</li><li>可以提问所有问题</li></ol><p>缺点：</p><ol><li>需要翻墙</li><li>账号难于注册，账号经常封禁</li><li>使用过程中需要反复重新登陆</li><li>答案来源不详，无法求证</li><li>只能回答 2021年9月前的知识</li><li><code>ChatGPT-4</code> 个人使用需要国外信用卡订阅其每月20美元的服务，</li><li><code>ChatGPT-4</code> 调用起<code>API</code>进行提问，每个问题约为 0.5元（我曾一周花掉了30美元，但听说最近降价了）</li></ol><h4 id="chatkit"><a href="#chatkit" class="headerlink" title="chatkit"></a><a href="https://chatkit.app/">chatkit</a></h4><p><code>ChatGPT</code> 套壳网站（调用 OpenAI 的 api）</p><p>优点：</p><ol><li>无需翻墙，稳定，不存在账号封禁问题</li><li>无回答次数限制</li><li>可选用多个模型如 <code>ChatGPT-3.5</code>、 <code>ChatGPT-4</code> 或 <code>Claude</code></li><li>一次付费永久使用（个人版：30美元，企业版：145美元&#x2F;50台设备）</li></ol><p>缺点:</p><p>使用了3个月，暂无发现缺点，该服务高可用。</p><h4 id="New-Bing"><a href="#New-Bing" class="headerlink" title="New Bing"></a><a href="www.bing.com">New Bing</a></h4><p>与 <code>Microsoft Edge</code> 浏览器绑定的类 <code>ChatGPT</code> 工具</p><p>优点：</p><ol><li>提供答案来源链接</li><li>使用搜索引擎提供信息，生成答案，具有即时性</li><li>免费使用，账号注册简单</li></ol><p>缺点：</p><ol><li>需要使用域名转发来规避中国对该网站的封禁</li><li>对于编程类问题回答正确率不及 <code>ChatGPT</code> 的一半</li><li>必须使用 <code>Microsoft Edge</code> 浏览器打开，或 <code>Chrome</code> 安装插件</li></ol><h4 id="Google-Bard"><a href="#Google-Bard" class="headerlink" title="Google Bard"></a><a href="https://bard.google.com/">Google Bard</a></h4><ul><li>与 <code>ChatGPT</code> 相同功能的产品</li><li>使用过程中，认为没有 <code>ChatGPT</code> 回答正确率高，建议使用 <code>ChatGPT</code> 替代</li></ul><h4 id="HuggingChat"><a href="#HuggingChat" class="headerlink" title="HuggingChat"></a><a href="https://huggingface.co/chat/">HuggingChat</a></h4><ul><li>与 ChatGPT 相同功能的产品</li><li>可以使用中文提问，但回答是英文</li></ul><h4 id="Claude"><a href="#Claude" class="headerlink" title="Claude"></a><a href="https://claude.ai/">Claude</a></h4><ul><li>与 ChatGPT 相同功能的产品</li><li>号称性能远超 ChatGPT (介绍链接： <a href="https://www.anthropic.com/index/introducing-claude">https://www.anthropic.com/index/introducing-claude</a>)</li><li>暂未绕过限制进行访问（被封禁网站）</li></ul><h4 id="文心一言-https-yiyan-baidu-com-）"><a href="#文心一言-https-yiyan-baidu-com-）" class="headerlink" title="[文心一言]https://yiyan.baidu.com/）"></a>[文心一言]<a href="https://yiyan.baidu.com/%EF%BC%89">https://yiyan.baidu.com/）</a></h4><ul><li>与 ChatGPT 相同功能的产品</li><li>之前使用中语意理解上没有 ChatGPT 好</li><li>暂未发现其优点</li></ul><h4 id="通义千问"><a href="#通义千问" class="headerlink" title="通义千问"></a><a href="https://tongyi.aliyun.com/">通义千问</a></h4><p>与 ChatGPT 相同功能的产品</p><p>使用不多，但是比较看好 阿里背后的云平台的算力支撑的AI服务</p><h4 id="讯飞星火"><a href="#讯飞星火" class="headerlink" title="讯飞星火"></a><a href="https://xinghuo.xfyun.cn/">讯飞星火</a></h4><ul><li>与 ChatGPT 相同功能的产品</li><li>之前被曝出后台调用 ChatGPT 的 API(套壳工具)</li><li>回答正确率过低，几乎无法使用</li></ul><h3 id="工具类-AI-产品"><a href="#工具类-AI-产品" class="headerlink" title="工具类 AI 产品"></a>工具类 AI 产品</h3><h4 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a><a href="https://github.com/features/copilot">Github Copilot</a></h4><p>代码补全工具。</p><p>集成于 VSCode、Vistual Studio 等工具中使用。</p><p>用于编程过程中使用，相当于高级的补全工具。</p><p>优点：</p><ol><li>擅长补全通用算法，或开源库接口</li><li>可以学习你自己代码的风格，帮你生成代码</li><li>可以对于错误的代码给出修正意见</li><li>可以对简单函数生成单元测试</li><li>可以询问示例代码</li></ol><p>缺点：</p><ol><li>对于询问代码，生成单元测试和询问功能，需要通过等待列表，通常需要数周到一个月</li><li>业务耦合型代码，它并不擅长</li><li>只能询问代码相关问题，不能询问架构或者概念型问题</li><li>补全正确率差强人意，仅仅是达到了商用水平</li></ol><h4 id="ChatPDF"><a href="#ChatPDF" class="headerlink" title="ChatPDF"></a><a href="https://www.chatpdf.com/">ChatPDF</a></h4><ul><li>基于上传文件的信息，来回答你的问题</li><li>免费额度，120页、10M以内的PDF，一天 3个文件和50个问题</li><li>缺点：</li></ul><ol><li>限制太多</li><li>付费需要国外信用卡</li><li>答非所问，几乎不可用</li></ol><h4 id="Chat2Doc"><a href="#Chat2Doc" class="headerlink" title="Chat2Doc"></a><a href="https://chat2doc.cn/">Chat2Doc</a></h4><ul><li>基于上传文件的信息，来回答你的问题，中文支持较好</li><li>未试用过无法评价</li></ul><h3 id="开源类"><a href="#开源类" class="headerlink" title="开源类"></a>开源类</h3><p>开源意味着可本地部署</p><h4 id="ChatGLM"><a href="#ChatGLM" class="headerlink" title="ChatGLM"></a><a href="https://github.com/THUDM/ChatGLM-6B">ChatGLM</a></h4><ul><li>开源大语言模型，可本地部署</li><li>目前最流行的中文大语言模型，衍生产品有很多</li><li>基于中文训练，对中文有较好的性能</li><li>使用精简的数据集，本地部署只需6G显存</li><li>由于我没有显卡，未尝试过本地部署</li></ul><h4 id="GPT4ALL"><a href="#GPT4ALL" class="headerlink" title="GPT4ALL"></a><a href="https://gpt4all.io/index.html">GPT4ALL</a></h4><ul><li>可本地部署，不需要显卡</li><li>多种模型可选</li><li>一键部署，非常轻量化</li><li>部分模型不能使用中文提问</li><li>试用时，回答速度稍慢，正确率不高，无法使用（后续该技术继续演进，正确率可能得到优化）</li></ul><h4 id="本草"><a href="#本草" class="headerlink" title="本草"></a><a href="https://github.com/SCIR-HI/Huatuo-Llama-Med-Chinese">本草</a></h4><p>基于中文医学知识的LLaMA微调模型。</p><ul><li>医学类问答模型</li><li>未试用过</li></ul><h4 id="ChatLaw"><a href="#ChatLaw" class="headerlink" title="ChatLaw"></a><a href="https://github.com/PKU-YuanGroup/ChatLaw">ChatLaw</a></h4><p>中文法律问答 AI。</p><ul><li>法律类问答模型</li><li>未试用过</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Copilot功能介绍</title>
      <link href="/2023/07/24/2023-07-24-GitHub-Copilot%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/24/2023-07-24-GitHub-Copilot%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>GitHub Copilot是GitHub和OpenAI合作开发的一个人工智能工具，用户在使用Visual Studio Code、Microsoft Visual Studio、Vim、Cursor或JetBrains集成开发环境时可以通过GitHub Copilot自动补全代码。GitHub于2021年6月29日对开公开该软件，GitHub Copilot于技术预览阶段主要面向Python、JavaScript、TypeScript、Ruby和Go等编程语言。</p><span id="more"></span><h2 id="提高编码效率"><a href="#提高编码效率" class="headerlink" title="提高编码效率"></a>提高编码效率</h2><h3 id="按-Tab-键自动补全代码"><a href="#按-Tab-键自动补全代码" class="headerlink" title="按 Tab 键自动补全代码"></a>按 <code>Tab</code> 键自动补全代码</h3><p><img src="/../resource/2023-07-24-Github_Copilot/1-1.gif" alt="1-1"></p><h3 id="结构体添加字段后，类内函数补全"><a href="#结构体添加字段后，类内函数补全" class="headerlink" title="结构体添加字段后，类内函数补全"></a>结构体添加字段后，类内函数补全</h3><p><img src="/../resource/2023-07-24-Github_Copilot/1-2.gif" alt="1-2"></p><h3 id="C-标准库补全"><a href="#C-标准库补全" class="headerlink" title="C++ 标准库补全"></a>C++ 标准库补全</h3><p><img src="/../resource/2023-07-24-Github_Copilot/1-3.gif" alt="1-3"></p><ul><li>对比 C++ 标准库手册, 需要阅读繁杂的解释</li></ul><p><img src="/../resource/2023-07-24-Github_Copilot/Snipaste_2023-07-24_10-48-16.png" alt="image"></p><h3 id="使用注释生成补全代码"><a href="#使用注释生成补全代码" class="headerlink" title="使用注释生成补全代码"></a>使用注释生成补全代码</h3><ul><li>通用算法</li></ul><p><img src="/../resource/2023-07-24-Github_Copilot/1-6-1.gif" alt="1-6-1"></p><h2 id="为代码生成注释"><a href="#为代码生成注释" class="headerlink" title="为代码生成注释"></a>为代码生成注释</h2><p><img src="/../resource/2023-07-24-Github_Copilot/2-1.gif" alt="2-1"></p><p><img src="/../resource/2023-07-24-Github_Copilot/2-1-1.gif" alt="2-1-1"></p><h2 id="为函数生成测试用例"><a href="#为函数生成测试用例" class="headerlink" title="为函数生成测试用例"></a>为函数生成测试用例</h2><p><img src="/../resource/2023-07-24-Github_Copilot/1-7.gif" alt="1-7"></p><h2 id="开源库学习"><a href="#开源库学习" class="headerlink" title="开源库学习"></a>开源库学习</h2><h3 id="Asio-网络库代码"><a href="#Asio-网络库代码" class="headerlink" title="Asio 网络库代码"></a>Asio 网络库代码</h3><p>文件中包含 <code>asio.hpp</code>, 写出类名即可补全对应开源库的示例代码。</p><p><img src="/../resource/2023-07-24-Github_Copilot/1-4-2.gif" alt="1-4-2"></p><h3 id="Curl-API-代码"><a href="#Curl-API-代码" class="headerlink" title="Curl API 代码"></a>Curl API 代码</h3><p>使用 <code>Github Copilot</code> 的问答功能可以直接询问代码。</p><p><img src="/../resource/2023-07-24-Github_Copilot/1-4-1.gif" alt="1-4-1"></p><h2 id="提高代码阅读效率"><a href="#提高代码阅读效率" class="headerlink" title="提高代码阅读效率"></a>提高代码阅读效率</h2><ul><li>解释代码</li></ul><p><img src="/../resource/2023-07-24-Github_Copilot/2-2.gif" alt="2-2"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++调试工具函数介绍</title>
      <link href="/2023/07/21/2022-09-13-C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/21/2022-09-13-C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了C++调试工具函数的设计与实现，重点围绕日志打印、时间管理、性能调优和业务辅助工具展开。通过封装to_string、string_stream、log_stream等工具，简化了日志打印和字符串拼接操作，提升了代码可读性和调试效率。时间管理工具如tick_count和stop_watch帮助开发者精确测量代码执行时间，性能调优工具如PROFILER和MEMORY_CHECK则用于优化代码性能和检测内存泄漏。此外，业务辅助工具如clamp、heartbeat和json_parser为常见业务场景提供了便捷的解决方案。整体设计基于“人易出错、懒惰”的假设，旨在减少调试时间，提升开发效率。</p><span id="more"></span><ul><li>我们假设人是会出错的，所以我们需要调试找寻 BUG</li><li>我们假设框架和流程设计基本正确，所以<strong>找寻问题的时间</strong>远大于<strong>改正问题的时间</strong></li><li>我们假设人是懒惰的，所以总是倾向于写更少的代码</li></ul><p><a href="../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/2022_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA.pptx">PPT</a></p><h2 id="调试日志打印类"><a href="#调试日志打印类" class="headerlink" title="调试日志打印类"></a>调试日志打印类</h2><h3 id="转换字符串-to-string"><a href="#转换字符串-to-string" class="headerlink" title="转换字符串 to_string"></a>转换字符串 to_string</h3><p>应用场景: 想要把某种类型转换为字符串</p><p>简单的转换:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br></pre></td></tr></table></figure><p>实际中可能用到的转换:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Integers\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Decimal:\t%i %d %.6i %i %.0i %+i %i\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">-4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hexadecimal:\t%x %x %X %#x\n&quot;</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Octal:\t%o %#o %#o\n&quot;</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Floating point\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Rounding:\t%f %.0f %.32f\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Padding:\t%05.2f %.2f %5.2f\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Scientific:\t%E %e\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hexadecimal:\t%a %A\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><p>因为自己使用占用符可能会出现使用错误(VS 编译检测不出来, g++ 有部分警告), 为了正确和格式的统一现使用统一函数封装</p><p>基本类型的重载:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">short</span> x)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>特殊类型的重载:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 保留两位小数: 输出类似 1.12</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">double</span> d)</span></span>;</span><br><span class="line"><span class="comment">/// 返回字符串: &quot;true&quot; 或 &quot;false&quot;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">bool</span> x)</span></span>;</span><br><span class="line"><span class="comment">/// 重载指针, 输出类似 0x123</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(T* <span class="type">const</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="使用-string-stream-拼接字符串"><a href="#使用-string-stream-拼接字符串" class="headerlink" title="使用 string_stream 拼接字符串"></a>使用 <code>string_stream</code> 拼接字符串</h3><p>场景: 拼接字符串</p><h4 id="C-是如何拼接字符串的"><a href="#C-是如何拼接字符串的" class="headerlink" title="C 是如何拼接字符串的?"></a>C 是如何拼接字符串的?</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ac[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">strcat</span>(ac, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(ac, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(ac, gos::<span class="built_in">to_string</span>(<span class="number">123</span>).<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h4 id="C-是如何拼接字符串的-1"><a href="#C-是如何拼接字符串的-1" class="headerlink" title="C++ 是如何拼接字符串的?"></a>C++ 是如何拼接字符串的?</h4><p>std::string 怎么实现拼接函数的</p><p>&#x2F;&#x2F;&#x2F; 编译错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">str = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x2F; 编译成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line"><span class="function">std::string <span class="title">strTemp</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>;</span><br><span class="line">str = <span class="string">&quot;123&quot;</span> + strTemp;</span><br></pre></td></tr></table></figure><p>重载 “+” 操作符，实现字符串拼接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string <span class="keyword">operator</span>+(<span class="type">const</span> std::string&amp; strLeft, <span class="type">const</span> std::string&amp; strRight);</span><br></pre></td></tr></table></figure><p>调用过程解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;123&quot;</span> + strTemp;</span><br><span class="line">&lt;=&gt;</span><br><span class="line">str = <span class="keyword">operator</span>+(<span class="string">&quot;123&quot;</span>, strTemp);</span><br><span class="line">&lt;=&gt;</span><br><span class="line">str = <span class="keyword">operator</span>+(std::<span class="built_in">string</span>(<span class="string">&quot;123&quot;</span>), strTemp);</span><br></pre></td></tr></table></figure><p>最后的拼接方式为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line"><span class="function">std::string <span class="title">strTemp</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">str = <span class="string">&quot;Hello&quot;</span> + strTemp + gos::<span class="built_in">to_string</span>(i);</span><br><span class="line">&lt;=&gt;</span><br><span class="line">str = (<span class="string">&quot;Hello&quot;</span> + strTemp) + gos::<span class="built_in">to_string</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h4 id="string-stream-是如何拼接字符串的"><a href="#string-stream-是如何拼接字符串的" class="headerlink" title="string_stream 是如何拼接字符串的?"></a><code>string_stream</code> 是如何拼接字符串的?</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gos::string_stream stream;</span><br><span class="line">stream &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;World&quot;</span> &lt;&lt; <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那么 gos::string_stream 是如何实现的?</p><p>查看对象原型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string_stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_str += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析调用过程:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gos::string_stream stream;</span><br><span class="line">stream &lt;&lt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&lt;=&gt;</span><br><span class="line">stream.<span class="keyword">operator</span>&lt;&lt;(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="string-stream-对其他复杂类型的处理"><a href="#string-stream-对其他复杂类型的处理" class="headerlink" title="string_stream 对其他复杂类型的处理"></a><code>string_stream</code> 对其他复杂类型的处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 打印 socket 地址</span></span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> SOCKADDR_IN&amp; addr_in);</span><br><span class="line"><span class="comment">/// 打印 PID_T</span></span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> PID_T&amp; stPID);</span><br><span class="line"><span class="comment">/// 打印 vector</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> std::vector&lt;T&gt;&amp; vec);</span><br><span class="line"><span class="comment">/// 打印 二进制数据</span></span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;&amp; vec);</span><br><span class="line"><span class="comment">/// 打印 map</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> std::map&lt;Key, Value&gt;&amp; map);</span><br></pre></td></tr></table></figure><h4 id="string-stream-如何转换为-std-string"><a href="#string-stream-如何转换为-std-string" class="headerlink" title="string_stream 如何转换为 std::string"></a><code>string_stream</code> 如何转换为 std::string</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string_stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用-string-stream-打印结构体"><a href="#使用-string-stream-打印结构体" class="headerlink" title="使用 string_stream 打印结构体"></a>使用 <code>string_stream</code> 打印结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以这样打印:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRUCT_T st;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %f&quot;</span>, st.i, st.d);</span><br></pre></td></tr></table></figure><p><code>gos::string_stream</code> 如何打印:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; st.i &lt;&lt; st.d;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gos::string_stream stream;</span><br><span class="line">stream &lt;&lt; st;</span><br></pre></td></tr></table></figure><p>考虑如下情况:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 该函数是否可行?</span></span><br><span class="line">gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; st.i &lt;&lt; st.d;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; st.i &lt;&lt; st.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="string-stream-与-GosLog-的适配"><a href="#string-stream-与-GosLog-的适配" class="headerlink" title="string_stream 与 GosLog 的适配"></a>string_stream 与 GosLog 的适配</h4><h5 id="DBG"><a href="#DBG" class="headerlink" title="DBG"></a><code>DBG</code></h5><p>查看函数定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">format_dbg_string</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> std::string&amp; strName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gos::string_stream stream;</span><br><span class="line">    stream &lt;&lt; strName &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> stream.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* szMsgName = <span class="string">&quot;MsgName&quot;</span>;</span><br><span class="line"><span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;szMsgName: %s&quot;</span>, gos::format_dbg_string(szMsgName, <span class="string">&quot;szMsgName&quot;</span>).<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p>使用辅助宏定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG(x) gos::format_dbg_string(x, std::string(#x)).c_str()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;szMsgName: %s&quot;</span>, gos::format_dbg_string(szMsgName, <span class="string">&quot;szMsgName&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">&lt;=&gt;</span><br><span class="line"><span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;%s&quot;</span>, <span class="built_in">DBG</span>(szMsgName));</span><br></pre></td></tr></table></figure><h5 id="DBG-给日志带来的改变"><a href="#DBG-给日志带来的改变" class="headerlink" title="DBG 给日志带来的改变"></a><code>DBG</code> 给日志带来的改变</h5><ol><li>省去了输入变量名称的过程, 见下面示例:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GosLog</span>(LOG_ERROR, <span class="string">&quot;CRC error! %s, %s, %s, %s &quot;</span>, <span class="built_in">DBG</span>(ucLocalCRC16_H), <span class="built_in">DBG</span>(ucLocalCRC16_L), <span class="built_in">DBG</span>(ucCRC16_H), <span class="built_in">DBG</span>(ucCRC16_L);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>可以打印任意类型，使用单一占位符<code>%s</code>规避了占位符错误导致的崩溃，见如下示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">1.123456</span>;</span><br><span class="line"><span class="type">char</span>* szMsgName = <span class="string">&quot;AppGetCfgReq&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">GosLog</span>(LOG_ERROR, <span class="string">&quot;%s %s %s %s&quot;</span>, <span class="built_in">DBG</span>(i), <span class="built_in">DBG</span>(d), <span class="built_in">DBG</span>(szMsgName), <span class="built_in">DBG</span>(b));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出</span></span><br><span class="line"><span class="number">2022</span><span class="number">-10</span><span class="number">-16</span> <span class="number">0</span>8:<span class="number">0</span>8:<span class="number">43.908</span> [ERROR] [dis] :<span class="built_in">i</span>(<span class="number">123</span>)  <span class="built_in">d</span>(<span class="number">1.12</span>) <span class="built_in">szMsgName</span>(AppGetCfgReq), <span class="built_in">b</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>可以打印结构体</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="keyword">friend</span> gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">&quot;STRUCT_T: &quot;</span> &lt;&lt; <span class="built_in">DBG</span>(&amp;st);</span><br><span class="line">    out &lt;&lt; <span class="built_in">DBG</span>(st.i);</span><br><span class="line">        out &lt;&lt; <span class="built_in">DBG</span>(st.d);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GosLog</span>(LOG_ERROR,<span class="string">&quot;%s&quot;</span>, <span class="built_in">DBG</span>(st));</span><br><span class="line"><span class="comment">/// 输出</span></span><br><span class="line"><span class="number">2022</span><span class="number">-10</span><span class="number">-16</span> <span class="number">0</span>8:<span class="number">0</span>8:<span class="number">43.908</span> [ERROR] [dis] :STRUCT_T: <span class="number">0x2389472</span> <span class="built_in">i</span>(<span class="number">123</span>)<span class="built_in">d</span>(<span class="number">1.12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="日志流-log-stream"><a href="#日志流-log-stream" class="headerlink" title="日志流 log_stream"></a>日志流 <code>log_stream</code></h3><p>使用 <code>string_stream</code> 实现字符串拼接， 使用析构函数调用打印日志函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">log_stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    log_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stream &lt;&lt; data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">log_stream</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;%s&quot;</span>, m_stream.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    gos::string_stream m_stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义辅助宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG gos::log_stream() stream</span></span><br><span class="line"></span><br><span class="line">LOG &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="异步日志-log-sync"><a href="#异步日志-log-sync" class="headerlink" title="异步日志 log_sync"></a>异步日志 <code>log_sync</code></h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>生产者-消费者模型</p><p><a href="../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86.png">异步日志原理</a></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">log_sync</span> : <span class="keyword">public</span> GThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; level, <span class="type">const</span> std::string&amp; strLog)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue.<span class="built_in">push</span>(level, strLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GOS_THREAD_RET <span class="title">ThreadEntry</span><span class="params">(<span class="type">void</span>* pPara)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string strLog = queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">/// 写入文件</span></span><br><span class="line">            <span class="built_in">log_to_file</span>(<span class="string">&quot;%s&quot;</span>, strLog.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><p>测试环境:</p><ul><li><p>CPU AMD Ryzen 7 PRO 4750U(8核16线程)</p></li><li><p>16G</p></li><li><p>固态硬盘</p></li><li><p>Win11 专业版 22H2</p></li><li><p>VS2022 C++20 Release</p></li><li><p>测试框架为 <a href="https://github.com/google/benchmark">google&#x2F;benchmark</a></p></li></ul><p>在短字符串和4K长度字符串，分别在 1线程、2线程、4线程和8线程下运行结果如下:</p><p><code>GosLog</code>:<br><img src="/../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/Benchmark_gos_log.png" alt="gos_log"></p><p><code>log_stream</code>:<br><img src="/../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/Benchmark_log_stream.png" alt="log_stream"></p><p>性能比较:</p><table><thead><tr><th align="center">测试用例</th><th align="center">GosLog</th><th align="center">log_sync</th><th align="center">GosLog&#x2F;log_sync</th></tr></thead><tbody><tr><td align="center">短字符串 、 1线程</td><td align="center">93.3478k&#x2F;s</td><td align="center">20.9662k&#x2F;s</td><td align="center">445%</td></tr><tr><td align="center">短字符串 、 2线程</td><td align="center">99.8429k&#x2F;s</td><td align="center">20.7688k&#x2F;s</td><td align="center">408%</td></tr><tr><td align="center">短字符串 、 4线程</td><td align="center">47.5319k&#x2F;s</td><td align="center">24.1499k&#x2F;s</td><td align="center">196%</td></tr><tr><td align="center">短字符串 、 8线程</td><td align="center">44.5061k&#x2F;s</td><td align="center">23.4319k&#x2F;s</td><td align="center">190%</td></tr><tr><td align="center">4K 字符串 、 1线程</td><td align="center">35.7577k&#x2F;s</td><td align="center">17.9889k&#x2F;s</td><td align="center">199%</td></tr><tr><td align="center">4K 字符串 、 2线程</td><td align="center">29.3773k&#x2F;s</td><td align="center">19.0816k&#x2F;s</td><td align="center">153%</td></tr><tr><td align="center">4K 字符串 、 4线程</td><td align="center">29.6178k&#x2F;s</td><td align="center">17.3948k&#x2F;s</td><td align="center">170%</td></tr><tr><td align="center">4K 字符串 、 8线程</td><td align="center">32.3738k&#x2F;s</td><td align="center">18.317k&#x2F;s</td><td align="center">176%</td></tr></tbody></table><p><code>GosLog</code> 在上面测试速度全面领先与 <code>log_steam</code>, 性能高出 <code>1.5</code> 到 <code>4.4</code> 倍。</p><p>备注:</p><p><img src="/../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/log_stream.png" alt="图片"></p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点:</p><ul><li>可以打印大于 4k 的字符串</li><li>多线程调用不会串行等待</li><li>不会输出到命令行，可以用作详细打印</li><li>可以利用 <code>operator&lt;&lt;</code> 打印， 便于快速编写代码</li></ul><p>缺点:</p><ul><li>性能远不如 <code>GosLog</code></li><li>调用打印和写入文件之间有延迟，在此期间崩溃会导致部分异步日志来不及写入文件</li><li>生产者速度过快会导致丢弃部分异步日志</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>详细打印(如结构体内的成员信息), 不会导致 cmd 里刷新过快</li><li>所有收发信令打印</li><li>数据库数据打印(从数据库中读取到内存时)</li><li>渲染视频帧线程打印(不会阻塞当前线程)</li></ul><h3 id="日志宏"><a href="#日志宏" class="headerlink" title="日志宏"></a>日志宏</h3><h4 id="日志级别辅助宏"><a href="#日志级别辅助宏" class="headerlink" title="日志级别辅助宏"></a>日志级别辅助宏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD gos::log_stream(LOG_DETAIL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI gos::log_stream(LOG_INFO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGW gos::log_stream(LOG_WARN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE gos::log_stream(LOG_ERROR)</span></span><br></pre></td></tr></table></figure><h4 id="条件判断日志宏"><a href="#条件判断日志宏" class="headerlink" title="条件判断日志宏"></a>条件判断日志宏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_IF(condition) ((condition) ? (LOG &lt;&lt; #condition &lt;&lt; <span class="string">&quot;, &quot;</span>) : DoNothing()))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">LOG_IF</span>(vec.<span class="built_in">size</span>() &gt; <span class="number">100</span>) &lt;&lt; <span class="string">&quot;vec is too large!&quot;</span>;</span><br><span class="line">&lt;=&gt;</span><br><span class="line"><span class="keyword">if</span>(vec.<span class="built_in">size</span>() &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;vec.size() &gt; 100&quot;</span> &lt;&lt; <span class="string">&quot;vec is too large!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样有日志等级区分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD_IF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI_IF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGW_IF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE_IF</span></span><br></pre></td></tr></table></figure><h4 id="特殊日志宏"><a href="#特殊日志宏" class="headerlink" title="特殊日志宏"></a>特殊日志宏</h4><h5 id="LOG-EVERY-N"><a href="#LOG-EVERY-N" class="headerlink" title="LOG_EVERY_N"></a>LOG_EVERY_N</h5><p>每 N 次打印一次日志</p><p>用于一些重复打印，如 ATS 报文每秒钟接收，每一条都打印则日志太多，全不打印则无法从日志中查看当前 ATS 报文是否在正常接收</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 每 60 次打印一次</span></span><br><span class="line"><span class="built_in">LOG_EVERY_N</span>(<span class="number">60</span>) &lt;&lt; <span class="string">&quot;Receive ATS Info!&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="LOG-FIRST-N"><a href="#LOG-FIRST-N" class="headerlink" title="LOG_FIRST_N"></a>LOG_FIRST_N</h5><p>前 N 次打印日志</p><p>通常用于程序启动时，确认各个线程是否正常启动，打印前 N 条日志。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 打印前五条日志</span></span><br><span class="line"><span class="built_in">LOG_FIRST_N</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="LOG-ONCE"><a href="#LOG-ONCE" class="headerlink" title="LOG_ONCE"></a>LOG_ONCE</h5><p>只打印第一次的日志</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">While</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 该日志只打印一次</span></span><br><span class="line">    LOG_ONCE &lt;&lt; <span class="string">&quot;Thread is start!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串类与日志类工具函数的演进路线图"><a href="#字符串类与日志类工具函数的演进路线图" class="headerlink" title="字符串类与日志类工具函数的演进路线图"></a>字符串类与日志类工具函数的演进路线图</h3><p>![图片](..&#x2F;resource&#x2F;2021_09_13_C++调试工具函数介绍_李建聪&#x2F;Xmind 1666080438328.png)</p><h2 id="时间相关类"><a href="#时间相关类" class="headerlink" title="时间相关类"></a>时间相关类</h2><h3 id="计时器-tick-count"><a href="#计时器-tick-count" class="headerlink" title="计时器 tick_count"></a>计时器 <code>tick_count</code></h3><p>为了更好的记录开始时间和结束时间， 所以封装该对象来记录并获取对应时间间隔的打印。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tick_count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">get_time_string</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>get_time_string()</code> 函数返回 <code>start</code> 到 <code>finish</code> 的间隔时间, 根据时间间隔大小获取的时间单位不同(<code>(s)</code>, <code>(ms)</code>, <code>(us)</code>), 这样打印可以通过搜索 <code>(s)</code> 来快速定位打印了秒级时间的日志。</p><h3 id="查看耗时百分比-stop-watch"><a href="#查看耗时百分比-stop-watch" class="headerlink" title="查看耗时百分比 stop_watch"></a>查看耗时百分比 <code>stop_watch</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stop_watch</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">(<span class="type">const</span> std::string&amp; strInfo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/// 在消息容器中，记录信息和时间间隔</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">stop_watch</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        tick.<span class="built_in">finish</span>(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">        <span class="comment">/// 遍历消息容器，并打印其间隔时间和百分比</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gos::stop_watch sw;</span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">tick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    st.<span class="built_in">tick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    st.<span class="built_in">tick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现如下日志:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2022-10-18 16:45:36.796] time:   5 (us), percent:  0.18% info: 1  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] time:   1 (us), percent:  0.04% info: 2  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] time:   2 (ms), percent: 99.74% info: 3  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] time:   1 (us), percent:  0.04% info: finish  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] Total Time: 2ms, info: finish &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br></pre></td></tr></table></figure><p>根据百分比找出耗时占比最高的代码片段, 为优化提供思路</p><h3 id="记录起止时间-interval-time-factory"><a href="#记录起止时间-interval-time-factory" class="headerlink" title="记录起止时间 interval_time_factory"></a>记录起止时间 <code>interval_time_factory</code></h3><p>为了灵活的获取间隔的时间，把 <code>interval_time</code> 做了一个单例用来全局查看时间间隔。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interval_time_factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">const</span> std::string&amp; strKey)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_interval_time.<span class="built_in">insert</span>(gos::<span class="built_in">to_string</span>(p), <span class="built_in">gos_get_uptime_1us</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(<span class="type">const</span> std::string&amp; strKey)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(<span class="string">&quot;%s interval time is %d&quot;</span>, strKey.<span class="built_in">c_str</span>(), m_interval_time[strKey]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// key: 唯一主键, value: 间隔时间记录对象</span></span><br><span class="line">    std::map&lt;std::string, interval_time&gt; m_interval_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    interval_time_factory::<span class="built_in">GetInstance</span>().<span class="built_in">start</span>(gos::<span class="built_in">to_string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    interval_time_factory::<span class="built_in">GetInstance</span>().<span class="built_in">finish</span>(gos::<span class="built_in">to_string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f2</span>();</span><br></pre></td></tr></table></figure><p>在日志中即可查看该指针从 <code>new</code> 到 <code>delete</code> 所经过的时间。</p><p>应用场景举例:</p><p>如视频帧从回调函数进入播放队列，到从队列 <code>pop</code> 后渲染完成后执行 <code>delete</code>, 为了记住该视频帧从回调函数到最终渲染的延迟时间。</p><h3 id="对象实例个数-object-counter"><a href="#对象实例个数-object-counter" class="headerlink" title="对象实例个数 object_counter"></a>对象实例个数 <code>object_counter</code></h3><p>用与查看某个对象当前存活的实例有几个.</p><p>原理为: 在构造函数中计数加一，析构函数中计数减一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> gos::object_counter</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">object obj0;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; obj<span class="number">0.</span><span class="built_in">get_count</span>();  <span class="comment">///&lt; 1</span></span><br><span class="line">&#123;</span><br><span class="line">    object obj1;</span><br><span class="line">    std::cout &lt;&lt; obj<span class="number">1.</span><span class="built_in">get_count</span>();  <span class="comment">///&lt; 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; obj<span class="number">0.</span><span class="built_in">get_count</span>();  <span class="comment">///&lt; 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对象存活时间-object-live-time"><a href="#对象存活时间-object-live-time" class="headerlink" title="对象存活时间 object_live_time"></a>对象存活时间 <code>object_live_time</code></h3><p>用于查看某个对象，构造函数到析构函数的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> gos::object_live_time</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    object obj;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">/// obj 在此处调用析构函数</span></span><br></pre></td></tr></table></figure><p>在日志中可以查看该对象的存活时间</p><h2 id="性能调优类"><a href="#性能调优类" class="headerlink" title="性能调优类"></a>性能调优类</h2><h3 id="判断函数执行时间-PROFILER"><a href="#判断函数执行时间-PROFILER" class="headerlink" title="判断函数执行时间 PROFILER"></a>判断函数执行时间 <code>PROFILER</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT64 iStart = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line">    ...</span><br><span class="line">    INT64 iFinish = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;f is spend time: %lld&quot;</span>, iFinish - iStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">profiler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">profiler</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        INT64 iStart = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">profiler</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        INT64 iFinish = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;f is spend time: %lld&quot;</span>, iFinish - iStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    INT64 iStart;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义辅助宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROFILER() profiler(__FILE__, __FUNCTION__, __LINE__)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>PROFILER()</code> 宏定义了一个临时变量，函数析构则该临时变量析构，所以该宏定义计算的是从该宏定义开始，到该函数结束的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PROFILER</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但同时应注意, 不能在同一作用域调用两次该宏定义.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PROFILER</span>();</span><br><span class="line">    <span class="built_in">PROFILER</span>(); <span class="comment">///&lt; 编译错误, 重定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断内存泄漏-MEMORY-CHECK"><a href="#判断内存泄漏-MEMORY-CHECK" class="headerlink" title="判断内存泄漏 MEMORY_CHECK"></a>判断内存泄漏 <code>MEMORY_CHECK</code></h3><p>该宏定义依赖于 <code>Windows</code> 的系统函数。(<code>Linux</code> 和 <code>C++ Builder</code> 中无法使用)</p><p>具体实现也是在构造函数中记录当前程序使用的内存数， 析构函数中记录内存差值后打印是否内存泄漏。</p><h2 id="业务辅助类"><a href="#业务辅助类" class="headerlink" title="业务辅助类"></a>业务辅助类</h2><h3 id="区间求值函数-clamp"><a href="#区间求值函数-clamp" class="headerlink" title="区间求值函数 clamp"></a>区间求值函数 <code>clamp</code></h3><p>实现功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">clamp</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value, <span class="type">const</span> <span class="type">int</span>&amp; low, <span class="type">const</span> <span class="type">int</span>&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value &lt; low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 数值小于下界， 返回下界值</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(height &lt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 数值大于上界， 返回上界值</span></span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 返回原始值</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Conf.<span class="built_in">GetValue</span>(<span class="string">&quot;max_timeout&quot;</span>, iMaxTimeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断配置项是否配置超出范围</span></span><br><span class="line"><span class="built_in">LOG_IF</span>(iMaxTimeout != gos::<span class="built_in">clamp</span>(iMaxTimeout, <span class="number">0</span>, <span class="number">3600</span>) &lt;&lt; <span class="string">&quot;config is out of range!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 或者自动限制范围</span></span><br><span class="line">iMaxTimeout = gos::<span class="built_in">clamp</span>(iMaxTimeout, <span class="number">0</span>, <span class="number">3600</span>);</span><br></pre></td></tr></table></figure><h3 id="心跳业务类-heartbeat"><a href="#心跳业务类-heartbeat" class="headerlink" title="心跳业务类 heartbeat"></a>心跳业务类 <code>heartbeat</code></h3><p>把心跳业务封装成对象，用于其他业务调用.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">heartbeat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">heartbeat</span>(<span class="type">int</span> max_time_ms);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">live</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">is_live</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 最大超时时间为 3s</span></span><br><span class="line"><span class="function">heartbeat <span class="title">obj</span><span class="params">(<span class="number">3000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// app 心跳消息来了</span></span><br><span class="line">obj.<span class="built_in">live</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// app 心跳消息来了</span></span><br><span class="line">obj.<span class="built_in">live</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在定时器中定期轮询</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">timer</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="built_in">is_live</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时业务类-timeout"><a href="#超时业务类-timeout" class="headerlink" title="超时业务类 timeout"></a>超时业务类 <code>timeout</code></h3><p>把超时业务封装成对象，用于其他业务调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">timeout</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">timeout</span>(<span class="type">int</span> max_time_ms) : <span class="built_in">m_heartbeat</span>(max_time_ms)</span><br><span class="line">    &#123;</span><br><span class="line">        m_heartbeat.<span class="built_in">live</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_timeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !m_heartbeat.<span class="built_in">is_live</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    gos::heartbeat m_heartbeat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请呼业务呼入时, 定义 60s 超时的对象</span></span><br><span class="line"><span class="function">timeout <span class="title">obj</span><span class="params">(<span class="number">60</span> * <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定时器轮询</span></span><br><span class="line"><span class="keyword">if</span>(obj.<span class="built_in">is_timeout</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模糊比较-approx-与-float-approx"><a href="#模糊比较-approx-与-float-approx" class="headerlink" title="模糊比较 approx 与 float_approx"></a>模糊比较 <code>approx</code> 与 <code>float_approx</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">approx</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">approx</span>(<span class="type">const</span> <span class="type">int64_t</span>&amp; anchor, <span class="type">const</span> <span class="type">int64_t</span>&amp; diff) : <span class="built_in">m_anchor</span>(anchor), <span class="built_in">m_diff</span>(diff) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 判断数值是否与本对象定义的数值相近, 数值在 [m_anchor - m_diff, m_anchor + m_diff] 返回真</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> <span class="type">int64_t</span>&amp; number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">abs</span>(number - m_anchor) &lt;= m_diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int64_t</span> m_anchor;  <span class="comment">///&lt; 用于比较的锚点值</span></span><br><span class="line">    <span class="type">int64_t</span> m_diff;    <span class="comment">///&lt; 浮动的数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gos::tick_count timer;</span><br><span class="line">timer.<span class="built_in">start</span>();  <span class="comment">///&lt; 计时开始</span></span><br><span class="line"><span class="built_in">gos_sleep_ms</span>(<span class="number">20</span>);</span><br><span class="line">timer.<span class="built_in">finish</span>(); <span class="comment">///&lt; 计时结束</span></span><br><span class="line"><span class="type">int</span> time = timer.<span class="built_in">get_ms</span>();</span><br><span class="line"><span class="comment">/// 判断时间间隔是否在 20 正负 1 的范围</span></span><br><span class="line"><span class="keyword">if</span>(gos::<span class="built_in">approx</span>(<span class="number">20</span>, <span class="number">1</span>).<span class="built_in">equal</span>(time))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥量辅助类-lock-guard"><a href="#互斥量辅助类-lock-guard" class="headerlink" title="互斥量辅助类 lock_guard"></a>互斥量辅助类 <code>lock_guard</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lock_guard</span>(gos::mutex&amp; mutex) : <span class="built_in">m_mutex</span>(mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">lock_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    gos::mutex&amp; m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑如下情况:</p><ol><li>多个函数返回</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gos::mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard</span><span class="params">(mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>返回语句中有被保护数据的读写</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>抛出异常</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard</span><span class="params">(mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        queue.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>多个锁</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gos::mutex mutex1;</span><br><span class="line">gos::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(condition)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取更新数据的-GetDifferenceBetweenVector"><a href="#获取更新数据的-GetDifferenceBetweenVector" class="headerlink" title="获取更新数据的 GetDifferenceBetweenVector"></a>获取更新数据的 <code>GetDifferenceBetweenVector</code></h3><p>为了比较新旧数据，增加、删除或更新的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           获取新旧两个 vector, 需要添加的元素，需要删除的元素，和重复的元素</span></span><br><span class="line"><span class="comment"> * @param           vecOld    [in]  旧数据</span></span><br><span class="line"><span class="comment"> * @param           vecNew    [in]  新数据</span></span><br><span class="line"><span class="comment"> * @param           vecAdd    [out] 需要添加的元素</span></span><br><span class="line"><span class="comment"> * @param           vecDel    [out] 需要删除的元素</span></span><br><span class="line"><span class="comment"> * @param           vecUnion  [out] 需要更新的元素</span></span><br><span class="line"><span class="comment"> * @return          true</span></span><br><span class="line"><span class="comment"> * @return          false</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @date            2022-06-02 13:50:34</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">GetDifferenceBetweenVector</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; vecOld, <span class="type">const</span> std::vector&lt;T&gt;&amp; vecNew,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       std::vector&lt;T&gt;&amp; vecAdd, std::vector&lt;T&gt;&amp; vecDel, std::vector&lt;T&gt;&amp; vecUnion)</span></span>;</span><br></pre></td></tr></table></figure><p>使用场景: ATS 数据更新线路图:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetDifferenceBetweenVector</span>(vecOldATS, vecNewATS, vecAdd, vecDel, vecUnion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; vecAdd.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 创建列车图标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; vecDel.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 删除列车图标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; vecUnion.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 更新列车图标位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊字符转义函数-EscapeCharUtility"><a href="#特殊字符转义函数-EscapeCharUtility" class="headerlink" title="特殊字符转义函数 EscapeCharUtility"></a>特殊字符转义函数 <code>EscapeCharUtility</code></h3><p>我们已知 GJson 是无法解析带有， <code>&quot;</code>、<code>\&quot;</code>、<code>,&#125;</code>, 但是保存调度台短信历史的时候，短信内容可能包含这些特殊字符。</p><p>如 <code>&quot;</code> 转换为 <code>%quotes;</code>、 <code>\</code> 转换为 <code>%backslash;</code></p><p>所以采用把特殊字符转换为特定的字符串，再转换成 json 字符串，到服务器后解析出来再替换回来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 特殊字符转码</span></span><br><span class="line">gos::<span class="built_in">EncodeEscapeChar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 特殊字符解码</span></span><br><span class="line">gos::<span class="built_in">DecodeEscapeChar</span>();</span><br></pre></td></tr></table></figure><h3 id="输入字符串检查对象-input-check"><a href="#输入字符串检查对象-input-check" class="headerlink" title="输入字符串检查对象 input_check"></a>输入字符串检查对象 <code>input_check</code></h3><p>使用场景:</p><p>用户输入某个字符串，该字符串需要符合某种规则。</p><ul><li>所有字符是数字</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sz != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*sz &lt; <span class="number">0</span> || *sz &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有字符是 <code>a~z</code>、 <code>A~Z</code> 和 <code>0~9</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sz != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(*sz))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如 <code>MAC</code> 地址中可能会出现 十六进制字符的间隔符号可能为 ‘:’、’-‘ 或者 ‘ ‘</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sz != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*sz != <span class="string">&#x27;:&#x27;</span> &amp;&amp; *sz != <span class="string">&#x27;-&#x27;</span> &amp;&amp; *sz != <span class="string">&#x27; &#x27;</span> &amp;&amp; !(*sz &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *sz &lt;= <span class="string">&#x27;f&#x27;</span>) &amp;&amp; !(*sz &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *sz &lt;= <span class="string">&#x27;F&#x27;</span>) &amp;&amp;</span><br><span class="line">            !(*sz &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *sz &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>强密码, 要求字符串中有数字、大小写字母和特殊符号</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((遍历一遍，查看是否拥有至少一个数字字符)</span><br><span class="line">        &amp;&amp; (遍历一遍, 查看是否拥有至少一个大写字母)</span><br><span class="line">        &amp;&amp; (遍历一遍, 查看是否拥有至少一个小写字母)</span><br><span class="line">        &amp;&amp; (遍历一遍, 查看是否有至少一个数字字符))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这些函数中，抽象出来了集中规则。</p><ul><li>字符符合某种规则(如数字、十六进制字符)</li><li>字符串中所有字符，全部符合、全部不符合和部分符合规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 假如每个字符都符合特定规则(字符为数字)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all_of</span>(str, IsNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNumber</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FUNC)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, FUNC pF)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = str.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pF</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all_of</span>(str, IsNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsUpcaseLetter</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">any_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, FUNC pF)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 这个字符串有任一大写字母 且 有任一数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any_of</span>(str, IsUpcaseLetter) &amp;&amp; <span class="built_in">any_of</span>(str, IsNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法:</p><p><code>input_check</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gos::input_check filter;</span><br><span class="line">    filter.<span class="built_in">AddRules</span>(any_of, IsNumber).<span class="built_in">AddRules</span>(any_of, IsUpcastLetter);</span><br><span class="line">    <span class="keyword">return</span> filter.<span class="built_in">IsValid</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="json-解析对象接口"><a href="#json-解析对象接口" class="headerlink" title="json 解析对象接口"></a><code>json</code> 解析对象接口</h3><p>定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">json_parser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 虚析构函数, 防止内存泄漏</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">json_parser</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 结构体转 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Json 字符串转结构体</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> json_parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::string str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 结构体转 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GJsonParam Param;</span><br><span class="line"></span><br><span class="line">        Param.<span class="built_in">Add</span>(<span class="string">&quot;int&quot;</span>, i);</span><br><span class="line">        Param.<span class="built_in">Add</span>(<span class="string">&quot;string&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">        strJson = Param.<span class="built_in">GetString</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GJson Json;</span><br><span class="line">        <span class="keyword">return</span> Json.<span class="built_in">Parse</span>(str) &amp;&amp; Json.<span class="built_in">GetValue</span>(<span class="string">&quot;int&quot;</span>, i) &amp;&amp; Json.<span class="built_in">GetValue</span>(<span class="string">&quot;string&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">object obj;</span><br><span class="line"></span><br><span class="line">std::string strJson;</span><br><span class="line"><span class="comment">/// 获取 json 字符串</span></span><br><span class="line">obj.<span class="built_in">StructToJson</span>(strJson);</span><br><span class="line"><span class="comment">/// 发送消息</span></span><br><span class="line"><span class="built_in">SendMsg</span>(strJson);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">json_parser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 结构体转 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Json 字符串转结构体</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 转化结构体数组到 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VectorToJson</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt; &amp;vec, std::string &amp;str)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 转换 Json 字符串到结构体数组</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">JsonToVector</span><span class="params">(<span class="type">const</span> std::string &amp;strFormatString, std::vector&lt;T&gt; &amp;vec)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> json_parser&lt;object&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;object&gt; vecObj;</span><br><span class="line"></span><br><span class="line">object ObjTemp;</span><br><span class="line">std::string strJson;</span><br><span class="line"><span class="comment">/// 数组 转换 json</span></span><br><span class="line">ObjTemp.<span class="built_in">VectorToJson</span>(vecObj, strJson);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// json 转换 数组</span></span><br><span class="line">ObjTemp.<span class="built_in">JsonToStruct</span>(strJson, vecObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附加介绍-智能指针"><a href="#附加介绍-智能指针" class="headerlink" title="附加介绍: 智能指针"></a>附加介绍: 智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : <span class="built_in">pCount</span>(<span class="keyword">new</span> <span class="type">int</span>), <span class="built_in">p</span>(pData)</span><br><span class="line">    &#123;</span><br><span class="line">        *pCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        pCount = stOther.pCount;</span><br><span class="line">        pData = stOther.pData;</span><br><span class="line"></span><br><span class="line">        ++(*pCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        --(*pCount);</span><br><span class="line">        <span class="keyword">if</span>(*pCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> pCount;</span><br><span class="line">            <span class="keyword">delete</span> pData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* pCount;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr obj0; <span class="comment">///&lt; pCount == 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr obj1 = stOther; <span class="comment">///&lt; pCount == 2</span></span><br><span class="line">    &#125; <span class="comment">///&lt; obj1 析构, pCount == 1</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">///&lt;  obj0 析构, pCount 自减为 0, 执行 delete 操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 实现高性能内存池</title>
      <link href="/2023/07/21/2022-12-23-C++%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E6%B1%A0/"/>
      <url>/2023/07/21/2022-12-23-C++%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>本文探讨了C&#x2F;C++中内存管理的复杂性，并提出通过实现内存池技术来优化内存分配性能。内存池通过预先分配一块内存区域，减少频繁的系统调用和内存碎片，从而提高效率。文章详细介绍了内存池的设计与实现，包括关键接口如allocate()、deallocate()、construct()和destroy()，并通过模板链表栈测试其性能。最终，内存池在栈结构中的表现优于std::allocator和std::vector，显著提升了内存分配效率。</p><span id="more"></span><p>在 C&#x2F;C++ 中，内存管理是一个非常棘手的问题，我们在编写一个程序的时候几乎不可避免的要遇到内存的分配逻辑，这时候随之而来的有这样一些问题：是否有足够的内存可供分配? 分配失败了怎么办? 如何管理自身的内存使用情况? 等等一系列问题。在一个高可用的软件中，如果我们仅仅单纯的向操作系统去申请内存，当出现内存不足时就退出软件，是明显不合理的。正确的思路应该是在内存不足的时，考虑如何管理并优化自身已经使用的内存，这样才能使得软件变得更加可用。本次项目我们将实现一个内存池，并使用一个栈结构来测试我们的内存池提供的分配性能。最终，我们要实现的内存池在栈结构中的性能，要远高于使用 <code>std::allocator</code> 和 <code>std::vector</code>.</p><ul><li>C++ 中的内存分配器 <code>std::allocator</code></li><li>内存池技术</li><li>手动实现模板链式栈</li><li>链式栈和列表栈的性能比较</li></ul><h3 id="内存池简介"><a href="#内存池简介" class="headerlink" title="内存池简介"></a>内存池简介</h3><p>内存池是池化技术中的一种形式。通常我们在编写程序的时候回使用 <code>new</code> <code>delete</code> 这些关键字来向操作系统申请内存，而这样造成的后果就是每次申请内存和释放内存的时候，都需要和操作系统的系统调用打交道，从堆中分配所需的内存。如果这样的操作太过频繁，就会找成大量的内存碎片进而降低内存的分配性能，甚至出现内存分配失败的情况。</p><p>而内存池就是为了解决这个问题而产生的一种技术。从内存分配的概念上看，内存申请无非就是向内存分配方索要一个指针，当向操作系统申请内存时，操作系统需要进行复杂的内存管理调度之后，才能正确的分配出一个相应的指针。而这个分配的过程中，我们还面临着分配失败的风险。</p><p>所以，每一次进行内存分配，就会消耗一次分配内存的时间，设这个时间为 T，那么进行 n 次分配总共消耗的时间就是 nT；如果我们一开始就确定好我们可能需要多少内存，那么在最初的时候就分配好这样的一块内存区域，当我们需要内存的时候，直接从这块已经分配好的内存中使用即可，那么总共需要的分配时间仅仅只有 T。当 n 越大时，节约的时间就越多。</p><h2 id="二、主函数设计"><a href="#二、主函数设计" class="headerlink" title="二、主函数设计"></a>二、主函数设计</h2><p>我们要设计实现一个高性能的内存池，那么自然避免不了需要对比已有的内存，而比较内存池对内存的分配性能，就需要实现一个需要对内存进行动态分配的结构（比如：链表栈），为此，可以写出如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span>    <span class="comment">// assert()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>      <span class="comment">// clock()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>     <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MemoryPool.hpp&quot;</span>  <span class="comment">// MemoryPool&lt;T&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StackAlloc.hpp&quot;</span>  <span class="comment">// StackAlloc&lt;T, Alloc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMS 10000000</span></span><br><span class="line"><span class="comment">// 重复次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REPS 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 STL 默认分配器</span></span><br><span class="line">    StackAlloc&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; stackDefault;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackDefault.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default Allocator Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存池</span></span><br><span class="line">    StackAlloc&lt;<span class="type">int</span>, MemoryPool&lt;<span class="type">int</span>&gt; &gt; stackPool;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackPool.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackPool.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackPool.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MemoryPool Allocator Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的两段代码中，<code>StackAlloc</code> 是一个链表栈，接受两个模板参数，第一个参数是栈中的元素类型，第二个参数就是栈使用的内存分配器。</p><p>因此，这个内存分配器的模板参数就是整个比较过程中唯一的变量，使用默认分配器的模板参数为 <code>std::allocator</code>，而使用内存池的模板参数为 <code>MemoryPool</code>。</p><blockquote><p>std::allocator 是 C++标准库中提供的默认分配器，他的特点就在于我们在 使用 new 来申请内存构造新对象的时候，势必要调用类对象的默认构造函数，而使用 std::allocator 则可以将内存分配和对象的构造这两部分逻辑给分离开来，使得分配的内存是原始、未构造的。</p></blockquote><p>下面我们来实现这个链表栈。</p><h2 id="三、模板链表栈"><a href="#三、模板链表栈" class="headerlink" title="三、模板链表栈"></a>三、模板链表栈</h2><p>栈的结构非常的简单，没有什么复杂的逻辑操作，其成员函数只需要考虑两个基本的操作：入栈、出栈。为了操作上的方便，我们可能还需要这样一些方法：判断栈是否空、清空栈、获得栈顶元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode_</span></span><br><span class="line">&#123;</span><br><span class="line">  T data;</span><br><span class="line">  StackNode_* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 为存储的对象类型, Alloc 为使用的分配器, 并默认使用 std::allocator 作为对象的分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = std::allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> StackAlloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 typedef 简化类型名</span></span><br><span class="line">    <span class="keyword">typedef</span> StackNode_&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::<span class="keyword">template</span> rebind&lt;Node&gt;::other allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">StackAlloc</span>() &#123; head_ = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 默认析构</span></span><br><span class="line">    ~<span class="built_in">StackAlloc</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当栈中元素为空时返回 true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (head_ == <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放栈中元素的所有内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (head_-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    allocator allocator_;</span><br><span class="line">    <span class="comment">// 栈顶</span></span><br><span class="line">    Node* head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单的逻辑诸如构造、析构、判断栈是否空、返回栈顶元素的逻辑都非常简单，直接在上面的定义中实现了，下面我们来实现 <code>clear()</code>, <code>push()</code> 和 <code>pop()</code> 这三个重要的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放栈中元素的所有内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node* curr = head_;</span><br><span class="line">  <span class="comment">// 依次出栈</span></span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Node* tmp = curr-&gt;prev;</span><br><span class="line">    <span class="comment">// 先析构, 再回收内存</span></span><br><span class="line">    allocator_.<span class="built_in">destroy</span>(curr);</span><br><span class="line">    allocator_.<span class="built_in">deallocate</span>(curr, <span class="number">1</span>);</span><br><span class="line">    curr = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  head_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为一个节点分配内存</span></span><br><span class="line">  Node* newNode = allocator_.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 调用节点的构造函数</span></span><br><span class="line">  allocator_.<span class="built_in">construct</span>(newNode, <span class="built_in">Node</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  newNode-&gt;data = element;</span><br><span class="line">  newNode-&gt;prev = head_;</span><br><span class="line">  head_ = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 出栈操作 返回出栈元素</span></span><br><span class="line">  T result = head_-&gt;data;</span><br><span class="line">  Node* tmp = head_-&gt;prev;</span><br><span class="line">  allocator_.<span class="built_in">destroy</span>(head_);</span><br><span class="line">  allocator_.<span class="built_in">deallocate</span>(head_, <span class="number">1</span>);</span><br><span class="line">  head_ = tmp;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节我们实现了一个用于测试性能比较的模板链表栈，目前的代码如下。在下一节中，我们开始详细实现我们的高性能内存池。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StackAlloc.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_ALLOC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_ALLOC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode_</span></span><br><span class="line">&#123;</span><br><span class="line">  T data;</span><br><span class="line">  StackNode_* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 为存储的对象类型, Alloc 为使用的分配器,</span></span><br><span class="line"><span class="comment">// 并默认使用 std::allocator 作为对象的分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = std::allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> StackAlloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 typedef 简化类型名</span></span><br><span class="line">    <span class="keyword">typedef</span> StackNode_&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::<span class="keyword">template</span> rebind&lt;Node&gt;::other allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">StackAlloc</span>() &#123; head_ = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 默认析构</span></span><br><span class="line">    ~<span class="built_in">StackAlloc</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当栈中元素为空时返回 true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (head_ == <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放栈中元素的所有内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Node* curr = head_;</span><br><span class="line">      <span class="keyword">while</span> (curr != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        Node* tmp = curr-&gt;prev;</span><br><span class="line">        allocator_.<span class="built_in">destroy</span>(curr);</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(curr, <span class="number">1</span>);</span><br><span class="line">        curr = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      head_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 为一个节点分配内存</span></span><br><span class="line">      Node* newNode = allocator_.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 调用节点的构造函数</span></span><br><span class="line">      allocator_.<span class="built_in">construct</span>(newNode, <span class="built_in">Node</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 入栈操作</span></span><br><span class="line">      newNode-&gt;data = element;</span><br><span class="line">      newNode-&gt;prev = head_;</span><br><span class="line">      head_ = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 出栈操作 返回出栈结果</span></span><br><span class="line">      T result = head_-&gt;data;</span><br><span class="line">      Node* tmp = head_-&gt;prev;</span><br><span class="line">      allocator_.<span class="built_in">destroy</span>(head_);</span><br><span class="line">      allocator_.<span class="built_in">deallocate</span>(head_, <span class="number">1</span>);</span><br><span class="line">      head_ = tmp;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (head_-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    allocator allocator_;</span><br><span class="line">    Node* head_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// STACK_ALLOC_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &quot;MemoryPool.hpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StackAlloc.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据电脑性能调整这些值</span></span><br><span class="line"><span class="comment">// 插入元素个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMS 25000000</span></span><br><span class="line"><span class="comment">// 重复次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REPS 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认分配器</span></span><br><span class="line">    StackAlloc&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; stackDefault;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackDefault.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default Allocator Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存池</span></span><br><span class="line">    <span class="comment">// StackAlloc&lt;int, MemoryPool&lt;int&gt; &gt; stackPool;</span></span><br><span class="line">    <span class="comment">// start = clock();</span></span><br><span class="line">    <span class="comment">// for (int j = 0; j &lt; REPS; j++) &#123;</span></span><br><span class="line">    <span class="comment">//     assert(stackPool.empty());</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; ELEMS; i++)</span></span><br><span class="line">    <span class="comment">//       stackPool.push(i);</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; ELEMS; i++)</span></span><br><span class="line">    <span class="comment">//       stackPool.pop();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;MemoryPool Allocator Time: &quot;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; (((double)clock() - start) / CLOCKS_PER_SEC) &lt;&lt; &quot;\n\n&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、设计内存池"><a href="#二、设计内存池" class="headerlink" title="二、设计内存池"></a>二、设计内存池</h2><p>在节中，我们在模板链表栈中使用了默认构造器来管理栈操作中的元素内存，一共涉及到了 <code>rebind::other</code>, <code>allocate()</code>, <code>dealocate()</code>, <code>construct()</code>, <code>destroy()</code>这些关键性的接口。所以为了让代码直接可用，我们同样应该在内存池中设计同样的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MEMORY_POOL_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_POOL_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize = <span class="number">4096</span>&gt;</span><br><span class="line"><span class="keyword">class</span> MemoryPool</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 typedef 简化类型书写</span></span><br><span class="line">    <span class="keyword">typedef</span> T*              pointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 rebind&lt;U&gt;::other 接口</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123;</span><br><span class="line">      <span class="keyword">typedef</span> MemoryPool&lt;U&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造, 初始化所有的槽指针</span></span><br><span class="line">    <span class="comment">// C++11 使用了 noexcept 来显式的声明此函数不会抛出异常</span></span><br><span class="line">    <span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">      currentBlock_ = <span class="literal">nullptr</span>;</span><br><span class="line">      currentSlot_ = <span class="literal">nullptr</span>;</span><br><span class="line">      lastSlot_ = <span class="literal">nullptr</span>;</span><br><span class="line">      freeSlots_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁一个现有的内存池</span></span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间只能分配一个对象, n 和 hint 会被忽略</span></span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n = <span class="number">1</span>, <span class="type">const</span> T* hint = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁指针 p 指向的内存区块</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, <span class="type">size_t</span> n = <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用构造函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(U* p, Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池中的对象, 即调用对象的析构函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(U* p)</span> </span>&#123;</span><br><span class="line">      p-&gt;~<span class="built_in">U</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用于存储内存池中的对象槽,</span></span><br><span class="line">    <span class="comment">// 要么被实例化为一个存放对象的槽,</span></span><br><span class="line">    <span class="comment">// 要么被实例化为一个指向存放对象槽的槽指针</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">Slot_</span> &#123;</span><br><span class="line">      T element;</span><br><span class="line">      Slot_* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据指针</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span>* data_pointer_;</span><br><span class="line">    <span class="comment">// 对象槽</span></span><br><span class="line">    <span class="keyword">typedef</span> Slot_ slot_type_;</span><br><span class="line">    <span class="comment">// 对象槽指针</span></span><br><span class="line">    <span class="keyword">typedef</span> Slot_* slot_pointer_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前内存区块</span></span><br><span class="line">    slot_pointer_ currentBlock_;</span><br><span class="line">    <span class="comment">// 指向当前内存区块的一个对象槽</span></span><br><span class="line">    slot_pointer_ currentSlot_;</span><br><span class="line">    <span class="comment">// 指向当前内存区块的最后一个对象槽</span></span><br><span class="line">    slot_pointer_ lastSlot_;</span><br><span class="line">    <span class="comment">// 指向当前内存区块中的空闲对象槽</span></span><br><span class="line">    slot_pointer_ freeSlots_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查定义的内存池大小是否过小</span></span><br><span class="line">    <span class="built_in">static_assert</span>(BlockSize &gt;= <span class="number">2</span> * <span class="built_in">sizeof</span>(slot_type_), <span class="string">&quot;BlockSize too small.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MEMORY_POOL_HPP</span></span></span><br></pre></td></tr></table></figure><p>在上面的类设计中可以看到，在这个内存池中，其实是使用链表来管理整个内存池的内存区块的。内存池首先会定义固定大小的基本内存区块(Block)，然后在其中定义了一个可以实例化为存放对象内存槽的对象槽（Slot_）和对象槽指针的一个联合。然后在区块中，定义了四个关键性质的指针，它们的作用分别是：</p><ol><li><code>currentBlock_</code>: 指向当前内存区块的指针</li><li><code>currentSlot_</code>: 指向当前内存区块中的对象槽</li><li><code>lastSlot_</code>: 指向当前内存区块中的最后一个对象槽</li><li><code>freeSlots_</code>: 指向当前内存区块中所有空闲的对象槽</li></ol><p>梳理好整个内存池的设计结构之后，我们就可以开始实现关键性的逻辑了。</p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="MemoryPool-construct-实现"><a href="#MemoryPool-construct-实现" class="headerlink" title="MemoryPool::construct() 实现"></a>MemoryPool::construct() 实现</h3><p><code>MemoryPool::construct()</code> 的逻辑是最简单的，我们需要实现的，仅仅只是调用信件对象的构造函数即可，因此：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用构造函数, 使用 std::forward 转发变参模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(U* p, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (p) <span class="built_in">U</span> (std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MemoryPool-deallocate-实现"><a href="#MemoryPool-deallocate-实现" class="headerlink" title="MemoryPool::deallocate() 实现"></a>MemoryPool::deallocate() 实现</h3><p><code>MemoryPool::deallocate()</code> 是在对象槽中的对象被析构后才会被调用的，主要目的是销毁内存槽。其逻辑也不复杂：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁指针 p 指向的内存区块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, <span class="type">size_t</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// reinterpret_cast 是强制类型转换符</span></span><br><span class="line">    <span class="comment">// 要访问 next 必须强制将 p 转成 slot_pointer_</span></span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(p)-&gt;next = freeSlots_;</span><br><span class="line">    freeSlots_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MemoryPool-MemoryPool-实现"><a href="#MemoryPool-MemoryPool-实现" class="headerlink" title="MemoryPool::~MemoryPool() 实现"></a>MemoryPool::~MemoryPool() 实现</h3><p>析构函数负责销毁整个内存池，因此我们需要逐个删除掉最初向操作系统申请的内存块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁一个现有的内存池</span></span><br><span class="line">~<span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// 循环销毁内存池中分配的内存区块</span></span><br><span class="line">  slot_pointer_ curr = currentBlock_;</span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    slot_pointer_ prev = curr-&gt;next;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(curr))</span></span>;</span><br><span class="line">    curr = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MemoryPool-allocate-实现"><a href="#MemoryPool-allocate-实现" class="headerlink" title="MemoryPool::allocate() 实现"></a>MemoryPool::allocate() 实现</h3><p><code>MemoryPool::allocate()</code> 毫无疑问是整个内存池的关键所在，但实际上理清了整个内存池的设计之后，其实现并不复杂。具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一时间只能分配一个对象, n 和 hint 会被忽略</span></span><br><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n = <span class="number">1</span>, <span class="type">const</span> T* hint = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有空闲的对象槽，那么直接将空闲区域交付出去</span></span><br><span class="line">  <span class="keyword">if</span> (freeSlots_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    pointer result = <span class="built_in">reinterpret_cast</span>&lt;pointer&gt;(freeSlots_);</span><br><span class="line">    freeSlots_ = freeSlots_-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果对象槽不够用了，则分配一个新的内存区块</span></span><br><span class="line">    <span class="keyword">if</span> (currentSlot_ &gt;= lastSlot_) &#123;</span><br><span class="line">      <span class="comment">// 分配一个新的内存区块，并指向前一个内存区块</span></span><br><span class="line">      data_pointer_ newBlock = <span class="built_in">reinterpret_cast</span>&lt;data_pointer_&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(BlockSize));</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(newBlock)-&gt;next = currentBlock_;</span><br><span class="line">      currentBlock_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(newBlock);</span><br><span class="line">      <span class="comment">// 填补整个区块来满足元素内存区域的对齐要求</span></span><br><span class="line">      data_pointer_ body = newBlock + <span class="built_in">sizeof</span>(slot_pointer_);</span><br><span class="line">      <span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(body);</span><br><span class="line">      <span class="type">size_t</span> bodyPadding = (<span class="built_in">alignof</span>(slot_type_) - result) % <span class="built_in">alignof</span>(slot_type_);</span><br><span class="line">      currentSlot_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(body + bodyPadding);</span><br><span class="line">      lastSlot_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(newBlock + BlockSize - <span class="built_in">sizeof</span>(slot_type_) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;pointer&gt;(currentSlot_++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、与-std-vector-的性能对比"><a href="#四、与-std-vector-的性能对比" class="headerlink" title="四、与 std::vector 的性能对比"></a>四、与 std::vector 的性能对比</h2><p>我们知道，对于栈来说，链栈其实并不是最好的实现方式，因为这种结构的栈不可避免的会涉及到指针相关的操作，同时，还会消耗一定量的空间来存放节点之间的指针。事实上，我们可以使用 <code>std::vector</code> 中的 <code>push_back()</code> 和 <code>pop_back()</code> 这两个操作来模拟一个栈，我们不妨来对比一下这个 <code>std::vector</code> 与我们所实现的内存池在性能上谁高谁低，我们在 主函数中加入如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较内存池和 std::vector 之间的性能</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; stackVector;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackVector.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackVector.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackVector.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件自动化测试方法和技术</title>
      <link href="/2023/07/21/2023-06-27-%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/07/21/2023-06-27-%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>软件自动化测试是指利用自动化工具和脚本来执行测试任务和验证软件系统的过程。它通过编写脚本和使用自动化工具来模拟用户操作、执行测试用例、比较预期结果和实际结果，从而自动化执行软件测试过程。</p><span id="more"></span><h2 id="自动化测试目的"><a href="#自动化测试目的" class="headerlink" title="自动化测试目的"></a>自动化测试目的</h2><p>为什么要使用自动化测试？</p><ol><li>节省人力</li><li>质量保障</li><li>量化代码质量（代码测试覆盖率）</li><li>便于重构</li><li>回归测试的快速迭代</li></ol><h2 id="C-自动化测试框架的选择"><a href="#C-自动化测试框架的选择" class="headerlink" title="C++ 自动化测试框架的选择"></a>C++ 自动化测试框架的选择</h2><table><thead><tr><th align="center">自动化测试框架</th><th align="center">GitHub Starts</th><th align="center">Standard Support</th><th align="center">Header-only</th><th align="center">Fixtures</th><th align="center">Mock</th><th align="center">BDD-style</th></tr></thead><tbody><tr><td align="center"><a href="https://github.com/google/googletest">Google Test</a></td><td align="center">30.2k</td><td align="center">C++14</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center"><a href="https://github.com/catchorg/Catch2">Catch2</a></td><td align="center">16.8k</td><td align="center">C++14</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center"><a href="https://github.com/doctest/doctest">DOCTest</a></td><td align="center">5.0k</td><td align="center">C++14</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr></tbody></table><ul><li><code>Google Test</code> 使用人数最多，功能最全面。</li><li><code>Catch2</code> 易于集成，支持 <code>BDD-style</code>，但是不支持 <code>Mock</code>。</li><li><code>DOCTest</code> 易于集成，不支持 <code>Mock</code>。</li></ul><h2 id="GoogleTest-简介"><a href="#GoogleTest-简介" class="headerlink" title="GoogleTest 简介"></a>GoogleTest 简介</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retrun i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(f,simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">f</span>(<span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="built_in">f</span>(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 Google Test 框架</span></span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="comment">// 运行所有测试用例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../resource/auto_test/Snipaste_2023-06-27_18-07-03.png" alt="image"></p><ul><li>改变函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retrun i<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../resource/auto_test/Snipaste_2023-06-27_18-21-20.png" alt="image"></p><ul><li>类推其他复杂函数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void f(std::string str, std::string&amp; out)</span><br><span class="line">&#123;</span><br><span class="line">    out = str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(f, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    std::string in = &quot;Hello world&quot;;</span><br><span class="line">    std::string out;</span><br><span class="line"></span><br><span class="line">    f(in, out);</span><br><span class="line"></span><br><span class="line">    ASSERT_EQ(out, in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../resource/auto_test/Snipaste_2023-07-12_18-54-50.png" alt="image"></p><ul><li>为失败添加更多说明</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASSERT(st.IsSuccess()) &lt;&lt; &quot;st is not success!&quot;;</span><br><span class="line">ASSERT(st.IsSuccess()) &lt;&lt; DBG(st);</span><br></pre></td></tr></table></figure><h2 id="ASSERT-宏说明"><a href="#ASSERT-宏说明" class="headerlink" title="ASSERT 宏说明"></a>ASSERT 宏说明</h2><p><a href="https://google.github.io/googletest/reference/assertions.html">GoogleTest ASSERT 官方说明</a>{: .btn .btn–success}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ASSERT_TRUE(condition);     <span class="comment">///&lt; true</span></span><br><span class="line">ASSERT_FALSE(condition);    <span class="comment">///&lt; false</span></span><br><span class="line"></span><br><span class="line">ASSERT_EQ(val1,val2);       <span class="comment">///&lt; val1 == val2</span></span><br><span class="line">ASSERT_NE(val1,val2);       <span class="comment">///&lt; val1 != val2</span></span><br><span class="line"></span><br><span class="line">ASSERT_LT(val1,val2);   <span class="comment">///&lt; val1 &lt; val2</span></span><br><span class="line">ASSERT_LE(val1,val2);   <span class="comment">///&lt; val1 &lt;= val2</span></span><br><span class="line">ASSERT_GT(val1,val2);   <span class="comment">///&lt; val1 &gt; val2</span></span><br><span class="line">ASSERT_GE(val1,val2);   <span class="comment">///&lt; val1 &gt;= val2</span></span><br><span class="line"></span><br><span class="line">ASSERT_STRCASEEQ(str1,str2);    <span class="comment">///&lt; str1 == str2(忽略大小写)</span></span><br><span class="line">ASSERT_FLOAT_EQ(val1,val2);     <span class="comment">///&lt; 浮点数比较,误差小于 4ULP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 数值模糊比较，std::abs(val1 - val2) &lt;= abs_error</span></span><br><span class="line">ASSERT_NEAR(val1,val2,abs_error);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 语句 statement 抛出异常，且异常的类型为 exception_type</span></span><br><span class="line">ASSERT_THROW(statement,exception_type);</span><br><span class="line"><span class="comment">/// 语句 statement 抛出异常，但不限定异常类型</span></span><br><span class="line">ASSERT_ANY_THROW(statement);</span><br><span class="line"><span class="comment">/// 语句 statement 不抛出异常</span></span><br><span class="line">ASSERT_NO_THROW(statement);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 验证该语句导致进程以非零退出状态终止，stderr 输出 matcher</span></span><br><span class="line">ASSERT_DEATH(statement,matcher);</span><br></pre></td></tr></table></figure><h2 id="测试夹具"><a href="#测试夹具" class="headerlink" title="测试夹具"></a>测试夹具</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    class_name()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 打开数据库链接</span></span><br><span class="line">        m_pDao = <span class="keyword">new</span> <span class="title class_">mysql</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~class_name()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 关闭数据库链接</span></span><br><span class="line">        delete m_pDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CfgDao* m_pDao = nullptr; <span class="comment">///&lt; 数据库实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(class_name, description)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_TRUE(m_pDao-&gt;InsertCallHistory(st));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程测试"><a href="#多线程测试" class="headerlink" title="多线程测试"></a>多线程测试</h2><p>GoogleTest 没有提供，一个测试用例，在多个线程中同时调用，以证明其线程安全。</p><p>但其实现原理可以手动实现，代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GosLog</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 本线程先 sleep 2秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">/// 调用一万次函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(f, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    std::deque&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 使用 test_function 创建线程</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(test_function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 等待每个线程结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;thread : threads)</span><br><span class="line">    &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取出重复的语句做测试夹具</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           多线程测试封装</span></span><br><span class="line"><span class="comment"> * @author          lijiancong</span></span><br><span class="line"><span class="comment"> * @date            2023-01-19 17:27:15</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mt_unittest</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">mt_unittest</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">mt_unittest</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add new work item to the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    ::<span class="function">testing::AssertionResult <span class="title">invoke</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> cpu_thread = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">        <span class="keyword">if</span> (cpu_thread &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 多线程测试要求测试机器， 硬件支持 3 线程以上</span></span><br><span class="line">            <span class="keyword">return</span> ::testing::<span class="built_in">AssertionFailure</span>() &lt;&lt; <span class="string">&quot;cpu_thread is less than 2. &quot;</span></span><br><span class="line">                &lt;&lt; std::<span class="built_in">to_string</span>(cpu_thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> task = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::jthread&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cpu_thread - <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(std::<span class="built_in">jthread</span>(</span><br><span class="line">                [<span class="keyword">this</span>, task]() <span class="keyword">mutable</span></span><br><span class="line">                &#123;</span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">mutex</span>(mutex_);</span><br><span class="line">                    <span class="comment">/// 等待同步开始</span></span><br><span class="line">                    cv_.<span class="built_in">wait</span>(mutex, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> ready_; &#125;);</span><br><span class="line">                    <span class="comment">/// 执行测试函数</span></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; guard&#123;mutex_&#125;;</span><br><span class="line">            ready_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">return</span> ::testing::<span class="built_in">AssertionSuccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="type">bool</span> ready_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_F</span>(mt_unittest, GosLogTest)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">invoke</span>(</span><br><span class="line">        []()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">GosLog</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板函数测试"><a href="#模板函数测试" class="headerlink" title="模板函数测试"></a>模板函数测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           擦除vector中特定值的元素</span></span><br><span class="line"><span class="comment"> * @param           vec      [out]  要操作的vector</span></span><br><span class="line"><span class="comment"> * @param           value    [in]   要擦除的值</span></span><br><span class="line"><span class="comment"> * @return          size_t  擦除元素的个数</span></span><br><span class="line"><span class="comment"> * @author          lijiancong</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">erase</span><span class="params">(Container&amp; vec,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="keyword">typename</span> Container::value_type&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator it =</span><br><span class="line">        std::<span class="built_in">remove</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), value);</span><br><span class="line">    <span class="type">size_t</span> count = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(std::<span class="built_in">distance</span>(it, vec.<span class="built_in">end</span>()));</span><br><span class="line">    vec.<span class="built_in">erase</span>(it, vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gos_erase_test</span> : <span class="keyword">public</span> testing::Test</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TYPED_TEST_SUITE(gos_erase_test, ::testing::Types&lt;</span><br><span class="line">                                 std::vector&lt;<span class="type">char</span>&gt;,</span><br><span class="line">                                 std::deque&lt;<span class="type">char</span>&gt;,</span><br><span class="line">                                 std::string,</span><br><span class="line">                                 std::vector&lt;<span class="type">int</span>&gt;,</span><br><span class="line">                                 std::deque&lt;<span class="type">int</span>&gt;</span><br><span class="line">                                 &gt;);</span><br><span class="line"></span><br><span class="line">TYPED_TEST(gos_erase_test, find_simple_char)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TypeParam</span> <span class="variable">n</span> <span class="operator">=</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    TypeParam cmp&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    ASSERT_EQ(<span class="number">1</span>, gos::erase(n, <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    ASSERT_EQ(<span class="number">2</span>, gos::erase(n, <span class="string">&#x27;b&#x27;</span>));</span><br><span class="line">    ASSERT_EQ(cmp, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mock-简介"><a href="#Mock-简介" class="headerlink" title="Mock 简介"></a>Mock 简介</h2><p><a href="https://google.github.io/googletest/gmock_for_dummies.html">Mock 入门</a>{: .btn .btn–success}</p><p>测试场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">TalkRequest</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroupCall</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">TalkRequest</span><span class="params">(<span class="type">int</span> number, SpeakManager&amp; SpeakManager)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SpeakManager-&gt;<span class="built_in">TalkRequest</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(GroupCall, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> SpeakManager;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(Groupcall::<span class="built_in">GI</span>().<span class="built_in">TalkRequest</span>(<span class="number">4106</span>, p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>SpeakManager::TalkRequest()</code>, 依赖于 SDK 的初始化, 依赖于通话存在，所以为单独测试 <code>GroupCall::TalkRequest()</code> 增加了难度。</p><p>实现方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include <span class="string">&quot;gtest/gtest.h&quot;</span></span><br><span class="line">#include <span class="string">&quot;gmock/gmock.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManagerBase</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    virtual bool <span class="title function_">TalkRequest</span><span class="params">(<span class="type">int</span> number)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 原业务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManager</span> : <span class="keyword">public</span> SpeakManagerBase</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// virtual bool TalkRequest(int number);</span></span><br><span class="line">    bool <span class="title function_">TalkRequest</span><span class="params">(<span class="type">int</span> number)</span> override;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 模拟类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManagerMock</span> : <span class="keyword">public</span> SpeakManagerBase</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    MOCK_METHOD(bool, TalkRequest, (<span class="type">int</span> number), (override));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroupCall</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> GroupCall&amp; GI()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> GroupCall instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool <span class="title function_">TalkRequest</span><span class="params">(<span class="type">int</span> number, SpeakManagerBase&amp; SpeakManager)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SpeakManager.TalkRequest(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST(GroupCall, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace testing;</span><br><span class="line"></span><br><span class="line">    SpeakManagerMock SpeakManager;</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在任意入参时，将会总是返回 true</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(_)).WillRepeatedly(Return(<span class="literal">true</span>));</span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_TRUE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(GroupCall, simple_test_1)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace testing;</span><br><span class="line"></span><br><span class="line">    SpeakManagerMock SpeakManager;</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在入参为 4106 时，将会总是返回 true</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(<span class="number">4106</span>))</span><br><span class="line">        .WillRepeatedly(Return(<span class="literal">true</span>));</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在入参在大于 4100 并且不等于 4106 的情况下，总是返回 false</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(AllOf(Gt(<span class="number">4100</span>), Ne(<span class="number">4106</span>))))</span><br><span class="line">                                .WillRepeatedly(Return(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_TRUE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_FALSE(GroupCall::GI().TalkRequest(<span class="number">4105</span>, SpeakManager));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(GroupCall, simple_test_2)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace testing;</span><br><span class="line"></span><br><span class="line">    SpeakManagerMock SpeakManager;</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在任意入参时，第一次调用返回 true， 第二次返回 false</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(_))</span><br><span class="line">        .WillOnce(Return(<span class="literal">true</span>))</span><br><span class="line">        .WillOnce(Return(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_TRUE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line">    ASSERT_FALSE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动化测试场景"><a href="#自动化测试场景" class="headerlink" title="自动化测试场景"></a>自动化测试场景</h2><p>通常自动化测试的测试用例之间不应存在影响，每个测试用例应拆分为最小可测试单元(函数)，测试用例的顺序应互不影响。</p><h3 id="工具函数测试"><a href="#工具函数测试" class="headerlink" title="工具函数测试"></a>工具函数测试</h3><ul><li>SQL 语句组装类测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TEST(sql_utility, simple)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// insert</span></span><br><span class="line">    gos::sql sql_string;</span><br><span class="line">    std::<span class="type">string</span> <span class="variable">str</span> <span class="operator">=</span> sql_string.insert(<span class="string">&quot;operation_log&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;UUID&quot;</span>, <span class="string">&quot;555&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;Time&quot;</span>, <span class="number">666</span>)</span><br><span class="line">        .bind(<span class="string">&quot;UserType&quot;</span>, <span class="string">&quot;777&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;UserID&quot;</span>, <span class="string">&quot;888&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;LogInfo&quot;</span>, <span class="string">&quot;999&quot;</span>)</span><br><span class="line">        .sql();</span><br><span class="line"></span><br><span class="line">    ASSERT_EQ(str, <span class="string">&quot;INSERT INTO operation_log(UUID, Time, UserType, UserID, LogInfo) VALUES(\&quot;555\&quot;, 666, \&quot;777\&quot;, \&quot;888\&quot;, \&quot;999\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// delete</span></span><br><span class="line">    gos::sql sql;</span><br><span class="line">    std::<span class="type">string</span> <span class="variable">strSQL</span> <span class="operator">=</span> sql.remove(<span class="string">&quot;operation_log&quot;</span>)</span><br><span class="line">                            .where(<span class="string">&quot;Time &lt; :time&quot;</span>)</span><br><span class="line">                            .bind(<span class="string">&quot;time&quot;</span>, <span class="number">55</span>).sql();</span><br><span class="line">    ASSERT_EQ(strSQL, <span class="string">&quot;DELETE FROM operation_log WHERE Time &lt; 55;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间函数测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TEST(gos_sleep_1ms, Simple_Test)</span><br><span class="line">&#123;</span><br><span class="line">    gos::tick_count timer;</span><br><span class="line">    <span class="comment">/// 开始计时</span></span><br><span class="line">    timer.start();</span><br><span class="line">    gos_sleep_1ms(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">/// 结束计时</span></span><br><span class="line">    timer.finish();</span><br><span class="line">    <span class="comment">/// 模糊比较，误差不超过 20ms</span></span><br><span class="line">    ASSERT_TRUE(gos::approx(<span class="number">1000</span>, <span class="number">20</span>).equal(timer.get_ms()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Json-接口函数测试"><a href="#Json-接口函数测试" class="headerlink" title="Json 接口函数测试"></a>Json 接口函数测试</h3><p>在客户端与服务端的通信中，如果使用 <code>json</code> 报文来传递事件，那么就存在 结构体序列化成 <code>json</code> 与 <code>json</code> 反序列化成结构体的过程，现在我们来测试这个过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DC_TO_DIS_LOAD_SDS_HISTORY_C</span> : <span class="keyword">public</span> gos::json_parser&lt;DC_TO_DIS_LOAD_SDS_HISTORY_C&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    std::string strDCLongNum;  <span class="comment">///&lt; M, 发送者长号码</span></span><br><span class="line">    UINT32 ulBeginTime;        <span class="comment">///&lt; M, 开始时间, 秒级时间戳</span></span><br><span class="line">    UINT32 ulEndTime;          <span class="comment">///&lt; M, 结束时间, 秒级时间戳</span></span><br><span class="line">    UINT32 ulCountLimit;       <span class="comment">///&lt; M, 最多回复记录数</span></span><br><span class="line"></span><br><span class="line">    bool operator==(const DC_TO_DIS_LOAD_SDS_HISTORY_C&amp; stOther) const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> strDCLongNum == stOther.strDCLongNum &amp;&amp;</span><br><span class="line">               ulBeginTime == stOther.ulBeginTime &amp;&amp;</span><br><span class="line">               ulEndTime == stOther.ulEndTime &amp;&amp;</span><br><span class="line">               ulCountLimit == stOther.ulCountLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 从 json 报文中解析出数值, 并赋予本结构体</span></span><br><span class="line">    virtual bool <span class="title function_">StructToJson</span><span class="params">(std::string&amp; str)</span> const;</span><br><span class="line">    <span class="comment">/// 从结构体的数值拼装 json 报文</span></span><br><span class="line">    virtual bool <span class="title function_">JsonToStruct</span><span class="params">(const std::string&amp; str)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取一个随机的本结构体</span></span><br><span class="line">    <span class="keyword">static</span> DC_TO_DIS_LOAD_SDS_HISTORY_C <span class="title function_">GetRandomObj</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST(DC_TO_DIS_LOAD_SDS_HISTORY_C, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">auto</span> <span class="variable">st</span> <span class="operator">=</span> DC_TO_DIS_LOAD_SDS_HISTORY_C::GetRandomObj();</span><br><span class="line"></span><br><span class="line">    std::string strJson;</span><br><span class="line">    <span class="comment">/// 序列化</span></span><br><span class="line">    ASSERT(st.StructToJson(strJson));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 反序列化</span></span><br><span class="line">    DC_TO_DIS_LOAD_SDS_HISTORY_C stCmp;</span><br><span class="line">    ASSERT(stCmp.JsonToStruct(strJson));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 判断两个结构体是否相等</span></span><br><span class="line">    ASSERT_EQ(st, strCmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上重复的步骤过多，封装后的测试用例较为整洁，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEST(DC_TO_DIS_LOAD_SDS_HISTORY_C, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">auto</span> <span class="variable">st</span> <span class="operator">=</span> DC_TO_DIS_LOAD_SDS_HISTORY_C::GetRandomObj();</span><br><span class="line"></span><br><span class="line">        ASSERT_TRUE(gos::test_json_parser(st));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库层自动化测试"><a href="#数据库层自动化测试" class="headerlink" title="数据库层自动化测试"></a>数据库层自动化测试</h3><p>数据库函数测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CfgDaoTests</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/// 初始化数据库链接</span></span><br><span class="line">    CfgDaoTests();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 释放数据库链接</span></span><br><span class="line">    ~CfgDaoTests() override;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@brief</span>           查询 brd_info 表中是否有记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>           find    [in]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          ::testing::AssertionResult</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>          lijiancong</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>            2022-07-07 16:59:03</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@note</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ::testing::AssertionResult <span class="title function_">HaveRowInBrdInfo</span><span class="params">(const DB_BRD_INFO_C&amp; find)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 查询记录</span></span><br><span class="line">        std::vector&lt;DB_BRD_INFO_C&gt; vec;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_pDao-&gt;QueryBrdInfo(vec, <span class="number">1000</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ::testing::AssertionFailure() &lt;&lt; <span class="string">&quot;QueryBrdInfo failed!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (const auto&amp; element : vec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (element == find)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ::testing::AssertionSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ::testing::AssertionFailure()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;can&#x27;t find struct! &quot;</span> &lt;&lt; DBG(find);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(CfgDaoTests, brd_info_simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 创建随机的结构体</span></span><br><span class="line">    <span class="type">DB_BRD_INFO_C</span> <span class="variable">stDB</span> <span class="operator">=</span> DB_BRD_INFO_C::GetRandomObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 验证没有该条记录</span></span><br><span class="line">    ASSERT_FALSE(HaveRowInBrdInfo(stDB));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 插入</span></span><br><span class="line">    ASSERT_TRUE(m_pDao-&gt;InsertBrdInfo(stDB));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 验证有该条记录</span></span><br><span class="line">    ASSERT_TRUE(HaveRowInBrdInfo(stDB));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 删除该条记录</span></span><br><span class="line">    ASSERT_TRUE(m_pDao-&gt;DeleteBrdInfo(stDB.GetKey()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 验证没有该条记录</span></span><br><span class="line">    ASSERT_FALSE(HaveRowInBrdInfo(stDB));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST_F(CfgDaoTests, call_history_simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件读取测试"><a href="#配置文件读取测试" class="headerlink" title="配置文件读取测试"></a>配置文件读取测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dc_global_config_manager_test</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">DC_GLOBAL_CONFIG_INFO_C</span> <span class="variable">cfg_</span> <span class="operator">=</span> DC_GLOBAL_CONFIG_INFO_C::GetRandomObj();</span><br><span class="line">    std::<span class="type">string</span> <span class="variable">m_strFile</span> <span class="operator">=</span> <span class="string">&quot;dc_global_config_manager_test.ini&quot;</span>;</span><br><span class="line"></span><br><span class="line">    dc_global_config_manager_test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gos_file_exist(m_strFile.c_str()))</span><br><span class="line">        &#123;</span><br><span class="line">            gos_delete_file(m_strFile.c_str());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 生成配置文件</span></span><br><span class="line">        inifile::IniFile ini_file;</span><br><span class="line"></span><br><span class="line">        ini_file.SetBoolValue(<span class="string">&quot;DCGlobal&quot;</span>, <span class="string">&quot;is_use_link_switch&quot;</span>,</span><br><span class="line">                                cfg_.is_use_link_switch_);</span><br><span class="line">        ini_file.SetIntValue(<span class="string">&quot;DCGlobal&quot;</span>, <span class="string">&quot;ping_interval_time_ms&quot;</span>,</span><br><span class="line">                                cfg_.ping_interval_time_ms_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 保存配置文件</span></span><br><span class="line">        ini_file.SaveAs(m_strFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~dc_global_config_manager_test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gos_file_exist(m_strFile.c_str()))</span><br><span class="line">        &#123;</span><br><span class="line">            gos_delete_file(m_strFile.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(dc_global_config_manager_test, DC_GLOBAL_CONFIG_MANAGER)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_TRUE(dc_global_config_manager::GI().load(m_strFile));</span><br><span class="line"></span><br><span class="line">    <span class="type">auto</span> <span class="variable">cfg</span> <span class="operator">=</span> dc_global_config_manager::GI().get();</span><br><span class="line"></span><br><span class="line">    EXPECT_EQ(cfg_, cfg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端软件集成测试"><a href="#客户端软件集成测试" class="headerlink" title="客户端软件集成测试"></a>客户端软件集成测试</h3><p>对于客户端大致有两个调用流程。</p><p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E5%8F%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png" alt="image"></p><p>对于回调业务设计:</p><p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E5%8F%B0%E5%9B%9E%E8%B0%83%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B.png" alt="image"></p><p>对于以上解决方案，需要客户端把业务类与界面类分开。</p><p>界面只根据输入数据进行更新显示。而业务类管理所有业务(管理业务信息)。</p><h3 id="服务器软件集成测试"><a href="#服务器软件集成测试" class="headerlink" title="服务器软件集成测试"></a>服务器软件集成测试</h3><p>同样对于服务端程序，一样可以做代理类而测试业务。</p><p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="image"></p><p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9B%9E%E8%B0%83%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B.png" alt="image"></p><h3 id="服务器业务函数测试"><a href="#服务器业务函数测试" class="headerlink" title="服务器业务函数测试"></a>服务器业务函数测试</h3><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VOID TaskAPP::OnAppRequestCallReq(const std::string &amp;app_id,</span><br><span class="line">                                  const APP_TO_DIS_MSG_INFO_C &amp;stAppMsgInfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!AppRegisterManager::GI().HandleAppRequestCallReq(app_id,</span><br><span class="line">                                            stAppMsgInfo, <span class="built_in">this</span>, m_pDao))</span><br><span class="line">    &#123;</span><br><span class="line">        GLOGE(<span class="string">&quot;AppRegisterManager HandleAppRequestCallReq failed! %s&quot;</span>,</span><br><span class="line">                DBG(stAppMsgInfo));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在事件函数中，使用单独的业务函数或业务类，把业务模块(<code>AppRegisterManager</code>)与数据库模块(<code>m_pDao</code>)还有事件调度模块(<code>TaskApp</code>)隔离开后，使用测试普通函数的模式测试该函数。</p><h3 id="如何组织工程级别单元测试"><a href="#如何组织工程级别单元测试" class="headerlink" title="如何组织工程级别单元测试"></a>如何组织工程级别单元测试</h3><p>使用 CMake 来组织工程文件。</p><h4 id="CMake-简介"><a href="#CMake-简介" class="headerlink" title="CMake 简介"></a>CMake 简介</h4><p>CMake是一个跨平台的自动化构建工具，用于管理软件项目的构建过程。它使用一种类似于脚本的语法（CMakeLists.txt文件）来描述项目的构建配置和依赖关系，并生成适合不同构建系统（如Make、Ninja、Visual Studio等）的构建脚本。<br>{: .notice–info}</p><ul><li>CMake 使用示例：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure><ul><li>Windows 下生成的 VS 工程结构</li></ul><p><img src="/../resource/auto_test/Snipaste_2023-07-14_10-37-45.png" alt="image"></p><ul><li>Linux 下生成的 Makefile:</li></ul><p><img src="/../resource/auto_test/Snipaste_2023-07-14_11-01-15.png" alt="image"></p><ul><li>编译工程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工程全部编译</span></span><br><span class="line">cmake --build .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工程 clean 后单独编译 Release 下的 dis</span></span><br><span class="line">cmake --build . --target dis_wz2 --config=Release --clean-first</span><br></pre></td></tr></table></figure><ul><li>使用 CMake 命令自动运行单元测试:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMakeLists.txt 中增加如下语句，注册运行的单元测试</span></span><br><span class="line">add_test(NAME GosTest COMMAND gos_unittest)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行运行 Debug 模式下的注册过的所有单元测试</span></span><br><span class="line">ctest . -C Debug</span><br></pre></td></tr></table></figure><ul><li>VS 中可视化界面运行单元测试</li></ul><p><img src="/../resource/auto_test/Snipaste_2023-07-14_10-39-31.png" alt="image"></p><h4 id="单个文件夹下的文件组织"><a href="#单个文件夹下的文件组织" class="headerlink" title="单个文件夹下的文件组织"></a>单个文件夹下的文件组织</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── cp4_debug.cpp</span><br><span class="line">├── cp4_debug.hpp</span><br><span class="line">└── cp4_debug_unittest.cpp</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>: 工程文件, 其中定义了生成静态库(<code>libcp4_debug.a</code>)，生成测试的可执行文件(<code>cp4_debug_unittest.exe</code>)。</p><h4 id="多个文件夹下的文件组织"><a href="#多个文件夹下的文件组织" class="headerlink" title="多个文件夹下的文件组织"></a>多个文件夹下的文件组织</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── db</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── CfgDao.cpp</span><br><span class="line">│   └── CfgDao.h</span><br><span class="line">│   └── CfgDao_unittest.cpp</span><br><span class="line">├── middle</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── ATSManager.cpp</span><br><span class="line">│   ├── ATSManager.h</span><br><span class="line">│   ├── ATSManager_unittest.cpp</span><br><span class="line">├── dis_main.cpp</span><br></pre></td></tr></table></figure><p>服务器中，<code>app/</code> 和 <code>cfg/</code> 文件夹会分别生成静态库，然后文件 <code>dis_main.cpp</code> 、 <code>libdb.a</code> 、 <code>libmiddle.a</code> 生成 <code>dis.exe</code>。</p><p>也同时生成对应的测试程序。</p><h4 id="如何引用第三方库（如：GoogleTest）"><a href="#如何引用第三方库（如：GoogleTest）" class="headerlink" title="如何引用第三方库（如：GoogleTest）"></a>如何引用第三方库（如：<code>GoogleTest</code>）</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── dis/</span><br><span class="line">│   ├── ...</span><br><span class="line">├── thirdparty/</span><br><span class="line">│   ├── googletest/</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">|       ├─- ...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMakeLists.txt 中增加如下语句，引用第三方库</span></span><br><span class="line">add_subdirectory(thirdparty/googletest)</span><br></pre></td></tr></table></figure><p>然后需要使用该第三方库的工程，包含第三方库的头文件，并链接该第三方库的 <code>libgtest.a</code> 文件，即可正常使用第三方库。</p><h2 id="如何确认测试覆盖率"><a href="#如何确认测试覆盖率" class="headerlink" title="如何确认测试覆盖率"></a>如何确认测试覆盖率</h2><ol><li>g++ 编译选项中添加: <code>-fprofile-arcs</code>、 <code>-ftest-coverage</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMakeLists.txt 中添加</span></span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wall -fprofile-arcs -ftest-coverage&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -fprofile-arcs -ftest-coverage&quot;)</span><br></pre></td></tr></table></figure><ol start="2"><li>编译并运行单元测试</li><li>生成覆盖率信息文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcov &lt;source_file&gt;</span><br></pre></td></tr></table></figure><p>直接使用 vim 打开该信息文件 <code>test.c.gcov</code></p><p><img src="/../resource/auto_test/Snipaste_2023-07-14_11-46-37.png" alt="image"></p><ol start="4"><li>使用<code>lcov</code>工具处理<code>.gcov</code>文件并生成可读的代码覆盖率报告。使用以下命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lcov -c -d &lt;directory&gt; -o coverage.info</span><br><span class="line">genhtml coverage.info -o coverage_report</span><br></pre></td></tr></table></figure><ol start="5"><li>打开 <code>coverage_report/index.html</code> 查看覆盖率报告</li></ol><p><img src="/../resource/auto_test/Snipaste_2023-07-14_17-33-17.png" alt="image"></p><p><img src="/../resource/auto_test/Snipaste_2023-07-14_17-33-48.png" alt="image"></p><h2 id="提交代码前的自动化测试"><a href="#提交代码前的自动化测试" class="headerlink" title="提交代码前的自动化测试"></a>提交代码前的自动化测试</h2><p>在提交 <code>push</code> 前，自动生成并运行单元测试， 可以使用 <code>git</code> 自带的 <code>pre-push</code>.</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .git</span><br><span class="line">│   ├── branches</span><br><span class="line">│   ├── COMMIT_EDITMSG</span><br><span class="line">│   ├── config</span><br><span class="line">│   ├── description</span><br><span class="line">│   ├── FETCH_HEAD</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   ├── hooks</span><br><span class="line">│       ├── pre-commit.sample</span><br><span class="line">│       ├── pre-push.sample</span><br></pre></td></tr></table></figure><p>在 <code>Linux</code> 下工程目录下, 找到 <code>./.git/hooks/pre-push.sample</code> 文件，复制一份并重命名为 <code>pre-push</code>，然后修改 <code>pre-push</code> 文件内容为如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># An example hook script to verify what is about to be committed.</span></span><br><span class="line"><span class="comment"># Called by &quot;git push&quot; with no arguments.  The hook should</span></span><br><span class="line"><span class="comment"># exit with non-zero status after issuing an appropriate message if</span></span><br><span class="line"><span class="comment"># it wants to stop the push.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To enable this hook, rename this file to &quot;pre-push&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动格式化代码</span></span><br><span class="line">python3 ./ClangFormat.py</span><br><span class="line"><span class="comment"># 添加格式化后的代码</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行单元测试</span></span><br><span class="line">cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> cmake .. ; cmake --build ./build/ ; cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> ctest .. -C Release</span><br><span class="line"></span><br><span class="line"><span class="comment"># If the tests fail, prevent the push</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Tests failed. Push aborted.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>添加内容后，为该脚本文件增加可执行权限。 <code>sudo chmod +x pre_push</code></p><p>如果该脚本运行过程中，异常结束则不会推送代码到远端，并提示错误。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节序简介</title>
      <link href="/2023/07/21/2022-01-05-%E5%AD%97%E8%8A%82%E5%BA%8F%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2022-01-05-%E5%AD%97%E8%8A%82%E5%BA%8F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>高低位字节区分: 举例<code>0x1234</code>, 高位字节为 <code>0x12</code>, 低位字节为 <code>0x34</code>。</p><span id="more"></span><ul><li><strong>小端字节序</strong>：低位字节在低地址，高位字节在高地址，即<code>0x1234</code>以<code>0x3412</code>形式储存。<code>CPU</code>处理速度快。</li></ul><p><img src="/../resource/%E5%AD%97%E8%8A%82%E5%BA%8F%E4%BB%8B%E7%BB%8D/280px-Little-Endian.svg.png" alt="280px-Little-Endian.svg"></p><ul><li><strong>大端字节序</strong>：高位字节在低地址，低位字节在高地址，这是人类读写数值的方法。即<code>0x1234</code>以<code>0x1234</code>形式储存。</li></ul><p><img src="/../resource/%E5%AD%97%E8%8A%82%E5%BA%8F%E4%BB%8B%E7%BB%8D/280px-Big-Endian.svg.png" alt="280px-Big-Endian.svg"></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/../resource/%E5%AD%97%E8%8A%82%E5%BA%8F%E4%BB%8B%E7%BB%8D/Snipaste_2022-01-07_15-57-25.png" alt="Snipaste_2022-01-07_15-57-25"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见颜色与RGB值</title>
      <link href="/2023/07/21/2022-02-28-%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/"/>
      <url>/2023/07/21/2022-02-28-%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>常见颜色与RGB值</p><span id="more"></span><h2 id="豆沙绿"><a href="#豆沙绿" class="headerlink" title="豆沙绿"></a>豆沙绿</h2><p>豆沙绿: 199 237 204 (#C7EDCC)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E8%B1%86%E6%B2%99%E7%BB%BF.png" alt="豆沙绿"></p><h2 id="护眼黄"><a href="#护眼黄" class="headerlink" title="护眼黄"></a>护眼黄</h2><p>护眼黄: 250 249 222 (#FAF9DE)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E6%8A%A4%E7%9C%BC%E9%BB%84.png" alt="护眼黄"></p><h2 id="灰色"><a href="#灰色" class="headerlink" title="灰色"></a>灰色</h2><p>字灰色: 155 163 178(#9BA3B2)<br>背景灰色: 223 225 230(#DFE1E6)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%81%B0%E8%89%B2.png" alt="字和背景灰色"></p><h2 id="蓝色"><a href="#蓝色" class="headerlink" title="蓝色"></a>蓝色</h2><p>字蓝色: 41 97 180(#2961B4)<br>背景蓝色: 222 235 255(#DEEBFF)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E8%93%9D%E8%89%B2.png" alt="字和背景蓝色"></p><h2 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h2><p>字绿色: 0 102 100(#006664)<br>背景绿色: 227 252 239(#E3FCEF)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BB%BF%E8%89%B2.png" alt="字和背景绿色"></p><p>字绿色: 19 99 53(#136335)<br>背景绿色: 198 239 206(#C6EFCE)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BB%BF%E8%89%B2%E6%96%B9%E6%A1%882.png" alt="字和背景绿色绿色方案2"></p><h2 id="红色"><a href="#红色" class="headerlink" title="红色"></a>红色</h2><p>字红色: 255 0 0(#FF0000)<br>背景橙色: 253 233 217(#FDE9D9)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BA%A2%E8%89%B2.png" alt="字和背景红色"></p><p>字红色: 128 0 0(#800000)<br>背景橙红色: 255 80 80(#FF5050)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BA%A2%E8%89%B2%E6%96%B9%E6%A1%882.png" alt="字和背景红色方案2"></p><p>字红色: 157 38 66(#9D2642)<br>背景红色: 255 199 206(#FFC7CE)</p><p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BA%A2%E8%89%B2%E6%96%B9%E6%A1%883.png" alt="字和背景红色方案3"></p><h2 id="橙色"><a href="#橙色" class="headerlink" title="橙色"></a>橙色</h2><p>RGB: 255 214 88(#FFD658)</p><p>RGB: 248 178 32(#F8B220)</p><p>RGB: 255 153 0(#FF9900)</p><p>RGB: 245 105 82(#F56952)</p><h2 id="绿色-1"><a href="#绿色-1" class="headerlink" title="绿色"></a>绿色</h2><p>RGB: 176 234 101(#B0EA65)</p><h2 id="蓝色-1"><a href="#蓝色-1" class="headerlink" title="蓝色"></a>蓝色</h2><p>RGB: 93 209 247(#5DD1F7)</p><h2 id="紫色"><a href="#紫色" class="headerlink" title="紫色"></a>紫色</h2><p>RGB: 112 102 243(#7066F3)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++容器的特性与适用场景</title>
      <link href="/2023/07/21/2022-06-17-C++%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/07/21/2022-06-17-C++%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>本文详细介绍了C++中各类容器的特性与适用场景，涵盖序列式容器（如<code>std::vector</code>、<code>std::list</code>）、关联式容器（如<code>std::set</code>、<code>std::map</code>）和无序容器（如<code>std::unordered_set</code>、<code>std::unordered_map</code>）。文章分析了每种容器的内部实现、性能特点、适用场景及常见操作，如<code>std::vector</code>的动态数组特性、<code>std::list</code>的双向链表结构、<code>std::map</code>的键值对管理等。此外，还探讨了迭代器的种类及其失效场景，帮助开发者根据具体需求选择合适的容器，优化代码性能。</p><span id="more"></span><p>C++容器的特性与适用场景, <a href="../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/C++%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.pptx">PPT</a></p><h2 id="容器类别"><a href="#容器类别" class="headerlink" title="容器类别"></a>容器类别</h2><p>首先放上一张来自《C++标准库》中的图片。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/STL_Container_Types.png" alt="STL Container Types"></p><h3 id="序列式容器（Sequence-container）"><a href="#序列式容器（Sequence-container）" class="headerlink" title="序列式容器（Sequence container）"></a>序列式容器（Sequence container）</h3><p>这是一种有序(ordered)集合，其内每个元素均有确凿的位置—-取决于插入时机和地点，与元素值无关。如果你以追加方式对一个集和置入6个元素，他们的排列次序将和置入次序一致。STL提供了5个定义好的序列式容器：array、vector、deque、list和forward_list。</p><h3 id="关联式容器-Associative-container"><a href="#关联式容器-Associative-container" class="headerlink" title="关联式容器(Associative container)"></a>关联式容器(Associative container)</h3><p>这是一种已排序(sorted)集合，元素位置取决于其value(或key—-如果元素是个key&#x2F;value pair)和给定的某个排序准则。如果将六个元素置入这样的集合中，他们的值将决定他们的次序，和插入次序无关。STL提供了4个关联式容器：set、multiset、map和multimap。</p><h3 id="无序容器（Unordered-associative-container）"><a href="#无序容器（Unordered-associative-container）" class="headerlink" title="无序容器（Unordered (associative) container）"></a>无序容器（Unordered (associative) container）</h3><p>这是一种无序集合(unordered collection), 其内每个元素的每个位置无关紧要，唯一重要的是某特定元素是否位于此集合内。元素值或其安插顺序，都不影响元素的位置，而且元素的位置有可能在容器生命周期中被改变。如果你放6个元素到这种集合内，它们的次序不明确，并且可能随时间而改变。STL内含4个预定义的无序容器：unordered_set、unordered_multiset、unordered_map和unordered_multimap。</p><ul><li><p><strong>Sequence</strong>容器通常被实现为array或linked list</p></li><li><p><strong>Associative</strong>容器通常被实现为binary tree</p></li><li><p><strong>Unordered</strong>容器通常被实现为hash table</p></li></ul><h2 id="各种容器使用时机"><a href="#各种容器使用时机" class="headerlink" title="各种容器使用时机"></a>各种容器使用时机</h2><p>  <img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/ContainerSelect.png" alt="ContainerSelect"></p><ul><li><p>默认情况下应该使用<code>std::vector</code>。<code>std::vector</code>的内部构造最简单，并允许随机访问，所以数据的访问十分方便灵活，数据的处理也够快。</p></li><li><p>如果经常要在<strong>序列头部和尾部安插和一处元素</strong>，应该采用<code>std::deque</code>。如果你希望元素被移除时，容器能够自动缩减内部用量，那么也该使用<code>std::deque</code>。此外，由于<code>std::vector</code>通常采用一个内存区块来存放元素，而<code>std::deque</code>采用<strong>多个区块</strong>，所以后者可内含更多元素。</p></li><li><p>如果需要经常<strong>在容器中段执行元素安插、移除和移动</strong>，可考虑使用<code>std::list</code>。<code>std::list</code>提供特殊的成员函数，可在<strong>常量时间内将元素从A容器转移到B容器</strong>。但由于<code>std::list</code><strong>不支持随机访问</strong>，所以如果只知道list的头部却要造访list的中端元素，效能会大打折扣。和所有“以节点为基础”的容器相似，<strong>只要元素仍是容器的一部分，list就不会令指向那些元素的迭代器失效</strong>。<code>std::vector</code>则不然，一旦超过其容量，它的所有<code>iterator</code>、<code>pointer</code>和<code>reference</code>失效。至于<code>std::deque</code>，当它的大小改变，所有<code>iterator</code>、<code>pointer</code>和<code>reference</code>都会失效。</p></li><li><p>如果你要的容器对异常处理使得“<strong>每次操作若不成功便无任何作用</strong>”，那么应该选用<code>std::list</code>(但是不调用其assignment操作符和sort(), 而且如果元素比较过程中会抛出异常，就不要调用merge()、remove()、remove_if()和unique()，或选用associative&#x2F;unordered容器（但不调用多元素安插动作，而且<strong>如果比较准则的复制&#x2F;赋值动作可能抛出异常，就不要调用swap()或erase()</strong>）)。</p></li><li><p>如果你经常需要根据某个准则<strong>查找元素</strong>，应当使用“依据该准则进行hash”的<code>std::unordered_set</code> 或<code>std::multiset</code>。然而，hash容器内是无序的，所以如果你必须以来元素的次序(order),应该使用<code>std::set</code>或<code>std::multiset</code>，他们根据查找准则对元素排序。</p></li><li><p>如果想处理key&#x2F;value pair，请采用<code>unordered_map</code>或<code>std::unordered_multimap</code>。如果元素次序很重要，可采用<code>std::map</code>或<code>std::multimap</code>。</p></li><li><p>如果需要关联式数组(associative array), 应采用unordered map。如果元素次序很重要，可采用 <code>std::map</code>。</p></li><li><p>如果需要字典结构，应采用<code>unordered std::multimap</code>。如果元素次序很重要，可采用<code>std::multimap</code>。</p></li></ul><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/ContainerTypes.png" alt="ContainerTypes"></p><table><thead><tr><th></th><th>Array</th><th>Vector</th><th>Dequeue</th><th>List</th><th>Forward List</th><th>关联容器</th><th>无序容器</th></tr></thead><tbody><tr><td>可用标准</td><td>TR1</td><td>C++98</td><td>C++98</td><td>C++11</td><td>C++98</td><td>C++98</td><td>TR1</td></tr><tr><td>数据结构</td><td>静态数组</td><td>动态数组</td><td>数组的数组</td><td>双向链表</td><td>单向链表</td><td>二叉树</td><td>哈希表</td></tr><tr><td>元素类型</td><td>value</td><td>value</td><td>value</td><td>value</td><td>value</td><td>set: value <br> map: key&#x2F;value</td><td>set: value <br> map: key&#x2F;value</td></tr><tr><td>是否允许重复</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td><td>只有 <code>multiset</code> 和 <code>multimap</code> 允许重复</td><td>只有 <code>multiset</code> 和 <code>multimap</code> 允许重复</td></tr><tr><td>迭代器类型</td><td>随机访问</td><td>随机访问</td><td>随机访问</td><td>双向迭代器</td><td>单向迭代器</td><td>双向迭代器</td><td>单向迭代器</td></tr><tr><td>增长&#x2F;缩小方式</td><td>不会增长&#x2F;缩小</td><td>在一端末尾增长</td><td>在两端末尾增长</td><td>到处增长</td><td>到处增长</td><td>到处增长</td><td>到处增长</td></tr><tr><td>是否可以随机访问</td><td>是</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>差不多</td></tr><tr><td>查找元素</td><td>慢</td><td>慢</td><td>慢</td><td>非常慢</td><td>非常慢</td><td>快</td><td>非常快</td></tr><tr><td>添加和删除操作是否会使迭代器无效</td><td>-</td><td>在重新申请内存时无效</td><td>总是无效</td><td>从不</td><td>从不</td><td>从不</td><td>在重新哈希时</td></tr><tr><td>添加和删除操作是否会使引用或指针无效</td><td>-</td><td>在重新申请内存时无效</td><td>总是无效</td><td>从不</td><td>从不</td><td>从不</td><td>从不</td></tr><tr><td>是否允许保留内存</td><td>-</td><td>是</td><td>否</td><td>-</td><td>-</td><td>-</td><td>是</td></tr><tr><td>移除元素时释放内存</td><td>-</td><td>只有在<code>shrink_to_fit()</code>时释放内存</td><td>有时</td><td>总是</td><td>总是</td><td>总是</td><td>又是</td></tr><tr><td>事务安全(成功或没有影响)</td><td>No</td><td>在尾部<code>push</code>&#x2F;<code>pop</code>事务安全</td><td>在头部和尾部<code>push</code>&#x2F;<code>pop</code>安全</td><td>所有的插入和擦除</td><td>所有的插入和擦除</td><td>假如比较函数没有出现异常，那么单个元素的插入和所有擦除操作都是事务安全的</td><td>假如比较函数和哈希函数没有出现异常，那么单个元素的插入和所有擦除操作都是事务安全的</td></tr></tbody></table><h2 id="容器的共同能力"><a href="#容器的共同能力" class="headerlink" title="容器的共同能力"></a>容器的共同能力</h2><ol><li>所有容器提供的都是 “value 语义” 而非 “reference 语义”。容器进行元素的安插动作是，内部实施的是 <code>copy</code> 和&#x2F;或 <code>move</code> 动作, 而不是管理元素的 <code>reference</code>。 如果不想要复制，那么只能使用 <code>std::move</code> 或 保存元素指针(不能使用引用来规避复制)。</li><li>元素在容器内有其特定顺序。每一种容器会提供若干返回迭代器的操作函数，这些迭代器可以用来遍历各个元素。如果你在元素之间迭代多次，你会获得相同的次序(不调用增删函数)</li><li>一般而言，各项操作并非绝对安全，也就是说他们不会检查每一个可能发生的错误。调用者必须确保传给操作函数的实参符合条件。</li><li>都提供如下成员函数</li></ol><table><thead><tr><th align="center">函数</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">default construct</td><td align="center"></td></tr><tr><td align="center">copy construct</td><td align="center"></td></tr><tr><td align="center">destructor</td><td align="center"></td></tr><tr><td align="center">begin()</td><td align="center"></td></tr><tr><td align="center">end()</td><td align="center"></td></tr><tr><td align="center">cbegin()</td><td align="center">after C++11</td></tr><tr><td align="center">cend()</td><td align="center">after C++11</td></tr><tr><td align="center">clear()</td><td align="center"></td></tr><tr><td align="center">swap()</td><td align="center">std::array: O(n), 其他容器: O(1)</td></tr><tr><td align="center">empty()</td><td align="center">empty() 的实现可能比 size() &#x3D;&#x3D; 0 更有效率，尽可能使用该函数</td></tr><tr><td align="center">size()</td><td align="center"></td></tr><tr><td align="center">max_size()</td><td align="center"></td></tr><tr><td align="center">empty()</td><td align="center"></td></tr><tr><td align="center">operator&#x3D;&#x3D;</td><td align="center"></td></tr><tr><td align="center">operator!&#x3D;</td><td align="center"></td></tr><tr><td align="center">operator&lt;</td><td align="center">除了无序容器</td></tr><tr><td align="center">operator&lt;&#x3D;</td><td align="center">除了无序容器</td></tr><tr><td align="center">operator&gt;</td><td align="center">除了无序容器</td></tr><tr><td align="center">operator&gt;&#x3D;</td><td align="center">除了无序容器</td></tr></tbody></table><h2 id="容器遍历方式"><a href="#容器遍历方式" class="headerlink" title="容器遍历方式"></a>容器遍历方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// After C++11</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> element : container)</span><br><span class="line">&#123;</span><br><span class="line">    element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只对拥有随机访问迭代器的容器使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; container.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    container[i]/container.<span class="built_in">at</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 所有元素通用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = container.<span class="built_in">begin</span>(); it != container.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size-0-与-empty"><a href="#size-0-与-empty" class="headerlink" title="size() &#x3D;&#x3D; 0 与 empty()"></a>size() &#x3D;&#x3D; 0 与 empty()</h3><p>在 <code>C++11</code> 之前 <code>std::list::empty()</code> 函数的时间复杂度可能是 <code>O(n)</code> 也可能是 <code>O(1)</code>.</p><div STYLE="page-break-after: always;"></div><h2 id="std-array-C-11"><a href="#std-array-C-11" class="headerlink" title="std::array C++11"></a><code>std::array</code> C++11</h2><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/array_base.png" alt="array"></p><ul><li>随机访问</li><li>固定大小, 编译期确定</li><li>大小可为零</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 作为返回值返回</span></span><br><span class="line"><span class="function">std::array&lt;<span class="type">int</span>, 5&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 作为入参时确定入参大小，不会降级为指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a.<span class="built_in">size</span>())&#123;&#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 搭配模板灵活使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">int</span>, N&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a.<span class="built_in">size</span>())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 6&gt; a;</span><br><span class="line"><span class="built_in">f2</span>(a);</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a><code>std::vector</code></h2><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/vector_base.png" alt="vector"></p><h3 id="迭代器示意"><a href="#迭代器示意" class="headerlink" title="迭代器示意"></a>迭代器示意</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/iterator.png" alt="iterator"></p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/reverse_iterator.png" alt="reserve_iterator"></p><h3 id="at-与-operator"><a href="#at-与-operator" class="headerlink" title="at() 与 operator[]"></a>at() 与 operator[]</h3><p><code>at()</code> 成员函数提供边界检查，超出边界时会抛出异常 <code>std::out_of_range</code></p><h3 id="size-与-capacity"><a href="#size-与-capacity" class="headerlink" title="size() 与 capacity()"></a>size() 与 capacity()</h3><p>size() 查看当前有几个元素</p><p>capacity() 查看预分配几个元素的空间</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/size()%E4%B8%8Ecapacity().png" alt="size"></p><h3 id="resize-与-reserve"><a href="#resize-与-reserve" class="headerlink" title="resize() 与 reserve()"></a>resize() 与 reserve()</h3><h4 id="resize-count"><a href="#resize-count" class="headerlink" title="resize(count)"></a>resize(count)</h4><blockquote><p>重设容器大小以容纳 count 个元素。</p><p>若当前大小大于 count ，则减小容器为其首 count 个元素。</p><p>若当前大小小于 count ，</p><ol><li>则后附额外的默认插入的元素</li><li>则后附额外的 value 的副本</li></ol></blockquote><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/resize.png" alt="resize"></p><h4 id="reserve-new-cap"><a href="#reserve-new-cap" class="headerlink" title="reserve(new_cap)"></a>reserve(new_cap)</h4><blockquote><p>增加 vector 的容量到大于或等于 new_cap 的值。若 new_cap 大于当前的 capacity() ，则分配新存储，否则该方法不做任何事。</p><p>reserve() 不更改 vector 的 size 。</p><p>若 new_cap 大于 capacity() ，则所有迭代器，包含尾后迭代器和所有到元素的引用都被非法化。否则，没有迭代器或引用被非法化。</p></blockquote><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/reserve.png" alt="reserve"></p><h3 id="shrink-to-fit-C-11"><a href="#shrink-to-fit-C-11" class="headerlink" title="shrink_to_fit() (C++11)"></a>shrink_to_fit() (C++11)</h3><blockquote><p>请求移除未使用的容量。</p><p>它是减少 capacity() 到 size()非强制性请求。请求是否达成依赖于实现。</p><p>若发生重分配，则所有迭代器，包含尾后迭代器，和所有到元素的引用都被非法化。若不发生重分配，则没有迭代器或引用被非法化。</p></blockquote><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/shrink_to_fit.png" alt="shrink_to_fit"></p><p>C++11 之前可以使用如下方式，缩减空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShrinkCapacity</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">tmp</span><span class="params">(v)</span></span>;</span><br><span class="line">    v.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="push-back-与-push-front"><a href="#push-back-与-push-front" class="headerlink" title="push_back() 与 push_front()"></a>push_back() 与 push_front()</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/push_back.png" alt="push_back()"></p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/push_front.png" alt="push_front()"></p><h3 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/insert.png" alt="insert()"></p><h3 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/erase.png" alt="erase()"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">/// 下面这句话为错误</span></span><br><span class="line">        <span class="comment">/// vec.erase(it++);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h3><blockquote><p>返回指向作为元素存储工作的底层数组的指针。指针满足范围 [data(); data() + size()) 始终是合法范围，即使容器为空（该情况下 data() 不可解引用）。</p></blockquote><p>拷贝 <code>vector</code> 中的数据到缓冲区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> auc[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// unsigned char 数组转换为 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">vec</span><span class="params">(auc, auc+<span class="keyword">sizeof</span>(auc))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// vector 转换为 unsigned char 数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* puc = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[vec.<span class="built_in">size</span>()];</span><br><span class="line"><span class="built_in">memcpy</span>(puc, vec.<span class="built_in">data</span>(), vec.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><h3 id="std-vector-bool"><a href="#std-vector-bool" class="headerlink" title="std::vector &lt; bool &gt;"></a>std::vector &lt; bool &gt;</h3><p>该容器不是 布尔类型的 <code>std::vector</code>, 而是有单独的实现，不应看作普通的 <code>std::vector</code> 使用。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li>如果 <code>push_back()</code> 安插元素时发生异常，函数将不会产生效用。</li><li>如果元素的 <code>copy/move</code> 操作(包括构造函数和赋值运算符)不抛出异常，这意味着 <code>insert()</code>、<code>emplace()</code>、<code>emplace_back()</code>、<code>push_back()</code>要么成功，要么什么也不发生。</li><li><code>pop_back()</code> 不会抛出任何异常</li><li>如果元素的 <code>copy/move</code> 的操作(包括构造函数和赋值运算符)不抛出异常, <code>erase()</code> 就不抛出异常</li><li><code>swap()</code> 和 <code>clear()</code> 不抛出异常</li><li>如果元素的 <code>copy/move</code> 操作(包括构造函数和赋值运算符)不抛出异常, 那么所有操作不是成功就是不产生效用。这类元素可能是 <a href="https://stackoverflow.com/questions/146452/what-are-pod-types-in-c">POD</a>。</li></ol><p>以上所有保证都基于一个条件: 析构函数不得抛出异常。</p><div STYLE="page-break-after: always;"></div><h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a><code>std::deque</code></h2><p>提供随机访问，接口与 <code>std::vector</code> 几乎一致。可以在首尾快速安插和删除。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/deque_base0.png" alt="deque_base"></p><p>通常实现为一组独立的区块，第一区块往一个方向发展，最末的区块往另一个方向发展。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/deque_base1.png" alt="deque_base"></p><h3 id="std-deque-与-std-vector-比较"><a href="#std-deque-与-std-vector-比较" class="headerlink" title="std::deque 与 std::vector 比较"></a><code>std::deque</code> 与 <code>std::vector</code> 比较</h3><h4 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h4><ul><li>在中段安插、移除元素的速度相对较慢，因为所有元素都需移动以腾出或填补空间。</li><li>迭代器属于随机访问迭代器，可以使用 <code>operator[]</code> \ <code>at()</code></li></ul><h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ul><li><code>std::deque</code> 可在常量时间内快速在首尾增删元素。 <code>std::vector</code> 只能在尾部。</li><li>访问元素时， <code>std::deque</code> 多了一个跳转的过程(在各个区块跳转)</li><li><code>std::deque</code> 的迭代器不是原始指针(因为各个区块之间不连续), 更没有 <code>data</code> 的成员函数</li><li><code>std::deque</code> 不支持对容量和内存分配时机的控制。</li><li><code>std::deque</code> 在首尾两端增删元素导致所有元素的迭代器失效(指针和引用仍有效)，其他所有增删操作都会导致所有元素的指针、引用和迭代器失效。</li><li><code>std::deque</code> 的内存分配优于 <code>std::vector</code>, <code>std::deque</code> 不必在内存分配时复制所有元素。</li><li><code>std::deque</code> 会释放不再使用的内存区块。 <code>std::deque</code> 的内存大小是可缩减的, 但要不要这么做，以及如何做，由实现决定。</li><li><code>std::deque</code> 不提供容量操作 <code>capacity()</code> 和 <code>reserve()</code></li><li>在内存区块大小有限制的系统中, <code>std::deque</code> 的 <code>max_size()</code> 可能比 <code>std::vector</code> 的 <code>max_size()</code> 要大。 因为 <code>std::deque</code> 使用的不止一块内存。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要在两端安插和移除元素</li><li>无须指向容器内的元素</li><li>要求使用内存会自动缩小</li></ul><h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p>原则上 <code>std::deque</code> 提供的异常处理和 <code>std::vector</code> 提供的一样</p><ul><li><code>push_front()</code> 和 <code>push_back()</code> 安插元素时发生异常，则该操作不带来任何效应。</li><li><code>pop_front()</code> 和 <code>pop_back()</code> 不会抛出任何异常。</li></ul><h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a><code>std::list</code></h2><p>双向链表。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/list_base.png" alt="list"></p><p><code>std::list</code> 的内部结构完全迥异于 <code>std::array</code>、<code>std::vector</code>、<code>std::deque</code>。 <code>std::list</code> 自身提供了两个指针，分别指向第一个元素和最后一个元素，如果操纵对应的指针即可。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/list_insert.png" alt="list_insert"></p><p>成员函数 <code>splice</code> 示意</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/list_splice.png" alt="list_splice"></p><h3 id="容器特性"><a href="#容器特性" class="headerlink" title="容器特性"></a>容器特性</h3><ul><li>提供 <code>front()</code>、<code>push_front()</code>、<code>pop_front()</code>、<code>back()</code>、<code>push_back()</code>和<code>pop_back()</code> 等操作函数。</li><li>不提供 <code>operator[]</code> 或 <code>at()</code></li><li>不支持随机访问。O(n)</li><li>在任何位置插入元素非常快。O(1), 只是改变了指针指向。</li><li>迭代器永久有效。插入和删除动作并不会造成指向其他元素的指针、引用和迭代器失效。</li><li>异常安全 <code>std::list</code> 的异常处理为: 要么操作成功、要么什么都不发生。</li><li>事务安全。 只要不调用赋值操作或 <code>sort()</code>, 并保证元素相互比较时不抛出异常那么<code>std::list</code>可以成为事务安全</li><li>空间最优。没有空间重新分配和预分配内存, 没有冗余内存占用</li><li>拥有较多的特殊成员函数，相较于 <code>STL</code> 中通用的同名函数，更具有效率。如 <code>merge</code>、<code>splice</code>、<code>remove</code>、<code>reverse</code>、<code>unique</code>、<code>sort</code>。</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>特性: 前向迭代器</p><ul><li>排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">list.<span class="built_in">sort</span>();</span><br><span class="line"><span class="comment">/// 错误用法: std::sort(list.begin(), list.end());</span></span><br></pre></td></tr></table></figure><ul><li>特殊的排序后显示</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::reference_wrapper&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">Observer</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(Observer.<span class="built_in">begin</span>(), Observer.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>特性: 迭代器永不失效</p><ul><li>双键结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">LEFT_KEY</span>, <span class="keyword">class</span> <span class="title class_">RIGHT_KEY</span>, <span class="keyword">class</span> <span class="title class_">VALUE</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bimap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;VALUE&gt; m_Value;                     <span class="comment">///&lt; 用于存放值</span></span><br><span class="line">    std::map&lt;LEFT_KEY, iterator&gt; m_LeftKeyMap;    <span class="comment">///&lt; 用于保存左键与值得映射关系的map</span></span><br><span class="line">    std::map&lt;RIGHT_KEY, iterator&gt; m_RightKeyMap;  <span class="comment">///&lt; 用于保存右键与值得映射关系的map</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h2 id="std-forward-list-C-11"><a href="#std-forward-list-C-11" class="headerlink" title="std::forward_list (C++11)"></a><code>std::forward_list</code> (C++11)</h2><p>标准描述</p><blockquote><p><code>std::forward_list</code> 是支持从容器中的任何位置快速插入和移除元素的容器。不支持快速随机访问。它实现为单链表，且实质上与其在 <code>C</code> 中实现相比无任何开销。与 <code>std::list</code> 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储。</p></blockquote><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/forward_list_base.png" alt="forward_list"></p><h3 id="与-std-list-比较"><a href="#与-std-list-比较" class="headerlink" title="与 std::list 比较"></a>与 <code>std::list</code> 比较</h3><ul><li><code>std::forward_list</code> 只提供前向迭代器，而不是双向迭代器。没有成员函数<code>rbegin()</code>、<code>rend()</code>、<code>crbegin()</code>和<code>crend()</code></li><li><code>std::forward_list</code> 不提供成员函数 <code>size()</code>。</li><li><code>std::forward_list</code> 没有指向最末元素的指针。所以没有成员函数如<code>back()</code>、<code>push_back()</code>和<code>pop_back()</code></li><li>对于所有令元素被安插在或删除于的某特定位置上的成员函数， <code>std::forward_list</code> 都提供特殊版本。原因是你必须传递第一个被处理元素的前一位置，前向迭代器不能回头。</li><li><code>insert_after()</code> 代替 <code>insert()</code>, 也额外提供 <code>before_begin()</code> 和 <code>cbefore_begin()</code></li></ul><h3 id="在起始处安插元素"><a href="#在起始处安插元素" class="headerlink" title="在起始处安插元素"></a>在起始处安插元素</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/forward_insert_begin.png" alt="forward_insert_begin"></p><div STYLE="page-break-after: always;"></div><h2 id="std-set-和-std-multiset"><a href="#std-set-和-std-multiset" class="headerlink" title="std::set 和 std::multiset"></a><code>std::set</code> 和 <code>std::multiset</code></h2><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/set_base.png" alt="set"></p><p><code>std::set</code> 和 <code>std::multiset</code> 会根据特定的排序准则，自动将元素排序。两者不同之处在于 <code>std::multiset</code> 允许元素重复而 <code>std::set</code> 不允许。</p><p>如果没有传入某个排序准则，就采用默认准则 <code>std::less</code> 以 <code>operator&lt;</code> 对元素进行比较。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/set_datastruct.png" alt="set"></p><h3 id="排序准则符合-严格弱序"><a href="#排序准则符合-严格弱序" class="headerlink" title="排序准则符合: 严格弱序"></a>排序准则符合: 严格弱序</h3><h4 id="详细定义"><a href="#详细定义" class="headerlink" title="详细定义"></a>详细定义</h4><blockquote><ol><li><p>必须是<strong>非对称的</strong>（antisymmetric）。</p><p> 对<code>operator&lt; </code>而言， 如果x &lt; y为true， 则y &lt; x为false。</p><p> 对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true，则op(y, x)为false。</p></li><li><p>必须是<strong>可传递的</strong>（transitive）。</p></li></ol><p>  对<code>operator&lt; </code>而言，如果x &lt; y 为true且y &lt; z为true， 则x &lt; z 为false。</p><p>  对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true且op(y, z)为tru，则op(x, z)为true。</p><ol start="3"><li><p>必须是<strong>非自反的</strong>（irreflexive）</p><p> 对<code>operator&lt; </code>而言，x &lt; x 永远是false</p><p> 对判断式(predicate) <code>op()</code>而言，op(x, x)永远是false。</p></li><li><p>必须有<strong>等效传递性</strong>（transitivity of equivalence）</p></li></ol><p>对<code>operator&lt; </code>而言，假如 !(a&lt;b) &amp;&amp; !(b&lt;a) 为true且 !(b&lt;c) &amp;&amp; !(c&lt;b) 为 true<br>那么!(a&lt;c) &amp;&amp; !(c&lt;a) 也为true.<br>对判断式(predicate) <code>op()</code>而言， 假如 op(a,b), op(b,a), op(b,c), 和op(c,b) 都为<br>false, 那么op(a,c) and op(c,a) 也为false.</p></blockquote><p><strong>简单的来说就是a&lt;b返回true，a&#x3D;b和a&gt;b返回false。</strong></p><h4 id="定制排序规则-operator"><a href="#定制排序规则-operator" class="headerlink" title="定制排序规则 operator&lt;"></a>定制排序规则 <code>operator&lt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CALL_INFO_C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> CALL_INFO_C&amp; stOther) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; stOther.x || (x == stOther.x &amp;&amp; y &lt; stOther.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::set&lt;CALL_INFO_C&gt; set;</span><br></pre></td></tr></table></figure><p>其中 <code>std::multiset</code> 的等效元素的次序是随机但稳定的。(C++11以后标准保证新插入的元素，会被放在等效元素群的末尾)</p><h3 id="std-set-和-std-multiset-的能力"><a href="#std-set-和-std-multiset-的能力" class="headerlink" title="std::set 和 std::multiset 的能力"></a><code>std::set</code> 和 <code>std::multiset</code> 的能力</h3><ul><li>通常以平衡二叉树完成。</li><li>自动排序的主要优点在于令二叉树于查找元素时拥有良好的性能。其查找函数具有 <code>O(logn)</code> 的时间复杂度。</li><li>不能随意改变元素值，因为这会打乱原本正确的顺序。</li><li>如果要改变元素值，必须先删除旧元素，再插入新元素。</li><li>不提供任何操作函数可以直接访问底层元素</li><li>通过迭代器进行元素间接访问，有一个限制: 从迭代器的角度看，元素值是常量.(例如不能使用: <code>std::remove()</code>)</li><li>其迭代器是双向迭代器(不能使用 <code>std::sort()</code>)</li></ul><div STYLE="page-break-after: always;"></div><h2 id="std-map-和-std-multimap"><a href="#std-map-和-std-multimap" class="headerlink" title="std::map 和 std::multimap"></a><code>std::map</code> 和 <code>std::multimap</code></h2><p><code>std::map</code> 和 <code>std::multimap</code> 将 <code>key/value pair</code> 当作元素进行管理。它们可根据 <code>key</code> 的排序准则自动为元素排序。 <code>std::multimap</code> 允许重复元素, <code>std::map</code> 不允许。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/map_base.png" alt="map"></p><p>同样 <code>key</code> 需要可比较且遵循严格弱序。</p><p><code>std::map</code> 和 <code>std::multimap</code> 通常以平衡二叉树完成。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/map_datastruct.png" alt="map"></p><p><code>std::map</code> 和 <code>std::multimap</code> 也无法改变 <code>key</code> 的值。只能删除再插入。</p><h3 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h3><p>若<code>key</code>不存在, 构造该元素后，返回元素的引用<br>若<code>key</code>存在, 返回元素的引用</p><p>所以要警惕如下语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line">std::cout &lt;&lt; map[<span class="string">&quot;string&quot;</span>]; <span class="comment">///&lt; 这里会默认插入一个元素 (&quot;string&quot;, 0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line">map[<span class="string">&quot;string&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="string">&quot;string&quot;</span>] = <span class="number">2</span>;  <span class="comment">///&lt; 会覆盖前面的值</span></span><br></pre></td></tr></table></figure><p>也可以利用这一特性用来计数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    map[str.<span class="built_in">at</span>(i)]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h2 id="无序容器-Unordered-Container-C-11"><a href="#无序容器-Unordered-Container-C-11" class="headerlink" title="无序容器 (Unordered Container) C++11"></a>无序容器 (Unordered Container) C++11</h2><p>C++11 之前因为标准库中没有哈希表类的数据结构，所以很多程序库自己实现了诸如 <code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>、<code>hash_multimap</code>。</p><p>为了避免名称冲突，C++11 标准采用了不一样的名称，使用统一前缀 <code>unordered_</code>, 即<code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>、<code>unordered_multimap</code>。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/unordered_map_base.png" alt="unordered_map"></p><p><code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>、<code>unordered_multimap</code> 底层实现都是哈希表，所以 <code>key</code> 需要可哈希。</p><p>但是在链表是单链还是双链(意味着其迭代器可能不是双向迭代器)，重新哈希的时机这些都没有指定，根据实现而定。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/unordered_map_datastruct.png" alt="unordered_map"></p><h3 id="定制哈希示例"><a href="#定制哈希示例" class="headerlink" title="定制哈希示例"></a>定制哈希示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MY_HASH</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> CALL_INFO_C&amp; st)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;CALL_INFO_C, <span class="type">int</span>, MY_HASH&gt; map;</span><br></pre></td></tr></table></figure><h3 id="容器特性-1"><a href="#容器特性-1" class="headerlink" title="容器特性"></a>容器特性</h3><p>安插、删除、查找元素大部分是 O(1), 但偶尔发生的重新哈希时间复杂度变为 O(n)</p><p>由于其迭代器只保证至少为前向迭代器，因此不提供包括 <code>rbegin()</code>、 <code>rend()</code>以及不能使用要求双向迭代器的的 STL 函数如<code>std::sort()</code>、<code>std::binary_search()</code></p><p>你可以手动强制重新哈希。</p><p>重新哈希可能发生在以下调用之后: <code>insert()</code>、<code>rehash()</code>、<code>rehash()</code> 或 <code>clear()</code>。</p><p><code>erase()</code> 函数并不会令指向其他元素的指针、引用和迭代器失效。</p><p><code>insert()</code> 和 <code>emplace()</code> 可能令所有迭代器失效。但不会影响引用的有效性。</p><p>当重新哈希过程发生，元素的引用仍然有效。</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>假如缓存中，我们缓存若干最近访问和删除的记录至内存用于快速访问，使得插入记录和读取最近的记录的时间复杂度为 <code>O(1)</code>。</p><ul><li>LRU (Least recently used)</li></ul><p>设计接口</p><ul><li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该擦除最久未使用的关键字。</li><li>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</li></ul><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/put.jpg" alt="put"></p><p>设计思路:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; KEY_VALUE;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::list&lt;KEY_VALUE&gt;::iterator&gt; map;</span><br><span class="line">std::list&lt;KEY_VALUE&gt; list;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>std::unordered_map</code> 特性: 单向迭代器, 增删元素 O(1), 增删元素后迭代器可能失效</p><p><code>std::list</code> 特性: 迭代器永不失效，任意位置插入常量时间 O(1), 访问首尾元素 O(1)</p><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">max_size</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (res != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            list.<span class="built_in">splice</span>(list.<span class="built_in">begin</span>(), list, res-&gt;second);</span><br><span class="line">            <span class="keyword">return</span> res-&gt;second-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">        list.<span class="built_in">push_front</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        <span class="keyword">if</span> (res != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            list.<span class="built_in">erase</span>(res-&gt;second);</span><br><span class="line">            map.<span class="built_in">erase</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        map[key] = list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 检查是否超出了最大数量</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">size</span>() &gt; max_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> last = list.<span class="built_in">end</span>();</span><br><span class="line">            --last;</span><br><span class="line">            map.<span class="built_in">erase</span>(last-&gt;first);</span><br><span class="line">            list.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; KEY_VALUE;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::list&lt;KEY_VALUE&gt;::iterator&gt; map;</span><br><span class="line">    std::list&lt;KEY_VALUE&gt; list;</span><br><span class="line">    <span class="type">int</span> max_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h2 id="特殊容器"><a href="#特殊容器" class="headerlink" title="特殊容器"></a>特殊容器</h2><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a><code>std::string</code></h3><p>其被定义为: <code>std::basic_string&lt;char&gt;</code></p><p>其中模板入参 <code>char</code> 可以换为 <code>unsigned char</code> 或 <code>wchar</code></p><h3 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a><code>std::stack</code></h3><p>后进先出</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/stack_base.png" alt="stack"></p><p><code>std::stack</code> 定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack;</span><br></pre></td></tr></table></figure><p>其底层类型默认为 <code>std::deque</code></p><p>之所以不选择 <code>std::vector</code> 是因为在内存管理上 <code>std::deque</code> 比 <code>std::vector</code> 更有效率。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/stack_base1.png" alt="stack"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="built_in">top</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_deque.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">push_front</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container m_deque;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h3 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a><code>std::queue</code></h3><p>先进先出</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/queue_base.png" alt="queue"></p><p>底层实现默认采用 <code>std::queue</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue;</span><br></pre></td></tr></table></figure><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/queue_base1.png" alt="queue"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="built_in">top</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_deque.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container m_deque;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h3 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a><code>std::priority_queue</code></h3><p>实现出一个队列，其中的元素按优先级存储。</p><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/priority_queue_base.png" alt="queue"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = vector&lt;T&gt;,</span><br><span class="line"><span class="keyword">typename</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure><p>应用实例:</p><p>求数据流中的中位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mi.<span class="built_in">push</span>(num);</span><br><span class="line">            num = mi.<span class="built_in">top</span>();</span><br><span class="line">            mi.<span class="built_in">pop</span>();</span><br><span class="line">            mx.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mx.<span class="built_in">push</span>(num);</span><br><span class="line">            num = mx.<span class="built_in">top</span>();</span><br><span class="line">            mx.<span class="built_in">pop</span>();</span><br><span class="line">            mi.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)mx.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span> (mx.<span class="built_in">top</span>() + mi.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::less&lt;<span class="type">int</span>&gt; &gt; mx;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; mi;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h3 id="std-bitset"><a href="#std-bitset" class="headerlink" title="std::bitset"></a><code>std::bitset</code></h3><p><code>std::bitset</code> 内含一个元素值为 <code>bit</code> 或 <code>bool</code> 值且大小固定的 <code>array</code>。当你需要管理各式<code>flag</code>, 并以 <code>flag</code> 的任意组合来表现变量时, 就可运用 <code>std::bitset</code>。</p><p>可容纳任意个数的标志位(编译期确定数量)</p><p><code>std::bitset</code> 编译期确定大小 <code>std::vector&lt;bool&gt;</code> 可动态增长。</p><h4 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h4><p>给 1000 个数字排序, 数字范围 [0, 99]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a[<span class="number">1000</span>] = &#123;<span class="number">10</span>, <span class="number">99</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">std::bitset&lt;100&gt; bitset;</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> pos = a[i];</span><br><span class="line">    bitset.<span class="built_in">set</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; bitset.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitset[i])</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 40 亿个 <code>unsigned</code> 数字([0, 99])中寻找不存在的数值</p><h4 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a></h4><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。多用于数据传输中的差错控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 0 &lt;= x, y &lt;= 2^31 - 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;32&gt; <span class="title">temp</span><span class="params">(x^y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p><code>Iterator</code>(迭代器)是一种”能够迭代某序列内所有元素”的对象，可通过改变自寻常pointer的一致性接口来完成工作。<code>Iterator</code>奉行一个纯抽象概念：任何东西，只要行为类似iterator，就是一种iterator。然而不同的的iterator具有不同的行进能力。</p><h3 id="迭代器种类"><a href="#迭代器种类" class="headerlink" title="迭代器种类"></a>迭代器种类</h3><table><thead><tr><th>迭代器种类</th><th>能力</th><th>提供者</th></tr></thead><tbody><tr><td>Output 迭代器</td><td>向前写入</td><td>Ostream,inserter</td></tr><tr><td>Input 迭代器</td><td>向前读取一次</td><td>Istream</td></tr><tr><td>Forward 迭代器</td><td>向前读取</td><td>Forward list、unordered containers</td></tr><tr><td>Bidirectional 迭代器</td><td>向前和向后读取</td><td>List、set、multiset、map、multimap</td></tr><tr><td>Random-access 迭代器</td><td>以随机访问方式读取</td><td>Array、vector、deque、string、C-style array</td></tr></tbody></table><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/iterator_base.png" alt="iterator"></p><p>Output迭代器允许一步一步前行并搭配write动作。因此你可以一个一个元素地赋值，不能使用output迭代器对同一区间迭代两次。事实上，甚至不保证你可以将一个value复制两次而其迭代器不累进。我们的目标是将一个value以下列形式写入一个黑洞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">  *pos = ...;</span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output 迭代器无需比较操作。你无法检验output迭代器是否有效，或写入是否成功。你唯一可做的就是写入。通常，一批写入动作是以一个”额外条件定义出”的”特定output迭代器”作为结束。<br>见下表Output迭代器操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter &#x3D; val</td><td>将val写至迭代器所指的位置</td></tr><tr><td>++iter</td><td>向前步进(step forward), 返回新位置</td></tr><tr><td>iter++</td><td>向前步进(step forward), 返回旧位置</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(copy 构造函数)</td></tr></tbody></table><h3 id="Input迭代器"><a href="#Input迭代器" class="headerlink" title="Input迭代器"></a>Input迭代器</h3><p>Input迭代器只能一次一个以前行方向读取元素，按此顺序一个个返回元素值。</p><p>Input迭代器的各项操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter</td><td>读取实际元素</td></tr><tr><td>iter-&gt;member</td><td>读取实际元素的成员(如果有的话)</td></tr><tr><td>++iter</td><td>向前步进(step forward), 返回新位置</td></tr><tr><td>iter++</td><td>向前步进(step forward), 返回旧位置</td></tr><tr><td>iter1 &#x3D;&#x3D; iter2</td><td>判断两个迭代器是否相等</td></tr><tr><td>iter1 !&#x3D; iter2</td><td>判断两个迭代器是否不相等</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(copy 构造函数)</td></tr></tbody></table><p>Input迭代器只能读取元素一次。如果你复制input迭代器, 并令原input迭代器和新产生的拷贝都向前读取, 可能会遍历到不同的值。<br><strong>所有的迭代器都具备input迭代器的能力，而且往往更强。</strong><code>Pure input</code>迭代器的典型例子就是”从标准输入设备读取数据”。同一个值不会被读取两次。一旦从<code>input stream</code>读入一个字(离开input缓冲区), 下次读取时就会返回另一个字。</p><p>对于input迭代器, 操作符&#x3D;&#x3D;和!&#x3D;只用来检查”某个迭代器是否等于一个past-the-end迭代器(指指向最末元素的下一个位置)”.这有其必要, 因为处理input迭代器的操作函数通常会有以下行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputIterator pos, end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos != end) &#123;</span><br><span class="line">  ... <span class="comment">// read-only access using *pos</span></span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有任何保证说，两个迭代器如果都不是past-the-end迭代器, 且指向不同位置，他们的比较结果会不相等</strong>(这个条件是和forward迭代器搭配引入的)。</p><p>也请注意, input迭代器的后置式递增操作符(<code>++iter</code>)不一定会返回什么东西。不过通常它会返回旧位置。<br>你应该尽可能优先先选用前置式递增操作符(<code>++iter</code>)而非后置式递增操作符(<code>iter++</code>), 因为前者效能更好。因为后者会返回一个临时对象。</p><h3 id="Forward-前向-迭代器"><a href="#Forward-前向-迭代器" class="headerlink" title="Forward(前向)迭代器"></a>Forward(前向)迭代器</h3><p>Forward迭代器是一种input迭代器且在前进读取时提供额外保证。</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter</td><td>访问实际元素</td></tr><tr><td>iter-&gt;member</td><td>访问实际元素的成员</td></tr><tr><td>++iter</td><td>向前步进(返回新位置)</td></tr><tr><td>iter++</td><td>向前步进(返回旧位置)</td></tr><tr><td>iter1 &#x3D;&#x3D; iter2</td><td>判断两个迭代器是否相等</td></tr><tr><td>iter1 !&#x3D; iter2</td><td>判断两个迭代器是否不等</td></tr><tr><td>TYPE()</td><td>创建迭代器(default构造函数)</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(拷贝构造函数)</td></tr><tr><td>iter1 &#x3D; iter2</td><td>对迭代器赋值(assign)</td></tr><tr><td>和input迭代器不同的是, 两个forward迭代器如果指向同一元素, <code>operator==</code>会获得<code>true</code>, 如果两者都递增, 会再次指向同一元素。</td><td></td></tr><tr><td>例如：</td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ForwardIterator pos1, pos2;</span><br><span class="line"></span><br><span class="line">pos1 = pos2 = begin; <span class="comment">/// both iterator refer to the same element</span></span><br><span class="line"><span class="keyword">if</span>(pos1 != end) &#123;</span><br><span class="line">  ++pos1; <span class="comment">/// pos1 is one element ahead</span></span><br><span class="line">  <span class="keyword">while</span>(pos1 != end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(*pos1 == *pos2) &#123;</span><br><span class="line">      ... <span class="comment">// precess adjacent duplicates</span></span><br><span class="line">      ++pos1;</span><br><span class="line">      ++pos2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Forward迭代器由以下对象和类型提供：</p><ul><li>Class<forward_list></li><li>Unordered container<br>然而标准库也允许<code>unordered</code>容器的实现提供<code>bidirectional</code>迭代器。<br>如果forward迭代器履行了output迭代器应有的条件, 那么它就是一个mutable forward迭代器, 即可用于读取，也可用于涂写。</li></ul><h3 id="Random-Access-随机访问-迭代器"><a href="#Random-Access-随机访问-迭代器" class="headerlink" title="Random-Access(随机访问)迭代器"></a>Random-Access(随机访问)迭代器</h3><p><code>Random-access</code>迭代器在<code>bidirectional</code>迭代器的基础上增加了随机访问能里。因此它必须提供<code>iterator</code>算数运算。也就是说，它能增减某个偏移量、<br>计算距离(<code>difference</code>), 并运用诸如&lt;和&gt;等管理操作符(<code>relational operator</code>)进行比较。</p><p>随机访问迭代器的新增操作:</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>iter[n]</td><td>访问索引位置为n的元素</td></tr><tr><td>iter+&#x3D;n</td><td>前进n个元素(如果n是负数, 则改为回退)</td></tr><tr><td>iter-&#x3D;n</td><td>回退n个元素(如果n是负数, 则改为前进)</td></tr><tr><td>iter+n</td><td>返回iter之后的第n个元素</td></tr><tr><td>n+iter</td><td>返回iter之后的第n个元素</td></tr><tr><td>iter-n</td><td>返回iter之前的第n个元素</td></tr><tr><td>iter1-iter2</td><td>返回iter1和iter2之间的距离</td></tr><tr><td>iter1 &lt; iter2</td><td>判断iter1是否在iter2之前</td></tr><tr><td>iter1 &gt; iter2</td><td>判断iter1是否在iter2之后</td></tr><tr><td>iter1 &lt;&#x3D; iter2</td><td>判断iter1是否不在iter2之后</td></tr><tr><td>iter1 &gt;&#x3D; iter2</td><td>判断iter1是否不在iter2之前</td></tr></tbody></table><p><code>Random-access</code>迭代器由以下对象和类型提供:</p><ul><li>可随机访问的容器(<code>array</code>、<code>vector</code>、<code>deque</code>)</li><li>String(<code>string</code>、<code>wstring</code>)</li><li>寻常的C-Style(<code>pointer</code>)</li></ul><div STYLE="page-break-after: always;"></div><h3 id="迭代器应用"><a href="#迭代器应用" class="headerlink" title="迭代器应用"></a>迭代器应用</h3><p>判断字符串是否为回文。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="type">const</span> std::string_view&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">equal</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>()/<span class="number">2</span>, s.<span class="built_in">rbegin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">is_palindrome</span>(<span class="string">&quot;1000000000个字符&quot;</span>); <span class="comment">///&lt; 时间复杂度: O(1)</span></span><br><span class="line"><span class="built_in">is_palindrome</span>(str); <span class="comment">///&lt; 时间复杂度: O(n)。 n = str.size();</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">equal</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>()/<span class="number">2</span>, s.<span class="built_in">rbegin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器失效场景"><a href="#迭代器失效场景" class="headerlink" title="迭代器失效场景"></a>迭代器失效场景</h3><p><a href="https://zh.cppreference.com/w/cpp/container">迭代器非法化</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于强制转换符构造临时对象的探索</title>
      <link href="/2023/07/21/2021-12-09-C++%E5%85%B3%E4%BA%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%AC%A6%E6%9E%84%E9%80%A0%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
      <url>/2023/07/21/2021-12-09-C++%E5%85%B3%E4%BA%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%AC%A6%E6%9E%84%E9%80%A0%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>本文通过实验验证了C++中临时对象的生命周期问题，特别是UnicodeString和AnsiString之间的转换。实验结果表明，使用强制类型转换符时，编译器会构造临时对象，并在该行结束后立即析构。尽管从临时对象中获取的指针可能存在潜在问题，但在C++ Builder、VS2010、VS2019和g++中均未出现编译警告或运行崩溃。此外，获取临时对象的引用在某些编译器中会引发警告或错误。结论是，尽管临时对象的指针使用可能不安全，但在实际测试中并未导致崩溃。</p><span id="more"></span><h2 id="验证背景"><a href="#验证背景" class="headerlink" title="验证背景"></a>验证背景</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TO_STR(x)   ((AnsiString)x).c_str()</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Dict::GetID</span><span class="params">(TcxComboBox *cb, UINT32 *pulID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHAR *szValue = <span class="built_in">TO_STR</span>(cb-&gt;Text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetID</span>(szValue, pulID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中 <code>TO_STR(x)</code> 宏定义，我理解为通过 <code>x</code> 构造出一个临时 <code>AnsiString</code> 的对象, 并对该临时对象调用成员函数 <code>c_str()</code> 获得指向其内部的 <code>const char *</code>。<br>由于匿名的临时对象的生命周期是该行结束即结束，所以获取到的 <code>const char *</code> 指针不可使用。<br>为了探究这个问题，使用以下代码来验证我的想法。</p><h2 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h2><p>由于 UnicodeString 不是标准库的对象，其源码繁杂且找不到手册，所以猜测 <code>UnicodeString</code> 与 <code>AnsiString</code> 的实现，分为两种:</p><ul><li><code>分别单独实现</code></li><li><code>UnicodeString</code> 继承自 <code>AnsiString</code></li></ul><h3 id="分别单独实现"><a href="#分别单独实现" class="headerlink" title="分别单独实现"></a>分别单独实现</h3><p>代码实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gos</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">const</span> T* dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> acText[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(acText, <span class="string">&quot;0x%X&quot;</span>, (<span class="type">size_t</span>)dec);</span><br><span class="line">    <span class="keyword">return</span> acText;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnsiString1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>(<span class="type">const</span> AnsiString1&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        <span class="built_in">sprintf</span>(str, obj.str);</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 拷贝构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, new str(&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~AnsiString1 析构函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, delete str(&quot;</span>&lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnicodeString1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;UnicodeString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~UnicodeString1 析构函数&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">AnsiString1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;operator AnsiString1(): &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AnsiString1 m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>C++ Builder</code> 运行结果</strong>:</p><p>不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x19FE64, str: 0xA926560</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x19FE64</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0x19FE64</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x19FE60, new str(0xA926520)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x19FE5C, new str(0xA926510)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x19FE5C, delete str(0xA926510)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x19FE60, delete str(0xA926520)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串: 0xA926510</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; E2238 Multiple declaration for &#x27;obj&#x27;</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj; ///&lt; E2357 Reference initialized with &#x27;AnsiString1&#x27;, needs lvalue of type &#x27;AnsiString1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>VS2010</code> 运行结果</strong>:</p><p>不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0xC3F914, str: 0x31A9F30</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0xC3F914</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0xC3F914</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F4FC, new str(0x31AA5B8)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F4F0, new str(0x31AA600)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xC3F4F0, delete str(0x31AA600)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xC3F4FC, delete str(0x31AA5B8)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x31AA600</span></span><br><span class="line">    AnsiString1&amp; r = (AnsiString1)obj;</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0xC3F914</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F518, new str(0x31AA5B8)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F8F0, new str(0x31AA600)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xC3F518, delete str(0x31AA5B8)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz1 = r.<span class="built_in">c_str</span>();    <span class="comment">///&lt; warning C4239: 使用了非标准扩展:“初始化”: 从“AnsiString1”转换到“AnsiString1 &amp;” 非常量引用只能绑定到左值</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz1: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz1: 0x31AA600</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不通过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>VS2019</code> 运行结果</strong>:</p><p>不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x8FFDF0, str: 0xA42310</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x8FFDF0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0x8FFDF0</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x8FFD0C, new str(0xA42498)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x8FFD18, new str(0xA42070)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x8FFD18, delete str(0xA42070)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x8FFD0C, delete str(0xA42498)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0xA42070</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不通过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj;  ///&lt; error C2440: “初始化”: 无法从“AnsiString1”转换为“AnsiString1 &amp;”, 非常量引用只能绑定到左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>g++</code> 运行结果</strong></p><p>不会崩溃</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x53EDAFC0, str: 0x9C2010</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x53EDAFC0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0x53EDAFC0</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x53EDAFC8, new str(0x9C2090)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x53EDAFC8, delete str(0x9C2090)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x9C2090~UnicodeString1 析构函数0x53EDAFC0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnicodeString-继承自-AnsiString"><a href="#UnicodeString-继承自-AnsiString" class="headerlink" title="UnicodeString 继承自 AnsiString"></a><code>UnicodeString</code> 继承自 <code>AnsiString</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gos</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">const</span> T* dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> acText[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(acText, <span class="string">&quot;0x%X&quot;</span>, (<span class="type">size_t</span>)dec);</span><br><span class="line">    <span class="keyword">return</span> acText;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnsiString1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>(<span class="type">const</span> AnsiString1&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        <span class="built_in">sprintf</span>(str, obj.str);</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 拷贝构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, new str(&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~AnsiString1 析构函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, delete str(&quot;</span>&lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnicodeString1</span> : <span class="keyword">public</span> AnsiString1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;UnicodeString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~UnicodeString1 析构函数&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">AnsiString1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;operator AnsiString1(): &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> *(AnsiString1*)<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>C++ Builder</code> 运行结果</strong>:</p><p>不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x19FE64, str: 0xA966560</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x19FE64</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x19FE60, new str(0xA966520)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x19FE60, delete str(0xA966520)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串: 0xA966520</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; E2238 Multiple declaration for &#x27;obj&#x27;</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj; ///&lt; E2357 Reference initialized with &#x27;AnsiString1&#x27;, needs lvalue of type &#x27;AnsiString1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>VS2010</code> 运行结果</strong>:</p><p>不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0xCFFA1C, str: 0x2C49F30</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0xCFFA1C</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xCFF610, new str(0x2C4A5B8)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xCFF610, delete str(0x2C4A5B8)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x2C4A5B8</span></span><br><span class="line">    AnsiString1&amp; r = (AnsiString1)obj; <span class="comment">///&lt; warning C4239: 使用了非标准扩展:“初始化”: 从“AnsiString1”转换到“AnsiString1 &amp;” 非常量引用只能绑定到左值</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xCFF9F8, new str(0x2C4A5B8)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz1 = r.<span class="built_in">c_str</span>();</span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz1: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz1: 0x2C4A5B8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>VS2019</code> 运行结果</strong>:</p><p>不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x3AFCD0, str: 0x682428</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x3AFCD0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x3AFBF8, new str(0x6823F0)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x3AFBF8, delete str(0x6823F0)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x6823F0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj;  ///&lt; error C2440: “初始化”: 无法从“AnsiString1”转换为“AnsiString1 &amp;”, 非常量引用只能绑定到左值</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>g++</code> 运行结果</strong></p><p>不会崩溃</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0xB512D870, str: 0x1D17010</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0xB512D870</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xB512D878, new str(0x1D17090)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xB512D878, delete str(0x1D17090)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x1D17090</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li><p>如果按照我们设想的 <code>UnicodeString</code> 的两种实现方式, 使用强制转换符， 在编译器 <code>C++ Builder</code>、<code>VS2010</code>、 <code>VS2019</code> 和 <code>g++</code> <strong>都会构造临时对象</strong>。</p></li><li><p>该临时对象在该行结束后马上析构。所以使用从临时对象中获取的指针可能会有问题，但<code>C++ Builder</code>、<code>VS2010</code>、 <code>VS2019</code> 和 <code>g++</code> <strong>没有出现编译警告和运行崩溃</strong>。</p></li><li><p>获取临时对象的引用在 <code>C++ Builder</code> 和 <code>VS2010</code> 中会有编译警告。在 <code>VS2019</code>、<code>g++</code> 中会直接编译错误。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 编程风格建议</title>
      <link href="/2023/07/21/2021-12-18-C++%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E5%BB%BA%E8%AE%AE/"/>
      <url>/2023/07/21/2021-12-18-C++%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>C++ 编程风格建议</p><p>本文总结了C++编程中的安全与效率优化建议。安全方面，强调使用引用而非指针、避免宏定义、缩短变量存活时间、禁止浮点数等量比较、类成员变量显式初始化、虚函数禁用缺省参数等。效率方面，建议优化循环嵌套、避免硬编码、使用强类型参数、避免布尔变量否定形式、删除无用代码等。此外，提倡使用<code>std::string</code>代替<code>char*</code>、避免<code>void*</code>、减少函数长度等，以提高代码可读性和维护性。这些建议旨在帮助开发者编写更安全、高效的C++代码。</p><span id="more"></span><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ol><li><p>引用和指针</p><ul><li>引用不会为空</li><li>引用不会改变指向</li><li>引用不能进行+、-、++、–运算</li></ul></li><li><p>宏定义多条语句</p><ul><li>使用do…while(false)来包含</li></ul></li><li><p>逻辑符号||的执行<br> 假设我们要同时自增a和b，如果任意一个函数失败了，则执行某些操作<br> Bad<br>     if(!IncreaseA() || !IncreaseB())<br>         假设自增A函数失败了，则不会自增B<br> Good<br>     分开写</p></li><li><p>尽可能缩短变量的存活时间</p><ul><li>短的变量存活时间减少了初始化错误的可能</li><li>阅读者同一时间需要阅读的代码变少，便于理解</li><li>当需要把一个大的函数分拆，短的存活时间方便拆分</li></ul></li><li><p>避免浮点数的数量级相差巨大的数字之间的四则运算<br> double d &#x3D; 100000000.0 + 0.1;</p></li><li><p>避免浮点数的等量比较</p></li><li><p>if&#x2F;循环语句必须使用大括号</p></li><li><p>禁止通过声明的方式引用外部函数接口、变量<br> 通过extern声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。</p></li><li><p>类的成员变量必须显式初始化</p></li><li><p>基类的析构函数必须声明为virtual</p></li><li><p>禁止虚函数使用缺省参数值</p></li><li><p>禁止重新定义继承而来的非虚函数</p></li><li><p>不允许使用宏来表示常量</p><ul><li>宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值</li><li>跟踪调试时也是显示值，而不是宏名</li><li>宏没有类型检查，不安全</li><li>宏没有作用域</li></ul></li><li><p>禁止用memcpy_s、memset_s初始化非POD对象</p><ul><li>POD类型主要包括int, char, float, double, enumeration, void, pointer等原始类ing以及聚合类型，不能使用封装和面向对象特性(如用户定义的构造&#x2F;赋值&#x2F;析构函数、基类、虚函数)</li><li>由于非POD类型比如非聚合类型的class对象，可能存在虚函数，内存布局不确定，跟编译器有关，滥用内存拷贝可能会导致严重的问题。</li><li>即使对聚合类型的class,使用直接的内存拷贝和比较，破坏了信息隐蔽和数据保护的作用，也不提倡使用memcpy_s、memset_s</li></ul></li><li><p>含有变量自增或自减运算的表达式中禁止再次引用该变量<br>x &#x3D; b[i] + i++;</p></li><li><p>不要保存std::string的c_str()返回的指针</p></li><li><p>对于指针和引用类型的形参，如果是不需要修改的，请使用const</p></li><li><p>使用强类型参数，避免使用void*</p></li><li><p>使用std::string代替char*</p><ul><li>不用考虑结尾的’\0’</li><li>可以直接使用+, &#x3D;, &#x3D;&#x3D;等运算符以及其他字符串操作函数</li><li>不需要考虑内存分配操作，避免了显式的new、delete, 以及由此导致的错误</li></ul></li></ol><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><ol><li><p>循环嵌套, 把大循环写在里面</p></li><li><p>strcmp的判断<br> Bad<br> if(!strcmp(str1, str2))<br> Good<br> if(strcmp(str1, str2) &#x3D;&#x3D; 0)</p></li><li><p>肯定语句比双重否定容易理解<br> Good<br> if(SomethingDone)<br> Bad<br> if(!NotDone)</p></li><li><p>条件判断语句<br> 常量在右，变量在左<br> 让编译器去检查误赋值的情况</p></li><li><p>使用小括号，避免优先级问题<br> Bad<br> if(a &lt; b &#x3D;&#x3D; c &#x3D;&#x3D; d)<br> Good<br> if((a &lt; b) &#x3D;&#x3D; (c &#x3D;&#x3D; d))</p></li><li><p>为变量指定唯一用途。避免采用不同取值区间来区分不同内容, 如，Account小于5000时表示老用户ID，大于5000时表示新用户ID</p></li><li><p>避免采用硬编码</p></li><li><p>布尔变量的命名</p><ul><li>避免采用status、sourcefile等模糊的布尔变量名，采用statusOK、sourcefileFound</li><li>避免采用否定形式的布尔变量<br>  if(!NotSuccess)</li></ul></li><li><p>避免在变量名中使用数字</p><ul><li>考虑使用数组代替</li><li>如果数组不适合，那么数字更不适合</li></ul></li><li><p>定义变量的作用域</p><ul><li>开始采用最严格的可见性，然后根据需求扩展变量的作用域</li><li>循环内的变量挪动到循环外，比反过来简单</li><li>把private变量变为public, 比反过来简单</li></ul></li><li><p>不用的代码段直接删除，不要注释掉</p><ul><li>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入容易被忽略的缺陷</li><li>使用版本控制来，记录代码。</li></ul></li><li><p>避免在变量名中使用容易混淆的字符</p><ul><li>数字<code>1</code>和小写的<code>l</code></li><li>数字<code>1</code>和大写的<code>L</code></li><li>数字<code>0</code>和大写的<code>O</code></li><li>数字<code>2</code>和小写的<code>z</code></li><li>数字<code>6</code>和大写的<code>G</code></li></ul></li><li><p>为空语句创建一个DoNothing()预处理宏或者内联函数</p></li><li><p>避免函数过长，函数不超过50行(非空非注释)</p><ul><li>函数应该可以一屏显示完(50行以内), 只做一件事情，而且把它做好。</li><li>过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步抽象。</li><li>即使一个长函数现在工作的很好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的BUG。建议将其拆分为更加简短并易于管理的若干函数，以便于他人阅读和修改代码。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网课《从零开始学架构》摘录</title>
      <link href="/2023/07/21/2021-12-02-%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/21/2021-12-02-%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文深入探讨了高可用存储架构的设计与实现，重点分析了主备复制、主从复制、双机切换和主主复制四种常见架构的优缺点及适用场景。主备复制简单但依赖人工干预，主从复制提升硬件利用率但增加复杂度，双机切换通过自动切换提高可用性但设计复杂，主主复制则适用于特定数据场景。文章还介绍了计算高可用架构的设计思路，包括主备、主从和集群模式，并探讨了应对接口级故障的降级、熔断、限流和排队策略。最后，文章总结了架构设计的核心理念，强调架构是系统的顶层结构，设计需遵循合适、简单和演化原则，并结合实际需求进行优化和创新。</p><span id="more"></span><p>innodb_buffer_pool_size、sync_binlog、innodb_log_file_size</p><p>PPC 与 TPC、Reactor 与 Proactor</p><p>幸运的是，最近我在学习的时候，无意中在网络上找到一份非常详尽的关于 Linux 服务器网络模型的详细系列文章。作者通过连载的方式，将 iterative、forking（对应专栏的 PPC 模式）、preforked（对应专栏的 prefork 模式）、threaded（对应专栏的 TPC 模式）、prethreaded（对应专栏的 prethread 模式）、poll、epoll（对应专栏的 Reactor 模式）共 7 种模式的实现原理、实现代码、性能对比都详尽地进行了阐述，完美地弥补了专栏内容没有实际数据对比的遗憾。</p><p><a href="https://unixism.net/2019/04/linux-applications-performance-introduction/">Linux Applications Performance: Introduction</a></p><p><a href="https://mp.weixin.qq.com/s/ZdNEgn1gxyat9PeOeycHTg">一文读懂「中台」的前世今生</a></p><p><a href="https://time.geekbang.org/column/intro/100006601?tab=catalog">从 0 开始学架构</a></p><h2 id="25-高可用存储架构：双机架构"><a href="#25-高可用存储架构：双机架构" class="headerlink" title="25 | 高可用存储架构：双机架构"></a>25 | 高可用存储架构：双机架构</h2><p>存储高可用方案的本质都是通过将数据复制到多个存储设备，通过数据冗余的方式来实现高可用，其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致问题。<br>因此，对任何一个高可用存储方案，我们需要从以下几个方面去进行思考和分析：</p><ul><li>数据如何复制？</li><li>各个节点的职责是什么？</li><li>如何应对复制延迟？</li><li>如何应对复制中断？</li></ul><p>双机解决方案:<br>主备、主从、主备 &#x2F; 主从切换和主主。</p><h2 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h2><p>主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等。</p><p>下面是标准的主备方案结构图：</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6.png" alt="主备复制"></p><p>其整体架构比较简单，主备架构中的“备机”主要还是起到一个备份作用，并不承担实际的业务读写操作，如果要把备机改为主机，需要人工操作。</p><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>主备复制架构的优点就是简单，表现有：</p><ul><li>对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。</li><li>对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。</li></ul><p>主备复制架构的缺点主要有：</p><ul><li>备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。</li><li>故障后需要人工干预，无法自动恢复。人工处理的效率是很低的，可能打电话找到能够操作的人就耗费了 10 分钟，甚至如果是深更半夜，出了故障都没人知道。人工在执行恢复操作的过程中也容易出错，因为这类操作并不常见，可能 1 年就 2、3 次，实际操作的时候很可能遇到各种意想不到的问题。</li></ul><p>综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制和主备复制只有一字之差，“从”意思是“随从、仆从”，“备”的意思是备份。我们可以理解为仆从是要帮主人干活的，这里的干活就是承担“读”的操作。也就是说，主机负责读写操作，从机只负责读操作，不负责写操作。</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="主从复制"></p><p>优缺点分析</p><p>主从复制与主备复制相比，优点有：</p><ul><li>主从复制在主机故障时，读操作相关的业务可以继续运行。</li><li>主从复制架构的从机提供读操作，发挥了硬件的性能。</li></ul><p>缺点有：</p><ul><li>主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。</li><li>主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。</li><li>故障时需要人工干预。</li></ul><p>综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。</p><h2 id="双机切换"><a href="#双机切换" class="headerlink" title="双机切换"></a>双机切换</h2><ol><li>设计关键<br>主备复制和主从复制方案存在两个共性的问题：</li></ol><ul><li>主机故障后，无法进行写操作。</li><li>如果主机无法恢复，需要人工指定新的主机角色。</li></ul><p>双机切换就是为了解决这两个问题而产生的，包括主备切换和主从切换两种方案。<br>简单来说，这两个方案就是在原有方案的基础上增加“切换”功能，即系统自动决定主机角色，并完成角色切换。<br>由于主备切换和主从切换在切换的设计上没有差别，我接下来以主备切换为例，一起来看看双机切换架构是如何实现的。<br>要实现一个完善的切换方案，必须考虑这几个关键的设计点：</p><p>主备间状态判断</p><p>主要包括两方面：状态传递的渠道，以及状态检测的内容。</p><p><strong>状态传递的渠道</strong>：是相互间互相连接，还是第三方仲裁？</p><p><strong>状态检测的内容</strong>：例如机器是否掉电、进程是否存在、响应是否缓慢等。</p><p>切换决策</p><p>主要包括几方面：切换时机、切换策略、自动程度。</p><p><strong>切换时机</strong>：什么情况下备机应该升级为主机？是机器掉电后备机才升级，还是主机上的进程不存在就升级，还是主机响应时间超过 2 秒就升级，还是 3 分钟内主机连续重启 3 次就升级等。</p><p><strong>切换策略</strong>：原来的主机故障恢复后，要再次切换，确保原来的主机继续做主机，还是原来的主机故障恢复后自动成为新的备机？</p><p><strong>自动程度</strong>：切换是完全自动的，还是半自动的？例如，系统判断当前需要切换，但需要人工做最终的确认操作（例如，单击一下“切换”按钮）。</p><p>数据冲突解决</p><p>当原有故障的主机恢复后，新旧主机之间可能存在数据冲突。</p><p>例如，用户在旧主机上新增了一条 ID 为 100 的数据，这个数据还没有复制到旧的备机，此时发生了切换，旧的备机升级为新的主机，用户又在新的主机上新增了一条 ID 为 100 的数据，当旧的故障主机恢复后，这两条 ID 都为 100 的数据，应该怎么处理？</p><p>以上设计点并没有放之四海而皆准的答案，不同的业务要求不一样，所以切换方案比复制方案不只是多了一个切换功能那么简单，而是复杂度上升了一个量级。形象点来说，如果复制方案的代码是 1000 行，那么切换方案的代码可能就是 10000 行，多出来的那 9000 行就是用于实现上面我所讲的 3 个设计点的。</p><h3 id="常见架构"><a href="#常见架构" class="headerlink" title="常见架构"></a>常见架构</h3><p>根据状态传递渠道的不同，常见的主备切换架构有三种形式：互连式、中介式和模拟式。</p><h4 id="互连式"><a href="#互连式" class="headerlink" title="互连式"></a>互连式</h4><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E5%8F%8C%E6%9C%BA%E5%88%87%E6%8D%A2%E4%BA%92%E8%81%94%E5%BC%8F.png" alt="双机切换互联式"></p><p>你可以看到，在主备复制的架构基础上，主机和备机多了一个“状态传递”的通道，这个通道就是用来传递状态信息的。这个通道的具体实现可以有很多方式：</p><ul><li>可以是网络连接（例如，各开一个端口），也可以是非网络连接（用串口线连接）。</li><li>可以是主机发送状态给备机，也可以是备机到主机来获取状态信息。</li><li>可以和数据复制通道共用，也可以独立一条通道。</li><li>状态传递通道可以是一条，也可以是多条，还可以是不同类型的通道混合（例如，网络 + 串口）。</li></ul><p>为了充分利用切换方案能够自动决定主机这个优势，客户端这里也会有一些相应的改变，常见的方式有：</p><ul><li>为了切换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。例如虚拟 IP，主机需要绑定这个虚拟的 IP。</li><li>客户端同时记录主备机的地址，哪个能访问就访问哪个；备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是“备机不对外提供服务”。</li></ul><p>互连式主备切换主要的缺点在于：</p><ul><li>如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。</li><li>虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。</li></ul><h4 id="中介式"><a href="#中介式" class="headerlink" title="中介式"></a>中介式</h4><p>中介式指的是在主备两者之外引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息，其架构图如下：</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E5%8F%8C%E6%9C%BA%E5%88%87%E6%8D%A2%E4%B8%AD%E4%BB%8B%E5%BC%8F.png" alt="双机切换中介式"></p><p>连接管理更简单：主备机无须再建立和管理多种类型的状态传递连接通道，只要连接到中介即可，实际上是降低了主备机的连接管理复杂度。</p><p>例如，互连式要求主机开一个监听端口，备机来获取状态信息；或者要求备机开一个监听端口，主机推送状态信息到备机；如果还采用了串口连接，则需要增加串口连接管理和数据读取。采用中介式后，主备机都只需要把状态信息发送给中介，或者从中介获取对方的状态信息。无论是发送还是获取，主备机都是作为中介的客户端去操作，复杂度会降低。</p><p>状态决策更简单：主备机的状态决策简单了，无须考虑多种类型的连接通道获取的状态信息如何决策的问题，只需要按照下面简单的算法即可完成状态决策。</p><ul><li>无论是主机还是备机，初始状态都是备机，并且只要与中介断开连接，就将自己降级为备机，因此可能出现双备机的情况。</li><li>主机与中介断连后，中介能够立刻告知备机，备机将自己升级为主机。</li><li>如果是网络中断导致主机与中介断连，主机自己会降级为备机，网络恢复后，旧的主机以新的备机身份向中介上报自己的状态。</li><li>如果是掉电重启或者进程重启，旧的主机初始状态为备机，与中介恢复连接后，发现已经有主机了，保持自己备机状态不变。</li><li>主备机与中介连接都正常的情况下，按照实际的状态决定是否进行切换。例如，主机响应时间超过 3 秒就进行切换，主机降级为备机，备机升级为主机即可。</li></ul><p>虽然中介式架构在状态传递和状态决策上更加简单，但并不意味着这种优点是没有代价的，其关键代价就在于如何实现中介本身的高可用。如果中介自己宕机了，整个系统就进入了双备的状态，写操作相关的业务就不可用了。这就陷入了一个递归的陷阱：为了实现高可用，我们引入中介，但中介本身又要求高可用，于是又要设计中介的高可用方案……如此递归下去就无穷无尽了。</p><p>幸运的是，开源方案已经有比较成熟的中介式解决方案，例如 ZooKeeper 和 Keepalived。ZooKeeper 本身已经实现了高可用集群架构，因此已经帮我们解决了中介本身的可靠性问题，在工程实践中推荐基于 ZooKeeper 搭建中介式切换架构。</p><h4 id="模拟式"><a href="#模拟式" class="headerlink" title="模拟式"></a>模拟式</h4><p>模拟式指主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。其基本架构如下：</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E5%8F%8C%E6%9C%BA%E5%88%87%E6%8D%A2%E6%A8%A1%E6%8B%9F%E5%BC%8F.png" alt="双机切换模拟式"></p><p>模拟式切换与互连式切换相比，优点是实现更加简单，因为省去了状态传递通道的建立和管理工作。</p><p>简单既是优点，同时也是缺点。因为模拟式读写操作获取的状态信息只有响应信息（例如，HTTP 404，超时、响应时间超过 3 秒等），没有互连式那样多样（除了响应信息，还可以包含 CPU 负载、I&#x2F;O 负载、吞吐量、响应时间等），基于有限的状态来做状态决策，可能出现偏差。</p><h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><p>主主复制指的是两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作，下面是基本架构图。</p><p>相比主备切换架构，主主复制架构具有如下特点：</p><ul><li>两台都是主机，不存在切换的概念。</li><li>客户端无须区分不同角色的主机，随便将读写操作发送给哪台主机都可以。</li></ul><p>从上面的描述来看，主主复制架构从总体上来看要简单很多，无须状态信息传递，也无须状态决策和状态切换。然而事实上主主复制架构也并不简单，而是有其独特的复杂性，具体表现在：如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的。</p><ul><li>用户注册后生成的用户 ID，如果按照数字增长，那就不能双向复制，否则就会出现 X 用户在主机 A 注册，分配的用户 ID 是 100，同时 Y 用户在主机 B 注册，分配的用户 ID 也是 100，这就出现了冲突。</li><li>库存不能双向复制。例如，一件商品库存 100 件，主机 A 上减了 1 件变成 99，主机 B 上减了 2 件变成 98，然后主机 A 将库存 99 复制到主机 B，主机 B 原有的库存 98 被覆盖，变成了 99，而实际上此时真正的库存是 97。类似的还有余额数据。</li></ul><p>因此，主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。例如，用户登录产生的 session 数据（可以重新登录生成）、用户行为的日志数据（可以丢失）、论坛的草稿数据（可以丢失）等。</p><h2 id="27-如何设计计算高可用架构？"><a href="#27-如何设计计算高可用架构？" class="headerlink" title="27 | 如何设计计算高可用架构？"></a>27 | 如何设计计算高可用架构？</h2><p>计算高可用的主要设计目标是当出现部分硬件损坏时，计算任务能够继续正常运行。因此计算高可用的本质是通过冗余来规避部分故障的风险，单台服务器是无论如何都达不到这个目标的。所以计算高可用的设计思想很简单：通过增加更多服务器来达到计算高可用。</p><p>计算高可用架构的设计复杂度主要体现在任务管理方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行。因此，计算高可用架构设计的关键点有下面两点。</p><ol><li>哪些服务器可以执行任务</li></ol><p>第一种方式和计算高性能中的集群类似，每个服务器都可以执行任务。例如，常见的访问网站的某个页面。</p><p>第二种方式和存储高可用中的集群类似，只有特定服务器（通常叫“主机”）可以执行任务。当执行任务的服务器故障后，系统需要挑选新的服务器来执行任务。例如，ZooKeeper 的 Leader 才能处理写操作请求。</p><ol start="2"><li>任务如何重新执行</li></ol><p>第一种策略是对于已经分配的任务即使执行失败也不做任何处理，系统只需要保证新的任务能够分配到其他非故障服务器上执行即可。</p><p>第二种策略是设计一个任务管理器来管理需要执行的计算任务，服务器执行完任务后，需要向任务管理器反馈任务执行结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行。</p><p>需要注意的是：“任务分配器”是一个逻辑的概念，并不一定要求系统存在一个独立的任务分配器模块。例如：</p><ul><li><p>Nginx 将页面请求发送给 Web 服务器，而 CSS&#x2F;JS 等静态文件直接读取本地缓存。这里的 Nginx 角色是反向代理系统，但是承担了任务分配器的职责，而不需要 Nginx 做反向代理，后面再来一个任务分配器。</p></li><li><p>对于一些后台批量运算的任务，可以设计一个独立的任务分配系统来管理这些批处理任务的执行和分配。</p></li><li><p>ZooKeeper 中的 Follower 节点，当接收到写请求时会将请求转发给 Leader 节点处理，当接收到读请求时就自己处理，这里的 Follower 就相当于一个逻辑上的任务分配器。</p></li></ul><p>常见的计算高可用架构：主备、主从和集群</p><h3 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h3><p>主备架构是计算高可用最简单的架构，和存储高可用的主备复制架构类似，但是要更简单一些，因为计算高可用的主备架构无须数据复制，其基本的架构示意图如下：</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%BB%E5%A4%87.png" alt="高可用主备"></p><p>主备方案的详细设计：</p><p>主机执行所有计算任务。例如，读写数据、执行操作等。</p><ul><li>当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务发送给备机，此时系统处于不可用状态。</li><li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续将任务发送给主机。</li><li>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机（即原来的备机）；同时，为了继续保持主备架构，需要人工增加新的机器作为备机。</li></ul><p>根据备机状态的不同，主备架构又可以细分为冷备架构和温备架构。</p><ul><li>冷备：备机上的程序包和配置文件都准备好，但备机上的业务系统没有启动（注意：备机的服务器是启动的），主机故障后，需要人工手工将备机的业务系统启动，并将任务分配器的任务请求切换发送给备机。</li><li>温备：备机上的业务系统已经启动，只是不对外提供服务，主机故障后，人工只需要将任务分配器的任务请求切换发送到备机即可。冷备可以节省一定的能源，但温备能够大大减少手工操作时间，因此一般情况下推荐用温备的方式。</li></ul><p>主备架构的优点就是简单，主备机之间不需要进行交互，状态判断和切换操作由人工执行，系统实现很简单。而缺点正好也体现在“人工操作”这点上，因为人工操作的时间不可控，可能系统已经发生问题了，但维护人员还没发现，等了 1 个小时才发现。发现后人工切换的操作效率也比较低，可能需要半个小时才完成切换操作，而且手工操作过程中容易出错。例如，修改配置文件改错了、启动了错误的程序等。<br>和存储高可用中的主备复制架构类似，计算高可用的主备架构也比较适合与内部管理系统、后台管理系统这类使用人数不多、使用频率不高的业务，不太适合在线的业务。</p><h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>和存储高可用中的主从复制架构类似，计算高可用的主从架构中的从机也是要执行任务的。任务分配器需要将任务进行分类，确定哪些任务可以发送给主机执行，哪些任务可以发送给备机执行，其基本的架构示意图如下：</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%BB%E4%BB%8E.png" alt="高可用主从"></p><p>主从方案详细设计：</p><ul><li>正常情况下，主机执行部分计算任务（如图中的“计算任务 A”），备机执行部分计算任务（如图中的“计算任务 B”）。</li><li>当主机故障（例如，主机宕机）时，任务分配器不会自动将原本发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功。</li><li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续按照原有的设计策略分配任务，即计算任务 A 发送给主机，计算任务 B 发送给从机。</li><li>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将原来的从机升级为主机（一般只是修改配置即可），增加新的机器作为从机，新的从机准备就绪后，任务分配器继续按照原有的设计策略分配任务。</li></ul><p>主从架构与主备架构相比，优缺点有：</p><ul><li>优点：主从架构的从机也执行任务，发挥了从机的硬件性能。</li><li>缺点：主从架构需要将任务分类，任务分配器会复杂一些。</li></ul><h2 id="31-如何应对接口级的故障？"><a href="#31-如何应对接口级的故障？" class="headerlink" title="31 | 如何应对接口级的故障？"></a>31 | 如何应对接口级的故障？</h2><p>解决接口级故障的核心思想：优先保证核心业务和优先保证绝大部分用户。</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。例如，论坛可以降级为只能看帖子，不能发帖子；也可以降级为只能看帖子和评论，不能发评论；而 App 的日志上传接口，可以完全停掉一段时间，这段时间内 App 都不能上传日志。</p><p>降级的核心思想就是丢车保帅，优先保证核心业务。例如，对于论坛来说，90% 的流量是看帖子，那我们就优先保证看帖的功能；对于一个 App 来说，日志上传接口只是一个辅助的功能，故障时完全可以停掉。</p><p>常见的实现降级的方式有：</p><ul><li>系统后门降级</li></ul><p>简单来说，就是系统预留了后门用于降级操作。例如，系统提供一个降级 URL，当访问这个 URL 时，就相当于执行降级指令，具体的降级指令通过 URL 的参数传入即可。这种方案有一定的安全隐患，所以也会在 URL 中加入密码这类安全措施。</p><p>系统后门降级的方式实现成本低，但主要缺点是如果服务器数量多，需要一台一台去操作，效率比较低，这在故障处理争分夺秒的场景下是比较浪费时间的。</p><ul><li>独立降级系统</li></ul><p>为了解决系统后门降级方式的缺点，将降级操作独立到一个单独的系统中，可以实现复杂的权限管理、批量操作等功能。其基本架构如下：</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E9%99%8D%E7%BA%A7.png" alt="降级"></p><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。</p><p>假设一个这样的场景：A 服务的 X 功能依赖 B 服务的某个接口，当 B 服务的接口响应很慢的时候，A 服务的 X 功能响应肯定也会被拖慢，进一步导致 A 服务的线程都被卡在 X 功能处理上，此时 A 服务的其他功能都会被卡住或者响应非常慢。这时就需要熔断机制了，即：A 服务不再请求 B 服务的这个接口，A 服务内部只要发现是请求 B 服务的这个接口就立即返回错误，从而避免 A 服务整个被拖慢甚至拖死。</p><p>熔断机制实现的关键是需要有一个统一的 API 调用层，由 API 调用层来进行采样或者统计，如果接口调用散落在代码各处就没法进行统一处理了。</p><p>熔断机制实现的另外一个关键是阈值的设计，例如 1 分钟内 30% 的请求响应时间超过 1 秒就熔断，这个策略中的“1 分钟”“30%”“1 秒”都对最终的熔断效果有影响。实践中一般都是先根据分析确定阈值，然后上线观察效果，再进行调优。</p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。</p><p>限流一般都是系统内实现的，常见的限流方式可以分为两类：基于请求限流和基于资源限流。</p><ul><li>基于请求限流</li></ul><p>基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。</p><p>限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，每秒请求峰值最高为 10 万。</p><p>无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值，例如系统设定了 1 分钟 10000 个用户，但实际上 6000 个用户的时候系统就扛不住了；也可能达到 1 分钟 10000 用户后，其实系统压力还不大，但此时已经开始丢弃用户访问了。</p><p>即使找到了合适的阈值，基于请求限流还面临硬件相关的问题。例如一台 32 核的机器和 64 核的机器处理能力差别很大，阈值是不同的，可能有的技术人员以为简单根据硬件指标进行数学运算就可以得出来，实际上这样是不可行的，64 核的机器比 32 核的机器，业务处理性能并不是 2 倍的关系，可能是 1.5 倍，甚至可能是 1.1 倍。</p><p>为了找到合理的阈值，通常情况下可以采用性能压测来确定阈值，但性能压测也存在覆盖场景有限的问题，可能出现某个性能压测没有覆盖的功能导致系统压力很大；另外一种方式是逐步优化，即：先设定一个阈值然后上线观察运行情况，发现不合理就调整阈值。</p><p>基于上述的分析，根据阈值来限制访问量的方式更多的适应于业务功能比较简单的系统，例如负载均衡系统、网关系统、抢购系统等。</p><ul><li>基于资源限流</li></ul><p>基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，即：找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列等。</p><p>例如，采用 Netty 来实现服务器，每个进来的请求都先放入一个队列，业务线程再从队列读取请求进行处理，队列长度最大值为 10000，队列满了就拒绝后面的请求；也可以根据 CPU 的负载或者占用率进行限流，当 CPU 的占用率超过 80% 的时候就开始拒绝新的请求。</p><p>基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实践中设计也面临两个主要的难点：如何确定关键资源，如何确定关键资源的阈值。通常情况下，这也是一个逐步调优的过程，即：设计的时候先根据推断选择某个关键资源和阈值，然后测试验证，再上线观察，如果发现不合理，再进行优化。</p><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间，全世界最有名的排队当属 12306 网站排队了。排队虽然没有直接拒绝用户，但用户等了很长时间后进入系统，体验并不一定比限流好。</p><p>由于排队需要临时缓存大量的业务请求，单个系统内部无法缓存这么多数据，一般情况下，排队需要用独立的系统去实现，例如使用 Kafka 这类消息队列来缓存用户请求。</p><h2 id="49-谈谈App架构的演进"><a href="#49-谈谈App架构的演进" class="headerlink" title="49 | 谈谈App架构的演进"></a>49 | 谈谈App架构的演进</h2><p>架构设计理念，可以提炼为下面几个关键点：</p><ul><li>架构是系统的顶层结构。</li><li>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</li><li>架构设计需要遵循三个主要原则：合适原则、简单原则、演化原则。</li><li>架构设计首先要掌握业界已经成熟的各种架构模式，然后再进行优化、调整、创新。</li></ul><h2 id="架构设计文档模板"><a href="#架构设计文档模板" class="headerlink" title="架构设计文档模板"></a>架构设计文档模板</h2><p>备选方案模板</p><h3 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h3><p>[需求介绍主要描述需求的背景、目标、范围等]</p><p>随着前浪微博业务的不断发展，业务上拆分的子系统越来越多，目前系统间的调用都是同步调用，由此带来几个明显的系统问题：</p><p>性能问题：当用户发布了一条微博后，微博发布子系统需要同步调用“统计子系统”“审核子系统”“奖励子系统”等共 8 个子系统，性能很低。<br>耦合问题：当新增一个子系统时，例如如果要增加“广告子系统”，那么广告子系统需要开发新的接口给微博发布子系统调用。<br>效率问题：每个子系统提供的接口参数和实现都有一些细微的差别，导致每次都需要重新设计接口和联调接口，开发团队和测试团队花费了许多重复工作量。</p><p>基于以上背景，我们需要引入消息队列进行系统解耦，将目前的同步调用改为异步通知。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>[需求分析主要全方位地描述需求相关的信息]</p><h4 id="5W"><a href="#5W" class="headerlink" title="5W"></a>5W</h4><p>5W 指 Who、When、What、Why、Where。</p><ul><li>Who：需求利益干系人，包括开发者、使用者、购买者、决策者等。</li><li>When：需求使用时间，包括季节、时间、里程碑等。</li><li>What：需求的产出是什么，包括系统、数据、文件、开发库、平台等。</li><li>Where：需求的应用场景，包括国家、地点、环境等，例如测试平台只会在测试环境使用。</li><li>Why：需求需要解决的问题，通常和需求背景相关</li></ul><p>消息队列的 5W 分析如下：</p><ul><li>Who：消息队列系统主要是业务子系统来使用，子系统发送消息或者接收消息。</li><li>When：当子系统需要发送异步通知的时候，需要使用消息队列系统。</li><li>What：需要开发消息队列系统。</li><li>Where：开发环境、测试环境、生产环境都需要部署。</li><li>Why：消息队列系统将子系统解耦，将同步调用改为异步通知。</li></ul><h4 id="1H"><a href="#1H" class="headerlink" title="1H"></a>1H</h4><p>这里的 How 不是设计方案也不是架构方案，而是关键业务流程。<br>消息队列系统这部分内容很简单，但有的业务系统 1H 就是具体的用例了，有兴趣的同学可以尝试写写 ATM 机取款的业务流程。如果是复杂的业务系统，这部分也可以独立成“用例文档”</p><p>消息队列有两大核心功能：业务子系统发送消息给消息队列。业务子系统从消息队列获取消息。</p><h4 id="8C"><a href="#8C" class="headerlink" title="8C"></a>8C</h4><p>8C 指的是 8 个约束和限制，即 Constraints，包括性能 Performance、成本 Cost、时间 Time、可靠性 Reliability、安全性 Security、合规性 Compliance、技术性 Technology、兼容性 Compatibility</p><p>注：需求中涉及的性能、成本、可靠性等仅仅是利益关联方提出的诉求，不一定准确；如果经过分析有的约束没有必要，或成本太高、难度太大，这些约束是可以调整的。</p><ul><li>性能：需要达到 Kafka 的性能水平。</li><li>成本：参考 XX 公司的设计方案，不超过 10 台服务器。</li><li>时间：期望 3 个月内上线第一个版本，在两个业务尝试使用。</li><li>可靠性：按照业务的要求，消息队列系统的可靠性需要达到 99.99%。</li><li>安全性：消息队列系统仅在生产环境内网使用，无需考虑网络安全；如消息中有敏感信息，消息发送方需要自行进行加密，消息队列系统本身不考虑通用的加密。</li><li>合规性：消息队列系统需要按照公司目前的 DevOps 规范进行开发。</li><li>技术性：目前团队主要研发人员是 Java，最好用 Java 开发。</li><li>兼容性：之前没有类似系统，无需考虑兼容性。</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>[分析需求的复杂度，复杂度常见的有高可用、高性能、可扩展等，具体请参考专栏第 10 期的分析]</p><p>注：文档的内容省略了分析过程，实际操作的时候每个约束和限制都要有详细的逻辑推导，避免完全拍脑袋式决策。</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>对于微博子系统来说，如果消息丢了，导致没有审核，然后触犯了国家法律法规，则是非常严重的事情；<br>对于等级子系统来说，如果用户达到相应等级后，系统没有给他奖品和专属服务，则 VIP 用户会很不满意，导致用户流失从而损失收入，虽然也比较关键，但没有审核子系统丢消息那么严重。<br>综合来看，消息队列需要高可用性，包括消息写入、消息存储、消息读取都需要保证高可用性。</p><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>前浪微博系统用户每天发送 1000 万条微博，那么微博子系统一天会产生 1000 万条消息，平均一条消息有 10 个子系统读取，那么其他子系统读取的消息大约是 1 亿次。<br>将数据按照秒来计算，一天内平均每秒写入消息数为 115 条，每秒读取的消息数是 1150 条；<br>再考虑系统的读写并不是完全平均的，设计的目标应该以峰值来计算。峰值一般取平均值的 3 倍，那么消息队列系统的 TPS 是 345，QPS 是 3450，考虑一定的性能余量。<br>由于现在的基数较低，为了预留一定的系统容量应对后续业务的发展，我们将设计目标设定为峰值的 4 倍，因此最终的性能要求是：TPS 为 1380，QPS 为 13800。<br>TPS 为 1380 并不高，但 QPS 为 13800 已经比较高了，因此高性能读取是复杂度之一。</p><h4 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h4><p>消息队列的功能很明确，基本无须扩展，因此可扩展性不是这个消息队列的关键复杂度。</p><h3 id="备选方案"><a href="#备选方案" class="headerlink" title="备选方案"></a>备选方案</h3><p>[备选方案设计，至少 3 个备选方案，每个备选方案需要描述关键的实现，无须描述具体的实现细节。此处省略具体方案描述，详细请参考专栏第 11 期]</p><p>备选方案 1：</p><p>直接引入开源 Kafka[此处省略方案描述]</p><p>备选方案 2：</p><p>集群 + MySQL 存储[此处省略方案描述]</p><p>备选方案 3：</p><p>集群 + 自研存储[此处省略方案描述]</p><h3 id="备选方案评估"><a href="#备选方案评估" class="headerlink" title="备选方案评估"></a>备选方案评估</h3><p>[备选方案 360 度环评，详细请参考专栏第 12 期。注意备选方案评估的内容会根据评估会议的结果进行修改，也就是说架构师首先给出自己的备选方案评估，然后举行备选方案评估会议，再根据会议结论修改备选方案文档]</p><h3 id="架构设计模板"><a href="#架构设计模板" class="headerlink" title="架构设计模板"></a>架构设计模板</h3><h4 id="总体方案"><a href="#总体方案" class="headerlink" title="总体方案"></a>总体方案</h4><p>[总体方案需要从整体上描述方案的结构，其核心内容就是架构图，以及针对架构图的描述，包括模块或者子系统的职责描述、核心流程]</p><h4 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h4><p>[架构总览给出架构图以及架构的描述]</p><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="架构总览"></p><p>架构关键设计点：</p><ul><li>采用数据分散集群的架构，集群中的服务器进行分组，每个分组存储一部分消息数据。</li><li>每个分组包含一台主 MySQL 和一台备 MySQL，分组内主备数据复制，分组间数据不同步。</li><li>正常情况下，分组内的主服务器对外提供消息写入和消息读取服务，备服务器不对外提供服务；主服务器宕机的情况下，备服务器对外提供消息读取的服务。</li><li>客户端采取轮询的策略写入和读取消息。</li></ul><h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><ul><li>消息发送流程</li></ul><p>[此处省略流程描述]</p><ul><li>消息读取流程</li></ul><p>[此处省略流程描述]</p><h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><h5 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h5><ul><li>消息发送可靠性</li></ul><p>业务服务器中嵌入消息队列系统提供的 SDK，SDK 支持轮询发送消息，当某个分组的主服务器无法发送消息时，SDK 挑选下一个分组主服务器重发消息，依次尝试所有主服务器直到发送成功；如果全部主服务器都无法发送，SDK 可以缓存消息，也可以直接丢弃消息，具体策略可以在启动 SDK 的时候通过配置指定。</p><p>如果 SDK 缓存了一些消息未发送，此时恰好业务服务器又重启，则所有缓存的消息将永久丢失，这种情况 SDK 不做处理，业务方需要针对某些非常关键的消息自己实现永久存储的功能。</p><ul><li>消息存储可靠性</li></ul><p>消息存储在 MySQL 中，每个分组有一主一备两台 MySQL 服务器，MySQL 服务器之间复制消息以保证消息存储高可用。如果主备间出现复制延迟，恰好此时 MySQL 主服务器宕机导致数据无法恢复，则部分消息会永久丢失，这种情况不做针对性设计，DBA 需要对主备间的复制延迟进行监控，当复制延迟超过 30 秒的时候需要及时告警并进行处理。</p><ul><li>消息读取可靠性</li></ul><p>每个分组有一主一备两台服务器，主服务器支持发送和读取消息，备服务器只支持读取消息，当主服务器正常的时候备服务器不对外提供服务，只有备服务器判断主服务器故障的时候才对外提供消息读取服务。</p><p>主备服务器的角色和分组信息通过配置指定，通过 ZooKeeper 进行状态判断和决策。主备服务器启动的时候分别连接到 ZooKeeper，在 &#x2F;MQ&#x2F;Server&#x2F;[group]目录下建立 EPHEMERAL 节点，假设分组名称为 group1，则主服务器节点为 &#x2F;MQ&#x2F;Server&#x2F;group1&#x2F;master，备服务器的节点为 &#x2F;MQ&#x2F;Server&#x2F;group1&#x2F;slave。节点的超时时间可以配置，默认为 10 秒。</p><h5 id="高性能设计"><a href="#高性能设计" class="headerlink" title="高性能设计"></a>高性能设计</h5><p>[此处省略具体设计]</p><h5 id="可扩展设计"><a href="#可扩展设计" class="headerlink" title="可扩展设计"></a>可扩展设计</h5><p>[此处省略具体设计。如果方案不涉及，可以简单写上“无”，表示设计者有考虑但不需要设计；否则如果完全不写的话，方案评审的时候可能会被认为是遗漏了设计点]</p><h5 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h5><p>消息队列系统需要提供权限控制功能，权限控制包括两部分：身份识别和队列权限控制。</p><ul><li>身份识别</li></ul><p>消息队列系统给业务子系统分配身份标识和接入 key，SDK 首先需要建立连接并进行身份校验，消息队列服务器会中断校验不通过的连接。因此，任何业务子系统如果想接入消息队列系统，都必须首先申请身份标识和接入 key，通过这种方式来防止恶意系统任意接入。</p><ul><li>队列权限</li></ul><p>某些队列信息可能比较敏感，只允许部分子系统发送或者读取，消息队列系统将队列权限保存在配置文件中，当收到发送或者读取消息的请求时，首先需要根据业务子系统的身份标识以及配置的权限信息来判断业务子系统是否有权限，如果没有权限则拒绝服务。</p><ul><li>其他设计</li></ul><p>[其他设计包括上述以外的其他设计考虑点，例如指定开发语言、符合公司的某些标准等，如果篇幅较长，也可以独立进行描述]</p><p>消息队列系统需要接入公司已有的运维平台，通过运维平台发布和部署。<br>消息队列系统需要输出日志给公司已有的监控平台，通过监控平台监控消息队列系统的健康状态，包括发送消息的数量、发送消息的大小、积压消息的数量等，详细监控指标在后续设计方案中列出。</p><h5 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h5><p>[部署方案主要包括硬件要求、服务器部署方式、组网方式等]</p><p>消息队列系统的服务器和数据库服务器采取混布的方式部署，即：一台服务器上，部署同一分组的主服务器和主 MySQL，或者备服务器和备 MySQL。因为消息队列服务器主要是 CPU 密集型，而 MySQL 是磁盘密集型的，所以两者混布互相影响的几率不大。</p><p>硬件的基本要求：32 核 48G 内存 512G SSD 硬盘，考虑到消息队列系统动态扩容的需求不高，且对性能要求较高，因此需要使用物理服务器，不采用虚拟机。</p><h4 id="架构演进规划"><a href="#架构演进规划" class="headerlink" title="架构演进规划"></a>架构演进规划</h4><p>[通常情况下，规划和设计的需求比较完善，但如果一次性全部做完，项目周期可能会很长，因此可以采取分阶段实施，即：第一期做什么、第二期做什么，以此类推]</p><p>整个消息队列系统分三期实现：</p><ul><li>第一期：实现消息发送、权限控制功能，预计时间 3 个月。</li><li>第二期：实现消息读取功能，预计时间 1 个月。</li><li>第三期：实现主备基于 ZooKeeper 切换的功能，预计时间 2 周。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面对对象简介与 C++ 类的基本介绍</title>
      <link href="/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>本文深入探讨了C++中构造函数与析构函数的作用，以及面向对象编程的三大特性：封装、继承和多态。通过实例代码，详细解析了如何通过封装隐藏实现细节、通过继承复用代码、以及通过多态实现接口与实现的分离。文章还介绍了<code>public</code>、<code>private</code>、<code>protected</code>等关键字的用法，以及虚函数、友元函数、静态成员等高级特性。最后，探讨了多重继承中的菱形继承问题及其解决方案，帮助读者全面理解C++面向对象编程的核心概念与实践技巧。</p><span id="more"></span><h2 id="C-构造函数与析构函数"><a href="#C-构造函数与析构函数" class="headerlink" title="C++ 构造函数与析构函数"></a>C++ 构造函数与析构函数</h2><p>类的基本组合元素。<br>构造函数、析构函数、拷贝构造函数和拷贝复制符</p><p>构造函数在对象被创建的时候调用，如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;          <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">    A* p = <span class="keyword">new</span> A;   <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数在对象被销毁时刻调用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        A obj;</span><br><span class="line">    &#125;   <span class="comment">///&lt; 临时变量超出作用域，调用析构函数</span></span><br><span class="line"></span><br><span class="line">    A* p = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">///&lt; 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造与析构函数的具体讲解可见 <a href="https://mercy1101.github.io/C++-%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/">类内默认成员函数</a></p><h2 id="面对对象的简介"><a href="#面对对象的简介" class="headerlink" title="面对对象的简介"></a>面对对象的简介</h2><p>对象有三个特点: 封装、继承和多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>封装方法</li><li>聚合数据</li><li>隐藏细节</li></ul><h4 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h4><p>当我们在使用对象时，自然而然可以把一系列方法放在一个类内，就比如我们想要定义一系列读取 <code>Json</code> 字符串的方法。</p><p>下面是 <code>C 语言</code>的封装方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GJSON*  <span class="title">gos_json_init</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>    <span class="title">gos_json_free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span>    <span class="title">gos_json_parse</span><span class="params">(GJSON* Json, <span class="type">char</span> *szJson)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span>*   <span class="title">gos_json_get_string</span> <span class="params">(GJSON* Json, <span class="type">char</span> *szKey)</span></span>;</span><br></pre></td></tr></table></figure><p>我们推断使用顺序是:</p><ol><li>使用 <code>gos_json_init</code> 来获取一个可用的 <code>Json</code> 解析用的结构体, 其中存储了一些信息。</li><li>使用 <code>gos_json_parse</code> 来读取一系列 <code>Json</code> 字符串中的键值。</li><li>使用 <code>gos_json_get_string</code> 来通过键来获取值。</li><li>最后使用 <code>gos_json_free</code> 来释放资源。</li></ol><p>那么调用过程如以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GJSON* pJson = <span class="built_in">gos_json_init</span>();</span><br><span class="line">    <span class="built_in">gos_json_parse</span>(pJson, <span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = <span class="built_in">gos_json_get_string</span>(pJson, <span class="string">&quot;Key&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">gos_json_free</span>(pJson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比面对对象接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span> *szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上面所示: <code>C++</code>的接口</p><p>由于类内保存了一个 <code>GJSON</code> 的指针 <code>m_Json</code>, 所以接口函数不需要 <code>GJSON*</code> 的入参.<br>由于可以被调用的函数只有两个，那我们可以推测调用方法:</p><ol><li>使用 <code>parser</code> 接口函数解析 <code>json</code> 字符串</li><li>使用 <code>get_string</code> 接口函数来获取对应键的值</li></ol><p>调用如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Json obj;</span><br><span class="line">    obj.<span class="built_in">parser</span>(<span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = obj.<span class="built_in">get_string</span>(<span class="string">&quot;Key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的调用可以看到少了调用 <code>init</code> 和 <code>free</code> 两个函数的过程，因为 <code>class</code> 可以使用构造函数中初始化自己，在析构函数中做相反动作，我们下面补充构造函数和析构函数的定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Json = <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(m_Json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span>*szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">    <span class="function">GJSON* <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h4><p><code>class</code> 带来的好处是，类内不仅可以定义函数，也可以聚合成员，定义在一起方便查看与传递。</p><p>例如我们有一堆配置项数据需要保存。</p><p>C 语言可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="type">bool</span>     g_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 给变量赋值</span></span><br><span class="line">    g_ulLogLevel = <span class="number">1</span>;</span><br><span class="line">    g_bLogToStdout = TRUE;</span><br><span class="line">    g_bLogToFile = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他 cpp 文件中访问这些配置项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToFile;</span><br></pre></td></tr></table></figure><p>C++ 可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LocalCfg</span>() &#123; <span class="built_in">GetLogCfg</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> m_ulLogLevel;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToStdout;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他地方访问这些配置项</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogCfg obj;</span><br><span class="line"></span><br><span class="line">    obj.m_ulLogLevel;</span><br><span class="line">    obj.m_bLogToStdout;</span><br><span class="line">    obj.m_bLogToFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们经常在类中见到函数 <code>Get</code> 和 <code>Set</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; value = i; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们为什么要把一个简单的赋值操作封装成函数呢？</p><p>如果我们想要把变量的赋值与其他业务联动，见下面的例子:</p><ol><li>追踪赋值，添加打印</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;value: %d -&gt; %d&quot;</span>, value, i);</span><br><span class="line">        value = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加锁来支持多线程</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        value = i;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> value_temp = value;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> value_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    GMutex mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>业务联动绑定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = i;</span><br><span class="line">        IsSet = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (IsSet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 返回无效值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 用于记录 value 是否有效</span></span><br><span class="line">    <span class="type">bool</span> IsSet = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="隐藏细节"><a href="#隐藏细节" class="headerlink" title="隐藏细节"></a>隐藏细节</h4><p>见下面代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 把大象放进冰箱里</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PutElephantInFreezer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/// 打开冰箱门</span></span><br><span class="line">        <span class="built_in">OpenFreezerDoor</span>();</span><br><span class="line">        <span class="comment">/// 把大象放进去</span></span><br><span class="line">        <span class="built_in">LetElephantIn</span>();</span><br><span class="line">        <span class="comment">/// 关上冰箱门</span></span><br><span class="line">        <span class="built_in">CloseFreezerDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LetElephantIn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    <span class="comment">// 调用 public 函数来把大象放进冰箱里</span></span><br><span class="line">    obj.<span class="built_in">PutElephantInFreezer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍"><a href="#相关语法介绍" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="关于-public-与-private"><a href="#关于-public-与-private" class="headerlink" title="关于 public 与 private"></a>关于 <code>public</code> 与 <code>private</code></h5><p>关于关键字 <code>public</code> 和 <code>private</code>, <code>public</code> 类型的类内成员变量和函数，可以被类的实例调用而 <code>private</code> 不能。</p><p>实例化简单来说就是，把一个就是在代码中定义该对象。(如果把类的定义比作蛋糕模子，那么类的实例就是蛋糕)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OBJECT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象实例化</span></span><br><span class="line">    OBJECT obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例访问 public 类成员</span></span><br><span class="line">    obj.i_public = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例无法访问 private 成员</span></span><br><span class="line">    <span class="comment">// obj.i_private = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="友元函数介绍-friend-function"><a href="#友元函数介绍-friend-function" class="headerlink" title="友元函数介绍 (friend function)"></a>友元函数介绍 (<code>friend function</code>)</h5><p>对于私有变量和私有成员函数, 友元函数可以打破访问权限限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 友元函数不属于某个类，所以定义时</span></span><br><span class="line"><span class="comment">/// 不需要这样写:</span></span><br><span class="line"><span class="comment">/// void count::Set(counter&amp; obj, int num)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 友元函数内，对象实例访问对象私有成员</span></span><br><span class="line">    obj.i_private = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>友元函数本质是普通函数，友元只是描述的是对类的友元。</p></li><li><p>友元函数不属于类，是独立的函数，所以不受作用域描述符的限制。</p></li><li><p>友元函数本身可以同时成为多个类的友元函数。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obja.i_private = num;</span><br><span class="line">    objb.i_private = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj_a;</span><br><span class="line">    B obj_b;</span><br><span class="line">    <span class="built_in">Set</span>(obj_a, obj_b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类内-static-与对象之间的关系"><a href="#类内-static-与对象之间的关系" class="headerlink" title="类内 static 与对象之间的关系"></a>类内 <code>static</code> 与对象之间的关系</h5><p>在对象内的 <code>static</code> 变量和函数，与对象的生命周期无关，每一个对象的所有实例都共享同一个 <code>static</code> 变量和函数。</p><p>类内 <code>static</code> 函数对类内的静态成员函数、构造函数、析构函数和静态成员变量享有访问权限。</p><h6 id="类内静态变量"><a href="#类内静态变量" class="headerlink" title="类内静态变量"></a>类内静态变量</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">///&lt; 记录对象被实例化了多少次</span></span><br><span class="line">    <span class="built_in">A</span>()&#123;count++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    std::cout &lt;&lt; A::counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="类内静态成员函数"><a href="#类内静态成员函数" class="headerlink" title="类内静态成员函数"></a>类内静态成员函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCounter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_non_static = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun_non_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj0;</span><br><span class="line">    A obj1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, A::<span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">0.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">1.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示 类内静态成员函数是可以直接访问类内静态成员变量也可以调用类内静态成员函数<br>但不能调用类内非静态成员变量和函数, 如 <code>i_non_static</code>、 <code>fun_non_static</code></p><p>静态成员函数的使用限制，不能调用非 <code>static</code> 的类内成员函数和成员变量。</p><p>类内静态函数在单例模式中的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleon* pInstance = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pInstance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pInstance = <span class="keyword">new</span> Singleon;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleon</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承用来从基类中继承来函数或成员变量, 省却重复定义。</p><p>假如我们有很多呼叫相关的业务，都需要一个唯一的业务标识号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() : <span class="built_in">strBusinessID</span>(gos::<span class="built_in">GetUUID</span>()) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string strBusinessID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 点呼从基类中继承出来了一个业务 ID</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P2PCall</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P2PCall p2p_call;   <span class="comment">///&lt; 自动生成了一个唯一的业务号</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p2p_call.strBusinessID &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍-1"><a href="#相关语法介绍-1" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span>: <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">derive</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~derive&quot;</span> &lt;&lt; std::endl; &#125; <span class="comment">///&lt; 不定义虚析构函数会导致内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base* p = <span class="keyword">new</span> derive;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="protected-关键字"><a href="#protected-关键字" class="headerlink" title="protected 关键字"></a><code>protected</code> 关键字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_protected</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 可访问基类中的 protected 成员</span></span><br><span class="line">    <span class="keyword">return</span> i_protected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int get_private()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   基类中的 private 成员不能被派生类访问</span></span><br><span class="line">  <span class="comment">//   return i_private;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  base obj0;</span><br><span class="line">  <span class="comment">// 在基类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj0.i_protected = 0;</span></span><br><span class="line">  derive obj;</span><br><span class="line">  <span class="comment">// 在派生类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj.i_protected = 0;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>假设一个程序员又想拥有使用 <code>VSCode</code> 的能力 又想拥有使用 <code>source insight</code> 能力，<code>UML</code> 图如下</p><p><img src="/../resource/C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/multiple_inheritance.png" alt="multiple_inheritance"></p><p>写成代码为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseVSCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseSourceInsight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Programmer 拥有了 class VSCode 和</span></span><br><span class="line"><span class="comment">// class SourceInsight 中的方法函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">UseVSCode</span>();</span><br><span class="line">    lijiancong.<span class="built_in">UserSourceInsight</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个基类中拥有同名成员变量或函数，则派生类使用时应标注该成员变量或函数的作用域，避免产生编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果两个基类中拥有同名成员变量或函数，</span></span><br><span class="line">    <span class="comment">/// 派生类使用时应该标注哪个类的成员变量或函数， 否则编译错误</span></span><br><span class="line">    <span class="keyword">return</span> A::i_protected;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="使用-virtual-阻隔菱形继承"><a href="#使用-virtual-阻隔菱形继承" class="headerlink" title="使用 virtual 阻隔菱形继承"></a>使用 <code>virtual</code> 阻隔菱形继承</h5><p>我们在使用多重继承时，可能会出现如下的情况。</p><p>可能出现如下情况:</p><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5Cmultiple_inheritance2.png" alt="multiple_inheritance2"></p><p>菱形继承不仅会出现二义性成员变量名或函数名，而且在虚函数的继承中，中间类每一个类都会保存一个继承的副本，导致未知问题。使用 <code>virtual</code> 关键字避免菱形继承导致的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Tool</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Tool::i: &quot;</span> &lt;&lt; &amp;i</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VSCode</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;VSCode::i: &quot;</span> &lt;&lt; &amp;(VSCode::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SourceInsight</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SourceInsight::i: &quot;</span></span><br><span class="line">              &lt;&lt; &amp;(SourceInsight::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5CSnipaste_2021-10-23_14-41-51.png" alt="Snipaste_2021-10-23_14-41-51"></p><p>如上图， <code>VSCode</code> 和 <code>SourceInsight</code> 两个类都保存了一份基类 <code>Tool::i</code> 的副本, 造成了二义性。使用 <code>virtual</code> 来避免菱形继承带来的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">///&lt; 正常使用 Tool 类中的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述对象 <code>VSCode</code> 和 <code>SourceInsight</code> 没有使用关键字 <code>virtual</code> 来标注继承方式，那么 <code>Programmer</code> 类中正常使用 <code>Tool::i</code>。</p><h5 id="继承的方式与访问权限"><a href="#继承的方式与访问权限" class="headerlink" title="继承的方式与访问权限"></a>继承的方式与访问权限</h5><p><code>public</code>、<code>private</code>、<code>protected</code> 三种继承方式</p><p>见基类定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>public</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>public</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// public 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `public`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive obj;</span><br><span class="line">    obj.i_public = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;  不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>protected</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>protected</code> 继承与 <code>public</code> 继承相比， 区别在于 基类中 <code>public</code> 成员在 <code>protected</code> 继承后的派生类中降级为 <code>protected</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">protected</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `protected`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;</span><br><span class="line">    i_protected = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private</code> 继承：</p><ul><li>基类中 <code>public</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>private</code> 继承与 <code>public</code> 继承相比，区别在于基类中 <code>public</code> 成员和 <code>protected</code> 成员在 <code>private</code> 继承后的派生类中都降级为 <code>private</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">private</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `private`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `private`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// i_public = 0;</span></span><br><span class="line">    <span class="comment">/// i_protected = 0;</span></span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，什么类型的继承，在派生类中最高的类成员访问权限就降级为什么类型。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态用于接口与多态实现的分离</p><p>下面代码示例为多态在工厂模式中的应用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Interface* <span class="title">getInterface</span><span class="params">(<span class="type">bool</span> bIsUseMySQL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bIsUseMySQL)</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">MySqlImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">RedisImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Interface* p = factory.<span class="built_in">GetInterface</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 通过基类指针指向派生类</span></span><br><span class="line">    <span class="comment">// 调用基类中的虚函数，会通过编译器自动识别</span></span><br><span class="line">    <span class="comment">// 是使用 MySQL 的实现还是 Redis 的实现</span></span><br><span class="line">    p-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">    p-&gt;<span class="built_in">Query</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用多态进行了函数覆盖(<code>override</code>), 但是在基类和派生类中出现了同名但不同入参的函数名，则会发生函数隐藏(<code>hide</code>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">///  这里没有使用多态对基类中的 `Insert` 函数进行覆盖(override), 而是单独创建了一个新的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;RedisImpl::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Interface* pRedis = <span class="keyword">new</span> RedisImpl;</span><br><span class="line">  pRedis-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常使用多态，访问派生类的 `Insert` 函数的实现</span></span><br><span class="line"></span><br><span class="line">  Interface* pMySQL = <span class="keyword">new</span> MySqlImpl;</span><br><span class="line">  <span class="comment">/// pMySQL-&gt;Insert(&quot;Hello World!&quot;); 无法使用基类指针访问多态函数 `Insert`</span></span><br><span class="line">  pMySQL-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 只能访问基类 `Insert` 函数的实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用关键字 <code>override</code> 关键字避免因输入错误而导致函数覆盖不正确的现象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 由于 `override` 要求必须该函数对基类函数进行覆盖，这里由于入参不一致, 会出现编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>一个基类的虚函数，在不同派生类中实现，会产生多个虚函数表。</p><p>派生类的多个实例都会保存一个指针，该指针指向对应虚函数的实现（即对应的虚函数表）。</p><p>虚函数表中放入特定实现的函数指针，被调用时，通过函数指针来调用对应的汇编。</p><h4 id="类成员变量初始化顺序"><a href="#类成员变量初始化顺序" class="headerlink" title="类成员变量初始化顺序"></a>类成员变量初始化顺序</h4><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">a</span>(): <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">x</span>(y<span class="number">+1</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; obj.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出:<br>x: -858993459, y: 0</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 基本操作</title>
      <link href="/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>本文详细介绍了SQL查询的基础与进阶操作，涵盖了简单查询、指定字段查询、条件过滤、模糊查询、排序、分组、聚合函数、子查询、连接查询等常用技巧。通过实例演示了如何高效地从数据库中提取数据，并深入探讨了<code>WHERE</code>与<code>HAVING</code>的区别、<code>DISTINCT</code>去重、<code>CASE WHEN</code>条件赋值等高级用法。此外，还介绍了表的操作（如重命名、删除、清空）以及插入数据时的主键冲突处理。文章内容实用，适合初学者和进阶者参考，帮助读者掌握SQL查询的核心技能。</p><span id="more"></span><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>最简单的查询语句： 查询 <code>dcuser</code> 表中所有字段。</p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>以上语句在代码中禁止使用，因为在数据库扩展时，<code>SELECT *</code> 语句对应的结构体如果没有增加字段，则会出现未知错误。</p><h3 id="指定字段查询"><a href="#指定字段查询" class="headerlink" title="指定字段查询"></a>指定字段查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">UserID</th><th align="center">Name</th><th align="center">DCType</th><th align="center">DepotID</th></tr></thead><tbody><tr><td align="center">3000</td><td align="center">dis01</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3001</td><td align="center">dis02</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3002</td><td align="center">dis03</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3003</td><td align="center">dis04</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">9999</td><td align="center">test</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><h3 id="查询添加过滤条件"><a href="#查询添加过滤条件" class="headerlink" title="查询添加过滤条件"></a>查询添加过滤条件</h3><p>查询 <code>dcuser</code> 表中具有行车调度权限(<code>DCType = 1</code>)的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 为 <code>13003</code> 或 <code>13004</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="number">13003</span>, <span class="number">13004</span>);</span><br></pre></td></tr></table></figure><h4 id="BETWEEN-AND"><a href="#BETWEEN-AND" class="headerlink" title="BETWEEN AND"></a>BETWEEN AND</h4><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 介于 <code>13003</code> 到 <code>13005</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID BETWEEN <span class="number">13003</span> AND <span class="number">13005</span>;</span><br><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID &gt;= <span class="number">13003</span> AND DCUserID &lt;= <span class="number">13005</span>;</span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis</code> 开头的内容。 <code>%</code> 代替任意数量字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis%&#x27;</span></span><br></pre></td></tr></table></figure><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis0</code> + 任意一个字符的内容。 <code>_</code> 代替一个任意字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis0_&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h3><p>按时间降序查询 <code>groupcallinfo</code> 表中的数据。</p><p>升序(<code>ASC</code>): 数值小的记录在前。<br>降序(<code>DESC</code>): 数值大的记录在前。</p><p>如果不写关键字, 则默认使用 升序<code>ASC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>也可以使用多字段排序。 按照 <code>Time</code> 字段降序， <code>ASC</code> 字段升序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>, SeqID <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="查询总数量"><a href="#查询总数量" class="headerlink" title="查询总数量"></a>查询总数量</h3><p>查询 <code>dcuser</code> 表中有几个全功能调度员的账号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;记录数&#x27;</span> <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">65535</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">记录数</th></tr></thead><tbody><tr><td align="center">2</td></tr></tbody></table><h3 id="限制查询记录条数"><a href="#限制查询记录条数" class="headerlink" title="限制查询记录条数"></a>限制查询记录条数</h3><p>查询组呼记录，只显示100条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>查询组呼记录表中所有具有行车调度权限调度台处理的记录。</p><p>翻译为 <code>SQL</code> 语句:</p><p>查询 <code>groupcallinfo</code> 表中， <code>DCUserID</code> 等于 <code>dcuser</code> 表中 <code>DCType</code> 等于 <code>1</code> 记录的 <code>UserID</code> 字段的值</p><p>三句话等价:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> A.DCUserID, A.GroupID, A.Time, A.CallType <span class="keyword">FROM</span> groupcallinfo A <span class="keyword">WHERE</span> A.DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> B.UserID <span class="keyword">FROM</span> dcuser B <span class="keyword">WHERE</span> B.DCType <span class="operator">=</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> contacts <span class="keyword">WHERE</span> (surname, firstname) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> surname, firstname <span class="keyword">FROM</span> customer);</span><br></pre></td></tr></table></figure><h3 id="ALL-与-ANY-关键字"><a href="#ALL-与-ANY-关键字" class="headerlink" title="ALL 与 ANY 关键字:"></a>ALL 与 ANY 关键字:</h3><p>找出 class1 中比 class2 所有 source 都高的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> source <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> source <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><p>找出 class1 中 second_name 与 class2 中的重名的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> second_name <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> second_name <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><h3 id="查询最大、最小、平均值"><a href="#查询最大、最小、平均值" class="headerlink" title="查询最大、最小、平均值"></a>查询最大、最小、平均值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最大通话时长&#x27;</span>, <span class="built_in">MIN</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最小通话时长&#x27;</span>, <span class="built_in">AVG</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;平均通话时长&#x27;</span> <span class="keyword">FROM</span> trainposcallinfo;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">最大通话时长</th><th align="center">最小通话时长</th><th align="center">平均通话时长</th></tr></thead><tbody><tr><td align="center">48</td><td align="center">2</td><td align="center">14.667</td></tr></tbody></table><h3 id="查询数据分组"><a href="#查询数据分组" class="headerlink" title="查询数据分组"></a>查询数据分组</h3><p>统计不同的 <code>DCUserID</code> 都有多少条组呼记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr></tbody></table><h4 id="WITH-ROLLUP"><a href="#WITH-ROLLUP" class="headerlink" title="WITH ROLLUP"></a>WITH ROLLUP</h4><p><code>WITH ROLLUP</code> 用来在 <code>GROUP BY</code> 统计的基础上再加一行总数的统计行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr><tr><td align="center"></td><td align="center">859</td></tr></tbody></table><h4 id="HAVING-与-WHERE-区别"><a href="#HAVING-与-WHERE-区别" class="headerlink" title="HAVING 与 WHERE 区别"></a>HAVING 与 WHERE 区别</h4><p>having子句与where都是设定条件筛选的语句，有相似之处也有区别。</p><p>having与where的区别:<br>having是在分组后对数据进行过滤<br>where是在分组前对数据进行过滤<br>having后面可以使用聚合函数<br>where后面不可以使用聚合</p><p>在查询过程中执行顺序：from&gt;where&gt;group（含聚合）&gt;having&gt;order&gt;select。</p><p>所以聚合语句(sum,min,max,avg,count)要比having子句优先执行，而where子句在查询过程中执行优先级别优先于聚合语句(sum,min,max,avg,count)。<br>where子句：<br>select sum(num) as rmb from order where id&gt;10<br>&#x2F;&#x2F;只有先查询出id大于10的记录才能进行聚合语句</p><p><a href="https://blog.csdn.net/ryan007liu/article/details/91441479">Mysql中having和where的区别</a></p><h3 id="查询过滤重复数据"><a href="#查询过滤重复数据" class="headerlink" title="查询过滤重复数据"></a>查询过滤重复数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCType</th></tr></thead><tbody><tr><td align="center">65535</td></tr><tr><td align="center">2</td></tr></tbody></table><p>说明: <code>DISTINCT</code> 关键词修饰的是语句整体，不能对单独字段修饰，并查询其他字段内容。<br>如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType, UserID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>如上语句意义为查询 DCType 且 UserID 同时不重复的列。</p><p>输出:</p><table><thead><tr><th align="center">DCType</th><th align="center">UserID</th></tr></thead><tbody><tr><td align="center">65535</td><td align="center">3000</td></tr><tr><td align="center">65535</td><td align="center">3001</td></tr><tr><td align="center">65535</td><td align="center">3002</td></tr><tr><td align="center">65535</td><td align="center">3003</td></tr><tr><td align="center">2</td><td align="center">9999</td></tr></tbody></table><h3 id="替换特定字段查询结果"><a href="#替换特定字段查询结果" class="headerlink" title="替换特定字段查询结果"></a>替换特定字段查询结果</h3><p>查询 <code>dcuser</code> 表中所有数据， <code>DCType</code> 字段等于 <code>65535</code> 的显示全功能调度员, 等于 <code>1</code> 的显示行车调度员, 其他取值显示原本的值, 该字段结果显示为<code>调度员类型</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> DCType <span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span> &quot;全功能调度员&quot; <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> &quot;行车调度员&quot; <span class="keyword">ELSE</span> UserID <span class="keyword">END</span> <span class="keyword">AS</span> &quot;调度员类型&quot; <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>分段看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CASE</span> DCType</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;全功能调度员&quot;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;行车调度员&quot;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">UserID</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span> &quot;调度员类型&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">调度员类型</th></tr></thead><tbody><tr><td align="center">全功能调度员</td></tr><tr><td align="center">14004</td></tr><tr><td align="center">行车调度员</td></tr></tbody></table><p>关于 <code>CASE... WHEN...</code> 更多用法见下面链接</p><p><a href="https://zhuanlan.zhihu.com/p/63333847">SQL之CASE WHEN用法详解</a><br><a href="https://www.gairuo.com/p/sql-select-case-when-then">SQL 查询：SELECT CASE 条件赋值</a><br><a href="https://blog.csdn.net/qq_31071543/article/details/79666427">关于case when复杂sql语句查询</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><a href="https://blog.csdn.net/lxf512666/article/details/52812146">SQL SELECT(复杂查询)之 自连接 &amp; 子查询 解析</a><br><a href="https://www.cnblogs.com/Hadley-pu/p/sql_selfconnect.html">sql中自连接的使用</a><br><a href="https://zhuanlan.zhihu.com/p/110891010">010-MySQL：自连接查询</a><br><a href="https://cloud.tencent.com/developer/article/1665642">算法工程师-SQL进阶：神奇的自连接与子查询</a></p><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>改变 dcuser 表名称到 dcuser_new</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> dcuser <span class="keyword">TO</span> dcuser_new;</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>删除整个 dcuser 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> dcuser;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p>删除表信息的方式有两种 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> dcuser;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>注 : truncate操作中的table可以省略，delete操作中的*可以省略</p><p>truncate、delete 清空表数据的区别 :<br>1&gt; truncate 是整体删除 (速度较快)，delete是逐条删除 (速度较慢)<br>2&gt; truncate 不写服务器 log，delete 写服务器 log，也就是 truncate 效率比 delete高的原因<br>3&gt; truncate 不激活trigger (触发器)，但是会重置Identity (标识列、自增字段)，相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的 ID数。而 delete 删除以后，identity 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件</p><p>参考资料:<br><a href="https://blog.csdn.net/chenshun123/article/details/79676446">MySQL 清空表(truncate)与删除表中数据(delete) 详解</a></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> runoob_tbl <span class="keyword">SET</span> runoob_title<span class="operator">=</span><span class="string">&#x27;学习 C++&#x27;</span> <span class="keyword">WHERE</span> runoob_id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="过程、函数"><a href="#过程、函数" class="headerlink" title="过程、函数"></a>过程、函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span>  Create10K<span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `Create10K`(<span class="keyword">IN</span> `for_time` <span class="type">INT</span>, <span class="keyword">IN</span> `type_int` <span class="type">INT</span>, <span class="keyword">IN</span> `info_text` <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> for_time <span class="operator">*</span> <span class="number">10000</span> DO</span><br><span class="line">    <span class="keyword">INSERT INTO</span> test_table(Type, Info) <span class="keyword">VALUES</span>(type_int, info_text);</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> Create10K(<span class="number">500</span>, <span class="number">1</span>, &quot;1&quot;);</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/sunada2005/p/3411873.html">常用SQL查询语句</a></p><h3 id="插入主键重复的数据"><a href="#插入主键重复的数据" class="headerlink" title="插入主键重复的数据"></a>插入主键重复的数据</h3><p>插入 <code>dcuser</code> 表中一条数据，如果主键重复则更新原数据的 <code>StationList</code> 字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> dcuser(UserID, Name, DCType, DepotID, StationList) <span class="keyword">VALUES</span>(<span class="number">14005</span>, <span class="string">&#x27;14005&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, &quot;1,2,3,4&quot;) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> StationList <span class="operator">=</span> &quot;1,2,3,4&quot;;</span><br></pre></td></tr></table></figure><h3 id="按天查询数量"><a href="#按天查询数量" class="headerlink" title="按天查询数量"></a>按天查询数量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP(date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d 0:0:0&#x27;</span>)), <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> sds_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL 8.0 Reference Manual</a><br><a href="https://dev.mysql.com/doc/mysql-tutorial-excerpt/8.0/en/examples.html">Chapter 7 Examples of Common Queries</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html">13.2.9 REPLACE Statement</a></p><p>TODO: 合并查询、分页查询、空值判断、Contact 拼接查询结果、REPLACE INTO、多条插入、事务、存储过程、视图、批量插入、my.ini 的配置项的研究、中间表查询<br><a href="https://www.cnblogs.com/zengen/archive/2011/08/10/2133423.html">SQL中的循环、for循环、游标</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用场景</title>
      <link href="/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>本文详细介绍了Git在多种开发场景中的实用技巧，包括如何通过<code>.gitignore</code>忽略临时文件、使用<code>git tag</code>标记版本、通过<code>git branch</code>管理分支开发、利用<code>git stash</code>临时保存未提交的代码、使用<code>git cherry-pick</code>将特定提交应用到其他分支，以及如何回退版本和搜索提交记录。文章还涵盖了<code>git diff</code>查看代码改动、<code>git clean</code>清理未跟踪文件等操作，帮助开发者高效管理代码版本，解决实际开发中的常见问题。</p><span id="more"></span><h2 id="场景：仓库中的临时文件"><a href="#场景：仓库中的临时文件" class="headerlink" title="场景：仓库中的临时文件"></a>场景：仓库中的临时文件</h2><p>我们编译出来了大量临时文件或很大的二进制文件，如 .o, .lib文件，这些文件不想上传。</p><p>提出问题： 想要在本文件夹中做版本控制，但需要忽略某些特定的文件</p><p>解决方案： 使用.gitignore文件来标记不想要进行版本控制的临时文件。</p><p>.gitignore 文件的用法:</p><p>.gitignore文件是由我们自己创建, 并默认放置在仓库的根目录。<br>Git 默认会忽略<code>.gitignore</code>中的文件名的大小写, 不过我们可以通过<code>git config core.ignorecase false</code>，来设置为不忽略大小写。</p><ol><li>文件内容格式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略.lib为后缀的文件</span></span><br><span class="line">*.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libmysql.lib 这个文件不忽略</span></span><br><span class="line">!libmysql.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的bin文件夹</span></span><br><span class="line">bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略根目录下的bin文件夹</span></span><br><span class="line">/bin/</span><br></pre></td></tr></table></figure><ol start="2"><li>已经被忽略的文件如何添加到暂存区: <code>git add -f &lt;filename&gt;</code></li><li>已经添加到暂存区中的文件如何忽略: <code>git rm --cached &lt;filename&gt;</code></li></ol><h2 id="场景-不小心提交了一个临时文件"><a href="#场景-不小心提交了一个临时文件" class="headerlink" title="场景: 不小心提交了一个临时文件"></a>场景: 不小心提交了一个临时文件</h2><p>我们对<strong>这个临时文件不想做版本跟踪</strong>，但是在<code>.gitignore</code>文件中添加该文件，这个文件仍然会被追踪。</p><p>提出问题: 如何忽略一个已经被追踪的文件?</p><p>解决方案：</p><ol><li><code>git rm filename</code>直接从仓库中删除该文件，并把该改动commit后，随后在<code>.gitignore</code>中添加该文件为忽略。</li><li><code>git update-index --assume-unchanged &lt;filename&gt;</code>, 这个操作不会删除该文件，也不用提交，但命令太长</li></ol><h2 id="场景-需要标记一个特定的版本"><a href="#场景-需要标记一个特定的版本" class="headerlink" title="场景: 需要标记一个特定的版本"></a>场景: 需要标记一个特定的版本</h2><p>当我们的代码进入到比较稳定，或者开发出了一个功能，需要标记一个commit来作为稳定版本的基准。</p><p>提出问题： 如何为commit添加标记和备注信息</p><p>解决方案： 使用<code>git tag</code>为版本打标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a vx.x.x -m &quot;message&quot;</span><br><span class="line">git push origin tags    ///&lt; 推送到远端</span><br></pre></td></tr></table></figure><h2 id="场景-修改远端标签名称"><a href="#场景-修改远端标签名称" class="headerlink" title="场景: 修改远端标签名称"></a>场景: 修改远端标签名称</h2><p>修改tag名 v1.0重命名v2.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag 新tag名称 旧tag名称</span><br><span class="line">git tag -d 旧tag名称</span><br><span class="line">git push origin :refs/tags/旧tag名称</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="场景：-开发一个功能"><a href="#场景：-开发一个功能" class="headerlink" title="场景： 开发一个功能"></a>场景： 开发一个功能</h2><p>某项功能可能开发时间较久，但又想把未完成的代码上传到远端版本库，来实现多台电脑同步。</p><p>例如：在开发随车通信需求时，在<code>linux</code>上编译<code>dis</code>，而我开发的环境在<code>windows</code>上, 当我在本地<code>window</code>开发的临时代码，想要放到<code>linux</code>机器上，这时我们需要分支来对代码的同步。</p><p>提出问题： 怎样才能在不影响远端仓库的代码的情况下，在远端备份开发过程代码？</p><p>解决方法： 使用 git branch<br>brunch 介绍:<br>brunch意味着你可以从主分支中，分叉出来一个分支来提交代码而不影响主分支的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/// 创建并切换到分支</span><br><span class="line">git checkout -b &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 做相应的提交，修改</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 把本地分支上传到远端</span><br><span class="line">git push origin &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 切换到另一台电脑上，拉去自己的分支</span><br><span class="line">git pull origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>合并分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop    ///&lt; 当前处于develop分支下</span><br><span class="line">git merge master   ///&lt; 把master的东西合入到当前分支，方便在自己开发的分支上处理冲突</span><br><span class="line">git checkout master    ///&lt; 切换到master分支</span><br><span class="line">git merge develop    ///&lt; 把develop合并到当前分支</span><br><span class="line">git branch -d future    ///&lt; 把合并过的分支删除</span><br></pre></td></tr></table></figure><h2 id="场景：临时切换分支"><a href="#场景：临时切换分支" class="headerlink" title="场景：临时切换分支"></a>场景：临时切换分支</h2><p>我们会遇到临时切换回主分支的情况。<br>例如： 当我在开发随车通信功能开发一半时，雷总让我在仓库中提交一个文档。如果我在自己的开发分支上上传该文档，那么在<code>master</code>分支上会没有这个文档，其他人也获取不到，所以只能切换回<code>master</code>分支上进行上传。</p><p>提出问题： 快速切换分支，做完提交，切换回开发分支时，工作区应跟切换分支前一样。</p><p>解决方案：<br>那么现在分为两种情况：</p><ol><li>我们工作区没有未被commit的文件，那么我们直接<code>git checkout &lt;branch_name&gt;</code>, 即可切换到相应的分支。</li><li>我们工作区有很多未被commit的代码，这时我们可以选择，把工作区内代码全部commit或者选择使用<code>git stash</code>来临时把未被commit的代码给存储起来， 在我们切换回开发分支时，再把临时存储的代码拿出来。</li></ol><p><code>stash</code>介绍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 把所有未commit的文件(工作区、暂存区里的文件)都放入一个临时的分支，使工作区可以切换分支</span><br><span class="line">git stash</span><br><span class="line">或</span><br><span class="line">git stash save &quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 切换到其他分支，并做一些提交, 并切换回自己的开发分支</span><br><span class="line">git checkout master</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line">/// 把临时存储的代码给拿出来，放入工作区(之前暂存区的文件在pop后的状态是到工作区)</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p><code>git stash --include-untracked</code>或<code>git stash -u</code> 来存储未被跟踪的文件</p><h2 id="场景：-某个commit，提交错分支了"><a href="#场景：-某个commit，提交错分支了" class="headerlink" title="场景： 某个commit，提交错分支了"></a>场景： 某个commit，提交错分支了</h2><p>开发过程中，突然出现了一个<code>BUG</code>需要立即修复，我们急着修复，把修复的代码放入了正在大改开发分支上。<br>提出问题： 我们需要怎样，把主分支上的<code>BUG</code>给修正过来<br>解决方案:</p><ol><li>切换到主分支，再次把刚才修改的文件，同样在主分支上进行修改，再次进行提交。</li><li>切换到主分支，使用<code>git cherry-pick &lt;SHA&gt;</code>把特定提交给放到主分支中。</li></ol><p>方案一存在修改的不一致，当后面需要合并分支时，需要处理冲突。<br>方案二快速提交，不用再次使用手动修改文件。</p><p><code>git cherry-pick &lt;SHA&gt;</code>用法示例：<br>该操作会把特定的commit给，放入当前所在的分支，并产生一个新的提交</p><p>之前分支的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">        \</span><br><span class="line">        e - f - g Feature</span><br></pre></td></tr></table></figure><p><code>cherry-pick</code>操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 切换到</span><br><span class="line">git checkout master</span><br><span class="line">/// 把提交f给提交到本分支</span><br><span class="line">git cherry-pick f</span><br></pre></td></tr></table></figure><p>操作后的分支情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">    \</span><br><span class="line">    e - f - g       Feature</span><br></pre></td></tr></table></figure><h2 id="场景-commit的信息输入错了"><a href="#场景-commit的信息输入错了" class="headerlink" title="场景: commit的信息输入错了"></a>场景: commit的信息输入错了</h2><p>提出问题： 怎么修改提交的commit信息</p><p>解决方案：</p><ol><li>修改最近一次提交的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">/// 进入到提交的文件里面，默认使用vim打开</span><br><span class="line">/// 修改好提交信息，保存后退出</span><br></pre></td></tr></table></figure><ol start="2"><li>如果想要修改之前的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3    ///&lt; 回退到HEAD前面第三个commit处</span><br><span class="line"></span><br><span class="line">/// 想要修改哪一个提交就把pick换成你想要的操作,edit</span><br><span class="line">git commit --amend</span><br><span class="line">/// 然后执行</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><ol start="3"><li>如果该 commit 已经 push 到远端</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line">git push --force-with-lease origin &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h2 id="场景-开发到一半，发现修改的思路有误"><a href="#场景-开发到一半，发现修改的思路有误" class="headerlink" title="场景: 开发到一半，发现修改的思路有误"></a>场景: 开发到一半，发现修改的思路有误</h2><p>我们从远端仓库拉去最新代码，修改过程中，发现修改错误了，想再从已经提交的代码上重新开始。</p><p>提出问题： 如何回退版本</p><p>解决方案：</p><ol><li>没有commit想要回退， 只是清除工作区修改的代码, 如何让当前已经修改过的代码恢复到HEAD的最新提交代码一致, 即清除工作区修改的代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 清除所有没有被暂存的改动</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">/// 清除该文件没有被暂存的改动</span><br><span class="line">git checkout filename</span><br></pre></td></tr></table></figure><ol start="2"><li>想要撤销上一个commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 删除工作区改动的代码，撤销最近一次的commit，撤销git add .</span><br><span class="line">/// 注意完成这个操作后，就恢复到了上一次的commit状态。</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">/// HEAD 指向 commit_id 指向的提交</span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--hard</code>换成<code>--soft</code>, 则会保留已经暂存和修改的文件</li><li><code>HEAD^</code>换成<code>HEAD~2</code>则可以回退两个commit</li></ul><h3 id="清除工作区的修改"><a href="#清除工作区的修改" class="headerlink" title="清除工作区的修改"></a>清除工作区的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_id&gt;    /// 返回到某个节点，不保留修改，已有的改动会丢失</span><br><span class="line">git reset --soft &lt;commit_id&gt;    /// 返回到某个节点，保留修改，已有的改动会保留，在未提交中， `git status` 或 `git diff` 查看</span><br><span class="line"></span><br><span class="line">git clean -df /// 返回到某个节点(未跟踪文件的删除)</span><br><span class="line">git clean -n  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -f  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -i  /// 显示将要删除的文件</span><br><span class="line">git clean -d  /// 递归删除目录及文件(未跟踪的文件)</span><br><span class="line">git clean -q  /// 仅显示错误，成功删除的文件不显示</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clean -nxdf /// 查看要删除的文件及目录，确认无误后再使用下面的命令进行删除</span><br><span class="line">git checkout . &amp;&amp; git clean -xdf</span><br></pre></td></tr></table></figure><h3 id="revert-和-reset"><a href="#revert-和-reset" class="headerlink" title="revert 和 reset"></a>revert 和 reset</h3><ol><li><p>revert<br>首先肯定的是 <code>revert</code>，<code>git revert commit_id</code> 能产生一个 与 <code>commit_id</code> 完全相反的提交，即 <code>commit_id</code> 里是添加， <code>revert</code> 提交里就是删除。<br><code>revert</code> 会生成一个新的提交记录，但不适合回退多个提交。</p></li><li><p>reset<br><code>reset</code> 的原理是把 <code>HEAD</code> 的指向，并删除回退后的版本之后的提交(被删除的提交可以通过 git reflog 查看)。<code>git reset --hard &lt;commit_id&gt;</code><br>但是由于是本地回退版本，所以在推送至远端时，需要使用 <code>git push -f origin master</code> 的命令象只覆盖远端分支。由于我们的远端仓库大部分都是对 <code>master</code> 分支进行保护不允许使用 <code>-f</code> 强制覆盖。我们可以先回退 <code>develop</code> 分支, 在 <code>develop</code> 分支上在创建一次提交(该提交已经领先于远端<code>master</code>分支), 再提交至远端 <code>develop</code> 分支后 <code>merge</code>。</p></li></ol><h2 id="场景：-想要找到某个特定业务的所有提交"><a href="#场景：-想要找到某个特定业务的所有提交" class="headerlink" title="场景： 想要找到某个特定业务的所有提交"></a>场景： 想要找到某个特定业务的所有提交</h2><p>假设我们的commit的信息都是采用模板来填写的，且已经有大量的<code>commit</code>时候，需要过滤检索一些特定提交信息的<code>commit</code>。</p><p>提出问题： 如何使用关键字搜索提交信息</p><p>解决方案：<br>使用git自带的文字搜索功能<code>git log --all --grep=&#39;TrainPosCall&#39;</code>, 搜索提交信息中带有<code>TrainPosCall</code>的<code>commit</code>。</p><h2 id="场景：-想要确认代码的改动"><a href="#场景：-想要确认代码的改动" class="headerlink" title="场景： 想要确认代码的改动"></a>场景： 想要确认代码的改动</h2><p>想要分步提交修改库函数的文件和修改业务逻辑的文件，需要确认每个文件的改动。</p><p>提出问题： 怎么查看已修改的代码对比之前的版本</p><p>解决方案：</p><ol><li>查看尚未缓存的改动：<code>git diff</code></li><li>查看已缓存的改动： <code>git diff --cached</code>, <code>git diff --staged</code></li><li>查看已缓存的与未缓存的所有改动：<code>git diff HEAD</code></li><li>显示摘要而非整个 diff： <code>git diff --stat</code></li><li>版本号与版本号之间的差别: <code>git diff &lt;SHA&gt; &lt;SHA&gt;</code></li></ol><h2 id="场景误删除分支"><a href="#场景误删除分支" class="headerlink" title="场景误删除分支"></a>场景误删除分支</h2><p>在误删除分支后，可以使用 <code>git reflog</code> 来查看分支的<code>commit id</code>并使用该<code>commit id</code>来创建一个新的分支<br><code>git branch recover-branch [commit id]</code></p><h2 id="场景-git-账户修改密码"><a href="#场景-git-账户修改密码" class="headerlink" title="场景: git 账户修改密码"></a>场景: git 账户修改密码</h2><p>操作<code>git</code>时, 出现错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: HTTP Basic: Access denied</span><br></pre></td></tr></table></figure><p>管理员权限输入以下命令后在命令行中操作<code>git</code>，重新输入用户名，密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/docs">git Reference</a></p><p><a href="https://git-scm.com/book/en/v2">Pro Git</a></p><p><a href="https://juejin.cn/post/6844903965625155597">Git新手教程-添加忽略文件(十)</a></p><p><a href="https://www.freecodecamp.org/news/git-cheat-sheet/">Git Cheat Sheet – 50 Git Commands You Should Know</a></p><p><a href="https://www.runoob.com/git/git-diff.html">git diff 命令</a></p><p><a href="https://www.atlassian.com/git/tutorials/saving-changes/git-diff">Git diff</a></p><p><a href="https://www.cnblogs.com/ibingshan/p/10783552.html">git clean 删除忽略文件 和 未被跟踪文件及文件夹</a></p><p><a href="https://git-scm.com/docs/git-branch">git-branch - List, create, or delete branches</a></p><p><a href="https://stackoverflow.com/questions/7124914/how-to-search-a-git-repository-by-commit-message/7124949#7124949">How to search a Git repository by commit message?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类型大小(32bit 与 64bit)</title>
      <link href="/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/"/>
      <url>/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/</url>
      
        <content type="html"><![CDATA[<p>本文详细对比了C++中常见数据类型在32位和64位系统下的内存占用情况，涵盖了标准类型（如<code>int</code>、<code>long</code>、<code>double</code>等）和自定义类型（如<code>UINT32</code>、<code>INT64</code>等）。通过代码示例和表格数据，展示了不同编译环境（VS2010、VS2019、Linux）下各类型的大小差异，特别是<code>size_t</code>、<code>pointer</code>、<code>long</code>等类型在32位和64位系统中的显著变化。文章为开发者提供了跨平台开发时类型选择的参考，帮助避免因类型大小不一致导致的问题。</p><span id="more"></span><p>C++ 类型大小 (32bit 与 64bit)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---标准类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int size:                &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long size:          &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size_t size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned char size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;signed char size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">signed</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pointer size:            &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---自定义类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SHORT(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT(int) size:                   &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;LONG(long) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT8(unsigned char) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT16(unsigned short) size:     &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT32(unsigned int) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT64(unsigned long long) size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT8(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT16(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT32(int) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT64(long long) size:           &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;FLOAT(float) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DOUBLE(double) size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CHAR(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BOOL(int) size:                  &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BYTE(unsigned char) size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;HANDLE(void*) size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>VS2010 32bit</th><th>VS2010 64bit</th><th>VS2019 32bit</th><th>VS2019 64bit</th><th>Linux 32bit</th><th>Linux 64bit</th><th>备注</th></tr></thead><tbody><tr><td>short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>unsigned short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>unsigned int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>unsigned long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>unsigned long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>size_t</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>signed char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>pointer</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>SHORT(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>LONG(long)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>UINT8(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>UINT16(unsigned short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>UINT32(unsigned int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>UINT64(unsigned long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>INT8(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>INT16(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT32(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>INT64(long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>FLOAT(float)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>DOUBLE(double)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>CHAR(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>BOOL(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>BYTE(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>HANDLE(void*)</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr></tbody></table><p>结论:</p><ol><li><code>size_t</code>、<code>pointer</code>、<code>long</code>、<code>unsigned long</code>、<code>HANDLE</code>这三种类型在<code>32bit</code>和<code>64bit</code>的大小有差别。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于对象的复制</title>
      <link href="/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>本文探讨了C++中对象复制的机制，重点介绍了拷贝构造函数和拷贝赋值运算符的使用。文章指出，虽然<code>memset</code>和<code>memcpy</code>在某些情况下可以用于初始化或复制对象，但它们仅适用于POD（Plain Old Data）类型，否则可能导致未定义行为。对于非POD类型，推荐使用构造函数、成员函数（如<code>clear()</code>）或STL算法（如<code>std::fill</code>、<code>std::copy</code>）来安全地初始化和复制对象。文章通过代码示例和外部参考链接，帮助读者理解如何正确管理对象的内存和复制行为。</p><span id="more"></span><p>通常我们使用对象内的拷贝构造函数和拷贝构造符来进行初始化和拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        i = other.i;</span><br><span class="line">        vec = other.vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝赋值符</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            i = other.i;</span><br><span class="line">            vec = other.vec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A foo;</span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">(foo)</span></span>; <span class="comment">///&lt; 在这里调用拷贝构造函数</span></span><br><span class="line">A bar2;</span><br><span class="line">bar2 = foo; <span class="comment">///&lt; 这里调用拷贝赋值符</span></span><br></pre></td></tr></table></figure><h2 id="关于memset"><a href="#关于memset" class="headerlink" title="关于memset"></a>关于memset</h2><p>首先说结论，不推荐使用<code>memset</code>对某个对象进行擦写内存。因为可能导致未定义行为。<br>具体可以查看<code>stackflow</code>上的这个问题 <a href="https://stackoverflow.com/questions/2481654/memset-for-initialization-in-c">memset for initialization in C++</a>和<a href="https://stackoverflow.com/questions/6421818/c-use-memset-or-a-struct-constructor-whats-the-fastest">Use memset or a struct constructor? What’s the fastest?</a></p><p>你可以使用构造函数进行初始化，也可以定义成员函数<code>clear()</code>， 或是使用<code>std::fill</code>, <code>std::fill_n</code>。<br>在使用函数<code>memset</code>时，有部分限定条件，只有目标对象为POD类型才可以使用。</p><p>简单来说就是，该对象如果没有继承，都是基础类型(如: <code>int</code>、<code>char</code>或其他<code>POD</code>类型), 没有包含如<code>std::array</code>, <code>std::vector</code>等STL容器, 该对象可以称为<code>POD</code>类型。如下面示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pod</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">12</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>POD</code>具体查看<a href="https://en.cppreference.com/w/cpp/named_req/PODType">C++ named requirements: PODType</a></p><h2 id="关于memcpy"><a href="#关于memcpy" class="headerlink" title="关于memcpy"></a>关于memcpy</h2><p>结论是，不推荐使用，同样除了你能确保该对象为<code>POD</code>类型，否则则会导致未定义现象。<br>可以使用拷贝构造函数或拷贝赋值符，或是<code>std::copy</code>或<code>std::copy_n</code>来代替<code>memcpy</code>;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《代码大全》</title>
      <link href="/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文总结了《代码大全》中关于变量命名、初始化和使用的核心建议。强调了变量命名应清晰、准确，避免使用模糊的缩写或隐含含义；变量初始化应靠近首次使用位置，缩短变量存活时间以提高代码可读性和维护性；同时，避免使用硬编码和具有相似含义的变量名。文章还提供了布尔变量命名的具体指导，建议使用肯定的语义和一致的缩写规则，确保代码易于理解和维护。</p><span id="more"></span><h2 id="强制类型转换的应用"><a href="#强制类型转换的应用" class="headerlink" title="强制类型转换的应用"></a>强制类型转换的应用</h2><h2 id="C-语言中-void-可以转换为任意指针"><a href="#C-语言中-void-可以转换为任意指针" class="headerlink" title="C 语言中 void* 可以转换为任意指针"></a>C 语言中 void* 可以转换为任意指针</h2><p>size_t 到 unsigned</p><p>变量初始化</p><ul><li>从未对变量赋值。它的值只是程序启动时变量所处内存区域的值</li><li>变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效</li><li>变量的一部分被赋值，而另一部分没有</li></ul><h2 id="在声明变量的时候初始化"><a href="#在声明变量的时候初始化" class="headerlink" title="在声明变量的时候初始化"></a>在声明变量的时候初始化</h2><h2 id="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"><a href="#理想情况下，在靠近第一次使用变量的位置声明和定义该变量" class="headerlink" title="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"></a>理想情况下，在靠近第一次使用变量的位置声明和定义该变量</h2><ul><li>在有可能的情况下使用<code>const</code>， 定义常量，入参。</li><li>特别注意计数器和累加器，在下一次使用时忘记重置其值。</li><li>在类的构造函数中，初始化该类的数据成员</li><li>检查是否需要重新初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尽可能缩短变量存活时间"><a href="#尽可能缩短变量存活时间" class="headerlink" title="尽可能缩短变量存活时间"></a>尽可能缩短变量存活时间</h2><p>短的变量存活时间减少了初始化错误的可能。</p><p>变量存活时间短还会使代码具有可读性。阅读者同一时间内需要阅读的代码越少，越容易理解代码。</p><p>当需要把一个大的函数，拆分成几个小程序，短的存活时间方便拆分。</p><p>在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。</p><p>直到变量即将被使用时再为其赋值。</p><p>把相关语句放在一起。把相关语句提取成单独的子程序。</p><p>开始时采用最严格的可见性，然后根据扩展变量的作用域。比如，把一个循环内的变量挪到循环外的难度要比反过来难度低，或把一个<code>private</code>转变为<code>public</code>的难度远比反过来难度低。</p><p>避免采用硬编码，宏定义总是好于硬编码。</p><ul><li><code>TITLE_BAR_COLOR</code> 比 <code>0xFFFFFF</code> 更能反应出所代表的信息</li><li>同时，也方便修改宏定义时，同时改变所有的颜色的RGB值</li></ul><h2 id="为变量指定单一用途"><a href="#为变量指定单一用途" class="headerlink" title="为变量指定单一用途"></a>为变量指定单一用途</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + temp) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - temp) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">temp = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discriminant = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + discriminant) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - discriminant) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">oldRoot = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = oldRoot;</span><br></pre></td></tr></table></figure><p>避免让代码具有隐含含义，把同一变量用于多个多个用途的另外一种方式是当变量代表不同事务时让其具有不同的取值集合。</p><ul><li>变量<code>count</code>的取值可能表示某个计数，除非他等于<code>-1</code>，在这种情况下表明有错误发生</li><li>变量<code>customerId</code>可能代表某个客户账号，除非他的取值大于50000，在这种情况下，你通过减去50000来得到过期账号。</li><li>变量<code>bytesWritten</code>可能表示写入输出文件的字节数，除非它的取值为负，在这种情况下他表示的是用于输出磁盘驱动器的号码。</li></ul><h2 id="变量名的注意事项"><a href="#变量名的注意事项" class="headerlink" title="变量名的注意事项"></a>变量名的注意事项</h2><p>糟糕的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x - xx;</span><br><span class="line">xxx = fido + <span class="built_in">SalesTax</span>(fido);</span><br><span class="line">x = x + <span class="built_in">LateFee</span>(x1, x) + xxx;</span><br><span class="line">x = x + <span class="built_in">Interest</span>(x1, x);</span><br></pre></td></tr></table></figure><p>良好的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">balance = balance - lastPayment;</span><br><span class="line">monthlyTotal = newPurchases + <span class="built_in">SalesTax</span>(newPurchases);</span><br><span class="line">balance = balance + <span class="built_in">LateFee</span>(customerID, balance) + monthlyTotal;</span><br><span class="line">balance = balance + <span class="built_in">Interest</span>(customerID, balance);</span><br></pre></td></tr></table></figure><p>为变量命名时最重要的考虑事项时，改名字要完全、准确地描述该变量所代表的事物<br>不包含晦涩的缩写，同时也没有歧义。<br>对于一个表示中国奥林匹克代表团成员数量的变量，你可能会使用<code>NumberOfPeopleOnTheChineseOlympicTeam</code><br>表示当前利率的变量最好为<code>rate</code>而不是<code>r</code>.</p><p>变量名太长: <code>numberOfPeopleOnTheChineseOlympicTeam</code>,<code>numberOfSeatsInTheStadium</code>, <code>maximumNumberOfPointsInModernOlympics</code><br>变量名太短: <code>n</code>, <code>np</code>, <code>ntm</code>, <code>ms</code>, <code>nsisd</code>, <code>m</code>, <code>max</code>, <code>min</code><br>变量名正好： <code>numTeamMembers</code>, <code>teamMemberCount</code>, <code>numSeatsInStadium</code>, <code>seatCount</code>, <code>teamPointsMax</code>, <code>pointSRecord</code></p><p>很多程序有表示计算机结果的变量：总额、平均值、最大值，等等。如果你要用类似于<code>Total</code>、<code>Sum</code>、<code>Average</code>、<code>Max</code>、<code>Min</code>、<code>Record</code>这样的限定词，那么请一定记住把限定词加到名字最后。<br>变量名中最重要的部分应该被放置在最前面，限定词在最后。<br>这样做会避免，<code>totalRevenue</code>和<code>revenueTotal</code>异议词语</p><p>为状态变量起一个比<code>flag</code>更好的名字。最好把标记<code>flag</code>看作状态变量，标记的名字中不应该含有<code>flag</code>，因为你从中丝毫看不出该标记是做什么的。<br>含义模糊的标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) ...</span><br><span class="line"><span class="keyword">if</span> (statusFlag &amp; <span class="number">0xF</span>) ...</span><br><span class="line"><span class="keyword">if</span> (printFlag == <span class="number">16</span>) ...</span><br><span class="line"><span class="keyword">if</span> (computeFlag == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure><p>更好的状态变量命名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dataReady) ...</span><br><span class="line"><span class="keyword">if</span> (characterType &amp; PRINTABLE_CHAR) ...</span><br><span class="line"><span class="keyword">if</span> (reportType == ReportType_Annual) ...</span><br><span class="line"><span class="keyword">if</span> (recalcNeeded == <span class="literal">false</span>) ...</span><br></pre></td></tr></table></figure><p>为布尔变量命名</p><ul><li><code>done</code> 用<code>done</code>表示某件事情已经发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>error</code> 用<code>error</code>表示有错误发生。在错误发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>found</code> 用<code>found</code>来表明某个值已经找到了。在没有找到设为<code>false</code>, 找到后设为<code>true</code>.</li><li><code>success</code>和<code>ok</code>, 操作失败时设为<code>false</code>, 操作成功后设为<code>true</code></li></ul><p>给布尔变量赋予隐含“真、假”含义的名字: <code>status</code>和<code>sourceFile</code>是很糟糕的布尔变量名。<br>应该把<code>status</code>替换为类似<code>error</code>或者<code>statusOK</code>这样的名称，把<code>sourceFile</code>替换为<code>sourceFileAvailable</code>、<code>sourceFileFound</code></p><p>使用肯定的布尔变量名，否定的布尔名如<code>notFound</code>、<code>notDone</code>以及<code>notSuccessful</code>比较难阅读。使用肯定的语义避免双重否定带来的阅读难度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnsiString strTmp;</span><br><span class="line">strTmp = edtAccount-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Account = strTmp;</span><br><span class="line">&#125;</span><br><span class="line">strTmp = edtPassword-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Password = strTmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩写的一般指导原则：</p><ul><li>使用标准的缩写(列在字典中的那些常见缩写)</li><li>去掉虚词<code>and</code>, <code>or</code>, <code>the</code>等</li><li>去掉无用的后缀<code>ing</code>, <code>end</code></li><li>确保不要改变变量的含义</li><li>反复使用上述技术，知道你把每个变量名的长度缩减到了8到20个字符，或者达到你所用的编程语言对变量名的限制字符数。</li></ul><h2 id="不要用每个单词中删除一个字符的方式来缩写"><a href="#不要用每个单词中删除一个字符的方式来缩写" class="headerlink" title="不要用每个单词中删除一个字符的方式来缩写"></a>不要用每个单词中删除一个字符的方式来缩写</h2><p>键入一个字符算不上是什么额外工作，而节省一个字符带来的便利却很难抵消由此而造成的可读性的损失。</p><h2 id="缩写要一致"><a href="#缩写要一致" class="headerlink" title="缩写要一致"></a>缩写要一致</h2><p>应该一直使用相同的缩写。要么全用<code>Num</code>，要么全用<code>No</code>，也不要有些地方使用全写<code>Number</code>, 同时在其他地方使用缩写<code>Num</code></p><h2 id="创建你能读出来的名字"><a href="#创建你能读出来的名字" class="headerlink" title="创建你能读出来的名字"></a>创建你能读出来的名字</h2><p>使用<code>xPos</code>而不是<code>xPstn</code>, 用<code>needsCompu</code>而不用<code>ndsCmptg</code>。这里可以使用电话沟通，如果你无法向他人读出你的代码，就请重新给变量起一个更清晰的名字。</p><h2 id="名字对于代码的读者的意义要比对作者更重要"><a href="#名字对于代码的读者的意义要比对作者更重要" class="headerlink" title="名字对于代码的读者的意义要比对作者更重要"></a>名字对于代码的读者的意义要比对作者更重要</h2><h2 id="避免使用令人误解的名字或缩写"><a href="#避免使用令人误解的名字或缩写" class="headerlink" title="避免使用令人误解的名字或缩写"></a>避免使用令人误解的名字或缩写</h2><p>要确保名字的含义是明确的</p><h2 id="避免使用具有相似含义的名字"><a href="#避免使用具有相似含义的名字" class="headerlink" title="避免使用具有相似含义的名字"></a>避免使用具有相似含义的名字</h2><p>如果你能够交换两个变量的名字而不会妨碍对程序的理解，那么你就需要为这两个变量重新命名了。</p><h2 id="避免在名字中使用数字"><a href="#避免在名字中使用数字" class="headerlink" title="避免在名字中使用数字"></a>避免在名字中使用数字</h2><p>如果名字中的数字真的非常重要，就请使用数组来代替一组单个的变量。如果数组不合适，那么数字就更不合适。</p><h2 id="避免在名字中拼错单词"><a href="#避免在名字中拼错单词" class="headerlink" title="避免在名字中拼错单词"></a>避免在名字中拼错单词</h2><h2 id="避免在名字中使用容易混淆的字符"><a href="#避免在名字中使用容易混淆的字符" class="headerlink" title="避免在名字中使用容易混淆的字符"></a>避免在名字中使用容易混淆的字符</h2><ul><li>数字<code>1</code>和小写的<code>l</code></li><li>数字<code>1</code>和大写的<code>L</code></li><li>数字<code>0</code>和大写的<code>O</code></li><li>数字<code>2</code>和小写的<code>z</code></li><li>数字<code>6</code>和大写的<code>G</code></li></ul><h2 id="避免浮点数的数量级相差巨大的数字之间的四则运算"><a href="#避免浮点数的数量级相差巨大的数字之间的四则运算" class="headerlink" title="避免浮点数的数量级相差巨大的数字之间的四则运算"></a>避免浮点数的数量级相差巨大的数字之间的四则运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">100000000.0</span> + <span class="number">0.1</span>;</span><br><span class="line">    std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免浮点数的等量比较"><a href="#避免浮点数的等量比较" class="headerlink" title="避免浮点数的等量比较"></a>避免浮点数的等量比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp += <span class="number">0.1</span>;</span><br><span class="line">        std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">IncreaseA</span>() || !<span class="built_in">IncreaseB</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为空语句创建一个DoNothing-预处理宏或者内联函数"><a href="#为空语句创建一个DoNothing-预处理宏或者内联函数" class="headerlink" title="为空语句创建一个DoNothing()预处理宏或者内联函数"></a>为空语句创建一个DoNothing()预处理宏或者内联函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(recordArray.<span class="built_in">Read</span>(index++) != recordArray.<span class="built_in">EmptyRecord</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DoNothing()</span></span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoNothing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华为C++编程规范摘录</title>
      <link href="/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/"/>
      <url>/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本文详细介绍了华为C++编程规范的核心内容，涵盖了代码风格、类型转换、内存管理、函数设计等多个方面。规范强调代码的可读性、安全性和可维护性，建议使用现代C++特性（如<code>auto</code>、<code>nullptr</code>、<code>override</code>等）提升代码质量，同时避免使用不安全的操作（如<code>reinterpret_cast</code>、<code>const_cast</code>等）。文章还提供了大量代码示例，帮助开发者理解并遵循规范，从而编写出高效、健壮的C++代码。</p><span id="more"></span><p><a href="https://www.bookstack.cn/read/openharmony-1.0-zh-cn/contribute-OpenHarmony-cpp-coding-style-guide.md">华为C++语言编程规范</a></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="3-7-1-if-循环语句必须使用大括号"><a href="#3-7-1-if-循环语句必须使用大括号" class="headerlink" title="3.7.1 if&#x2F;循环语句必须使用大括号"></a>3.7.1 if&#x2F;循环语句必须使用大括号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>();  <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-不用的代码段直接删除，不要注释掉"><a href="#4-4-3-不用的代码段直接删除，不要注释掉" class="headerlink" title="4.4.3 不用的代码段直接删除，不要注释掉"></a>4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入容易被忽略的缺陷。正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。使用版本控制来，记录代码。</p><h3 id="5-2-3-禁止通过声明的方式引用外部函数接口、变量"><a href="#5-2-3-禁止通过声明的方式引用外部函数接口、变量" class="headerlink" title="5.2.3 禁止通过声明的方式引用外部函数接口、变量"></a>5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。通过<code>extern</code>声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。同时这种隐式依赖，容易导致架构腐化。</p><h3 id="5-2-4-禁止在extern-C-中包含头文件"><a href="#5-2-4-禁止在extern-C-中包含头文件" class="headerlink" title="5.2.4 禁止在extern &quot;C&quot;中包含头文件"></a>5.2.4 禁止在<code>extern &quot;C&quot;</code>中包含头文件</h3><p>在<code>extern &quot;C&quot;</code> 中包含头文件，有可能导致<code>extern &quot;C&quot;</code>嵌套，部分编译器对<code>extern &quot;C&quot;</code>嵌套层次有限制，嵌套层次太多会编译错误。</p><h3 id="7-1-1-类的成员变量必须显式初始化"><a href="#7-1-1-类的成员变量必须显式初始化" class="headerlink" title="7.1.1 类的成员变量必须显式初始化"></a>7.1.1 类的成员变量必须显式初始化</h3><p>如果类有成员变量，没有定义构造函数，有没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。<br>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化</p><h3 id="7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。"><a href="#7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。" class="headerlink" title="7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。"></a>7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。</h3><p>可以将拷贝构造函数或者赋值操作符设置为<code>private</code>，并且不实现。<br>C++11以后可以使用关键字<code>delete</code>, 来删除该成员函数。</p><h3 id="7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"><a href="#7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止" class="headerlink" title="7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"></a>7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><h3 id="7-1-6-禁止在构造函数和析构函数中调用虚函数"><a href="#7-1-6-禁止在构造函数和析构函数中调用虚函数" class="headerlink" title="7.1.6 禁止在构造函数和析构函数中调用虚函数"></a>7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>在构造函数和析构函数中调用当前对象的虚函数，会导致未定义的行为。在C++中，一个基类一次只构造一个完整的对象。</p><h3 id="7-2-1-基类的析构函数应该声明为virtual"><a href="#7-2-1-基类的析构函数应该声明为virtual" class="headerlink" title="7.2.1 基类的析构函数应该声明为virtual"></a>7.2.1 基类的析构函数应该声明为<code>virtual</code></h3><p><code>虚析构函数</code></p><h3 id="7-2-2-禁止虚函数使用缺省参数值"><a href="#7-2-2-禁止虚函数使用缺省参数值" class="headerlink" title="7.2.2 禁止虚函数使用缺省参数值"></a>7.2.2 禁止虚函数使用缺省参数值</h3><p>在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着你最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。为了避免虚函数重载时，因参数声明不一致给使用者带来的困惑和由此导致的问题，规定所有虚函数均不允许声明缺省参数值。</p><h3 id="7-2-3-禁止重新定义继承而来的非虚函数"><a href="#7-2-3-禁止重新定义继承而来的非虚函数" class="headerlink" title="7.2.3 禁止重新定义继承而来的非虚函数"></a>7.2.3 禁止重新定义继承而来的非虚函数</h3><p>因为非虚函数无法实现动态绑定，只有虚函数才能实现动态绑定：只要操作基类的指针，即可获得正确的结果。</p><h3 id="8-1-1-避免函数过长，函数不超过50行-非空非注释"><a href="#8-1-1-避免函数过长，函数不超过50行-非空非注释" class="headerlink" title="8.1.1 避免函数过长，函数不超过50行(非空非注释)"></a>8.1.1 避免函数过长，函数不超过50行(非空非注释)</h3><p>函数应该可以一屏显示完(50行以内), 只做一件事情，而且把它做好。<br>过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步抽象。<br>例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。<br>即使一个长函数现在工作的很好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的BUG。建议将其拆分为更加简短并易于管理的若干函数，以便于他人阅读和修改代码。</p><h3 id="9-1-1-不允许使用宏来表示常量"><a href="#9-1-1-不允许使用宏来表示常量" class="headerlink" title="9.1.1 不允许使用宏来表示常量"></a>9.1.1 不允许使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名；宏没有类型检查，不安全；宏没有作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MSI_SDN_LEN 20  <span class="comment">///&lt; Bad</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>; <span class="comment">///&lt; Good</span></span><br><span class="line"><span class="comment">/// C++11以上的版本，可以使用`constexpr`</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="9-1-2不允许使用魔鬼数字"><a href="#9-1-2不允许使用魔鬼数字" class="headerlink" title="9.1.2不允许使用魔鬼数字"></a>9.1.2不允许使用魔鬼数字</h3><p>魔鬼数字是看不懂、难以理解的数字。<br>例如<code>type = 12</code>，看不懂，但改成<code>mouthsCount = yearsCount * 12</code>, 就容易理解。<br>数字<code>0</code>有时候也难以理解。<code>status = 0</code>并不能表达是什么状态。<br>解决途径： 对于局部使用的数字，可以增加注释说明，对于多处使用的数字，必须定义<code>const</code>常量，并通过符号命名自注释。<br>禁止出现下列情况： 没有通过符号来解释数字含义，如<code>const int ZERO = 0</code>，符号命名限制了其取值，如<code>const int XXX_TIMER_INTERVAL_300MS = 300</code>，<br>直接使用<code>XX_TIMER_INTERVAL_MS</code>来表示该常量是定时器的时间间隔。</p><h3 id="9-1-3-常量应该保证单一职责"><a href="#9-1-3-常量应该保证单一职责" class="headerlink" title="9.1.3 常量应该保证单一职责"></a>9.1.3 常量应该保证单一职责</h3><p>一个常量只用来标识一个特定功能，即一个常量不能有多种用途。</p><p>好的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> A_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Namespace1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Namespace2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-4-禁止用memcpy-s、memset-s初始化非POD对象"><a href="#9-1-4-禁止用memcpy-s、memset-s初始化非POD对象" class="headerlink" title="9.1.4 禁止用memcpy_s、memset_s初始化非POD对象"></a>9.1.4 禁止用<code>memcpy_s</code>、<code>memset_s</code>初始化非<code>POD</code>对象</h3><p><code>POD</code>类型主要包括<code>int</code>, <code>char</code>, <code>float</code>, <code>double</code>, <code>enumeration</code>, <code>void</code>, <code>pointer</code>等原始类ing以及聚合类型，不能使用封装和面向对象特性(如用户定义的构造&#x2F;赋值&#x2F;析构函数、基类、虚函数)<br>由于非<code>POD</code>类型比如非聚合类型的<code>class</code>对象，可能存在虚函数，内存布局不确定，跟编译器有关，滥用内存拷贝可能会导致严重的问题。<br>即使对聚合类型的<code>class</code>,使用直接的内存拷贝和比较，破坏了信息隐蔽和数据保护的作用，也不提倡使用<code>memcpy_s</code>、<code>memset_s</code></p><h3 id="9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量"><a href="#9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量" class="headerlink" title="9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量"></a>9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量</h3><p>含有变量自增或自减的表达式中，如果再引用该变量，其结果在C++标准中未明确定义。会产生未定义的结果。<br>注意，运算次序的问题不能使用括号来解决，因为之不是优先级的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i++; <span class="comment">///&lt; Bad: b[i]运算跟i++, 先后顺序并不明确。</span></span><br></pre></td></tr></table></figure><p>正确的写法是将自增或自减运算单独放一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i;</span><br><span class="line">i++;    <span class="comment">///&lt; Good， 单独一行</span></span><br></pre></td></tr></table></figure><p>函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Func</span>(i++, i)    <span class="comment">///&lt; Bad</span></span><br><span class="line"></span><br><span class="line">i++;    <span class="comment">///&lt; Good， 自增运算单独放一行</span></span><br><span class="line"><span class="built_in">Func</span>(i, i)</span><br></pre></td></tr></table></figure><h3 id="9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换"><a href="#9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换" class="headerlink" title="9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换"></a>9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换</h3><p>C++提供的类型转换操作比C风格更具有针对性，更易读，也更安全，C++提供的转换有：</p><ol><li><code>dynamic_cast</code>: 主要用于继承体系下行转换，<code>dynamic_cast</code>具有类型检查的功能，请做好基类和派生类的设计，避免使用<code>dynamec_cast</code>来进行转换。</li><li><code>static_cast</code>: 和C风格相似可做值的强制转换，或上行转换(把派生类的指着或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。</li><li><code>reinterpret_cast</code>: 用于转换不相关的类型。<code>reinterpret_cast</code>强制编译器将某个类型对象的内存重新解释成另一种类型，这是一种不安全的转换，建议尽可能少用<code>reinterpret_cast</code></li><li><code>const_cast</code>: 用于移除对象的<code>const</code>属性，使对象变得可修改，这样会破坏数据的不变性，建议尽可能少用。</li></ol><h3 id="9-5-1-不要保存std-string的c-str-返回的指针"><a href="#9-5-1-不要保存std-string的c-str-返回的指针" class="headerlink" title="9.5.1 不要保存std::string的c_str()返回的指针"></a>9.5.1 不要保存<code>std::string</code>的<code>c_str()</code>返回的指针</h3><p>C++标准中并未规定<code>c_str()</code>返回的指针持久有效，所以不要保存。</p><h3 id="9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const"><a href="#9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const" class="headerlink" title="9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用const"></a>9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用<code>const</code></h3><p>不变的值更易于理解&#x2F;跟踪和分析， 把<code>const</code>作为默认悬念，在编译时会对其进行检查，使代码更安全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-6-2-对于不会修改成员变量的成员函数请使用const修饰"><a href="#9-6-2-对于不会修改成员变量的成员函数请使用const修饰" class="headerlink" title="9.6.2 对于不会修改成员变量的成员函数请使用const修饰"></a>9.6.2 对于不会修改成员变量的成员函数请使用<code>const</code>修饰</h3><p>尽可能将成员函数声明为<code>const</code>。访问函数应该总是<code>const</code>。只要不修改数据成员的成员函数，都声明为<code>const</code>。对于虚函数，应当从设计意图上考虑继承链上的所有类是否需要在此虚函数中修改数据成员，而不是仅关注单个类的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">PrintValue</span><span class="params">()</span> <span class="type">const</span> <span class="comment">///&lt; 修饰成员函数, 不会修改成员变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="2-4-1-避免滥用typedef或者-define对基本类型起别名"><a href="#2-4-1-避免滥用typedef或者-define对基本类型起别名" class="headerlink" title="2.4.1 避免滥用typedef或者#define对基本类型起别名"></a>2.4.1 避免滥用<code>typedef</code>或者<code>#define</code>对基本类型起别名</h3><p>除有明确的必要性，否则不要用<code>typedef</code>、<code>#define</code>对基本数据类型进行重定义。优先使用<code>&lt;cstdint&gt;</code>头文件中的基本。</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有、无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有、无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有、无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有、无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有、无符号整数类型</td></tr></tbody></table><h3 id="3-1-1-行宽不超过120个字符"><a href="#3-1-1-行宽不超过120个字符" class="headerlink" title="3.1.1 行宽不超过120个字符"></a>3.1.1 行宽不超过120个字符</h3><h3 id="3-9-1-表达式换行要保持换行的一致性，运算符放行末"><a href="#3-9-1-表达式换行要保持换行的一致性，运算符放行末" class="headerlink" title="3.9.1 表达式换行要保持换行的一致性，运算符放行末"></a>3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">IsCorrect</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsValid</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsSomething</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-1-合理安排空行，保持代码紧凑"><a href="#3-14-1-合理安排空行，保持代码紧凑" class="headerlink" title="3.14.1 合理安排空行，保持代码紧凑"></a>3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。</p><ul><li>根据上下内容的相关程度，合理安排空行</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不适用连续三个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但<code>namespace</code>的大括号内不做要求</li></ul><h3 id="5-2-1-尽量避免使用前置声明"><a href="#5-2-1-尽量避免使用前置声明" class="headerlink" title="5.2.1 尽量避免使用前置声明"></a>5.2.1 尽量避免使用前置声明</h3><h3 id="6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"><a href="#6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰" class="headerlink" title="6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"></a>6.1.1 对于<code>cpp</code>文件中不需要导出的变量，常量或者函数，请使用匿名<code>namespace</code>封装或者用<code>static</code>修饰</h3><p>更加推荐使用匿名<code>namespace</code>：</p><ol><li><code>static</code>在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数， 静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li><code>static</code>只能保证变量，常量和函数的文件作用域，但是<code>namespace</code>还可以封装类型等。</li><li>统一<code>namespace</code>来处理C++的作用域，而不需要同时使用<code>static</code>和<code>namespace</code>来管理</li><li><code>static</code>修饰的函数不能用来实例化模板，而匿名<code>namespace</code>可以</li></ol><p>注意： 不要<code>.h</code>中使用匿名<code>namespace</code>或者<code>static</code></p><h3 id="6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"><a href="#6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数" class="headerlink" title="6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"></a>6.2.1 优先使用命名空间来管理全局函数，如果和某个<code>class</code>有直接关系的，可以使用静态成员函数</h3><p>非成员函数放在名字控件内可避免污染全局作用域，也不要用类+静态成员方法来简单管理全局函数。如果某个全局函数和某个类有紧密联系，那么可以作为类的静态成员函数。<br>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><h3 id="6-4-1-尽量避免使用全局变量，考虑使用单例模式"><a href="#6-4-1-尽量避免使用全局变量，考虑使用单例模式" class="headerlink" title="6.4.1 尽量避免使用全局变量，考虑使用单例模式"></a>6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><h3 id="8-3-1-函数参数使用引用代替指针"><a href="#8-3-1-函数参数使用引用代替指针" class="headerlink" title="8.3.1 函数参数使用引用代替指针"></a>8.3.1 函数参数使用引用代替指针</h3><p>引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。</p><h3 id="8-3-2-使用强类型参数，避免使用void"><a href="#8-3-2-使用强类型参数，避免使用void" class="headerlink" title="8.3.2 使用强类型参数，避免使用void*"></a>8.3.2 使用强类型参数，避免使用void*</h3><p>一般认为<code>C/C++</code>是强类型语言，既然我们使用的是强类型语言，就应该保持这样的风格。好处是尽量让编译器在编译阶段就检查出类型不匹配的问题。</p><h3 id="8-3-3-函数的参数个数不超过5个"><a href="#8-3-3-函数的参数个数不超过5个" class="headerlink" title="8.3.3 函数的参数个数不超过5个"></a>8.3.3 函数的参数个数不超过5个</h3><p>函数的参数过多，会使得该函数易于受外部变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。<br>如果超过可以考虑</p><ul><li>看能否拆分函数</li><li>看能否将相关参数合在一起，定义结构体</li></ul><h3 id="9-1-1-一组相关的整型变量应定义未枚举。"><a href="#9-1-1-一组相关的整型变量应定义未枚举。" class="headerlink" title="9.1.1 一组相关的整型变量应定义未枚举。"></a>9.1.1 一组相关的整型变量应定义未枚举。</h3><p>枚举比<code>#define</code>或<code>const int</code>更安全。编译器会检查参数值是否位于枚举取值范围内，避免错误发生。</p><h3 id="9-1-2-变量使用时才声明并初始化"><a href="#9-1-2-变量使用时才声明并初始化" class="headerlink" title="9.1.2 变量使用时才声明并初始化"></a>9.1.2 变量使用时才声明并初始化</h3><p>变量在使用前未赋初值，是常见的低级编程错误。使用前才声明变量并初始化，非常方便地避免了此类低级错误。<br>在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：</p><ul><li>程序难以理解与维护： 变量定义与使用分离</li><li>变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值（0）来初始化。如果变量在被赋予有效值以前使用，还会导致错误。</li></ul><p>遵循变量作用域最小化原则与就近声明原则，使得代码更容易阅读，方便了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string name;   <span class="comment">///&lt; Bad</span></span><br><span class="line">name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>)</span></span>;   <span class="comment">///&lt; Good</span></span><br></pre></td></tr></table></figure><h3 id="9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"><a href="#9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则" class="headerlink" title="9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"></a>9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则</h3><p>当变量与常量进行比较时，如果常量放左边， 如<code>if(MAX == v)</code>不符合阅读习惯，而<code>if(MAX &gt; v)</code>更难以理解，应当按人的正常阅读、表达习惯，将常量放右边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value &lt; MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有特殊情况， 如： <code>if(MIN &lt; value &amp;&amp; value &lt; MAX)</code>用来描述区间时，前半段是常量在左的。<br>不用担心将<code>==</code>误写成<code>=</code>, 因为<code>if(value = MAX)</code>会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><h3 id="9-2-2-使用括号明确操作符的优先级"><a href="#9-2-2-使用括号明确操作符的优先级" class="headerlink" title="9.2.2 使用括号明确操作符的优先级"></a>9.2.2 使用括号明确操作符的优先级</h3><p>使用括号明确操作符的优先级，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b + ; <span class="comment">///&lt; 操作符相同,可以不加括号</span></span><br><span class="line">x = <span class="number">1</span> &lt;&lt; (<span class="number">2</span> + <span class="number">3</span>);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br><span class="line">x = (a == b) ? a : (a - b);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br></pre></td></tr></table></figure><h3 id="9-3-1-避免使用dynamic-cast"><a href="#9-3-1-避免使用dynamic-cast" class="headerlink" title="9.3.1 避免使用dynamic_cast"></a>9.3.1 避免使用<code>dynamic_cast</code></h3><ol><li><code>dynamic_cast</code>依赖于C++的<code>RTTI</code>, 让程序员在运行时识别C++类对象的类型</li><li><code>dynamic_cast</code>的出现一般说明我们的基类和派生类设计出现了问题，派生类破坏了基类的七月，不得不通过</li><li><code>dynamic_cast</code>转换到子类进行特殊处理，这个时候更希望来改善类的设计，而不是通过<code>dynamic_cast</code>来解决问题</li></ol><h3 id="9-3-2-避免使用reinterpret-cast"><a href="#9-3-2-避免使用reinterpret-cast" class="headerlink" title="9.3.2 避免使用reinterpret_cast"></a>9.3.2 避免使用<code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code>用于转换不相关类型。尝试用<code>reinterpret_cast</code>将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。</p><h3 id="9-3-3-避免使用const-cast"><a href="#9-3-3-避免使用const-cast" class="headerlink" title="9.3.3 避免使用const_cast"></a>9.3.3 避免使用<code>const_cast</code></h3><p><code>cosnt_cast</code>用于移除对象的<code>const</code>和<code>volatile</code>性质。<br>使用<code>const_cast</code>转换后的指针或者引用来修改<code>const</code>对象，行为是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不好的例子</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i);</span><br><span class="line">*p = <span class="number">2048</span>;  <span class="comment">///&lt; 未定义行为</span></span><br></pre></td></tr></table></figure><h3 id="9-4-1-使用RAII特性来帮助跟踪动态分配"><a href="#9-4-1-使用RAII特性来帮助跟踪动态分配" class="headerlink" title="9.4.1 使用RAII特性来帮助跟踪动态分配"></a>9.4.1 使用<code>RAII</code>特性来帮助跟踪动态分配</h3><p><code>RAII</code>是”资源获取就是初始化”的简写(Resource Acquisition Is Initialization), 是一种利用对象生命周期来控制程序资源(如内存、文件句柄、网络连接、互斥量等等)的简单技术。<br><code>RAII</code>的一般做法是这样的： 在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内之中有效，最后在对象析构的时候释放资源，这种做法有两大好处:</p><ul><li>我们不需要显式地释放资源</li><li>对象所需的资源在其生命期内始终有效。这样，就不必检查资源有效性问题，可以简化逻辑、提高效率。</li></ul><h3 id="9-5-1-使用std-string代替char"><a href="#9-5-1-使用std-string代替char" class="headerlink" title="9.5.1 使用std::string代替char*"></a>9.5.1 使用<code>std::string</code>代替<code>char*</code></h3><p>说明: 使用<code>string</code>代替<code>char*</code>有很多优势，比如:</p><ol><li>不用考虑结尾的<code>&#39;\0&#39;</code></li><li>可以直接使用<code>+</code>, <code>=</code>, <code>==</code>等运算符以及其他字符串操作函数</li><li>不需要考虑内存分配操作，避免了显式的<code>new</code>、<code>delete</code>, 以及由此导致的错误</li></ol><p>需要注意的是</p><h3 id="9-5-2-使用新的标准头文件"><a href="#9-5-2-使用新的标准头文件" class="headerlink" title="9.5.2 使用新的标准头文件"></a>9.5.2 使用新的标准头文件</h3><p>使用C++的标准头文件时，请使用<code>&lt;cstdlib&gt;</code>这样的，而不是<code>&lt;stdlib.h&gt;</code></p><h3 id="9-6-1-初始化后不会再修改的成员变量定义为const"><a href="#9-6-1-初始化后不会再修改的成员变量定义为const" class="headerlink" title="9.6.1 初始化后不会再修改的成员变量定义为const"></a>9.6.1 初始化后不会再修改的成员变量定义为<code>const</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> length): <span class="built_in">dataLength_</span>(length)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dataLength_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现代C-since-C-11"><a href="#现代C-since-C-11" class="headerlink" title="现代C++(since C++11)"></a>现代C++(since C++11)</h2><h2 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h2><h3 id="10-1-1-在重写虚函数时请使用override或final关键字"><a href="#10-1-1-在重写虚函数时请使用override或final关键字" class="headerlink" title="10.1.1 在重写虚函数时请使用override或final关键字"></a>10.1.1 在重写虚函数时请使用<code>override</code>或<code>final</code>关键字</h3><p><code>override</code>和<code>final</code>关键字都能保证函数是虚函数，且重写了基类的虚函数。如果子类函数与基类函数圆形不一致，则产生编译错误。<code>final</code>还保证u函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>还保证虚函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现，也可以避免有多个子类时，重写虚函数的修改遗漏。</p><h3 id="10-1-2-使用delete关键字删除函数"><a href="#10-1-2-使用delete关键字删除函数" class="headerlink" title="10.1.2 使用delete关键字删除函数"></a>10.1.2 使用<code>delete</code>关键字删除函数</h3><p>相比于将类成员函数声明为<code>private</code>但不实现， <code>delete</code>关键字更明确，且适用范围更广。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    <span class="comment">///&lt; 只看头文件不知道拷贝构造函数是否被删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 明确删除拷贝赋值符</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，<code>delete</code>关键字还支持删除非成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> Process&lt;<span class="type">void</span>&gt; </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="10-1-3-使用nullptr-而不是NULL或0"><a href="#10-1-3-使用nullptr-而不是NULL或0" class="headerlink" title="10.1.3 使用nullptr, 而不是NULL或0"></a>10.1.3 使用<code>nullptr</code>, 而不是<code>NULL</code>或<code>0</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;   <span class="comment">///&lt; 错误: void* 不能自动转为 char*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span>(C::pmf)() = &amp;C::Func;</span><br><span class="line"><span class="keyword">if</span>(pmf == <span class="literal">NULL</span>) &#123;&#125; <span class="comment">///&lt; 错误： void* 不能自动转换为指向成员函数的指针</span></span><br></pre></td></tr></table></figure><p>如果把<code>NULL</code>定义为<code>0</code>, 或者在需要空指针的地方直接使用<code>0</code>。这样引入了另外的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 无法判断返回的是整数还是空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载也会出现重载的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用F(int)， 而不是F(int*)</span></span><br></pre></td></tr></table></figure><p>另外<code>sizeof(NULL) == sizeof(void*)</code>并不总是成立的。</p><p><code>nullptr</code>的又是不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。<br><code>nullptr</code>是<code>std::nullptr_t</code>类型， 而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 调用F(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 正确的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h2><h3 id="10-1-1-合理使用auto"><a href="#10-1-1-合理使用auto" class="headerlink" title="10.1.1 合理使用auto"></a>10.1.1 合理使用<code>auto</code></h3><ul><li><code>auto</code>可以避免编写冗长、重复的类型名，也可以保证定义变量时初始化</li><li><code>auto</code>类型推导规则复杂，需要仔细理解</li><li>如果能够使代码更清晰，继续使用明确的类型，且旨在局部变量使用<code>auto</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 避免冗长的类型名</span></span><br><span class="line">std::map&lt;std::string, std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 保证初始化</span></span><br><span class="line"><span class="type">int</span> x;  <span class="comment">///&lt; 编译正确，没有初始化</span></span><br><span class="line"><span class="keyword">auto</span> x; <span class="comment">///&lt; 编译失败，没有初始化</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ POD的介绍</title>
      <link href="/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>本文详细介绍了C++中的POD（Plain Old Data）类型，解释了其定义、特性以及在编程中的特殊用途。POD类型包括标量类型、POD数组和符合特定条件的类类型，具有内存布局明确、生命周期简单等特点。文章还探讨了POD类型在内存操作（如<code>memcpy</code>）、<code>goto</code>语句和类型转换中的优势，并提供了相关标准定义的参考链接，帮助读者深入理解POD类型的重要性和应用场景。</p><span id="more"></span><h2 id="POD-plain-old-data-介绍"><a href="#POD-plain-old-data-介绍" class="headerlink" title="POD(plain old data)介绍"></a><code>POD</code>(<code>plain old data</code>)介绍</h2><h3 id="简旧类型-plain-old-data"><a href="#简旧类型-plain-old-data" class="headerlink" title="简旧类型(plain old data)"></a>简旧类型(<code>plain old data</code>)</h3><ul><li>一个标量类型(<code>scalar type</code>)</li><li>简旧类型(POD)数组</li><li>一个符合以下要求的<code>class</code>类型(<code>class</code> or <code>struct</code> or <code>union</code>)<ul><li>C++11以前:<ul><li>是一个聚合类型(<code>aggregate type</code>)</li><li>所有非静态成员都是简旧类型(<code>POD</code>)</li><li>没有成员是引用类型</li><li>没有用户定义的拷贝构造函数</li><li>没有用户定义的析构函数</li></ul></li><li>C++11以后<ul><li>是一个平凡类型(<code>trivial type</code>)</li><li>是一个标准布局类型</li><li>所有非静态成员是简旧类型(<code>POD</code>)</li></ul></li></ul></li></ul><h3 id="POD类型特别在哪里？"><a href="#POD类型特别在哪里？" class="headerlink" title="POD类型特别在哪里？"></a>POD类型特别在哪里？</h3><p><a href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special">What are Aggregates and PODs and how&#x2F;why are they special?</a></p><p>像<code>POD-classes</code>，<code>PD-unions</code>, <code>scalar type</code>和<code>数组</code>这样的类型被统一的叫做<code>POD-types</code>， <code>PODs</code>在很多地方都非常特别。下面一些例子。</p><ul><li><code>POD-classes</code>最接近C语言形式的结构体。不同的是，<code>PODs</code>可以有成员函数和任意静态成员，但他们两者都不能改变对象的内存排布。所以假如你想要写一个或多或少可移植型的可以被C语言甚至<code>.NET</code>使用的动态库，你应该尝试你所有导出的函数和返回值都是<code>POD-types</code>.</li><li>一个<code>non-POD</code>类类型对象的生存周期开始于当构造函数结束，结束于当析构函数结束。对于<code>POD</code>类型类，生命周期开始于内存空间被对象占用，结束于内存空间被释放或者被重用后。</li><li>对于<code>POD</code>类型的对象， 标准保证它当你使用<code>memcpy</code>对你对象中内容转化为<code>char</code>或<code>unsigned</code>数组时，然后<code>memcpy</code>这个内容回到你的对象内，这个对象将持有原始的值。请注意：对于<code>non-POD</code>类型对象没有这样的保证。下面的例子假设类型<code>T</code>是<code>POD</code>类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N sizeof(T)</span></span><br><span class="line"><span class="type">char</span> buf[N];</span><br><span class="line">T obj;  <span class="comment">///&lt; obj initialized to its original value</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;obj, N);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;obj, buf, N);</span><br><span class="line"><span class="comment">/// 保持它的原始值</span></span><br></pre></td></tr></table></figure><ul><li><code>goto</code>语句. 你可能知道，通过goto从一个一些变量还没有在这个作用域中定义的点跳转到一个已经定义的点是非法的（编译器会报错）。这个限制应用在只有当这个变量是一个<code>non-POD</code>类型。看下面例子中<code>f()</code>是语义错误, <code>g()</code>则符合语义。注意，微软编译器在这条规则上特别松散，它在这两个情况下只是抛出一个警告。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">NonPOD</span> &#123;<span class="built_in">NonPOD</span>()&#123;&#125;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  NonPOD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">POD</span>&#123;<span class="type">int</span> i; <span class="type">char</span> c;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  POD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它保证了在<code>POD</code>对象的开始处没有内存填充位。其他情况下，假如一个<code>POD-class： A</code>使一个类型<code>T</code>的第一个成员，你可以安全的使用<code>reinterpret_cast</code>从<code>A*</code>到<code>T*</code>然后获取指向第一个成员的指针，反之亦然。</li></ul><h3 id="补充定义"><a href="#补充定义" class="headerlink" title="补充定义"></a>补充定义</h3><h4 id="标量类型-scalar-type"><a href="#标量类型-scalar-type" class="headerlink" title="标量类型(scalar type)"></a>标量类型(<code>scalar type</code>)</h4><p><code>scalar type</code>是一个不是数组类型或<code>class</code>类型的(可能<code>const</code>或<code>volatile</code>限定的[^2])<code>object</code>类型.<br>英文原文[^1]</p><blockquote><p>scalar types are (possibly cv-qualified) object types that are not array types or class types</p></blockquote><h4 id="聚合类型-aggregate-type"><a href="#聚合类型-aggregate-type" class="headerlink" title="聚合类型(aggregate type)"></a>聚合类型(<code>aggregate type</code>)</h4><p>首先介绍一下<code>聚合类型</code>:<br>聚合类型是以下类型的其中一种[^3]:</p><ul><li>数组类型</li><li><code>class</code>类型(典型的例子, <code>struct</code>, <code>union</code>):<ul><li>没有<code>private</code>和<code>protected</code>非静态数据成员(到C++11)</li><li>没有用户定义的构造函数(显式的默认或删除的构造函数) (C++11起, 到C++17)</li><li>没有用户提供的继承的或显式的构造函数(显式的默认或删除的构造函数)(C++17起，到C++20)</li><li>没有用户定义的或继承的构造函数(C++20起)</li><li>没有基类(C++17之前)， 没有<code>virtual</code>,<code>private</code>,<code>protected</code>基类(C++17起)</li><li>没有虚成员函数</li><li>没有默认成员的初始化器(从C++11到C++14)</li></ul></li></ul><h4 id="平凡类型-TrivialType"><a href="#平凡类型-TrivialType" class="headerlink" title="平凡类型 (TrivialType)"></a>平凡类型 (<code>TrivialType</code>)</h4><p>要求[^4]:</p><ul><li>可平凡复制(<code>TrivialCopyable</code>)</li><li>若该类型是类类型或其数组，则该类拥有一个或多个合格的默认构造函数，均为平凡的</li></ul><h4 id="可平凡可复制-Trivially-Copyable"><a href="#可平凡可复制-Trivially-Copyable" class="headerlink" title="可平凡可复制(Trivially Copyable)"></a>可平凡可复制(<code>Trivially Copyable</code>)</h4><p>下面列举的类型称作平凡可复制类型[^5]:</p><ul><li>标量类型</li><li>平凡可复制的类<ul><li>至少有一个拷贝构造函数，移动构造函数，拷贝赋值符是符合要求的</li><li>每个合格的拷贝构造函数(假如有的话)是平凡的</li><li>每个合格的移动构造函数(假如有的话)是平凡的</li><li>每个合格的拷贝赋值符(假如有的话)是平凡的</li><li>每个合格的移动赋值符(假如有的话)是平凡的</li><li>有一个平凡的没有被删除的析构函数</li></ul></li><li>可平凡复制的数组类型<br>这意味着一个平凡可拷贝的<code>class</code>没有虚函数和虚基类函数。</li></ul><h3 id="参考文献和扩展阅读"><a href="#参考文献和扩展阅读" class="headerlink" title="参考文献和扩展阅读"></a>参考文献和扩展阅读</h3><p>[^1]:<a href="https://stackoverflow.com/questions/14821936/what-is-a-scalar-object-in-c">What is a scalar Object in C++?</a></p><p>[^2]:<a href="https://stackoverflow.com/questions/15413037/what-does-cv-unqualified-mean-in-c">What does “cv-unqualified” mean in C++?</a>, <a href="https://en.cppreference.com/w/cpp/language/cv">cv (const and volatile) type qualifiers</a></p><p>[^3]:<a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">C++ standard: aggregate type</a></p><p>[^4]:<a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">C++ standard: C++ named requirements: TrivialType</a></p><p>[^5]: <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">C++ standard: C++ named requirements: TriviallyCopyable</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UML语法简介</title>
      <link href="/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>本文详细介绍了UML（统一建模语言）中的几种核心关系：泛化关系、实现关系、聚合关系、组合关系、关联关系和依赖关系。通过清晰的图示和实例，文章解释了每种关系的定义、表示方法及其在面向对象设计中的应用场景。例如，泛化关系表示类的继承，组合关系表示强依赖的整体与部分关系，而依赖关系则描述对象间的临时性调用关系。本文为开发者提供了UML关系的全面指南，帮助其在软件设计中更好地理解和应用这些概念。</p><span id="more"></span><h2 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example.png" alt="generalize_example"></p><p>eg：猫是一种动物；猫与动物之间为泛化关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example(2).png" alt="generalize_example(2)"></p><h2 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h2><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”猫”和”鸟”运动方式不同，它们的运动方式一个为走一个为飞，必须要在派生类”动物”中提供具体实现，那么”猫”和”鸟”对于基类动物来说为实现关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/realize_example.png" alt="realize_example"></p><h2 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h2><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/aggregation_example.png" alt="aggregation_example"></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，<strong>整体和部分不是强依赖的</strong>，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h2 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/composition_example.png" alt="composition_example"></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种<strong>强依赖的特殊聚合关系</strong>，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h2 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h2><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/association_example.png" alt="association_example"></p><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h2 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h2><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/dependency_example.png" alt="dependency_example"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(2)</title>
      <link href="/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
      <url>/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
      
        <content type="html"><![CDATA[<p>本文深入探讨了《Effective Modern C++》中的关键概念，重点分析了C++11&#x2F;14中的初始化方式、特种成员函数生成机制以及<code>auto</code>和<code>decltype</code>的类型推导规则。文章详细介绍了大括号初始化的优势与陷阱，强调了其在阻止隐式窄化转换和避免解析歧义中的作用。同时，文章还解析了移动操作、复制操作和析构函数的生成条件，帮助读者理解如何正确管理资源。最后，文章对比了<code>auto</code>和模板类型推导的异同，并总结了<code>decltype</code>的行为特点，为现代C++编程提供了实用指导。</p><span id="more"></span><h1 id="《Effective-Modern-C-》读书笔记-2"><a href="#《Effective-Modern-C-》读书笔记-2" class="headerlink" title="《Effective Modern C++》读书笔记(2)"></a>《Effective Modern C++》读书笔记(2)</h1><ol><li><p>裸指针在声明中并没有指出，裸指针指涉到的是单个对象还是一个数组。</p></li><li><p>裸指针在声明中也没有提示在使用完指涉到的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象。</p></li><li><p>即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用<code>delete</code>运算符，还是有其他用途。</p></li><li><p>即使知道了使用<code>delete</code>运算符，还是会发生到底应该用的那个对象形式（<code>delete</code>）还是数组形式（<code>delete[]</code>）。</p></li><li><p>即启用够确信，指针拥有其指涉对象，并且也确知应该如何析构，要保证析构在所有代码路径上都仅执行一次（包括那些异常导致的路径）仍然困难重重。只要少在一条路径上执行，就会导致资源泄露。而如果析构在一条路径上执行了多次，则会导致未定义行为。</p></li><li><p>没有什么正规的方式能检测出指针是否空悬，也就是说，它指涉的内存是否已经不再持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然指涉到它，就会产生空悬指针。</p></li></ol><p>在创建对象时注意区分<code>()</code>和<code>&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;  <span class="comment">///&lt; 调用默认构造函数</span></span><br><span class="line">Widget w2 = w1; <span class="comment">///&lt; 调用复制构造函数</span></span><br><span class="line">w1 = w2;  <span class="comment">///&lt; 赋值运算符</span></span><br></pre></td></tr></table></figure><p>大括号可以用来为非静态成员指定默认初始化值，却不能使用小括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 不可行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不可复制的对象可以采用大括号和小括号来进行初始化，却不能使用<code>=</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">///&lt; 不可行</span></span><br></pre></td></tr></table></figure><p>大括号适用所有场合。<br>大括号初始化有一项新特性，就是它禁止内建型别之间进行隐式窄化型别转换。而采用小括号和<code>=</code>的初始化则不会进行窄化型别转换检查，因为如果那样的化就会破坏太多的遗留代码了。</p><p>大括号初始化的另一项值得一提的特征是，它对于C++最令人苦恼之解析语法免疫。C++规定：任何能够解析为声明的都要解析为声明。本来想要以默认方式构造一个对象，结果却一不小心声明了一个函数。这个错误的根本原因构造函数调用语法。<br>当你想要以传参的方式调用构造函数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">///&lt; 调用Widget的构造函数，传入形参10</span></span><br></pre></td></tr></table></figure><p>但你如果试图用相同的语法构造一个没有形参的Widget的话，结果却变成了声明了一个函数而非对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;  <span class="comment">///&lt; 最令人苦恼之解析语法现身</span></span><br></pre></td></tr></table></figure><p>由于函数声明不能使用大括号来指定形参列表，所以使用大括号来完成对象的默认构造上面这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;  <span class="comment">///&lt; 调用没有形参的Widget构造函数</span></span><br></pre></td></tr></table></figure><p>大括号初始化的缺陷在于伴随它有时会出现的意外行为。这种行为源于大括号初始化物、<code>std::initializer_list</code>以及构造函数重载决议之间的纠结。</p><p>如果一个或多个构造函数声明了任何一个具备<code>std::initializer_list</code>型别的形参那么采用了大括号初始化语法的调用语句会强烈地优先选用带有<code>std::initializer_list</code>型别形参的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;  <span class="comment">///&lt; 调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;  <span class="comment">///&lt; 使用最后一个构造函数, 10, true 被强制转化为long double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你的确想要调用一个带有<code>std::initializer_list</code>型别形参的构造函数，并传入一个空的<code>std::initializer_list</code>的话，你可以通过把空大括号对作为构造函数实参的方式实现这个目的，即把一对空大括号放入一对小括号或大括号的方式来清楚地表明你传递地是什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;  <span class="comment">///&lt; 带有std::initializer_list型别形参地构造函数</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;  <span class="comment">///&lt; 同上</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有十个元素，每个元素值都为20的vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有两个元素，值分别为10、20 的vector</span></span><br></pre></td></tr></table></figure><p><code>std::make_unique</code>和<code>std::make_shared</code>在函数内部使用的小括号，作为其接口的一部分。</p><ul><li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫</li><li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有<code>std::initializer_list</code>型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个<code>std::vector&lt;数值型别&gt;</code>对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li></ul><h2 id="理解特种成员函数的生成机制"><a href="#理解特种成员函数的生成机制" class="headerlink" title="理解特种成员函数的生成机制"></a>理解特种成员函数的生成机制</h2><p>两种复制操作是彼此独立的：声明了其中一个，并不会阻止编译器生成另外一个。如果你生成了一个复制构造函数，同时未声明复制赋值运算符，并撰写了要求复制赋值的代码，则编译器会为你生成复制赋值运算符。反过来一样。</p><p>两种移动操作并不彼此独立：声明了其中一个就会阻止编译器生成另外一个。假设你声明了一个移动构造函数，你实际上表明了移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。综上声明一个移动构造函数会阻止编译器去生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器去生成移动构造函数。</p><p>一旦显式声明了赋值操作，这个类也就不再会生成移动操作了。依据在于，声明复制操作的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。从而判定既然按成员复制不适用于赋值操作，则按成员移动极有可能也不适用于移动操作。<br>一旦声明了移动操作，编译器就会删除复制操作。</p><p>三大律：如果你声明了复制构造函数、复制复制运算符，或析构函数中的任何一个，你就得同时声明所有这三个。<br>如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：1. 在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行。 2. 该类的析构函数也会参与到该资源的管理之中。</p><p>大三律的一个推论是，如果存在用户声明的析构函数，则平凡的按成员赋值也不适用于该类。如果声明了析构函数，则复制操作就不该被自动生成，因为他们呢的行为不可能正确。所以在C++11中：只要用户声明了析构函数，就不会生成移动操作。</p><p>移动操作的生成条件（如果需要生成）仅当以下三者同时成立：</p><ul><li>该类未声明任何复制操作</li><li>该类未声明任何移动操作</li><li>该类未声明任何析构操作</li></ul><p>总而言之， C++11中， 支配特种成员函数的机制如下：</p><ul><li>默认构造函数： 仅当类中不包含用户声明的构造函数时才生成</li><li>析构函数：与C++98中基本相同，唯一的区别在于析构函数默认为<code>noexcept</code>.仅当基类的析构函数为虚的，派生类析构函数才是虚的。</li><li>复制构造函数： 按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。</li><li>移动构造函数和移动赋值运算符<br>都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</li></ul><p>成员函数模板的存在会阻止编译器生成任何特种成员函数。</p><ul><li><p>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成</p></li><li><p>复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数时才生成，复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</p></li><li><p>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</p></li><li><p>auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别少打一些字</p></li><li><p>在模板推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</p></li><li><p>对万能引用形参进行推导时，左值实参会进行特殊处理。</p></li><li><p>对按值传递的形参进行推导时，若实参型别中带有<code>const</code>或<code>volatile</code>饰词，则它们还是会被当作不带<code>const</code>或<code>volatile</code>饰词的型别来处理。</p></li><li><p>在模板型别推导过程中， 数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</p></li><li><p>在一般情况下，auto型别推导和模板型推导是一模一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>, 但模板型别推导却不会。</p></li><li><p>在函数返回值或lambda式的形参中使用auto， 意思是使用模板型别推导而非auto型推导。</p></li><li><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的型别而不做任何修改</p></li><li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，<code>decltype</code>总是得出型别<code>T&amp;</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 观察者设计模式</title>
      <link href="/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了C++中的观察者设计模式，通过代码示例展示了如何实现一个简单的观察者模式。观察者模式允许对象（观察者）订阅另一个对象（被观察者）的状态变化，并在状态变化时自动接收通知。文章通过<code>subscriber</code>和<code>observer</code>类的实现，演示了如何注册观察者、广播消息以及处理观察者的生命周期。该模式适用于需要解耦对象间依赖关系的场景，如事件处理系统。</p><span id="more"></span><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subscriber</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;subscriber&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">subscriber</span>(<span class="type">const</span> std::string&amp; user_name) : <span class="built_in">user_name_</span>(user_name) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; user_name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string user_name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">boardcast</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = it-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sp) &#123;</span><br><span class="line">        sp-&gt;<span class="built_in">callback</span>(message);</span><br><span class="line">        it++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">regist</span><span class="params">(std::weak_ptr&lt;subscriber&gt; wp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(wp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::weak_ptr&lt;subscriber&gt;&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ob = std::<span class="built_in">make_shared</span>&lt;observer&gt;();</span><br><span class="line">  <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber1&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp1-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber2&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp2-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp3 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber3&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp3-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    <span class="keyword">auto</span> sp4 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber4&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp4-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;start boardcast!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;boardcast again!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 指针与引用</title>
      <link href="/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
      <url>/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文详细探讨了C++中指针与引用的区别与应用场景。指针可以为空，支持偏移操作，常用于修改变量和高效传递对象；而引用必须初始化，不可为空，且不支持四则运算，但同样能直接修改对象并减少复制成本。文章通过代码示例展示了指针和引用的具体用法，帮助读者理解两者的核心差异及其在编程中的实际应用。</p><span id="more"></span><h1 id="C-指针与引用"><a href="#C-指针与引用" class="headerlink" title="C++指针与引用"></a>C++指针与引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>可以为空（万恶之首）</li><li>可以做指针的偏移操作</li><li>可以用做修改一个变量</li><li>可以用来用来快速传递一个对象，没有复制的成本(只有指针复制的成本)<br>见下面代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* i)</span> </span>&#123;</span><br><span class="line">  *i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">f1</span>(&amp;num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num为2</span></span><br><span class="line">  <span class="built_in">f2</span>(num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num仍为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>引用同指针一样可以直接修改对象本身，减少传递对象的复制成本</li><li>引用不可为空，即创建必须初始化</li><li>引用不能同指针一样，进行四则运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> &amp;r = i;</span><br><span class="line">  r = <span class="number">1</span>;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为1</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为1</span></span><br><span class="line">  <span class="built_in">f1</span>(r);</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为100</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可见<a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类内默认成员函数</title>
      <link href="/2023/07/21/2020-12-11-C++%20%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/21/2020-12-11-C++%20%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在C++中，类的默认成员函数包括默认构造函数、析构函数、拷贝构造函数、移动构造函数、拷贝赋值运算符和移动赋值运算符。如果未显式定义，编译器会自动生成这些函数。默认函数的生成依赖于类成员的类型特性，特别是在涉及const或引用成员时。编译器不会为某些类合成移动操作，尤其是当类定义了自己的拷贝控制成员时。移动操作不同于拷贝操作，不会隐式定义为删除的函数，但在某些条件下可能被定义为删除的。理解这些默认函数的生成和依赖关系，有助于编写更高效和安全的C++代码。</p><span id="more"></span><p>C++ 类内默认成员函数</p><p>当我们在创建一个类时， 如果你没有主动定义六个默认函数的话，编译器将为你自动创建。<br>如下面两个类完全等价</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">object</span>(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">object</span>(object&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(object&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面代码示例默认函数的调用场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>; <span class="comment">///&lt; 构造函数 #1</span></span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;  <span class="comment">///&lt; 析构函数 #2</span></span><br><span class="line">  <span class="built_in">object</span>(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>;  <span class="comment">///&lt; 拷贝构造函数 #3</span></span><br><span class="line">  <span class="built_in">object</span>(object&amp;&amp; other) = <span class="keyword">default</span>; <span class="comment">///&lt; 移动构造函数 #4</span></span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>; <span class="comment">///&lt; 拷贝赋值符 #5</span></span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(object&amp;&amp; other) = <span class="keyword">default</span>;  <span class="comment">///&lt; 移动赋值符 #6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 构造函数#1示例</span></span><br><span class="line">  object x; <span class="comment">///&lt; 调用默认构造函数#1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 析构函数#2示例</span></span><br><span class="line">  &#123;</span><br><span class="line">    object x2;</span><br><span class="line">  &#125; <span class="comment">///&lt; 超出作用域临时变量x2,调用析构函数#2</span></span><br><span class="line"></span><br><span class="line">  object* p3 = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  <span class="keyword">delete</span> p3;  <span class="comment">///&lt; 调用析构函数#2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝构造函数#3示例</span></span><br><span class="line">  object base;</span><br><span class="line">  <span class="function">object <span class="title">copy1</span><span class="params">(base)</span></span>;  <span class="comment">///&lt; 调用拷贝构造函数 #3</span></span><br><span class="line">  object copy2 = base;  <span class="comment">///&lt; 调用拷贝构造赋值符#3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 移动构造函数#4示例</span></span><br><span class="line">  object base_move;</span><br><span class="line">  <span class="function">object <span class="title">copy_move</span><span class="params">(std::move(base_move))</span></span>; <span class="comment">///&lt; 由于入参为右值, 调用移动构造函数#4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝构造赋值符#5示例</span></span><br><span class="line">  object base_operator;</span><br><span class="line">  object copy_operator;</span><br><span class="line">  copy_operator = base_operator;  <span class="comment">///&lt; 调用拷贝构造赋值符#5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 移动构造赋值符#6示例</span></span><br><span class="line">  object move_base;</span><br><span class="line">  object move_operator = std::<span class="built_in">move</span>(move_base);  <span class="comment">///&lt; 调用移动构造赋值符#6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>当一个类的析构函数被定为<code>private</code>或是<code>delete</code>时，该类只能构造而无法析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  object1* p = <span class="keyword">new</span> object1; <span class="comment">///&lt; 编译通过</span></span><br><span class="line">  <span class="comment">/// delete p; ///&lt; 编译错误</span></span><br><span class="line">  <span class="comment">/// object1 obj;  ///&lt; 编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个类<code>object2</code>等同于上面<code>object1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="各个默认合成函数的生成关系"><a href="#各个默认合成函数的生成关系" class="headerlink" title="各个默认合成函数的生成关系"></a>各个默认合成函数的生成关系</h2><p>构造析构与拷贝构造与拷贝赋值运算符的默认生成关系</p><p>原则：<br>需要析构函数的类也需要拷贝和赋值操作。<br>需要拷贝和赋值操作函数的类，不一定需要析构函数。<br>需要拷贝操作的类也需要赋值操作，反之亦然。<br>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p><p>原因：</p><p>一个成员有删除的或不可访问的析构函数会导致合成的默认拷贝和拷贝构造函数被定义为删除的，为了防止创建出无法销毁的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ~<span class="built_in">a</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a obj0; <span class="comment">///&lt; 没有默认构造函数, 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于具有引用成员或无法默认构造的<code>const</code>成员的类，编译器不会为其合成默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> i;   <span class="comment">///&lt; 未赋值的 const 变量</span></span><br><span class="line">  <span class="type">int</span>&amp; j;        <span class="comment">///&lt; 未指向的引用变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// a obj0; ///&lt; 没有默认构造函数, 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有<code>const</code>成员，则它不能使用合成的拷贝复制运算符，因为<code>const</code>成员被创建后无法再次赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a obj0;</span><br><span class="line">  a obj1;</span><br><span class="line">  obj0 = obj1;  <span class="comment">///&lt; 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于具有引用成员的类， 其合成拷贝构造函数也是被删除的。因为无法使引用改变指向。</p><p>管理类外资源的类必须定义拷贝控制成员。</p><p>赋值运算符有两个要求：</p><ul><li>如果将一个对象赋予它自身，赋值运算符必须能正常工作。</li><li>大多数赋值运算符组合了析构函数和拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>&#123;</span><br><span class="line">  std::string* p;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> object&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">      p = <span class="keyword">new</span> std::<span class="built_in">string</span>(*other.p);  <span class="comment">///&lt; 当传入对象就是自己时会出错。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，编译器总会为我们合成这些操作，而编译器不会为某些类合成移动操作。特别是，当一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。<br>如果一个类没有移动操作，通过正常的函数匹配，<strong>类会使用对应的拷贝操作来代替移动操作</strong>。</p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时编译器才会为合成移动构造函数或移动赋值运算符。</p><p>与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式要求编译器生成<code>=default</code>的移动操作，且编译器不能移动所有成员移动所有成员，则编译器会将移动操作定义为删除的函数。</p><ul><li><p>与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。</p></li><li><p>类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。</p><p><img src="/%5Cresource%5CC++%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%5CSnipaste_2020-12-07_14-14-02.png" alt="Snipaste_2020-12-07_14-14-02"></p></li><li><p>类似拷贝赋值运算符，如果有类成员是<code>const</code>的或是引用，则类的移动赋值运算符被定义为删除的。</p><p><img src="/%5Cresource%5CC++%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%5CSnipaste_2020-12-07_14-16-31.png" alt="Snipaste_2020-12-07_14-16-31"></p></li></ul><p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地定义为删除的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  object&amp;&amp; <span class="keyword">operator</span>=(object&amp;&amp; other) &#123;&#125;</span><br><span class="line">  <span class="built_in">object</span>(object&amp;&amp; other) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  object obj;</span><br><span class="line">  <span class="keyword">auto</span> obj_copy1 = std::<span class="built_in">move</span>(obj);</span><br><span class="line">  <span class="keyword">auto</span> obj_copy2 = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/%5Cresource%5CC++%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%5CSnipaste_2020-12-07_11-15-47.png" alt="Snipaste_2020-12-07_11-15-47"></p><p>下面代码中<code>#1</code>拷贝构造函数由于接收的是<code>const</code>的引用，所以也能够匹配右值入参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">object</span>(<span class="type">const</span> object&amp; obj) = <span class="keyword">default</span>;  <span class="comment">///&lt; #1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  object obj1;</span><br><span class="line">  <span class="function">object <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有一个拷贝构造函数但未定义移动构造函数时，编译器不会合成移动构造函数。但是函数匹配规则保证该类型的对象会被拷贝，即使我们试图使用<code>std::move</code>来移动他们时也是如此。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">///  默认构造函数</span></span><br><span class="line">  <span class="built_in">a</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">a</span>(<span class="type">const</span> a&amp; other)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a obj0;</span><br><span class="line">  a obj1 = std::<span class="built_in">move</span>(obj0); <span class="comment">///&lt; 此处会调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="特殊成员函数之间的依赖关系"><a href="#特殊成员函数之间的依赖关系" class="headerlink" title="特殊成员函数之间的依赖关系"></a>特殊成员函数之间的依赖关系</h1><p>编译器隐式声明</p><table><thead><tr><th align="center"></th><th align="center"><strong>默认构造函数</strong></th><th align="center"><strong>析构函数</strong></th><th align="center"><strong>拷贝构造函数</strong></th><th align="center"><strong>拷贝赋值</strong></th><th align="center"><strong>移动构造函数</strong></th><th align="center"><strong>移动赋值</strong></th></tr></thead><tbody><tr><td align="center"><strong>全部不声明</strong></td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td></tr><tr><td align="center"><strong>任意构造函数</strong></td><td align="center">不声明</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td></tr><tr><td align="center"><strong>默认构造函数</strong></td><td align="center">用户声明</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td></tr><tr><td align="center"><strong>析构函数</strong></td><td align="center">预置</td><td align="center">用户声明</td><td align="center">预置</td><td align="center">预置</td><td align="center">不声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>拷贝构造函数</strong></td><td align="center">不声明</td><td align="center">预置</td><td align="center">用户声明</td><td align="center">预置</td><td align="center">不声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>拷贝赋值</strong></td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">用户声明</td><td align="center">不声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>移动构造函数</strong></td><td align="center">不声明</td><td align="center">预置</td><td align="center">弃置</td><td align="center">弃置</td><td align="center">用户声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>移动赋值</strong></td><td align="center">预置</td><td align="center">预置</td><td align="center">弃置</td><td align="center">弃置</td><td align="center">不声明</td><td align="center">用户声明</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 智能指针简介与错误使用情况</title>
      <link href="/2023/07/21/2020-12-11-C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/"/>
      <url>/2023/07/21/2020-12-11-C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>智能指针在C++中用于简化内存管理，主要包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。</p><ul><li><code>std::unique_ptr</code>独占对象所有权，不可复制，仅可移动；</li><li><code>std::shared_ptr</code>通过引用计数共享对象所有权，适合多个对象共享资源的场景；</li><li><code>std::weak_ptr</code>用于打破循环引用，观察对象但不影响其生命周期。本文详细介绍了三种智能指针的用法、实现原理及常见错误使用情况，并通过代码示例展示了如何避免内存泄漏和循环引用问题，帮助开发者更有效地管理资源。</li></ul><span id="more"></span><p>智能指针是为了更方便的管理内存而设计的，设计思想就是让使用者不再管理内存，而是由智能指针来进行管理。<br>换句话说以后不用再考虑<code>new</code>出来的对象什么时候需要<code>delete</code>，智能指针能帮你管理内存。<br>智能指针分为三种: <code>std::shared_ptr</code>、<code>std::weak_ptr</code>和<code>std::unique_ptr</code>。</p><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><code>std::unique_ptr</code>指针拥有其管理对象的所有权，该智能指针不能被复制，只能被移动。当<code>std::unique_ptr</code>智能指针被析构，则其管理的对象也会被析构。<br>举一个简单的例子，高中宿管大爷，早六点开灯，晚十点关灯，其他人没有办法参与开关灯的事情。这里开关灯指的就是内存的分配与释放。</p><p>用法示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);  <span class="comment">///&lt; 分配一个int的内存，其值为0</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(p);  <span class="comment">///&lt; 使用指针p来创建一个智能指针对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      /// 由于std::unique_ptr对象不可复制，所以下面三句话编译不过</span></span><br><span class="line"><span class="comment">      std::unique_ptr&lt;int&gt; up_copy1(up);</span></span><br><span class="line"><span class="comment">      std::unique_ptr&lt;int&gt; up_copy2;</span></span><br><span class="line"><span class="comment">      up_copy2 = up;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125; <span class="comment">///&lt; 在这个地方智能指针up被析构，up的析构函数对指针p执行delete操作，从而达到智能回收内存的作用</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> up = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>); <span class="comment">///&lt; 这句话等价于上面的两句话</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面看一下<code>std::unique_ptr</code>简单实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJECT&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 构造函数</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(OBJECT* p) : <span class="built_in">p_</span>(p) &#123;&#125;</span><br><span class="line">  <span class="comment">/// 析构函数</span></span><br><span class="line">  ~<span class="built_in">unique_ptr</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(p_ != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> p_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 删除拷贝构造函数, 标识这个类不可拷贝</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&lt;OBJECT&gt;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">/// 删除拷贝构造赋值符, 标识这个类不可拷贝</span></span><br><span class="line">  unique_ptr&lt;OBJECT&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&lt;OBJECT&gt;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">/// 移动构造函数</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; other) &#123;</span><br><span class="line">    p_ = other.p_;</span><br><span class="line">    other.p_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 移动赋值符</span></span><br><span class="line">  <span class="function">unique_ptr&lt;OBJECT&gt;&amp; <span class="title">unique_ptr</span><span class="params">(unique_ptr&amp;&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p_;</span><br><span class="line">    p_ = other.p_;</span><br><span class="line">    other.p_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  OBJECT* p_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>见示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="function">unique_ptr&lt;object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> object)</span></span>;</span><br><span class="line">     <span class="function">unique_ptr&lt;object&gt; <span class="title">other</span><span class="params">(std::move(p))</span></span>;  <span class="comment">///&lt; 调用移动构造函数</span></span><br><span class="line">     <span class="comment">/// 此时other智能指针拥有对象的管理权，而p失去了该对象的管理权</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../resource/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/Snipaste_2020-12-03_15-42-50.png" alt="Snipaste_2020-12-03_15-42-50"></p><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p><code>std::shared_ptr</code>使用引用计数的方法来决定是否需要释放掉管理对象的内存。<br>举一个很简单的例子，办公室中每一个人下班出门前都会看一下还有没有人在办公室中，如果有就直接走掉不关灯，如办公室内没有人了就执行关灯操作。<br>见下面简单实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OBJECT&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 构造函数</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(OBJECT* object):<span class="built_in">p_</span>(object), <span class="built_in">count_</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">    ++(*count_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 析构函数</span></span><br><span class="line">  ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(--(*count_) == <span class="number">0</span>) &#123;  <span class="comment">///&lt; 如果自己是最后一个管理该对象的人，自己被析构时负责做善后工作即delete对象</span></span><br><span class="line">      <span class="keyword">delete</span> p_;</span><br><span class="line">      <span class="keyword">delete</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; other) &#123;</span><br><span class="line">    count_ = other.count_;  <span class="comment">///&lt; 把引用计数的指针复制过来</span></span><br><span class="line">    ++(*count_);  <span class="comment">///&lt; 所有shared_ptr中的count_都自加一下</span></span><br><span class="line">    p_ = other.p_;  <span class="comment">///&lt; 复制管理对象的指针</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝赋值运算符</span></span><br><span class="line">  shared_ptr&lt;OBJECT&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;<span class="keyword">this</span>; <span class="comment">///&lt; 如果复制的对象是自己，则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    count_ = other.count_;  <span class="comment">///&lt; 把引用计数的指针复制过来</span></span><br><span class="line">    ++(*count_);  <span class="comment">///&lt; 所有shared_ptr中的count_都自加一下</span></span><br><span class="line">    <span class="keyword">delete</span> p_;</span><br><span class="line">    p_ = other.p_;  <span class="comment">///&lt; 复制管理对象的指针</span></span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  OBJECT* p_ = <span class="literal">nullptr</span>; <span class="comment">///&lt; 指向管理对象的指针</span></span><br><span class="line">  <span class="type">int</span>* count_ = <span class="literal">nullptr</span>;  <span class="comment">///&lt; 引用计数, 之所以使用指针是为了让管理同一个对象的引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行一下例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;object&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> object)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp1</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp2</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp4</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp5</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp6</span><span class="params">(sp)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/..%5Cresource%5CC++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%5CSnipaste_2020-12-03_10-47-05.png" alt="Snipaste_2020-12-03_10-47-05"><br>\resource\C++智能指针简介与错误使用情况</p><p>可以看到该对象被构造了一次，又被析构了一次。</p><p>上面的实现虽然让内存管理变得简单，但也带来了一些麻烦。<br>由于智能指针拥有了对象的管理权，<strong>万一两个智能指针管理同一对象，那么这两个智能指针在析构时会对同一对象执行两次<code>delete</code>， 从而造成崩溃</strong>。见下面代码举例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    object* p = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="function">shared_ptr&lt;object&gt; <span class="title">sp1</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;object&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码运行会崩溃。因为两个截然不同的智能指针<code>sp1</code>和<code>sp2</code>同时管理了同一个<code>object</code>对象， 它们分别析构时会对指针<code>p</code>，<code>delete</code>两次。<br>所以我们更加推荐使用<code>std::make_shared</code>来代替使用裸指针初始化智能指针。见下面举例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;object&gt; sp = std::<span class="built_in">make_shared</span>&lt;object&gt;();</span><br><span class="line"><span class="comment">/// 代替下面的初始化的方法</span></span><br><span class="line"><span class="comment">/// std::shared_ptr&lt;object&gt; sp = std::shared_ptr&lt;object&gt;(new object);</span></span><br></pre></td></tr></table></figure><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>我们有时会在代码里遇到这样一种情况，见下面代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">error_object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;error_object&gt; <span class="title">get_sp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;error_object&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中<code>get_sp()</code>的函数，目的是想返回一个能够管理自己的智能指针，但是我们可以看到<strong>每调用一次get_sp()，我们都会用同一个指针<code>this</code>, 创建一个不同的智能指针</strong>。<br>这意味着我们调用两次<code>get_sp()</code>函数后，程序运行时会崩溃。</p><p>为了应对这种情况标准库中设计了一个工具函数<code>std::enable_shared_from_this</code>, 具体用法如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">correct_object</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;correct_object&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> instance = std::<span class="built_in">make_shared</span>&lt;correct_object&gt;();</span><br><span class="line">  std::shared_ptr&lt;correct_object&gt; sp1 = instance.<span class="built_in">shared_from_this</span>();</span><br><span class="line">  std::shared_ptr&lt;correct_object&gt; sp2 = instance.<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以正常运行。<br>关于<code>std::enable_shared_from_this</code>的实现原理，见<code>C++ enable_shared_from_this原理与简单实现</code>。</p><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p><code>std::weak_ptr</code>不能被称为一个独立的智能指针，它是<code>std::shared_ptr</code>智能指针的一种扩展。</p><p><code>std::weak_ptr</code>的功能是，观察一个被<code>std::shared_ptr</code>管理的对象, 但不会影响<code>std::shared_ptr</code>的引用计数。</p><p><code>std::weak_ptr</code>可以观察一个对象有没有被释放，或是用来防止<code>std::shared_ptr</code>的循环引用问题。</p><p>下面代码用于检查资源是否已经释放。用于解决裸指针的野指针的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::weak_ptr&lt;object&gt; weak;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;object&gt;();</span><br><span class="line">      weak = sp;</span><br><span class="line">      std::shared_ptr&lt;object&gt; sp1 = weak.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span>(sp1)&#123;</span><br><span class="line">         sp1-&gt;<span class="built_in">doSomeThing</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (weak.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;资源没有释放&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;资源已经释放&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码出现了引用回环，会导致智能指针对象被销毁了，但资源没有被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">list_node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;list_node&gt; next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp0 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    sp0-&gt;next = sp1;</span><br><span class="line">    sp1-&gt;next = sp2;</span><br><span class="line">    sp2-&gt;next = sp0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/..%5Cresource%5CC++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%5CSnipaste_2020-12-03_14-50-26.png" alt="Snipaste_2020-12-03_14-50-26"></p><p>我们可以看到该对象的析构函数一个也没有执行，说明内存没有释放。</p><p>我们现在换成<code>std::weak_ptr</code>来保存指向下一个节点的智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">list_node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::weak_ptr&lt;list_node&gt; next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp0 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    sp0-&gt;next = sp1;</span><br><span class="line">    sp1-&gt;next = sp2;</span><br><span class="line">    sp2-&gt;next = sp0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/..%5Cresource%5CC++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%5CSnipaste_2020-12-03_15-00-25.png" alt="Snipaste_2020-12-03_15-00-25"></p><p>现在指针形成的环路被<code>std::weak_ptr</code>完美解决了。内存能够正确释放了。</p><p>实际使用用例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subscriber</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 订阅者被观察器调用的函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123; std::cout &lt;&lt; str &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 广播者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boardcaster</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/// 广播者注册订阅者</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">regist</span><span class="params">(std::shared_ptr&lt;subscriber&gt; sp)</span> </span>&#123; vec.<span class="built_in">push_back</span>(sp); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 广播事件</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">boardcast</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = it-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sp) &#123;</span><br><span class="line">        <span class="comment">/// 让订阅者接受消息</span></span><br><span class="line">        sp-&gt;<span class="built_in">read</span>(str);</span><br><span class="line">        it++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;subscriber is delete!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);  <span class="comment">///&lt; 擦除这个订阅者的指针</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::weak_ptr&lt;subscriber&gt;&gt; vec; <span class="comment">///&lt; 用于保存订阅者的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boardcaster obj;</span><br><span class="line">  <span class="keyword">auto</span> reader0 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt;();</span><br><span class="line">  obj.<span class="built_in">regist</span>(reader0);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> reader1 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt;();</span><br><span class="line">    obj.<span class="built_in">regist</span>(reader1);</span><br><span class="line">    <span class="keyword">auto</span> reader2 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt;();</span><br><span class="line">    obj.<span class="built_in">regist</span>(reader2);</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">boardcast</span>(<span class="string">&quot;start boardcast!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  obj.<span class="built_in">boardcast</span>(<span class="string">&quot;reader1 and reader2 is deleted， boardcast angin!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170">智能指针（现代 C++）</a></p><p><a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html">C&#x2F;C++内存泄漏及检测</a></p><p><a href="https://www.zhihu.com/question/63946754">知乎 C++ 怎么检测内存泄露，怎么定位内存泄露？</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> new new(_NORMAL_BLOCK,__FILE__,__LINE__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">_CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG)|_CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/finding-memory-leaks-using-the-crt-library?view=vs-2022">使用 CRT 库查找内存泄漏</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压力测试工具设计-初试瀑布式软件开发周期</title>
      <link href="/2023/07/21/2023-07-21-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3-%E5%88%9D%E8%AF%95%E7%80%91%E5%B8%83%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/07/21/2023-07-21-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3-%E5%88%9D%E8%AF%95%E7%80%91%E5%B8%83%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>用于集成测试时的模拟机器的硬件情况，如 cpu 占用率、内存占用率、磁盘占用率。</p><p>本文使用 <a href="#moscow-%E8%8E%AB%E6%96%AF%E7%A7%91-%E6%B3%95%E5%88%99"><code>MoSCoW</code> (莫斯科)</a> 法则, 对需求优先级进行排序。</p><span id="more"></span><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="5-自动化测试"><a href="#5-自动化测试" class="headerlink" title="5. 自动化测试"></a>5. 自动化测试</h3><p>应可以在跨平台的环境下，自动化测试。</p><h3 id="6-使用提示"><a href="#6-使用提示" class="headerlink" title="6. 使用提示"></a>6. 使用提示</h3><h4 id="6-1-提示应具有良好的可读性"><a href="#6-1-提示应具有良好的可读性" class="headerlink" title="6.1 提示应具有良好的可读性"></a>6.1 提示应具有良好的可读性</h4><p>Must have</p><h4 id="6-2-重点文本，颜色高亮"><a href="#6-2-重点文本，颜色高亮" class="headerlink" title="6.2 重点文本，颜色高亮"></a>6.2 重点文本，颜色高亮</h4><p>Could have</p><h2 id="假设约束"><a href="#假设约束" class="headerlink" title="假设约束"></a>假设约束</h2><h2 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h2><h3 id="1-cpu-占用率模拟"><a href="#1-cpu-占用率模拟" class="headerlink" title="1. cpu 占用率模拟"></a>1. cpu 占用率模拟</h3><h4 id="1-1-支持单核满载"><a href="#1-1-支持单核满载" class="headerlink" title="1.1 支持单核满载"></a>1.1 支持单核满载</h4><p>Should have</p><h4 id="1-2-支持多核满载"><a href="#1-2-支持多核满载" class="headerlink" title="1.2 支持多核满载"></a>1.2 支持多核满载</h4><p>Must have</p><h4 id="1-3-CPU-占用率区间"><a href="#1-3-CPU-占用率区间" class="headerlink" title="1.3 CPU 占用率区间"></a>1.3 CPU 占用率区间</h4><p>不限制最低 CPU 占用率，限制最高 CPU 占用率为 95%([x%, 95%]).</p><h4 id="1-4-关闭程序后，CPU-占用率恢复到运行前水平"><a href="#1-4-关闭程序后，CPU-占用率恢复到运行前水平" class="headerlink" title="1.4 关闭程序后，CPU 占用率恢复到运行前水平"></a>1.4 关闭程序后，CPU 占用率恢复到运行前水平</h4><p>Must have</p><h3 id="2-内存占用率模拟"><a href="#2-内存占用率模拟" class="headerlink" title="2. 内存占用率模拟"></a>2. 内存占用率模拟</h3><p>TODO(lijiancong): 需要确认内存占用率的计算方式。</p><h4 id="2-1-支持内存占用率区间"><a href="#2-1-支持内存占用率区间" class="headerlink" title="2.1 支持内存占用率区间"></a>2.1 支持内存占用率区间</h4><p>不限制最低内存占用率，限制最高内存占用率为 95%([x%, 95%]).</p><h4 id="2-2-关闭程序后，内存占用率恢复到运行前水平"><a href="#2-2-关闭程序后，内存占用率恢复到运行前水平" class="headerlink" title="2.2 关闭程序后，内存占用率恢复到运行前水平"></a>2.2 关闭程序后，内存占用率恢复到运行前水平</h4><h3 id="3-磁盘占用率模拟"><a href="#3-磁盘占用率模拟" class="headerlink" title="3. 磁盘占用率模拟"></a>3. 磁盘占用率模拟</h3><h4 id="3-1-支持磁盘占用率区间"><a href="#3-1-支持磁盘占用率区间" class="headerlink" title="3.1 支持磁盘占用率区间"></a>3.1 支持磁盘占用率区间</h4><p>Must have</p><p>不限制最低磁盘占用率，限制最高磁盘占用率为 95%([x%, 95%]).</p><h4 id="3-2-关闭程序后，磁盘占用率恢复到运行前水平"><a href="#3-2-关闭程序后，磁盘占用率恢复到运行前水平" class="headerlink" title="3.2 关闭程序后，磁盘占用率恢复到运行前水平"></a>3.2 关闭程序后，磁盘占用率恢复到运行前水平</h4><p>Should have</p><h4 id="3-3-支持运行当前运行磁盘的占用率模拟"><a href="#3-3-支持运行当前运行磁盘的占用率模拟" class="headerlink" title="3.3 支持运行当前运行磁盘的占用率模拟"></a>3.3 支持运行当前运行磁盘的占用率模拟</h4><p>Must have</p><h4 id="3-4-支持指定磁盘的占用率模拟"><a href="#3-4-支持指定磁盘的占用率模拟" class="headerlink" title="3.4 支持指定磁盘的占用率模拟"></a>3.4 支持指定磁盘的占用率模拟</h4><p>Won’t have</p><h2 id="非功能需求"><a href="#非功能需求" class="headerlink" title="非功能需求"></a>非功能需求</h2><h3 id="4-跨平台支持"><a href="#4-跨平台支持" class="headerlink" title="4. 跨平台支持"></a>4. 跨平台支持</h3><h3 id="4-1-跨系统支持"><a href="#4-1-跨系统支持" class="headerlink" title="4.1 跨系统支持"></a>4.1 跨系统支持</h3><h4 id="4-1-1-Windows11"><a href="#4-1-1-Windows11" class="headerlink" title="4.1.1. Windows11"></a>4.1.1. Windows11</h4><p>Must have</p><h4 id="4-1-2-Windows10"><a href="#4-1-2-Windows10" class="headerlink" title="4.1.2. Windows10"></a>4.1.2. Windows10</h4><p>Must have</p><h4 id="4-1-3-Centos7"><a href="#4-1-3-Centos7" class="headerlink" title="4.1.3. Centos7"></a>4.1.3. Centos7</h4><p>Should have</p><h4 id="4-1-4-Ubuntu"><a href="#4-1-4-Ubuntu" class="headerlink" title="4.1.4. Ubuntu"></a>4.1.4. Ubuntu</h4><p>Should have</p><h4 id="4-1-5-openEuler"><a href="#4-1-5-openEuler" class="headerlink" title="4.1.5. openEuler"></a>4.1.5. openEuler</h4><p>Should have</p><h4 id="4-1-6-MacOS"><a href="#4-1-6-MacOS" class="headerlink" title="4.1.6. MacOS"></a>4.1.6. MacOS</h4><p>Could have</p><h3 id="4-2-多编译器支持"><a href="#4-2-多编译器支持" class="headerlink" title="4.2 多编译器支持"></a>4.2 多编译器支持</h3><h4 id="4-2-1-G-12"><a href="#4-2-1-G-12" class="headerlink" title="4.2.1. G++12"></a>4.2.1. G++12</h4><p>Must have</p><h4 id="4-2-2-Visual-Studio-2022"><a href="#4-2-2-Visual-Studio-2022" class="headerlink" title="4.2.2. Visual Studio 2022"></a>4.2.2. Visual Studio 2022</h4><p>Must have</p><h4 id="4-2-3-Visual-Studio-2010"><a href="#4-2-3-Visual-Studio-2010" class="headerlink" title="4.2.3. Visual Studio 2010"></a>4.2.3. Visual Studio 2010</h4><p>Could have</p><h4 id="4-2-4-clang14"><a href="#4-2-4-clang14" class="headerlink" title="4.2.4. clang14"></a>4.2.4. clang14</h4><p>Could have</p><h4 id="4-2-5-G-3-8-及以上"><a href="#4-2-5-G-3-8-及以上" class="headerlink" title="4.2.5. G++3.8 及以上"></a>4.2.5. G++3.8 及以上</h4><p>Could have</p><h3 id="7-安全要求"><a href="#7-安全要求" class="headerlink" title="7. 安全要求"></a>7. 安全要求</h3><p>以不损害硬件为原则，运行本软件后恢复硬件环境到运行前水平。</p><h4 id="7-1-cpu-高负载"><a href="#7-1-cpu-高负载" class="headerlink" title="7.1 cpu 高负载"></a>7.1 cpu 高负载</h4><h5 id="7-1-1-高负载限制-95"><a href="#7-1-1-高负载限制-95" class="headerlink" title="7.1.1 高负载限制 95%"></a>7.1.1 高负载限制 95%</h5><h5 id="7-1-2-高负载时间限制-20min"><a href="#7-1-2-高负载时间限制-20min" class="headerlink" title="7.1.2 高负载时间限制 20min"></a>7.1.2 高负载时间限制 20min</h5><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="MoSCoW-莫斯科-法则"><a href="#MoSCoW-莫斯科-法则" class="headerlink" title="MoSCoW (莫斯科) 法则"></a>MoSCoW (莫斯科) 法则</h3><p><code>MoSCoW</code> 法则是一种优先级排序法则，用于项目管理定义范围、确定功能质量、变更管理中常用的工具法则，以便用户、项目主管、项目经理、供应商对纳入项目中的每个需求交付的重要性和紧急性达成共识。</p><p><code>MoSCoW</code> 代表四个优先级别的首字母的缩写，再加上O使之能够形成便于记忆的名称——<code>MoSCoW</code>。</p><ol><li><code>Must have</code>: 必须有。 如果不包含，则产品不可行。 <code>Must Have</code> 的功能，通常就是最小可行产品（<code>MVP</code>）的功能。</li><li><code>Should have</code>: 应该有。 这些功能很重要，但不是必需的。 虽然“应该有”的要求与“必须有”一样重要，但它们通常可以用另一种方式来代替，去满足客户要求。</li><li><code>Could have</code>: 可以有。 这些要求是客户期望的，但不是必需的。 可以提高用户体验，或提高客户满意度。 如果时间充足，资源允许，通常会包括这些功能。 但如果交付时间紧张，通常现阶段不会做，会挪到下一阶段或者下一期做。</li><li><code>Won’t have</code>:这次不会有。 最不重要，最低回报的事项，或在当下是不适合的要求。 不会被计划到当前交货计划中。 “不会有”会被要求删除，或重新考虑。</li></ol><p><img src="/../resource/2023-07-21-stress_tool/xx.gif" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EN50128中的基本要求</title>
      <link href="/2023/06/16/2023-06-09-EN50128%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82/"/>
      <url>/2023/06/16/2023-06-09-EN50128%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>SIL2 认证的中对于信号子系统中软件开发质量保障的标准 EN50128 标准的基本要求摘录。</p><span id="more"></span><h1 id="文档要求"><a href="#文档要求" class="headerlink" title="文档要求"></a>文档要求</h1><ul><li><p>5.3.2.7 对于每个文档，应根据唯一的参考编号以及与其他文档的定义和记录关系提供可追溯性。</p></li><li><p>5.3.2.8 每个术语、首字母缩略词或缩写在每个文档中应具有相同的含义。如果由于历史原因无法做到这一点，则应列出不同的含义并给出参考文献。</p></li><li><p>5.3.2.9 除与原有软件有关的文档（见7.3.4.7）外，每份文档应按照以下规则编写：</p></li><li><ul><li>它应包含或实施与其具有继承关系的先前文档的所有适用条件和要求;</li></ul></li><li><ul><li>它不得与前一份文档相抵触。</li></ul></li><li><p>5.3.2.10 每个项目或概念应在每份文档中使用相同的名称或描述。</p></li></ul><h1 id="通用要求"><a href="#通用要求" class="headerlink" title="通用要求"></a>通用要求</h1><ul><li><p>6.5.4.14 在验证安全相关系统时，应将要求的可追溯性作为重要考虑因素，并应提供方法，以便在生命周期的所有阶段进行证明。</p></li><li><p>6.5.4.15 在本欧洲标准的背景下，并在适合指定软件安全完整性级别的程度上，可追溯性应特别解决</p></li><li><pre><code>a) 将需求追溯到设计或满足这些要求的其他对象</code></pre></li><li><pre><code>b) 设计对象的可追溯性到实例化它们的实现对象</code></pre></li><li><pre><code>c) 设计对象的可追溯性到实例化它们的实现对象</code></pre></li><li><p>可追溯性应成为配置管理的主题</p></li><li><p>6.5.4.16 在特殊情况下，例如预先存在的软件或原型软件，可以在代码的实施和&#x2F;或记录之后，但在验证&#x2F;确认之前创建可追溯性。在这些情况下，应证明验证&#x2F;确认与所有阶段的可追溯性一样有效。</p></li><li><p>6.5.4.17 无法充分追溯的要求、设计或实施对象应证明与系统的安全性或完整性无关。</p></li></ul><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><ol><li>软件架构、接口和设计规范的内部一致。 软件架构、接口和设计规范在一致性和完整性方面是否充分满足软件要求规范。</li><li>规范与质量保证进程使用了相同的术语。对于规范这个文档使用了唯一的文件编号（文档编号: xxx，版本Vxxx），并具有与其他文档的定义和记录关系（规范中章节1.5. 与其它开发任务&#x2F;文档的关系），以提供可追溯性。</li><li>每个术语、首字母缩略词或缩写在每个文档中应具有相同的含义。见规范中章节1.6.术语和缩写词。</li><li>它应包含或实施与其具有继承关系的先前文档的所有适用条件和要求;也不与前一份文档抵触。</li><li>每个项目或概念应在每份文档中使用相同的名称或描述。见规范中章节1.6.术语和缩写词。</li><li>在规范中，可追溯性得到满足。见规范中章节 6. 可追溯性分析。</li><li>规范中没有已经预先存在的软件，所以不用为其创建可追溯性和验证其可追溯性。</li></ol><h1 id="验证报告要求"><a href="#验证报告要求" class="headerlink" title="验证报告要求"></a>验证报告要求</h1><ul><li><p>6.2.4.12 任何软件验证报告均应由验证员负责，根据输入的文档编写。为了清晰和方便起见，可以对这些报告进行分区，并应遵循软件验证计划。6.2.4.13 中的要求是指软件验证报告</p></li><li><p>6.2.4.13 每份软件验证报告应记录以下内容：</p></li><li><p>a) 已验证项目的身份和配置，以及验证者名称</p></li><li><p>b) 不符合规格要求的物品;</p></li><li><p>c) 对问题适配的组件、数据、结构和算法。</p></li><li><p>d) 检测到错误或缺陷;</p></li><li><p>e) 软件验证计划的实现或偏离（如果出现偏差，验证报告应说明偏差是否严重）;</p></li><li><p>f) 假设,如果有的话;</p></li><li><p>g) 核查结果摘要</p></li></ul><h1 id="测试规范要求"><a href="#测试规范要求" class="headerlink" title="测试规范要求"></a>测试规范要求</h1><ul><li>6.1.4.4 每个测试规范应记录以下内容</li><li>a) 测试目标</li><li>b) 测试用例、测试数据和预期结果;</li><li>c) 要执行的测试类型;</li><li>d) 测试环境、工具、配置和进程</li><li>e) 判断测试完成情况的测试标准;</li><li>f) 要达到的测试覆盖率的标准和程度</li><li>g) 参与测试过程的人员的角色和职责</li><li>h) 测试规范涵盖的要求</li><li>i) 软件测试设备的选择和使用;</li></ul><h1 id="测试报告要求"><a href="#测试报告要求" class="headerlink" title="测试报告要求"></a>测试报告要求</h1><ul><li>6.1.4.5 测试报告应按如下方式制作：</li><li>a) 测试报告应当载明测试人员姓名，说明测试结果以及是否满足测试规范的测试目标和测试标准。故障应记录和总结;</li><li>b) 测试用例及其结果应记录，最好以机器可读的形式记录，以供后续分析;</li><li>c) 测试应是可重复的，并在可行的情况下通过自动方式进行;</li><li>d) 应验证用于自动执行测试的测试脚本;</li><li>e) 应记录所有涉及项目（使用的硬件、使用的软件、使用的设备、设备校准以及测试规范的版本信息）的身份和配置;</li><li>f) 应提供对测试覆盖率和测试完成情况的评估，并注明任何偏差</li></ul><h1 id="确认报告"><a href="#确认报告" class="headerlink" title="确认报告"></a>确认报告</h1><ul><li><p>6.3.4.8 确认结果应记录在软件确认报告中。</p></li><li><p>6.3.4.9 确认者应检查验证过程是否完成。</p></li><li><p>6.3.4.10 软件确认报告应完整说明已验证的软件基线。</p></li><li><p>6.3.4.11 确认报告应明确指出软件中任何已知的缺陷,以及这些缺陷可能对软件使用产生的影响</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SIL2 </category>
          
          <category> EN50128 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SIL2 </tag>
            
            <tag> EN50128 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ nullptr与NULL</title>
      <link href="/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/"/>
      <url>/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/</url>
      
        <content type="html"><![CDATA[<p>本文探讨了C++中<code>NULL</code>与<code>nullptr</code>的区别。<code>NULL</code>是一个宏定义，通常被定义为<code>0</code>，在函数重载时可能导致歧义；而<code>nullptr</code>是一个特殊类型，专门用于表示空指针，能够明确调用指针类型的函数重载。通过代码示例，文章展示了<code>nullptr</code>在避免函数重载歧义中的优势，帮助读者理解其在现代C++编程中的重要性。</p><span id="more"></span><h1 id="NULL-与-nullptr-的区别"><a href="#NULL-与-nullptr-的区别" class="headerlink" title="NULL 与 nullptr 的区别"></a>NULL 与 nullptr 的区别</h1><p>NULL 为宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure><p>NULL的类型不明显，而一下情况会出现函数重载不明确的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用函数不确定，编译器警告或报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>nullptr</code>是一个特殊类型(<code>nullptr_t</code>)专门用来指代空指针。见下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;  <span class="comment">///&lt; #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125; <span class="comment">///&lt; #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 明确调用#2函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(1)</title>
      <link href="/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/"/>
      <url>/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/</url>
      
        <content type="html"><![CDATA[<p>《Effective Modern C++》读书笔记中，作者详细讲解了C++11&#x2F;14中<code>std::move</code>与<code>std::forward</code>的使用。<code>T&amp;&amp;</code>在模板中有两种含义：右值引用和万能引用。万能引用可用于完美转发，但需谨慎使用<code>std::move</code>和<code>std::forward</code>，避免意外的左值改动。完美转发可能在大括号初始化、重载函数名、模板名及位域传参时失败。位域传参需传递副本。本文通过代码示例，深入探讨右值引用、万能引用的特性及其在实际应用中的注意事项，帮助读者更好地理解和应用现代C++特性。</p><span id="more"></span><h1 id="《Effective-Modern-C-》读书笔记-1"><a href="#《Effective-Modern-C-》读书笔记-1" class="headerlink" title="《Effective Modern C++》读书笔记(1)"></a>《Effective Modern C++》读书笔记(1)</h1><p>在运行期， <code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>(); <span class="comment">///&lt; 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; 非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span>  <span class="comment">///&lt; 右值引用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span> <span class="comment">///&lt; 非右值引用</span></span></span><br></pre></td></tr></table></figure><p><code>T&amp;&amp;</code>有两种不同的含义</p><ol><li>右值引用</li><li>表示既可以是右值引用也可以是左值引用</li></ol><p>万能引用会在两个地方现身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">///&lt; param是个万能引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; var2是个万能引用</span></span><br></pre></td></tr></table></figure><p>而不涉及型别推导<code>&amp;&amp;</code>就是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 不涉及型别推导</span></span><br></pre></td></tr></table></figure><p><code>const</code>关键字也可以确定<code>const T&amp;&amp;</code>是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>在一个模板中的<code>T&amp;&amp;</code>也不一定是万能引用， 见下面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为<code>push_back</code>是<code>vector</code>的成员函数， 如果<code>vector</code>实例存在的话就一定有确定的类型，所以并不存在型别推导。</p><p>另外，声明<code>auto&amp;&amp;</code>都是万能引用。</p><p>针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></p><p>当转发右值引用给其他函数是，应当对其实施向右值的无条件强制型别转换(通过<code>std::move</code>)，因为它们一定绑定到右值，而当转发万能引用时，应当对其实施向右值的有条件强制型别转换(通过<code>std::forward</code>), 因为它们不一定绑定到右值。<br>应当避免针对右值引用实施<code>std::forward</code>。而另一方面，针对万能引用使用<code>std::move</code>的想法更为糟糕，因为那样做的后果是某些左值会遭到意外改动(例如某些临时变量)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(newName);  <span class="comment">///&lt; 可以编译但糟糕透顶</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;  <span class="comment">///&lt; 工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>(); <span class="comment">///&lt; n是个局部变量</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">setName</span>(n); <span class="comment">///&lt; 将n移入了w</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">///&lt; n的值变得未知了</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ... <span class="comment">///&lt; 对w进行操作</span></span><br><span class="line">  <span class="keyword">return</span> w; <span class="comment">///&lt; 没有任何东西被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(w);  <span class="comment">///&lt; 将w移入返回值, 千万不要这么做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RVO</code>(return value optimization): 编译器若要在一个按值返回的函数里省略对局部对象的复制（或者移动）, 则需要满足两个前提条件： 1. 局部对象型别和函数返回值型别相同. 2. 返回的就是局部对象本身。即使实施<code>RVO</code>的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。当<code>RVO</code>的前提条件允许时，要么发生复制省略，要么<code>std::move</code>隐式地被实施于返回的局部对象。</p><ul><li>针对右值引用的最后一次使用实施<code>std::move</code>, 针对万能引用的最后一次使用实施<code>std::forward</code>。</li><li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行动。</li><li>若局部对象可能适用于返回值优化，则请勿针对其实施<code>std::move</code>或<code>std::forward</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::<span class="built_in">is_integral</span>&lt;T&gt;());  <span class="comment">///&lt; std::is_integral不够正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::is_integral&lt;&gt;</code>不够正确是因为如果传给万能引用<code>name</code>实参是个左值，那么<code>T</code>就会被推导为左值引用。因为<code>int&amp;</code>不是<code>int</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美转发的含义是我们不仅转发对象，还转发其显著特征：型别、左值还是右值，以及是否带有<code>const</code>和<code>volation</code>饰词等等。</p><p>大括号初始化物<br>假设<code>f</code>的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std:vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure><p>在此情况下，以大括号初始化物调用<code>f</code>可以通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>但如果把同一大括号初始化物的运用，就是一种完美转发失败的情形。编译器采用推导的手法来取得传递给<code>fwd</code>实参的型别结果，而后它会比较推导型别结果和<code>f</code>声明的形参型别。完美转发会在下面两个条件中的任何一个成立时失败：</p><ul><li>编译器无法为一个或多个<code>fwd</code>的形参推导出型别结果。编译器无法编译通过。</li><li>编译器为一个或多个<code>fwd</code>的形参推导出了”错误的”型别结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(Widget::MinVals); <span class="comment">///&lt; 没问题, 当f(28)处理</span></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals); <span class="comment">///&lt; 错误，无法链接</span></span><br></pre></td></tr></table></figure><p>无法链接的原因是，完美转发，转发的是入参(<code>Widget::MinVals</code>)的引用，而引用在编译器底层是指针实现的。由于<code>static</code>变量并没有被分配实际的地址，所以产生了链接错误。</p><p>完美转发的失败情形还包括：重载的函数名字和模板名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">///&lt; 一个接受函数指针入参的函数f</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 然后调用</span></span><br><span class="line"><span class="built_in">f</span>(processVal);</span><br></pre></td></tr></table></figure><p>上面在调用函数<code>f</code>的时候，其中<code>processVal</code>仅仅只是函数的名字，但编译器知道匹配的是单入参版本的函数。</p><p>而使用完美转发时，编译器是无法知道使用的是什么版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(processVal);  <span class="comment">///&lt; 编译不过</span></span><br></pre></td></tr></table></figure><p>最后一种完美转发失败的情形是位域被用作函数实参的时候。<br>标准中：非<code>const</code>引用不得绑定到位域。既然没有办法创建指涉到任意比特的指针(C++标准规定，可以指涉的最小实体是单个char)，那自然没有办法把引用绑定到任意比特上了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPV4Header</span> &#123;</span><br><span class="line">  std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">  IHL:<span class="number">4</span>,</span><br><span class="line">  DSCP:<span class="number">6</span>,</span><br><span class="line">  ECN:<span class="number">2</span>,</span><br><span class="line">  totalLength:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength); <span class="comment">///&lt; 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(h.totalLength); <span class="comment">///&lt; 错误！</span></span><br></pre></td></tr></table></figure><p>把位域传递给完美转发函数的关键，就是利用转发目的函数接收的总是位域值的副本这一事实。可以自己复制一份，并以该副本调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"><span class="built_in">fwd</span>(length);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ lambda表达式</title>
      <link href="/2020/12/09/2020-12-09-C++%20lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/12/09/2020-12-09-C++%20lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>C++11引入的lambda表达式提供了按引用和按值两种捕获模式。在使用按引用捕获时，需警惕空悬引用问题，即闭包内的引用可能指向已销毁的局部变量或形参。</p><p>按值捕获虽然避免了空悬引用，但在捕获类成员时，仅捕获<code>this</code>指针的副本，而非成员变量的副本。lambda表达式不能捕获<code>static</code>变量，只能按引用使用。</p><p>相比于<code>std::bind</code>，lambda表达式更灵活，特别是在处理函数重载和延迟计算时，lambda表达式更具优势，建议优先使用。</p><span id="more"></span><p>C++11 中有两种捕获模式： 按引用和按值。按引用的默认捕获模式可能导致空悬引用，按值的默认捕获模式也无法对空悬引用免疫，而且会让你认为你的闭包是独立的(事实上它们可能不是独立的)。</p><p>按引用捕获会导致闭包包含指涉到局部变量的引用，或者指涉到定义<code>lambda</code>式的作用域内的形参的引用。一旦由<code>lambda</code>式所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会空悬。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">  vec.<span class="built_in">push_back</span>([&amp;](<span class="type">int</span> val)&#123; <span class="keyword">return</span> val / divisor;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> lamdba = vec.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">lambda</span>(<span class="number">1</span>);  <span class="comment">///&lt; 此处可能会出现空悬引用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会觉得如果把上面的按引用捕获换为按值捕获这样的空悬引用就不会出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;&gt; vec;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>([=](<span class="type">int</span> val)&#123; <span class="keyword">return</span> val / divisor;&#125;);  <span class="comment">///&lt; 这里是引用捕获</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>  divisor = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用捕获只能针对于在创建<code>lambda</code>式的作用域内可见的非静态局部变量（包括形参）；</p><p>上面代码等价于这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>([=](<span class="type">int</span> val)&#123; <span class="keyword">return</span> val / divisor;&#125;);</span><br><span class="line">    <span class="comment">/// 等价于下面这句</span></span><br><span class="line">    <span class="comment">/// vec.push_back([this](int val)&#123; return val / this-&gt;divisor;&#125;);</span></span><br><span class="line">    <span class="comment">/// 默认捕获列表捕获的是this的副本，而不是divisor的副本</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>  divisor = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lambda</code>表达式同样不能捕获<code>static</code>变量， 在<code>lambda</code>表达式中使用<code>static</code>变量只能是按引用。</p><h3 id="lambda-表达式与-std-bind-优先选用lambda"><a href="#lambda-表达式与-std-bind-优先选用lambda" class="headerlink" title="lambda 表达式与 std::bind 优先选用lambda"></a>lambda 表达式与 std::bind 优先选用lambda</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm, steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h, _1, <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>在创建setSoundB这函数对象的时候，通过<code>std::bind</code>去创建的时候<code>steady_clock::now()</code>已经进行了计算，而不是在调用时刻进行计算，<br>同样在具有函数重载的情况时，<code>std::bind</code>接收的只是函数名称无法参与函数重载的判断，会导致编译不过。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(4)</title>
      <link href="/2020/11/05/2020-11-04-%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/"/>
      <url>/2020/11/05/2020-11-04-%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/</url>
      
        <content type="html"><![CDATA[<p>在《C++ 并发编程实战》读书笔记中，作者介绍了屏障和无锁数据结构的概念。屏障（或内存障碍）用于强制内存顺序，确保某些操作的执行顺序不被编译器或硬件重排。无锁数据结构允许多个线程并发访问，避免了传统锁机制带来的阻塞问题。无锁数据结构具有更高的并发性和健壮性，但可能导致活锁或降低整体性能。通过代码示例，作者展示了如何实现无锁栈数据结构，并讨论了其优缺点。理解并应用这些并发编程技术，可以显著提高程序的性能和可靠性。</p><span id="more"></span><h2 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h2><p>屏障的这些操作可以强制内存顺序约束，而无需修改任何数据，并且与使用<code>memory_order_relaxed</code>顺序约束的原子操作组合起来使用。屏障是全局操作，能在执行该屏障的线程里影响其他原子操作的顺序。<br>屏障一般也被称为内存障碍(memory barriers), 它们之所以这样命名, 是因为他们在代码中放置了一行代码，是的特定的操作无法穿越。<br>在独立变量上的松散操作通常可以自由地被编译器或硬件重新排序。屏障限制了这一自由，并且在之前并不存在的地方引入<code>happens-before</code>和<code>synchronizes-with</code>关系。</p><p>松散操作可以使用平常排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_relaxed);</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h2><p>数据结构的线程安全的基本原理</p><ul><li>保证当数据结构不变性被别的线程破坏时的状态不被任何别的线程看到。</li><li>注意避免数据结构结构所固有的竞争现象，通过为完整操作提供函数，而不是提供操作步骤。</li><li>注意当出现例外时，数据结构是怎么样来保证不变性不被破坏。</li><li>当使用数据结构时，通过限制锁的范围和避免使用嵌套锁，来降低产生死锁的机会。</li></ul><p>第二个要考虑的是实现真正的并发读取</p><ul><li>锁的范围能否被限定，使得一个操作的部分可以在锁外被执行？</li><li>数据结构的不同部分能否被不同的互斥元保护？</li><li>能否所有操作需要同样级别的保护？</li><li>数据结构的一个小改变能否在不影响操作语义情况下提高并发机会？</li></ul><h3 id="无锁数据结构："><a href="#无锁数据结构：" class="headerlink" title="无锁数据结构："></a>无锁数据结构：</h3><p>对于有资格称为无锁的数据结构,就必须能够让多于一个线程可以并发的访问此数据结构。这些线程不需要做相同的操作，无所队列可以允许一个线程push的同时，另一个线程pop，到那时如果两个吸纳成同时试图插入新数据的时候，就会打破无锁队列。不仅如此，如果一个访问数据结构的线程在操作中途被调度器挂起的话别的线程必须仍然能够完成操作而无需等待挂起的线程。</p><h4 id="无等待数据结构"><a href="#无等待数据结构" class="headerlink" title="无等待数据结构"></a>无等待数据结构</h4><p>无等待的数据结构是一种无锁的数据结构，并且有着额外的特性，每个访问数据结构的线程都可以在有限数量的步骤内完成它的操作，而不用管别的线程的行为，因为其他线程的冲突而可能卷入无限次重试的算法不是无等待。<br>为了确保每个线程都能够在有限步骤内完成它的操作，就必须保证每个操作都可以在一个操作周期内执行，并且一个线程执行的操作不会导致另一个线程上操作的失败。</p><h4 id="无锁数据结构的优点与缺点"><a href="#无锁数据结构的优点与缺点" class="headerlink" title="无锁数据结构的优点与缺点"></a>无锁数据结构的优点与缺点</h4><p>使用无锁数据结构的最主要的原因就是为了实现最大程度的并发。对于基于锁的容器，总是有可能一个线程必须阻塞，并在可以继续前等待另一个线程完成其操作。互斥元锁的目的就是通过互斥来阻止并发。<br>使用无锁数据结构的第二个原因是健壮性。当一个线程在持有锁的时候终止，哪个数据结构就永远被破坏了。但是如果一个线程在操作无所数据结构时终止了，就不会丢失任何数据。</p><p>因为不使用任何锁，因此无锁数据结构是不会发生死锁的，尽管有可能存在活锁.<br>当两个线程都试图修改数据结构，但是对于每个线程来说，另一个线程所作的修改都会要求此线程的操作重新被执行，因此这两个线程都会一直循环和不断尝试，在这种情况下就会发生活锁。除非某个线程先到达（通过协议，通过更快或完全靠运气）, 不然此循环会一直继续下去。活锁通常是短暂的，因为它们取决于线程的精确调度，因此活锁会降低性能而不会导致长期问题。<br>这就是无锁数据结构的缺点，尽管它可以增加在数据结构上操作的并发能力，并且减少了线程等待的时间，但是它可能降低整体性能。首先，无锁代码使用的原子操作可能比非原子操作要慢很多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    node* next;</span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_) : <span class="built_in">data</span>(data_) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::atomic&lt;node*&gt; head;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span></span>&#123;</span><br><span class="line">    node* <span class="type">const</span> new_node = <span class="keyword">new</span> <span class="built_in">node</span>(data);</span><br><span class="line">    new_node-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(new_node-&gt;next, new_node));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; result)</span></span>&#123;</span><br><span class="line">    node* old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next));</span><br><span class="line">    result = old_head-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; threads_in_pop;</span><br><span class="line">  std::atomic&lt;node*&gt; to_be_deleted;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">try_reclaim</span><span class="params">(node* old_head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threads_in_pop == <span class="number">1</span>) &#123;</span><br><span class="line">      node* nodes_to_delete = to_be_deleted.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (!--threads_in_pop) &#123;</span><br><span class="line">        <span class="built_in">delete_nodes</span>(nodes_to_delete);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodes_to_delete) &#123;</span><br><span class="line">        <span class="built_in">chanin_pending_nodes</span>(nodes_to_delete);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nodes) &#123;</span><br><span class="line">      node* next = nodes-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> nodes;</span><br><span class="line">      nodes = next;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++threads_in_pop;</span><br><span class="line">    node* old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span> (old_head &amp;&amp; !head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next));</span><br><span class="line">    std::shared_ptr&lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">      res.<span class="built_in">swap</span>(old_head-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">try_reclaim</span>(old_head);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(3)</title>
      <link href="/2020/11/04/2020-11-04%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/"/>
      <url>/2020/11/04/2020-11-04%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/</url>
      
        <content type="html"><![CDATA[<p>在C++中的多线程编程中，<code>synchronizes-with</code>关系用于确保线程间的同步，主要通过原子操作实现。</p><p><code>happens-before</code>关系则用于定义操作的执行顺序，确保一个操作的结果在另一个操作之前可见。原子操作的内存顺序有六种：<code>memory_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>和<code>memory_order_seq_cst</code>。</p><p>其中，<code>memory_order_seq_cst</code>提供最严格的顺序一致性，而<code>memory_order_relaxed</code>则允许最大程度的重排序。</p><p>获取-释放顺序在同步线程间数据时提供了一种平衡性能和一致性的方式。通过合理选择内存顺序，可以在性能和线程安全之间找到最佳平衡。本文通过代码示例详细解释了这些概念的应用和区别。</p><span id="more"></span><h2 id="synchronizes-with关系"><a href="#synchronizes-with关系" class="headerlink" title="synchronizes-with关系"></a>synchronizes-with关系</h2><p><code>synchronizes-with</code> 关系是你只能在原子类型上的操作之间得到的东西。如果一个数据结构包含原子类型，并且在该数据结构上的操作会内部执行适当的原子操作，该数据结构上的操作（如锁定互斥元）可能会提供这种关系，但是从根本上说<code>synchronizes-with</code>关系只出自原子类型上的操作。</p><p>基本思想： 在一个变量<code>x</code>上的一个被适当标记的原子写操作<code>w</code>， 与在<code>x</code>上的一个被适当标记的，通过写入<code>(W)</code>，或是由与执行最初的写操作<code>W</code>相同的线程在<code>x</code>上的后续原子写操作，或是由任意线程在<code>x</code>上一系列的原子的读-修改-写操作（<code>fetch_add()</code>或<code>compare_exchange_weak()</code>）来读取所存储的值的原子读操作同步，其中随后通过第一个线程读取的值是通过<code>W</code>写入的值。<br>换个说法：如果线程A存储一个值而线程B读取该值，那么线程A中存储和线程B中的载入之间存在一种<code>synchronizes-with</code>关系。</p><h2 id="happens-before-关系"><a href="#happens-before-关系" class="headerlink" title="happens-before 关系"></a>happens-before 关系</h2><p><code>happens-before</code>(发生于之前)关系是程序中操作顺序的基本构件，它指定了哪些操作看到其他操作的结果。对于单个线程，它是直观的，如果一个操作排在另一个操作之前，那么该操作就发生于另一个操作之前。这就意味着，如果一个操作（A）发生于另一个操作(B)之前的语句里，那么A就发生于B之前。</p><p>有时候，单条语句中的操作是有顺序的，例如使用内置的逗号操作符或者使用一个表达式的结果作为另一个表达式的参数。<br>但一般来说，单条语句中的操作是非顺序的，而且也没有<code>sequenced-before</code>（因此也没有<code>happens-before</code>）.当然，一条语句的所有操作在下一句的所有操作之前发生。<br>对于多线程中，如果线程间的一个线程上的操作A发生于另一个线程上的操作B之前，那么A发生于B之前。</p><h2 id="原子操作的内存顺序"><a href="#原子操作的内存顺序" class="headerlink" title="原子操作的内存顺序"></a>原子操作的内存顺序</h2><p>有六种内存顺序选项可以应用到原子类型上的操作：</p><ul><li>memory_order_relaxed</li><li>memory_order_consume</li><li>memory_order_acquire</li><li>memory_order_release</li><li>memory_order_acq_rel</li><li>memory_order_seq_cst</li></ul><p>除非你为某个特定的操作做出指定，原子类型上的所有操作的内存顺序选项都是<code>memory_order_seq_cst</code>, 这是最严格的可用选项。</p><p>尽管有六种选项，它们其实代表了三种模型：</p><ul><li>顺序一致(sequentially consistent)顺序(<code>memory_order_seq_cst</code>)</li><li>获得-释放(acquire_release)顺序(<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>和<code>memory_order_acq_rel</code>)</li><li>松散(relaxed)顺序(<code>memory_order_relaxed</code>)<br>这些不同的内存顺序模型在不同的CPU架构上可能有着不同的成本。<br>例如：在基于具有通过处理器而非做更改者对操作的可见性进行良好的控制架构上的系统中，<br>顺序一致的顺序相对于获取-释放顺序或松散顺序，可能会要求额外的同步指令。<br>获取-释放相对于松散顺序，可能会要求额外的同步指令。</li></ul><p>如果这些系统拥有很多处理器，这些额外的同步指令可能占据显著的时间量，从而降低该系统的整体性能。<br>另一方面，为了确保原子性，对于超出需要的获得&#x3D;释放排序，使用x86或x86-64架构的CPU不会要求额外的指令，甚至对于载入操作，顺序一致顺序不需要任何特殊的处理，尽管在存储时会有一点额外的成本。</p><p>不同的内存顺序模型的可用性，允许高手们利用更细粒度的顺序关系来提升性能，在不太关键的情况下，当允许使用默认的顺序一致顺序时，它们是有优势的。</p><h3 id="1-顺序一致顺序"><a href="#1-顺序一致顺序" class="headerlink" title="1. 顺序一致顺序"></a>1. 顺序一致顺序</h3><p>默认的顺序被命名为顺序一致(<code>sequentially consistent</code>), 因为这意味着程序的行为与一个简单的顺序的世界观时一致的。<br>如果所有原子类型实例上的操作时顺序一致的，多线程程序的行为，就好像是所有这些操作由单个线程以某种特定的顺序执行一致的，多线程程序的行为，就好像是所有这些操作由单个线程以某种特定的顺序进行执行一样。<br>这意味着如果你的代码在一个线程中有一个操作在另一个之前，其顺序必须对所有其他的线程可见。<br>从同步的观点来看，顺序一致的存储与读取该存储值的同一个变量的顺序一致载入是同步的。这提供了一种两个（或多个）线程操作的顺序约束，但顺序一致比它更加强大。<br>在使用顺序一致原子操作的系统中，所有在载入后完成的顺序一致原子操作，也必须出现在其他线程的存储之后。该约束并不会推荐使用具有松散内存顺序的原子操作，它们仍然可以看到操作处于不同的顺序，所以你必须在所有的线程上使用顺序一致的操作。<br>但易于理解就产生了代价，在一个带有许多处理器的弱顺序机器上，他可能导致显著的性能惩罚，因为操作的整体顺序必须与处理器之间保持一致，可能需要处理器之间密集且昂贵的同步操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line"></span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">  d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">///&lt; 这里永不触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序一致时最直观和直觉的排序，但也是最昂贵的内存顺序，因为它要求所有线程之间的全局同步。在多处理器系统中，这可能需要处理器之间相当密集和耗时的通信。</p><h3 id="2-非顺序一致的内存顺序"><a href="#2-非顺序一致的内存顺序" class="headerlink" title="2. 非顺序一致的内存顺序"></a>2. 非顺序一致的内存顺序</h3><p>时间不再有单一的全局顺序，这意味着不同的线程可能看到相同的操作的不同方面。你不仅得考虑事情真正的并行发生，而且线程不必和事件的顺序一致。<br>即使线程正在运行完全相同的代码，由于其他线程中的操作没有明确的顺序约束，它们可能与时间的顺序不一致，因为不同的CPU缓存和内部缓冲区可能为相同的内存保存了不同的值。<br>在没有其他的顺序约束时，唯一的要求是所有的线程对每个独立变量的修改顺序达成一致。</p><h3 id="3-松散顺序"><a href="#3-松散顺序" class="headerlink" title="3. 松散顺序"></a>3. 松散顺序</h3><p>以松散顺序执行的原子类型上的操作不参与<code>synchronzes-with</code>关系。单线程中的同一个变量的操作仍然服从<code>happens-before</code>关系，但对于其他线程的顺序几乎没有任何要求。唯一的要求是，从同一个线程对单个原子变量的访问不能被重排，一旦给定的线程看到了原子变量的特定值，该线程之后的读取就不能获取该变量更早的值。<br>在没有任何线程同步的情况下，每个变量的修改顺序时使用<code>memory_order_relaxed</code>的线程之间唯一共享的东西。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line"></span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">///&lt; 可能会触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>assert</code>可以触发，因为x的载入能够读到false，即使y的载入读到了true，并且x的存储发生于y存储之前。x和y是不同的变量，所以关于每个操作所产生的值的可见性没有顺序保证。</p><p>不同变量的松散操作可以被自由地重排前提是它们服从所有约束下的<code>happens-before</code>关系（例如在同一个线程中）。<br>它们并不引入<code>synchronizes-with</code>关系。即便在存储操作中存在<code>happens-before</code>关系，但任一存储和任一载入之间却不存在，所以载入可以在顺序之外看到存储。</p><h3 id="4-获取-释放顺序"><a href="#4-获取-释放顺序" class="headerlink" title="4. 获取-释放顺序"></a>4. 获取-释放顺序</h3><p>获取-释放顺序是松散顺序的进步，操作仍然没有总的顺序，但的确引入了一些同步。在这用顺序模型下，原子载入时获取操作(<code>memory_order_acquire</code>)，原子存储时释放操作(<code>memory_order_release</code>), 原子的读-修改-写操作是获取、释放或两者兼备(<code>memory_order_acq_rel</code>)。同步在进行释放的线程和进行获取的线程之间是对偶的。释放操作与读取写入值的获取操作同步。这意味着，不同的线程仍然可以看到不同的排序，但这些顺序是受到限制的</p><h3 id="5-使用获取-释放顺序和MEMORY-ORDER-CONSUME的数据依赖"><a href="#5-使用获取-释放顺序和MEMORY-ORDER-CONSUME的数据依赖" class="headerlink" title="5. 使用获取-释放顺序和MEMORY_ORDER_CONSUME的数据依赖"></a>5. 使用获取-释放顺序和MEMORY_ORDER_CONSUME的数据依赖</h3><p>有两个处理数据历来的新的关系：依赖顺序在其之前(dependency-ordered-before)和带有对其的以来(carries-a-dependency-to)。<br>与<code>sequenced-before</code>相似，<code>carries-a-dependency-to</code>严格适用于的单个线程之内，是操作间数据以来的基本模型。如果操作A的结果被用于操作B的操作数，那么A带有对B的依赖。如果操作A的结果是类似int的标量类型的值，那么如果A的结果存储一个变量中，并且该变量随后被用作操作B的操作数，此关系也是适用的。这种操作具有传递性，所以如果A带有对B的以来且B带有对C的依赖，那么A带有对C的依赖。</p><p>另一方面，<code>depency-order-before</code>的关系可以适用于线程之间。它是通过使用标记了<code>memory_order_consume</code>的原子载入操作引入的。<br>这是<code>memory_order_acquire</code>的一种特例，它限制了对直接依赖的数据同步。标记为<code>memroy_order_release</code>、<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>的存储操作A的依赖顺序在标记为<code>memory_order_acquire</code>，那么这与<code>synchronizes-with</code>关系所得到的是相反的。如果操作B带有对操作C的某种依赖，那么A也是依赖顺序在C之前。</p><p>如果这对线程间<code>happens-before</code>关系没有影响，那么在同步目的上就无法为你带来任何好处，但它的却实现了：如果A依赖顺序在B之前，则A也是线程间发生于B之前。</p><p>这种内存顺序的一个重要用途，是在原子操作载入指向某数据的指针的场合。通过在载入上使用<code>memory_order_consume</code>以及在之前的存储上使用<code>memory_order_release</code>, 你可以确保所指向的数据得到正确的同步，无需在其他非依赖的数据上强加任何同步需求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  std::string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;X*&gt; p;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X* x = <span class="keyword">new</span> X;</span><br><span class="line">  x-&gt;i = <span class="number">42</span>;</span><br><span class="line">  x-&gt;s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  a.<span class="built_in">store</span>(<span class="number">99</span>, std::memory_order_relaxed);</span><br><span class="line">  p.<span class="built_in">store</span>(x, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X* x;</span><br><span class="line">  <span class="keyword">while</span> (!(x = p.<span class="built_in">load</span>(std::memory_order_consume))) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(x-&gt;i == <span class="number">42</span>);</span><br><span class="line">  <span class="built_in">assert</span>(x-&gt;s == <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="built_in">assert</span>(a.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">99</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(use_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(create_x)</span></span>;</span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ std::visit介绍</title>
      <link href="/2020/11/03/2020-11-03-C++%20visit%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/11/03/2020-11-03-C++%20visit%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>本文深入探讨了C++中的<code>std::visit</code>及其在变体类型（<code>std::variant</code>）中的应用。通过多个示例，展示了如何使用<code>std::visit</code>访问变体类型中的值，并介绍了如何通过重载的<code>operator()</code>实现多态行为。文章还展示了如何利用模板和宏简化<code>std::visit</code>的使用，使其更加灵活和易读。核心代码片段展示了如何通过<code>overload</code>结构体和宏封装实现类型匹配和访问，为处理复杂变体类型提供了高效的工具。本文为C++开发者提供了实用的技巧，帮助他们在实际项目中更好地使用<code>std::visit</code>。</p><span id="more"></span><p>见一个简单的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> d)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">var1</span><span class="params">(<span class="number">42</span>)</span>, <span class="title">var2</span><span class="params">(<span class="number">3.14</span>)</span>, <span class="title">var3</span><span class="params">(<span class="string">&quot;visit&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var1); <span class="comment">// calls operator() for matching int type</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var2); <span class="comment">// calls operator() for matching double type</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var3); <span class="comment">// calls operator() for matching std::string type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看官网给的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the variant to visit</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">var_t</span> = std::variant&lt;<span class="type">int</span>, <span class="type">long</span>, <span class="type">double</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helper type for the visitor #4</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">overloaded</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">var_t</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">15l</span>, <span class="number">1.5</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">    <span class="comment">/// 1. void visitor, only called for side-effects(here, for I/O)</span></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;std::cout &lt;&lt; arg; &#125;, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 2. value-returning visitor, demonstrates the idiom of returning another variant</span></span><br><span class="line">    <span class="type">var_t</span> w = std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg)-&gt;<span class="type">var_t</span> &#123;<span class="keyword">return</span> arg + arg; &#125;, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 3. type-matching visitor: a lambda that that handles each type differently.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;. After doubling, variant holds.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std:<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;int with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">long</span>&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;long with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;double with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;std::string with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">static_assert</span>(always_false_v&lt;T&gt;, <span class="string">&quot;non-exhaustive visitor!&quot;</span>);</span><br><span class="line">    &#125;, w);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">    <span class="comment">/// 4. another type-matching visitor: a class with 3 overloaded operator()&#x27;s</span></span><br><span class="line">    std::<span class="built_in">visit</span>(overloaded&#123;</span><br><span class="line">      [](<span class="keyword">auto</span> arg) &#123;std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;,</span><br><span class="line">      [](<span class="type">double</span> arg) &#123;std::cout &lt;&lt; std::fixed &lt;&lt; arg &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;,</span><br><span class="line">      [](<span class="type">const</span> std::string arg) &#123;std::cout &lt;&lt; std::<span class="built_in">quoted</span>(arg) &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;,</span><br><span class="line">      &#125;, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最为核心的代码片段为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="keyword">struct</span> <span class="title class_">overload</span> : Fs... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Fs::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="title">overload</span><span class="params">(Fs...)</span> -&gt; overload&lt;Fs...&gt;</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">visit</span>(overload</span><br><span class="line">&#123;</span><br><span class="line">    [](<span class="type">int</span> x)&#123; ... &#125;,</span><br><span class="line">    [](<span class="type">long</span> x)&#123; ... &#125;,</span><br><span class="line">    [](<span class="keyword">auto</span>...)&#123; ... &#125;</span><br><span class="line">&#125;, v);</span><br></pre></td></tr></table></figure><p>使用宏封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="keyword">struct</span> <span class="title class_">overload</span> :Fs... &#123;<span class="function"><span class="keyword">using</span> <span class="title">Fs::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="title">overload</span><span class="params">(Fs...)</span>-&gt;overload&lt;Fs...&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matcher</span> &#123;</span><br><span class="line">  std::tuple&lt;Ts...&gt; vs;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Vs&gt; <span class="keyword">constexpr</span> <span class="title">matcher</span><span class="params">(Vs&amp;&amp;... vs)</span> : vs(std::forward&lt;Vs&gt;(vs)...) &#123;</span>&#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Fs</span>&gt; <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>-&gt;*(Fs&amp;&amp; f) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> curry = [&amp;](<span class="keyword">auto</span>&amp;&amp;... vs) &#123;<span class="keyword">return</span> std::<span class="built_in">visit</span>(std::forward&lt;Fs&gt;(f), vs...); &#125;;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">apply</span>(curry, std::<span class="built_in">move</span>(vs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="title">matcher</span><span class="params">(Ts&amp;&amp;...)</span>-&gt;matcher&lt;Ts&amp;&amp;...&gt;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Match(...) matcher&#123;__VA_ARGS__&#125;-&gt;* overload</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt;&gt; vec&#123;<span class="number">1</span>, <span class="number">1.0</span>, <span class="string">&quot;ljslkfjskd&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : vec) &#123;</span><br><span class="line">    <span class="built_in">Match</span>(it) &#123;</span><br><span class="line">      [](<span class="keyword">auto</span>&amp;&amp; x) &#123;std::cout &lt;&lt; <span class="string">&quot;unknow type!&quot;</span> &lt;&lt; std::endl; &#125;,</span><br><span class="line">      [](<span class="type">int</span> x) &#123;std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;,</span><br><span class="line">      [](<span class="type">double</span> x) &#123;std::cout &lt;&lt; <span class="string">&quot;double: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(2)</title>
      <link href="/2020/11/03/2020-11-03%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
      <url>/2020/11/03/2020-11-03%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
      
        <content type="html"><![CDATA[<p>《C++ 并发编程实战》读书笔记(2)深入探讨了C++并发编程中的关键概念，包括条件变量的超时等待、线程启动的实现、内存模型、原子操作以及比较&#x2F;交换操作。核心内容包括：使用<code>std::condition_variable</code>实现超时等待、通过<code>std::packaged_task</code>启动线程、C++内存模型中的对象与内存位置关系、原子操作的不可分割性及其内存顺序语义，以及比较&#x2F;交换操作（<code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>）的应用场景与优化策略。本文为C++开发者提供了并发编程的实践指导，帮助编写高效、安全的并发代码。</p><span id="more"></span><h1 id="《C-并发编程实战》读书笔记-2"><a href="#《C-并发编程实战》读书笔记-2" class="headerlink" title="《C++ 并发编程实战》读书笔记(2)"></a>《C++ 并发编程实战》读书笔记(2)</h1><p>等待一个具有超时条件的条件变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condiiton_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> timeout = std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lk, timeout) == std::cv_status::timeout) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的启动线程的实现，不推荐实际使用， 因为创建一个线程时间成本很高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> A&gt;</span><br><span class="line">std::future&lt;std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type&gt;</span><br><span class="line"><span class="built_in">spawn_task</span>(F&amp;&amp; f, A&amp;&amp; a) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type result_type;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">(A&amp;&amp;)</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line">  <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), std::move(a))</span></span>;</span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>C++程序中的所有数据均是<code>对象(object)</code>组成的。这并不是说你可以创建一个派生自<code>int</code>的新类，或是基本类型具有成员函数。这只是一句关于C++中数据的构造块的一种陈述。C++标准定义对象那个为存储区域，尽管它会为这些对象分配属性，如它们的类型和生存周期。<br>无论什么类型，对象均被存储与一个或多个内存位置中。每个内存位置要么是一个标量类型的对象，比如<code>unsigned short</code>或<code>my_class*</code>, 要么是相邻位域的序列。如果使用位域，有非常重要的一点必须注意：虽然相邻的位域是不同的对象，但他们仍然算作相同的内存位置。</p><ul><li>每个变量都是一个对象，包括其他对象的成员。</li><li>每个对象占据至少一个内存位置。</li><li>如<code>int</code>或<code>char</code>这样的基本类型的变量恰好一个内存位置，不论其大小，即使它们相邻或是数组的一部分。</li><li>相邻的位域是相同内存位置的一部分。</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作是一个不可分割的操作。从系统中的任何一个线程中，你都无法观察到一个完成到一半的这种操作，他要么做完了要么没做完。</p><p>传统意义上，标准原子类型是不可复制且不可赋值的，因为它们没有拷贝构造函数和拷贝赋值运算符。但是，它们确实支持从相应的内置类型的赋值进行隐式转换并赋值。由于他是一个泛型类模板，操作只限为<code>load()</code>、<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。<br>在原子类型上的每一个操作均具有一个可选的内存顺序参数，它可以用来指定所需的内存顺序语义。顺序运算分为三种类型：</p><ul><li>存储（<code>store</code>）操作, 可以包括<code>memory_order_relaxed</code>、<code>memory_order_release</code>或<code>memory_order_seq_cst</code>顺序</li><li>载入(<code>load</code>)操作，可以包括<code>memory_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>或<code>memory_order_seq_cst</code>顺序。</li><li>读-修改-写(<code>read_modify_write</code>)操作， 可以包括<code>memory_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>顺序。<br>所有操作的默认顺序为<code>memory_order_seq_cst</code>。</li></ul><p>使用<code>std::atomic_flag</code>实现一个自旋锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock_mutex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">spinlock_mutex</span>():<span class="built_in">flag</span>(ATOMIC_FLAG_INIT)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  std::atomic_flag flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="根据当前值存储一个新值"><a href="#根据当前值存储一个新值" class="headerlink" title="根据当前值存储一个新值"></a>根据当前值存储一个新值</h2><p>这个新的操作被称为比较&#x2F;交换，它以<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>成员函数形式出现。<br>比较&#x2F;交换操作是是使用原子类型编程的基石，它比较原子变量值和所提供的期望值，<br>如果两者相等，则存储提供的期望值。<br>如果两者不等，则期望值更新为原子变量的实际值。<br>比较&#x2F;交换函数的返回类型为<code>bool</code>, 如果执行了存储即为<code>true</code>, 反之则为<code>false</code>。</p><p>对于<code>compare_exchange_weak()</code>,<br>即使原始值等于期望值也可能出现存储不成功，在这种情况下变量的值是不变的， <code>compare_exchange_weak()</code>的返回值为<code>false</code>。<br>这最有可能发生在缺少单个的比较并交换指令的机器上，此时处理器无法保证该操作被完成–这就是所谓的伪失败，因为失败的原因是时间的函数而不是变量的值。<br>由于<code>compare_exchange_weak()</code>可能会伪失败，它通常必须用在循环中。</p><p>另一方面，仅当实际值不等于<code>expected</code>值时<code>compare_exchange_strong()</code>才保证返回<code>false</code>。这样可以消除对循环的需求。</p><p>如果你想要改变变量，无论其初始值是多少， <code>expected</code>的更新就变得很有用，每次经过循环时，<code>excepted</code>被重新载入，因此如果没有其他线程在此期间修改其值，那么<code>compare_exchange_weak()</code>或<code>compare_exchange_strong()</code>的调用在下一次循环中应该是成功的。</p><p>如果计算待存储的值很简单，为了避免在<code>compare_exchange_weak()</code>可能会伪失败的平台上的双重循环，（于是<code>compare_exchange_strong</code>包含一个循环), 则使用<code>compare_exchange_weak()</code>可能是有好处的。另一方面，<br>如果计算待存储的值本身是耗时的，当<code>expected</code>值没有变化时，使用<code>compare_exchange_strong()</code>来避免被迫重新计算待存储的值可能时有意义的。对于<code>std::atomic&lt;bool&gt;</code>而言这并不重要，毕竟只有两个值，但对于较大的原子类型这会有所不同。</p><p>比较&#x2F;交换函数还有一点非同寻常，他们可以接受两个内存顺序参数。这就允许内存顺序的语义在成功和失败的情况下有所区别。对于一次成功调用具有<code>memory_order_acq_rel</code>语义而一次失败的调用有着<code>memory_order_relaxed</code>语义，这想必是极好的。一次失败的比较&#x2F;交换并不进行存储，因此它无法具有<code>memory_order_release</code>或<code>memory_order_acq_rel</code>语义。因此再失败时禁止提供这些值作为顺序。你也不应为失败提供比成功更严格的内存顺序。如果你希望<code>memory_order_acquire</code>或者<code>memory_order_seq_cst</code>作为失败的语义，你也必须为成功指定这些语义。</p><p>如果你没有为失败指定一个顺序，就会假定它与成功是相同的，除了顺序的<code>release</code>部分被除去：<code>memory_order_release</code>变成<code>memory_order_relaxed</code>, <code>memory_order_acq_rel</code>变成<code>memory_order_acquire</code>。如果你都没有指定，他们它们通常默认为<code>memory_order_seq_cst</code>， 这为成功和失败都提供了完整的序列顺序。以下对<code>compare_exchange_weak()</code>的两个调用时等价的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; b;</span><br><span class="line"><span class="type">bool</span> expected;</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected, <span class="literal">true</span>, memory_order_acq_rel, memory_order_acquire);</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(exprected, <span class="literal">true</span>, memory_order_acq_rel);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 快速排序的实现</title>
      <link href="/2020/11/02/2020-11-02-C++%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/11/02/2020-11-02-C++%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了快速排序的并行版实现，通过C++标准库中的<code>std::partition</code>和并行执行策略<code>std::execution::par</code>，实现了高效的并行排序。代码展示了如何随机选择枢轴元素，并通过分区操作将数组分为小于和大于枢轴的两部分，然后递归地对子数组进行排序。文章还强调了实现快速排序的两个关键要求：必须使用前进迭代器，且元素必须支持比较操作或重载<code>operator&lt;</code>。本文为C++开发者提供了并行排序的实用技巧，帮助提升排序算法的性能。</p><span id="more"></span><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序并行版实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIt&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">quick_sort</span><span class="params">(ForwardIt first, ForwardIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">decltype</span>(std::<span class="built_in">distance</span>(first, last)) temp = <span class="built_in">rand</span>() % std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">  <span class="keyword">auto</span> pivot = *std::<span class="built_in">next</span>(first, temp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> middle1 = std::<span class="built_in">partition</span>(std::execution::par, first, last, [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em)&#123;</span><br><span class="line">    <span class="keyword">return</span> em &lt; pivot;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> middle2 = std::<span class="built_in">partition</span>(std::execution::par, middle1, last, [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em)&#123;</span><br><span class="line">    <span class="keyword">return</span> !(pivot &lt; em);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">quick_sort</span>(first, middle1);</span><br><span class="line">  <span class="built_in">quick_sort</span>(middle2, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用要求：</p><ol><li>必须是前进迭代器</li><li>元素必须是可比较的，或有<code>operator&lt;</code>运算符重载</li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(1)</title>
      <link href="/2020/11/02/2020-11-02%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/"/>
      <url>/2020/11/02/2020-11-02%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/</url>
      
        <content type="html"><![CDATA[<p>本文深入探讨了C++并发编程中的关键技巧，包括使用<code>std::lock</code>和<code>std::lock_guard</code>避免死锁、通过固定顺序获取锁防止死锁、利用<code>std::unique_lock</code>实现灵活的锁管理，以及使用<code>std::call_once</code>实现线程安全的延迟初始化。文章还介绍了如何通过<code>std::condition_variable</code>实现线程间的数据等待与通知机制，展示了线程安全队列的实现。这些技巧为C++开发者提供了高效处理并发问题的实用工具，帮助编写更安全、更高效的多线程程序。</p><span id="more"></span><h1 id="《C-并发编程实战》读书笔记-1"><a href="#《C-并发编程实战》读书笔记-1" class="headerlink" title="《C++ 并发编程实战》读书笔记(1)"></a>《C++ 并发编程实战》读书笔记(1)</h1><p>在交换操作中使用<code>std::lock()</code>和<code>std::lock_guard</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd) : <span class="built_in">some_detail</span>(sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(&amp;lhs == &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      std::<span class="built_in">lock</span>(lhs.m, rhs.m);  <span class="comment">///&lt; 这一行执行完后，两个锁都已经加锁了</span></span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, std::adopt_lock)</span></span>; <span class="comment">///&lt; 获取这个锁便于函数执行完毕后再解锁</span></span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, std::adopt_lock)</span></span>;</span><br><span class="line">      <span class="built_in">swap</span>(lhs.some_detail, rhs.some_detail); <span class="comment">///&lt; 交换数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="避免死锁的提示"><a href="#避免死锁的提示" class="headerlink" title="避免死锁的提示"></a>避免死锁的提示</h2><ol><li><p>避免嵌套锁。<br>如果你已经持有一个锁，就别再获取其他锁, 原因很简单因为每个线程仅持有一个锁。如果需要获取多个锁，就使用<code>std::lock()</code>这样单个动作来执行。</p></li><li><p>在持有锁时，避免调用用户提供的代码。<br>因为代码是程序员写的，你不知道它会做什么。如果用户提供的代码也在获取一个锁的话，可能导致死锁。</p></li><li><p>以固定的顺序获取锁<br>如果你绝对需要获取两个或更多的锁，并且不能以<code>std::lock</code>的单个操作取得，次优的做法是在每个线程中以相同的顺序获取它们。<br>见下面例子定义的层级锁。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function">      : hierarchy_value_(value), previous_hierarchy_value_(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @name     lock</span></span><br><span class="line">  <span class="comment">/// @brief    用来锁定自己的函数，</span></span><br><span class="line">  <span class="comment">///           锁定顺序依照本线程中小的数值先锁定，到锁定大的数值</span></span><br><span class="line">  <span class="comment">///           如果顺序反过来则会抛出异常</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// @author   Lijiancong, pipinstall@163.com</span></span><br><span class="line">  <span class="comment">/// @date     2020-02-17 13:22:50</span></span><br><span class="line">  <span class="comment">/// @warning  线程安全</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    internal_mutex_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value_ = previous_hierarchy_value_;</span><br><span class="line">    internal_mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    <span class="keyword">if</span> (!internal_mutex_.<span class="built_in">try_lock</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex internal_mutex_;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchy_value_;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchy_value_;</span><br><span class="line">  <span class="comment">/// thread_local 变量会在每个线程都有一个实例</span></span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this_thread_hierarchy_value_ &gt;= hierarchy_value_) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previous_hierarchy_value_ = this_thread_hierarchy_value_;</span><br><span class="line">    this_thread_hierarchy_value_ = hierarchy_value_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在交换操作中使用<code>std::lock()</code>和<code>std::unique_lock</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd) : <span class="built_in">some_detail</span>(sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">firend <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(&amp;lhs == &amp; rhs) <span class="keyword">return</span>;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, std::defer_lock)</span></span>;  <span class="comment">///&lt; 获取并延迟(defer)锁定</span></span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, std::defer_lock)</span></span>;</span><br><span class="line">      std::<span class="built_in">lock</span>(lock_a, lock_b);  <span class="comment">///&lt; 锁定两个锁</span></span><br><span class="line">      <span class="built_in">swap</span>(lhs.some_detail, rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>std::call_once</code>的线程安全的类成员延迟初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  connection_info connection_details;</span><br><span class="line">  connection_handle connection;</span><br><span class="line"></span><br><span class="line">  std::once_flag connection_init_flag;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">open_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connection = connection_manager.<span class="built_in">open</span>(connection_details);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(connection_info <span class="type">const</span>&amp; connection_details_) : <span class="built_in">connection_details</span>(conection_details_) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="type">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);</span><br><span class="line">    connection.<span class="built_in">send_data</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> connection.<span class="built_in">receive_data</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>c++11</code>中，初始化被定义在只发生在一个线程上，并且其他线程不可以继续直到初始化完成，所以竞争条件仅仅在于哪个线程会执行初始化，而不会有更多别的问题。对于需要单一全局实例的场合，这可以用作<code>std::call_once</code>的替代品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>;</span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> my_class instance;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>std::condition_variable</code> 等待数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(threadsafe_queue <span class="type">const</span>&amp; other) &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">      data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">      data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">      value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">      data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">      <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">      data_queue.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU的简单实现</title>
      <link href="/2020/09/21/2020-09-21-C++%20LRU%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/09/21/2020-09-21-C++%20LRU%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了最近最少使用缓存（LRU）的简单实现。LRU缓存通过键值对存储数据，并在达到容量上限时删除最近最少使用的项目。文章详细展示了如何使用C++实现LRU缓存，包括<code>get</code>和<code>put</code>操作的核心逻辑。通过<code>std::list</code>和<code>std::unordered_map</code>的结合，实现了高效的数据访问和更新。本文为开发者提供了LRU缓存的实用实现方法，适合需要高效缓存管理的场景。</p><span id="more"></span><h2 id="LRU的简单实现"><a href="#LRU的简单实现" class="headerlink" title="LRU的简单实现"></a>LRU的简单实现</h2><p>最近最少使用缓存(LRU)，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 最近最少使用缓存(LRU)，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">max_size</span>(capacity) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///  获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(res != map.<span class="built_in">end</span>())&#123;</span><br><span class="line">        list.<span class="built_in">splice</span>(list.<span class="built_in">begin</span>(), list, res-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> res-&gt;second-&gt;second;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">      list.<span class="built_in">push_front</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">      <span class="keyword">if</span>(res != map.<span class="built_in">end</span>())&#123;</span><br><span class="line">        list.<span class="built_in">erase</span>(res-&gt;second);</span><br><span class="line">        map.<span class="built_in">erase</span>(res);</span><br><span class="line">      &#125;</span><br><span class="line">      map[key] = list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(map.<span class="built_in">size</span>() &gt; max_size)&#123;</span><br><span class="line">        <span class="keyword">auto</span> last = list.<span class="built_in">end</span>();</span><br><span class="line">        --last;</span><br><span class="line">        map.<span class="built_in">erase</span>(last-&gt;first);</span><br><span class="line">        list.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::list&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; map;</span><br><span class="line">    std::list&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; list;</span><br><span class="line">    <span class="type">int</span> max_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 跳表简单实现</title>
      <link href="/2020/09/20/2020-09-20-C++%20%E8%B7%B3%E8%A1%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/09/20/2020-09-20-C++%20%E8%B7%B3%E8%A1%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了跳表（Skiplist）的简单实现，跳表是一种高效的数据结构，支持快速查找、插入和删除操作。文章详细展示了跳表的C++实现代码，包括节点结构定义、搜索、添加和删除操作的逻辑。通过随机层级生成和多层链表结构，跳表在保持简单性的同时，提供了接近平衡树的性能。本文为C++开发者提供了跳表的实用实现方法，适合需要高效数据管理的场景。</p><span id="more"></span><h2 id="跳表简单实现"><a href="#跳表简单实现" class="headerlink" title="跳表简单实现"></a>跳表简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">int</span> i, Node *r, Node *d) : <span class="built_in">val</span>(i), <span class="built_in">right</span>(r), <span class="built_in">down</span>(d) &#123;&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *down;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Skiplist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &lt; target) &#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r_level &lt;= max_level &amp;&amp; (<span class="built_in">rand</span>() &amp; <span class="number">1</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">      ++r_level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r_level &gt; max_level) &#123;</span><br><span class="line">      max_level = r_level;</span><br><span class="line">      head = <span class="keyword">new</span> <span class="built_in">Node</span>(num, <span class="literal">nullptr</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    Node *last = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = max_level; l &gt;= <span class="number">1</span>; --l) &#123;</span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &lt; num) &#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= r_level) &#123;</span><br><span class="line">        cur-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(num, cur-&gt;right, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (last) &#123;</span><br><span class="line">          last-&gt;down = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        last = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = head;</span><br><span class="line">    <span class="type">bool</span> seen = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = max_level; l &gt;= <span class="number">1</span>; --l) &#123;</span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &lt; num) &#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val == num) &#123;</span><br><span class="line">        seen = <span class="literal">true</span>;</span><br><span class="line">        Node *temp = cur-&gt;right;</span><br><span class="line">        cur-&gt;right = cur-&gt;right-&gt;right;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> max_level = <span class="number">0</span>;</span><br><span class="line">  Node *head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 回调函数示例</title>
      <link href="/2020/09/19/2020-09-19-C++%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B/"/>
      <url>/2020/09/19/2020-09-19-C++%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C-回调函数示例"><a href="#C-回调函数示例" class="headerlink" title="C++ 回调函数示例"></a>C++ 回调函数示例</h2><p>简单示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">callback</span>(print);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>Enter: callback()</p><p>print()</p><p>Leave: callback()</p></blockquote><p>接下来我们把这两个函数放入类中实现，在调用的时候绑定函数名和其对应实例就可以按以上例子方法调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller control;</span><br><span class="line">  operation op;</span><br><span class="line">  <span class="comment">/// 绑定实例和对应的操作函数</span></span><br><span class="line">  <span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(&amp;operation::print, &amp;op);</span><br><span class="line">  control.<span class="built_in">callback</span>(f);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们把绑定函数对象的过程封装起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_print_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">bind</span>(&amp;operation::print, <span class="keyword">this</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller control;</span><br><span class="line">  operation op;</span><br><span class="line">  control.<span class="built_in">callback</span>(op.<span class="built_in">get_print_function</span>());</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(7)数据结构</title>
      <link href="/2020/08/31/2020-08-31-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/08/31/2020-08-31-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是不可变字节(<code>byte</code>)序列，其本身是一个符合结构.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  str unsafe.Pointer</span><br><span class="line">  <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头部指针指向字节数组，但没有<code>NULL</code>结尾。默认以<code>UTF-8</code>编码存储<code>Unicode</code>字符，字面量里允许使用十六进制、八进制和<code>UTF</code>编码格式。</p><blockquote><p>内置函数<code>len</code>返回字节数组长度，<code>cap</code>不接受字符串类型参数。</p></blockquote><p>字符串默认值不是<code>nil</code>, 而是<code>&quot;&quot;</code>.</p><p>使用<code>for</code>遍历字符串是，分<code>byte</code>和<code>rune</code>两种方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;<span class="comment">// byte</span></span><br><span class="line">s:=<span class="string">&quot;李建聪&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;<span class="comment">// rune: 返回数组索引号，以及Unicode字符</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///0: [æ]</span></span><br><span class="line"><span class="comment">///1: [</span></span><br><span class="line"><span class="comment">///2: []</span></span><br><span class="line"><span class="comment">///3: [å]</span></span><br><span class="line"><span class="comment">///4: [»]</span></span><br><span class="line"><span class="comment">///5: [º]</span></span><br><span class="line"><span class="comment">///6: [è]</span></span><br><span class="line"><span class="comment">///7: []</span></span><br><span class="line"><span class="comment">///8: [ª]</span></span><br><span class="line"><span class="comment">///0: [李]</span></span><br><span class="line"><span class="comment">///3: [建]</span></span><br><span class="line"><span class="comment">///6: [聪]</span></span><br></pre></td></tr></table></figure><p>要修改字符串，须将其转换为可变类型(<code>[]rune</code>或<code>[]byte</code>), 待完成后再转换回来。但不管怎么转换，都须重新分配内存，并复制数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(format <span class="type">string</span>, ptr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">p := reflect.ValueOf(ptr).Pointer()</span><br><span class="line">h := (*<span class="type">uintptr</span>)(unsafe.Pointer(p))</span><br><span class="line">fmt.Printf(format, *h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;<span class="comment">// byte</span></span><br><span class="line">s:=<span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">pp(<span class="string">&quot;s: %x\n&quot;</span>, &amp;s)</span><br><span class="line"></span><br><span class="line">bs := []<span class="type">byte</span>(s)</span><br><span class="line">s2 := <span class="type">string</span>(bs)</span><br><span class="line"></span><br><span class="line">pp(<span class="string">&quot;string to []byte, bs:%x\n&quot;</span>, &amp;bs)</span><br><span class="line">pp(<span class="string">&quot;[]byte to string, s2:%x\n&quot;</span>, &amp;s2)</span><br><span class="line"></span><br><span class="line">rs := []<span class="type">rune</span>(s)</span><br><span class="line">s3 := <span class="type">string</span>(rs)</span><br><span class="line"></span><br><span class="line">pp(<span class="string">&quot;string to []byte, rs:%x\n&quot;</span>, &amp;rs)</span><br><span class="line">pp(<span class="string">&quot;[]byte to string, s3:%x\n&quot;</span>, &amp;s3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// s: 2bcc91</span></span><br><span class="line"><span class="comment">/// string to []byte, bs:c0000a20a0</span></span><br><span class="line"><span class="comment">/// []byte to string, s2:c0000a20b0</span></span><br><span class="line"><span class="comment">/// string to []byte, rs:c0000b80c0</span></span><br><span class="line"><span class="comment">/// []byte to string, s3:c0000a20d0</span></span><br></pre></td></tr></table></figure><p>编译器会为了某些场合进行专门优化，避免额外分配和复制操作：</p><ul><li>将<code>[]byte</code>转换为<code>string key</code>, 去<code>map[string]</code>查询的时候。</li><li>将<code>string</code>转换为<code>[]byte</code>, 进行<code>for range</code>迭代时，直接取字节赋值给局部变量。</li></ul><p>除了类型转换外，动态构建字符串也容易造成性能问题。<br>用加法操作符拼接字符串时，每次都须重新分配内存。如此，在构建超大字符串时，性能就显得极差。<br>改进思路时预分配i足够大的空间。常用方法是用<code>string.Join</code>函数，他会统计所有参数长度，并一次性完成内存分配操作。<br>另外<br>utf8.ValidString(s) 返回s是不是一个有效的字符串<br>utf8.RuneCountInString(s) 替代<code>len</code>返回<code>unicode</code>的字符数量</p>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(6)方法</title>
      <link href="/2020/08/27/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E6%96%B9%E6%B3%95/"/>
      <url>/2020/08/27/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是与对象实例绑定的特殊函数。<br>方法是面向对象编程的基本概念，用于维护和展示对象的自身状态。对象是内敛的，每个实例都有各自不同的独立特征，以属性和方法来暴露对外通信接口。普通函数则专注于算法流程，通过接收参数来完成特定逻辑运算，并返回最终结果。换句话说，方法是有关联的而函数通常没有。<br>方法和函数定义语法区别，在于前者有前置实例接收参数，编译器以此确定方法所数类型。<br>可以为当前包，以及除接口和指针以外的任何类型定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%#x&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  <span class="built_in">println</span>(a.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// 0x19</span></span><br></pre></td></tr></table></figure><p>方法同样不支持重载(<code>overload</code>)。<code>receiver</code>参数名没有限制，按惯例会选用简短有意义的名称。如方法内部并不引用实例，可省略参数名，仅保留类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span></span> test() &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;hi~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法可看作特殊的函数，那么<code>receiver</code>的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> value() &#123;</span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;v: %p, %v\n&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span></span> pointer() &#123;</span><br><span class="line">  (*n)++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;p: %p, %v\n&quot;</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  a.value()</span><br><span class="line">  a.pointer()</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;a: %p, %v\n&quot;</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// v: 0xc8200741c8, 26 /// receiver 被复制</span></span><br><span class="line"><span class="comment">/// p: 0xc8200741c0, 26</span></span><br><span class="line"><span class="comment">/// a: 0xc8200741c0, 26</span></span><br></pre></td></tr></table></figure><p>可使用实例值或指针调用方法，编译器会根据方法<code>receiver</code>类型自动在基础类型和指针类型间转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  p := &amp;a</span><br><span class="line">  a.value()</span><br><span class="line">  a.pointer()</span><br><span class="line">  p.value()</span><br><span class="line">  p.pointer()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// p2 := &amp;p   错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// v: 0xc82999a2c0, 26</span></span><br><span class="line"><span class="comment">/// p: 0xc82999a298, 26</span></span><br><span class="line"><span class="comment">/// v: 0xc82000a2f0, 27</span></span><br><span class="line"><span class="comment">/// v: 0xc82000a298, 27</span></span><br></pre></td></tr></table></figure><p>指针类型的<code>receiver</code>必须时合法指针(包括<code>nil</code>), 或能获取实例地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *X)</span></span> test() &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;hi!&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a *X</span><br><span class="line">  a.test()  <span class="comment">///相当于test(nil)</span></span><br><span class="line">  X&#123;&#125;.test()  <span class="comment">/// 错误无法获取地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何选择方法的<code>receiver</code>类型：</p><ul><li>要修改实例状态，用<code>*T</code></li><li>无需修改状态的小对象或固定值，建议用<code>T</code></li><li>大对象建议用<code>*T</code>, 以减少复制成本。</li><li>引用类型、字符串、函数等指针包装对象，直接用T。</li><li>若包含<code>Mutex</code>等同步字段，用<code>*T</code>,避免因复制造成锁操作无效</li><li>其他无法确定的情况，都用<code>*T</code></li></ul><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>可以访问匿名字段成员那样调用其方法，有编译器负责查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line">  buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := data()</span><br><span class="line">  d.Lock()  <span class="comment">/// 编译器会处理为 sync.(*Mutex).Lock()调用</span></span><br><span class="line">  <span class="keyword">defer</span> d.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法也会有同名遮蔽问题。但利用这一特性可实现类似(<code>override</code>)操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">  user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun (user) toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m manager)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.user.toString() + <span class="string">&quot;; manager&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> m manager</span><br><span class="line">  <span class="built_in">println</span>(m.toString())</span><br><span class="line">  <span class="built_in">println</span>(m.user.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// user; manager</span></span><br><span class="line"><span class="comment">/// user</span></span><br></pre></td></tr></table></figure><p>尽可能直接访问匿名字段的成员和方法，但他们依然不属于继承关系。</p><h3 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h3><p>类型有一个与之相关的方法集，这决定了它是否实现某个接口。</p><ul><li>类型<code>T</code>方法集包含所有<code>receiver T</code>方法。</li><li>类型<code>*T</code>方法集包含所有<code>recever T</code> + <code>*T</code>方法。</li><li>匿名嵌入<code>S</code>, <code>T</code>方法集包含所有<code>receiver S</code>方法。</li><li>匿名嵌入<code>*S</code>, <code>T</code>方法集包含所有<code>receiver S</code>+<code>*S</code>方法。</li><li>匿名嵌入<code>S</code>或<code>*S</code>, <code>*T</code>方法集包含所有<code>receiver S</code>+<code>*S</code>方法。</li></ul><p>可利用反射测试这些规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">  S <span class="comment">// 匿名嵌入字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span></span> sVal() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*S)</span></span> sPtr() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> tVal() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span></span> tPtr() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodSet</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(a)</span><br><span class="line">  <span class="keyword">for</span> i, n := <span class="number">0</span>, t.NumMethod(); i &lt; n; i++ &#123;</span><br><span class="line">    m := t.Method(i)</span><br><span class="line">    fmt.Println(m.Name, m.Type)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t T</span><br><span class="line">  methodSet(t)  <span class="comment">///&lt; 显示T方法集</span></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;-------&quot;</span>)</span><br><span class="line">  methodSet(&amp;t) <span class="comment">///&lt; 显示*T方法集</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// sVal func(main.T)</span></span><br><span class="line"><span class="comment">/// tVal func(main.T)</span></span><br><span class="line"><span class="comment">/// ---------</span></span><br><span class="line"><span class="comment">/// sPtr func(*main.T)</span></span><br><span class="line"><span class="comment">/// sVal func(*main.T)</span></span><br><span class="line"><span class="comment">/// tPtr func(*main.T)</span></span><br><span class="line"><span class="comment">/// tVal func(*main.T)</span></span><br></pre></td></tr></table></figure><p>方法集影响接口实现和方法表达式转换，于通过实例或实例指针调用方法无关。实例并不使用方法集，而是直接调用(或通过隐式字段名).<br>很显然，匿名字段就是为方法准备的。否则，完全没必要为少写个字段名而大费周折。<br>面向对象的三大特征”封装”,”继承”和”多态”, Go仅仅实现了部分特征，它更倾向于”组合优于继承“这种思想。将模块分解成相互独立的更小单元，分别处理不同方面的需求，最后以匿名嵌入方式组合到一起，共同实现对外接口。而且其简短一致的调用方式，更是隐藏了内部实现细节。</p><blockquote><p>组合没有父子依赖，不会破坏封装。且整体和局部松耦合，可任意增加来实现实现扩展。各单元持有单一职责，互无关联，实现和维护更加简单。</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>方法和函数一样，除直接调用外还可以赋值给变量，或作为参数传递。依照具体引用方式不同，可分为<code>expression</code>和<code>value</code>两种状态。<br>通过类型引用<code>Method expression</code>会被还原为普通函数央视，receiver是第一参数，调用时须显示传参。至于类型，可以是<code>T</code>或<code>*T</code>, 只要目标方法集中即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %d&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %d\n&quot;</span>, &amp;n, n)</span><br><span class="line">  f1 := N.test  <span class="comment">///&lt; func(n N)</span></span><br><span class="line">  f1(n)</span><br><span class="line">  f2 := (*N).test <span class="comment">///&lt; func(n *N)</span></span><br><span class="line">  f2(&amp;n)  <span class="comment">///&lt; 按方法集中的签名传递正确类型的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc82000a140, 25</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a158, 25</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a168, 25</span></span><br></pre></td></tr></table></figure><p>当然，也可直接以表达式方式调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">  N.test(n)</span><br><span class="line">  (*N).test(&amp;n) <span class="comment">///&lt; 注意： *N 须使用括号，以免语法解析错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于实例或指针引用的<code>method value</code>, 参数签名不会改变，依旧按正常方式调用。<br>但当<code>method value</code>被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需的<code>receiver</code>对象，与其绑定，以便在稍后执行时，能隐式传入<code>receiver</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %v\n&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  n++</span><br><span class="line">  f1 := n.test  <span class="comment">//&lt; 因为test方法的reveiver是类型,所以复制n, 等于101</span></span><br><span class="line"></span><br><span class="line">  n++</span><br><span class="line">  f2 := p.test  <span class="comment">///&lt; 复制*p, 等于102</span></span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %v\n&quot;</span>, p, n)</span><br><span class="line">  f1()</span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc829976028, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc820076060, 101</span></span><br><span class="line"><span class="comment">/// test.n: 0xc820076060, 102</span></span><br></pre></td></tr></table></figure><blockquote><p>编译器会为method value生成一个包装函数，实现间接调用。至于<code>receiver</code>复制，和闭包的实现方法基本相同，打包成<code>funcval</code>, 经由<code>DX</code>寄存器传递。</p></blockquote><p>当<code>method value</code>作为参数是，会复制含<code>receiver</code>在内的整个<code>method value</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(m <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">  m()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.h: %p, %v&quot;</span>, p, n)</span><br><span class="line">  n++</span><br><span class="line">  call(n.test)</span><br><span class="line">  n++</span><br><span class="line">  call(p.test)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n 0x82000a288, 100</span></span><br><span class="line"><span class="comment">/// test.n 0x82000a2c0, 101</span></span><br><span class="line"><span class="comment">/// main.n 0x82000a2d0, 102</span></span><br></pre></td></tr></table></figure><p>当然，如果目标方法的<code>receiver</code>是指针类型，那么被复制的仅是指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %v\n&quot;</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  n++</span><br><span class="line">  f1 := n.test  <span class="comment">///&lt; 因为test方法的receiver是*N类型, 所以复制&amp;n</span></span><br><span class="line">  n++</span><br><span class="line">  f2 := p.test  <span class="comment">///&lt; 复制p指针</span></span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %v\n&quot;</span>, p, n)</span><br><span class="line">  f1()  <span class="comment">///&lt; 延迟调用，n == 103</span></span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc82000a298, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a298, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a298, 103</span></span><br></pre></td></tr></table></figure><p>只要receiver参数类型正确，使用<code>nil</code>同样可以执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span></span> value() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*N)</span></span> pointer() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p *N</span><br><span class="line">  p.pointer() <span class="comment">// method value</span></span><br><span class="line">  (*N)(<span class="literal">nil</span>).pointer() <span class="comment">// method value</span></span><br><span class="line">  (*N).pointer(<span class="literal">nil</span>) <span class="comment">// method expression</span></span><br><span class="line">  <span class="comment">/// p.value() 错误： invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 二叉树的遍历</title>
      <link href="/2020/08/26/2020-08-26-C++%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2020/08/26/2020-08-26-C++%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>前序遍历：</p><p>遍历的顺序是：根节点-左节点-右节点</p><p>递归代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">order</span>(root);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      s.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><p>遍历的顺序是：左节点-根节点-右节点</p><p>递归代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">          res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">order</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          s.<span class="built_in">push</span>(root);</span><br><span class="line">          root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><p>遍历的顺序是：左节点-右节点-根节点</p><p>递归代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">          res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">order</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      s.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          s.<span class="built_in">pop</span>();</span><br><span class="line">          res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">          s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;right) s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;left) s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 算法题解</title>
      <link href="/2020/08/26/2020-08-26-C++%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/26/2020-08-26-C++%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="排序操作次数"><a href="#排序操作次数" class="headerlink" title="排序操作次数"></a>排序操作次数</h2><p>题目描述:<br>有一种排序算法定义如下，该排序算法每次把一个元素提到序列的开头，例如2, 1, 3, 4，只需要一次操作把1提到序列起始位置就可以使得原序列从小到大有序。现在给你个乱序的1-n的排列，请你计算最少需要多少次操作才可以使得原序列从小到大有序。<br>输入描述</p><p>输入第一行包含两个正整数n，表示序列的长度。（1 &lt;&#x3D; n &lt;&#x3D; 100000）<br>接下来一行有n个正整数，表示序列中的n个元素，中间用空格隔开。（1 &lt;&#x3D; a_i &lt;&#x3D; n）</p><p>输出描述</p><p>输出仅包含一个整数，表示最少的操作次数。</p><p>样例输入<br>4<br>2 1 3 4</p><p>样例输出<br>1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_operation_count</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">sorted</span><span class="params">(vec)</span></span>;</span><br><span class="line">  std::<span class="built_in">sort</span>(sorted.<span class="built_in">begin</span>(), sorted.<span class="built_in">end</span>());</span><br><span class="line">  <span class="type">int</span> p = sorted.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> q = p;</span><br><span class="line">  <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; q &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">at</span>(p) == sorted.<span class="built_in">at</span>(q)) &#123;</span><br><span class="line">      --p;</span><br><span class="line">      --q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; vec.<span class="built_in">at</span>(p) != sorted.<span class="built_in">at</span>(q)) &#123;</span><br><span class="line">        --p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; vec.<span class="built_in">at</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">get_operation_count</span>(vec) &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(5)接口</title>
      <link href="/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口代表一种调用契约，是多个方法声明的集合。接口最常见的使用场景，是对包外提供访问，或预留扩展空间。<br><code>Go</code>接口的实现机制很简洁，只要目标类型方法集内包含接口声明的全部方法，就被视为实现了该接口，无须做显式声明。当然，目标类型可实现多个接口。<br>接口：</p><ul><li>不能有字段</li><li>不能定义自己的方法</li><li>只能声明方法，不能实现</li><li>可嵌入其他接口类型</li></ul><p>接口通常以<code>er</code>作为名称后缀，方法名是声明组成部分，但参数名可不同或省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  test()</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>() &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// var t tester = d  ///&lt; 错误</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果接口没有任何声明方法声明，那么就是一个空接口, 他的用途类似面向对象的根类型<code>Object</code>, 可被赋值为任何类型的对象。<br>接口变量默认值是<code>nil</code>。如果实现接口的类型支持，可做相等运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t1, t2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == <span class="literal">nil</span>, t1 == t2)</span><br><span class="line"></span><br><span class="line">  t1, t2 = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">  t1, t2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// panic: runtime error: comparing uncomparable type map[string]int</span></span><br></pre></td></tr></table></figure><p>可以像匿名字段一样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算实现了该接口。<br>前提是，不能有同名方法, 不能嵌入自身或循环嵌入，那会导致递归错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  stringer  <span class="comment">///&lt; 嵌入接口</span></span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超集接口变量可隐式转换为子集，反过来不行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(a stringer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(a.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  pp(t) <span class="comment">///&lt; 隐式转换为自己接口</span></span><br><span class="line">  <span class="keyword">var</span> s stringer = t  <span class="comment">///&lt; 超集转换为子集</span></span><br><span class="line">  <span class="built_in">println</span>(s.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持匿名接口类型，可直接用于变量定义，或作为结构字段类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">interface</span> &#123;  <span class="comment">///&lt; 匿名接口类型</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t <span class="keyword">interface</span> &#123; <span class="comment">///&lt; 定义匿名接口变量</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125; = data&#123;&#125;</span><br><span class="line"></span><br><span class="line">  n := node&#123;</span><br><span class="line">    data: t,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println</span>(n.data.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h3><p>接口执行一个名为<code>itab</code>的结构存储运行期所需的相关类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">  tab *itab <span class="comment">///&lt; 类型信息</span></span><br><span class="line">  data unsafe.Pointer <span class="comment">///&lt; 实际对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">  inter *interfacetype  <span class="comment">///&lt; 接口类型</span></span><br><span class="line">  _type *_type  <span class="comment">///&lt; 实际对象类型</span></span><br><span class="line">  fun [<span class="number">1</span>]<span class="type">uintptr</span>  <span class="comment">///&lt; 实际对象方法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关类型信息里保存了接口和实际对象的元数据。同时<code>itab</code>还用<code>fun</code>数组（不定长结构）保存了实际方法地址，从而实现在运行期对目标方法的动态调用。<br>除此之外，接口还有一个重要特征：将对象赋值给接口变量时，会复制该对象。我们甚至无法修改结构存储的复制品，因为它也是<code>unaddressable</code>的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := data&#123;<span class="number">100</span>&#125;</span><br><span class="line">  vat t <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  p := &amp;t.(data)  <span class="comment">///&lt; 错误</span></span><br><span class="line">  t.(data).x = <span class="number">200</span>  <span class="comment">///&lt; 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即便将其复制出来，用本地变量修改后，依然无法对<code>iface.data</code>赋值。解决方法就是将对象指针赋值给接口，那么接口内存存储的就是指针的复制品。<br>只有当接口变量内部的两个指针(<code>itab</code>, <code>data</code>)都为<code>nil</code>时, 接口才等于<code>nil</code>.</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体地接口类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> String() <span class="type">string</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;data:%d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data = <span class="number">15</span></span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> n, ok := x.(fmt.Stringer); ok &#123;  <span class="comment">///&lt; 转换为更具体地接口类型</span></span><br><span class="line">    fmt.Println(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> d2, ok := x.(data); ok &#123; <span class="comment">///&lt; 转换回原始类型</span></span><br><span class="line">    fmt.Println(d2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e := x.(<span class="type">error</span>)  <span class="comment">///&lt; 错误： main.data is not error</span></span><br><span class="line">  fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>ok-idiom</code>模式，即便转换失败也不会引发<code>panic</code>。还可用<code>switch</code>语句在多种类型间做出推断匹配，这样空接口就有更多发挥空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;d:%d&quot;</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> v := x(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">      <span class="built_in">println</span>(*v)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">string</span>:</span><br><span class="line">      <span class="built_in">println</span>(v(<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">case</span> fmt.Stringer:</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// d: 100</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： <code>type switch</code>不支持<code>fallthrought</code></p></blockquote><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>让编译器检查，确保类型实现了指定接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> x <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">///&lt; 包初始函数</span></span><br><span class="line">  <span class="keyword">var</span> _ fmt.Stringer = x(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数类型，让相同签名地函数自动实现某个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncString <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t fmt.Stringer = FuncString(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt. Println(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(4)并发</title>
      <link href="/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>并发： 逻辑上具备同时处理多个任务的能力。</li><li>并行： 物理上在同一时刻执行多个并发任务。<br>多线程或多进程时并行的基本条件，但单线程也可用协程做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，它也有自己的优势。除了将因阻塞而浪费的时间找回来以外，还免去了线程切换的开销。协程上运行的多个任务本质上是依旧串行的，加上可控自主，所以并不需要做同步处理。<br>通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源。用协程来提高处理器时间片利用率。</li></ul><p>简单将<code>goroutine</code>归纳为协程并不合适。运行时创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。这更像是多线程和协程的综合体，能最大限度提升执行效率，发挥多核处理能力。<br>只须在函数调用前添加<code>go</code>关键字即可创建并发任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(s)</span><br><span class="line">&#125; (<span class="string">&quot;hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>关键字<code>go</code>并非执行并发操作，而是创建一个并发任务单元。新建任务被放置在系统队列中，等待调度器安排合适系统线程去获取执行权。当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。</p><p>每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间。相比系统默认<code>MB</code>级别的线程栈，<code>goroutinue</code>自定义栈初始仅须<code>2 KB</code>，所以才能创建成千上万的并发任务。自定义栈采取按需分配策略，在需要时进行扩容，最大能到<code>GB</code>规模。<br>与<code>defer</code>一样，<code>gorountine</code>也会因”延迟执行”而立即计算并复制执行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">c++</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">100</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;go:&quot;</span>, x, y)</span><br><span class="line">&#125;(a, counter())</span><br><span class="line">a += <span class="number">100</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main:&quot;</span>, a, counter())</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)<span class="comment">// 等待 `goroutine` 结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main: 200 2</span></span><br><span class="line"><span class="comment">/// go: 100 1</span></span><br></pre></td></tr></table></figure><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>进程退出时不会等待并发任务结束，可用管道(<code>channel</code>)阻塞，然后发出退出信号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)<span class="comment">///&lt; 创建通道。因为仅是通知，数据并没有实际意义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;goroutine done.&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(exit)<span class="comment">///&lt; 关闭通道</span></span><br><span class="line">&#125; ()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">&lt;-exit<span class="comment">///&lt; 如通道关闭，立即解除阻塞</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><p>除关闭通道外，写入数据也可解除阻塞。<br>如要等待多个任务结束，推荐使用<code>sync.WaitGroup</code>。通过设定计数器，让每个<code>goroutine</code>在退出前递减，直至归零时接触阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)<span class="comment">///&lt; 累加计数</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()<span class="comment">///&lt; 递减计数</span></span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;goroutine&quot;</span>, id, <span class="string">&quot;done.&quot;</span>)</span><br><span class="line">&#125; (i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">wg.Wait()<span class="comment">///&lt; 阻塞，直到计数为零</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine 2 done.</span></span><br><span class="line"><span class="comment">/// goroutine 3 done.</span></span><br><span class="line"><span class="comment">/// goroutine 7 done.</span></span><br><span class="line"><span class="comment">/// goroutine 9 done.</span></span><br><span class="line"><span class="comment">/// goroutine 6 done.</span></span><br><span class="line"><span class="comment">/// goroutine 0 done.</span></span><br><span class="line"><span class="comment">/// goroutine 8 done.</span></span><br><span class="line"><span class="comment">/// goroutine 4 done.</span></span><br><span class="line"><span class="comment">/// goroutine 1 done.</span></span><br><span class="line"><span class="comment">/// goroutine 5 done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><p>尽管<code>WaitGroup.Add</code>实现了原子操作，但建议在<code>goroutine</code>外累加计数器，以免<code>Add</code>尚未执行，<code>Wait</code>已经退出。<br>可在多处使用<code>Wait</code>阻塞，他们都能接收到通知</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()<span class="comment">///&lt; 等待归零，解除阻塞</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;wait exit.&quot;</span>)</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done.&quot;</span>)</span><br><span class="line">wg.Done()<span class="comment">///&lt; 递减计数</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()<span class="comment">///&lt; 等待归零</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// done.</span></span><br><span class="line"><span class="comment">/// wait exit.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><h3 id="GOMAXPROCE"><a href="#GOMAXPROCE" class="headerlink" title="GOMAXPROCE"></a>GOMAXPROCE</h3><p>运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量默认与处理器核数相等，可用<code>runtime.GOMAXPROCS</code>函数(或环境变量)修改。</p><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h3><p>与线程不同，<code>goroutine</code>任务无法设置优先级，无法获取编号，没有局部存储(TLS), 甚至连返回值都会被抛弃。但除优先级外，其他功能都很容易实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> gs [<span class="number">5</span>]<span class="keyword">struct</span> &#123;<span class="comment">///&lt; 用于实现类似TLS功能</span></span><br><span class="line">id <span class="type">int</span><span class="comment">///&lt; 编号</span></span><br><span class="line">result <span class="type">int</span><span class="comment">///&lt; 返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gs); i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;<span class="comment">// 使用参数避免闭包延迟求值</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">gs[id].id = id</span><br><span class="line">gs[id].result = (id + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, gs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [&#123;id:0 result:100&#125; &#123;id:1 result:200&#125; &#123;id:2 result:300&#125; &#123;id:3 result:400&#125; &#123;id:4 result:500&#125;]</span></span><br></pre></td></tr></table></figure><blockquote><p>如使用<code>map</code>作为局部存储容器，建议做同步处理，因为运行时会对其做并发读写检查。</p></blockquote><h3 id="Gosched"><a href="#Gosched" class="headerlink" title="Gosched"></a>Gosched</h3><p>暂停，释放线程去执行其他任务。当前任务被放回队列，等待下次调度时恢复执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;<span class="comment">/// 让出当前线程，调度执行b</span></span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-exit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0</span></span><br><span class="line"><span class="comment">/// a: 1</span></span><br><span class="line"><span class="comment">/// b</span></span><br><span class="line"><span class="comment">/// a: 2</span></span><br><span class="line"><span class="comment">/// a: 3</span></span><br></pre></td></tr></table></figure><h3 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h3><p><code>Goexit</code>立即终止当前任务，运行时确保所有已注册延迟调用被执行。该函数不会影响其他并发任务，不会引发<code>panic</code>, 自然也就无法捕获。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(exit)<span class="comment">///&lt; 执行</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)<span class="comment">///&lt; 执行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>, <span class="built_in">recover</span>() == <span class="literal">nil</span>)<span class="comment">///&lt; 执行，recover返回nil</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">///&lt; 在多层调用中执行Goexit</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">runtime.Goexit()<span class="comment">///&lt; 立即终止整个调用堆栈</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;c done.&quot;</span>)</span><br><span class="line">&#125; ()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;b done.&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;a done.&quot;</span>)<span class="comment">///&lt; 不会执行</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-exit</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// c</span></span><br><span class="line"><span class="comment">/// b true</span></span><br><span class="line"><span class="comment">/// a</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><p>如果在<code>main.main</code>里调用<code>Goexit</code>, 它会等待其他任务结束，然后让进程直接崩溃。<br>无论身处哪一层，<code>Goexit</code>都能立即终止整个调用堆栈，这与<code>return</code>仅退出当前函数不同。标准库函数<code>os.Exit</code>可终止进程，但不会执行延迟调用。</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p><code>Go</code>语言并未实现严格的并发安全。<br>允许全局变量、指针、引用类型这些非安全内存共享操作，就需要开发人员自行维护数据一致和完整性。<code>Go</code>鼓励使用<code>CSP</code>通道，以通信来代替内存共享，实现并发安全。</p><blockquote><p>CSP: Communicating Sequential Process</p></blockquote><p>通过消息来避免竞态的模型除了<code>CSP</code>, 还有<code>Actor</code>。但两者由较大区别<br>作为<code>CSP</code>核心，通道(channel)是显式的，要求操作双方必须知道数据类型和具体通道，并不关心另一端操作者身份和数量。可如果另一端未准备妥当，或消息未能及时处理时，会阻塞当前端。<br>相比起来，<code>Actor</code>是透明的，它不在乎数据类型及通道，只要知道接收者信箱即可。默认就是异步方式，发送方对消息是否被接收和处理并不关心。</p><p>从底层实现上来说，通道知识一个队列。同步模式下，发送和接受双方配对，然后直接赋值数据给对方。如配对失败，则置入等待队列，直到另一方出现后才被唤醒。异步模式抢夺的则是数据缓冲槽。发送方要求有空槽可供写入，而接收方则要求有缓冲数据可读。需求不符时，同样加入缓冲队列，直到有另一方写入数据或腾出空槽后被唤醒。<br>除传递消息（数据）外，通道还常被用做事件通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := &lt;-<span class="keyword">chan</span><span class="comment">///&lt; 接收消息</span></span><br><span class="line"><span class="built_in">println</span>(s)</span><br><span class="line"><span class="built_in">close</span>(done)<span class="comment">///&lt; 关闭通道，作为结束通知</span></span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="string">&quot;hi!&quot;</span> <span class="comment">///&lt; 发送消息</span></span><br><span class="line">&lt;-done<span class="comment">///&lt; 阻塞，直到有数据或管道关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步模式必须有配对操作的<code>goroutine</code>出现，否则会一直阻塞。而异步模式在缓冲区未满或数据未读完前，不会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)  <span class="comment">///&lt; 创建带3个缓冲槽的异步通道。</span></span><br><span class="line">  c &lt;- <span class="number">1</span>  <span class="comment">///&lt; 缓冲区未满，不会阻塞</span></span><br><span class="line">  c &lt;- <span class="number">2</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br></pre></td></tr></table></figure><p>多数时候，异步通道有助于提升性能，减少排队阻塞。<br>缓冲去大小仅是内部属性，不属于类型组成部分。另外通道变量本身就是指针，可用相等操作符判断是否为同一对象或<code>nil</code>。<br>内置函数<code>cap</code>和<code>len</code>返回缓冲区大小和当前已缓冲数量；而对于同步通道则都返回0；据此可判断通道时同步还是异步</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  b &lt;- <span class="number">1</span></span><br><span class="line">  b &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;b:&quot;</span>, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0 0</span></span><br><span class="line"><span class="comment">/// b: 2 3</span></span><br></pre></td></tr></table></figure><h3 id="收发"><a href="#收发" class="headerlink" title="收发"></a>收发</h3><p>除使用简单的发送和接受操作符外，还可用<code>ok-idom</code>或<code>range</code>模式处理数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)<span class="comment">///&lt; 确保发出结束通知</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">x, ok := &lt;-c</span><br><span class="line"><span class="keyword">if</span> !ok &#123;<span class="comment">///&lt; 据此判断通道是否被关闭</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line">c &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(c)<span class="comment">///&lt; 及时使用`close`函数关闭通道引发结束通知，否则可能会导致死锁。</span></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="comment">/// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>一次性事件用<code>close</code>效率更好，没有多余开销。连续或多样性事件，可传递不同数据标志实现。还可使用<code>sync.Cond</code>实现单播或广播事件。</p></blockquote><p>对于<code>closed</code>或<code>nil</code>通道，发送和接收操作都有相应规则：</p><ul><li>向已关闭通道发送数据，引发<code>panci</code></li><li>从已关闭接收数据，返回已缓冲数据或零值。</li><li>无论收发，<code>nil</code>通道都会阻塞。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  c &lt;- <span class="number">10</span></span><br><span class="line">  c &lt;- <span class="number">20</span></span><br><span class="line">  <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(c)+<span class="number">1</span>; i++ &#123;</span><br><span class="line">    x, ok := &lt;-c</span><br><span class="line">    <span class="built_in">println</span>(i, <span class="string">&quot;:&quot;</span>, ok, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复关闭或关闭<code>nil</code>通道都会引发<code>panic</code>错误。</p><h3 id="单向"><a href="#单向" class="headerlink" title="单向"></a>单向</h3><p>通道默认时双向的，并不区分发送和接收端。<br>尽管可用<code>make</code>创建单向通道，但那没有任何意义。通常使用类型装欢来获取单向通道，并分别赋予操作双方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> recv &#123;</span><br><span class="line">      <span class="built_in">println</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      send &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在单向通道上做逆向操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  &lt;-send  <span class="comment">///&lt; 无效操作</span></span><br><span class="line">  recv &lt;- <span class="number">1</span> <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，close不能用于接收端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;- <span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line">  <span class="built_in">close</span>(recv) <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无法将单向通道重新转换回去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">  a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = a</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = a</span><br><span class="line"></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(recv)  <span class="comment">/// 错误</span></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(send)  <span class="comment">/// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>如要同时处理多个通道，可选用<code>select</code>语句。它会随机选择一个可用通道做收发操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">///&lt; 接收端</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">x<span class="type">int</span></span><br><span class="line">ok <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;<span class="comment">///&lt; 随机选择可用 channel 接收数据</span></span><br><span class="line"><span class="keyword">case</span> x, ok = &lt;-a:</span><br><span class="line">name = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">case</span> x, ok = &lt;-b:</span><br><span class="line">name = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ok &#123;<span class="comment">///&lt; 如果任一通道关闭，则终止接收</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(name, x)<span class="comment">///&lt; 输出接收的数据信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">///&lt; 发送端</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(a)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(b)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> a &lt;- i:</span><br><span class="line"><span class="keyword">case</span> b &lt;- i*<span class="number">10</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a 0</span></span><br><span class="line"><span class="comment">/// b 10</span></span><br><span class="line"><span class="comment">/// a 2</span></span><br><span class="line"><span class="comment">/// a 3</span></span><br><span class="line"><span class="comment">/// a 4</span></span><br><span class="line"><span class="comment">/// a 5</span></span><br><span class="line"><span class="comment">/// b 60</span></span><br><span class="line"><span class="comment">/// a 7</span></span><br><span class="line"><span class="comment">/// a 8</span></span><br><span class="line"><span class="comment">/// a 9</span></span><br></pre></td></tr></table></figure><p>如要等全部通道消息处理结束(closed),可将已完成通道设置为<code>nil</code>。这样它就会被阻塞，不再被<code>select</code>选中。<br>即使是同一通道，也会随机选择<code>case</code>执行。</p><p>当所有通道都不可用时，<code>select</code>会执行<code>default</code>语句。如此可避开<code>select</code>阻塞，但须注意处理外层循环，以免陷入空耗。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>通常使用工厂方法将<code>goroutine</code>和通道绑定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> receiver <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.WaitGroup</span><br><span class="line">  data <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newReceiver</span><span class="params">()</span></span> * receiver &#123;</span><br><span class="line">  r := &amp;receiver&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  r.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> r.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> r.data&#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;recv:&quot;</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := newReceiver()</span><br><span class="line">  r.data &lt;- <span class="number">1</span></span><br><span class="line">  r.data &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(r.data) <span class="comment">///&lt; 关闭通道，发出结束通知</span></span><br><span class="line">  r.Wait()  <span class="comment">///&lt; 等待接收者处理结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于通道本身就是一个并发安全的队列，可用作<code>ID generator</code>、<code>Pool</code>等用途。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type pool chan []<span class="function">byte</span></span><br><span class="line"><span class="function">func <span class="keyword">new</span> <span class="title">Pool</span><span class="params">(cap <span class="type">int</span>)</span> pool </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(chan []byte, cap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">get</span>() []byte &#123;</span><br><span class="line">  var v []byte</span><br><span class="line"></span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> v = &lt;-p: <span class="comment">///&lt; 获取</span></span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 获取失败，则创建</span></span><br><span class="line">      v = <span class="built_in">make</span>([]byte, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">put</span>(b []byte) &#123;</span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> p &lt;- b:</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 放回失败，放弃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用通道实现信号量(semaphore)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>) <span class="comment">///&lt; 最多允许两个并发同时执行</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">///&lt; acquire: 获取信号</span></span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem&#125;() <span class="comment">///&lt; release: 释放信号</span></span><br><span class="line">      time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">      fmt.Println(id, time.Now())</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库<code>time</code>提供了<code>timeout</code>和<code>tick channel</code>实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second*<span class="number">5</span>):</span><br><span class="line">          fmt.Println(<span class="string">&quot;timeout ...&quot;</span>)</span><br><span class="line">          os.Exit(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">          fmt.Println(time.Now())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  &lt;-(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)  <span class="comment">// 直接用nil channel阻塞进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获<code>INT</code>、<code>TERM</code>信号，顺便实现一个简易的<code>atexit</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exits = &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.RWMutex</span><br><span class="line">  <span class="function"><span class="keyword">func</span> []<span class="title">func</span><span class="params">()</span></span></span><br><span class="line">  signals <span class="keyword">chan</span> os.Signal</span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atexit</span><span class="params">(f <span class="keyword">func</span>()</span></span>)&#123;</span><br><span class="line">  exits.Lock()</span><br><span class="line">  <span class="keyword">defer</span> exits.Unlock()</span><br><span class="line">  exits.funcs = <span class="built_in">append</span>(exits.funcs, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> exits.signals == <span class="literal">nil</span> &#123;</span><br><span class="line">    exits.signals = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(exits.signals, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">  &#125;</span><br><span class="line">  exits.RLock()</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> exits.funcs &#123;</span><br><span class="line">    <span class="keyword">defer</span> f() <span class="comment">///&lt; 即使某些函数panic,延迟调用也能确保后续函数执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  exits.RUnlock()</span><br><span class="line">  &lt;-exit.signals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit1 ...&quot;</span>)&#125;)</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit2 ...&quot;</span>)&#125;)</span><br><span class="line">  waitExit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源泄露"><a href="#资源泄露" class="headerlink" title="资源泄露"></a>资源泄露</h3><p>通道可能会引发<code>goroutine leak</code>, 确切的说，是指<code>goroutine</code>处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致他们会在等待队列里长久休眠形成资源泄露。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>标准库<code>sync</code>提供了互斥和读写锁，另有原子操作等，可基本满足日常开发需要。<code>Mutex</code>、<code>RWMutex</code>的使用并不复杂，只有几个地方需要注意。<br>将<code>Mutex</code>作为匿名字段时，相关方法必须实现为<code>pointer-receiver</code>, 否则会因赋值导致锁机制失效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> test(s <span class="type">string</span>) &#123;</span><br><span class="line">d.Lock()</span><br><span class="line"><span class="keyword">defer</span> d.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="built_in">println</span>(s, i)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d data</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">d.test(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">d.test(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁不支持递归锁。</li><li>对性能要求较高时，应避免使用<code>defer Unlock</code></li><li>读写并发时，用<code>RWMutex</code>性能会更好一些</li><li>对单个数据读写保护，可尝试用原子操作</li><li>执行严格的测试，尽可能打开数据竞争检查</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(3)工作空间</title>
      <link href="/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/"/>
      <url>/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p>依照规范，工作空间由<code>src</code>、<code>bin</code>、<code>pkg</code>三个目录组成。通常需要将空间路径添加到<code>GOPATH</code>环境变量列表中, 以便相关工具能正常工作。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- service/</span><br><span class="line">  |          |</span><br><span class="line">  |          +-- user.go</span><br><span class="line">  |</span><br><span class="line">  +-- bin/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server</span><br><span class="line">  |</span><br><span class="line">  +-- pkg/</span><br><span class="line">       |</span><br><span class="line">       +-- linux_amd64/</span><br><span class="line">            |</span><br><span class="line">            +-- service.a</span><br></pre></td></tr></table></figure><p>在工作空间里，包括子包在内的所有源码文件都保存在<code>src</code>目录下。至于<code>bin</code>、<code>pkg</code>两个目录， 其主要影响 <code>go install/get</code>命令，他们会将编译结果(可执行文件或静态库)安装到这两个目录下，以实现增量编译。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>编译器等相关工具按<code>GOPATH</code>设置的路径搜索目标。也就是说在导入目标库时，排在列表前面的路径比当前工作空间优先级更高。另外，<code>go get</code>默认将下载的第三方包保存到列表中第一个工作空间内。</p><p>环境变量<code>GOPATH</code>用于指示工具链和标准库的存放位置。在生成工具链时，相关路径就已经嵌入到可执行文件内，故无需额外设置。<br>除通过设置<code>GOROOT</code>环境变量覆盖内部路径外，还可移动目录(改名、符号链接等), 或重新编译工具链来解决。<br>至于<code>GOBIN</code>, 则是强制替代工作空间的<code>bin</code>目录，作为<code>go install</code>目标保存路径。这可避免将所有工作空间的<code>bin</code>路径添加到<code>PATH</code>环境变量当中。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>使用标准库或第三方包前，须用<code>import</code>导入，参数是工作空间中以<code>src</code>为起始的绝对路径。编译器从标准库开始搜索，然后依次搜索<code>GOPATH</code>列表中的各个工作空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span> <span class="comment">// 实际路径: /usr/local/go/src/net/http</span></span><br></pre></td></tr></table></figure><p>除使用默认包名外，还可使用别名，以解决同名冲突问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> osx <span class="string">&quot;github.com/apple/osx/lib&quot;</span></span><br><span class="line"><span class="keyword">import</span> nix <span class="string">&quot;github.com/linux/lib&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>import</code>导入参数是路径，而非包名。尽管习惯将包和目录名保持一致，但这不是强制规定。在代码中引用包成员时，使用包名而非目录名。</p></blockquote><p>有四种不同的导入方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>    <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 默认方式: test.A</span></span><br><span class="line"><span class="keyword">import</span> X  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 别名方式: X.A</span></span><br><span class="line"><span class="keyword">import</span> .  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 简便方式: A</span></span><br><span class="line"><span class="keyword">import</span> _  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 初始化方式: 无法引用，仅用来初始化目标包。</span></span><br></pre></td></tr></table></figure><blockquote><p>不能直接或间接导入自己，不支持任何形式的循环导入。</p></blockquote><p>未使用的导入(不包括初始化方式)会被编译器视为错误。</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>除工作空间和绝对路径外，部分工具还支持相对路径。可在非工作空间目录下，直接运行、编译一些测试代码。<br>但在设置了<code>GOPATH</code>的工作空间后相对路径会导致编译失败。<code>go run</code>不受影响。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>包内每个源码文件都可定义一到多个初始化函数，但编译器不保证执行次序。<br>实际上，所有这些初始化函数(包括标准库和导入的第三方包)都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且仅执行一次。</p><p>编译器首先确保完成所有全局变量初始化，然后才开始执行初始化函数。直到这些全部结束后，运行时才正式进入<code>main.main</code>入口函数。<br>可在初始化函数中创建<code>goroutine</code>，或等到它结束执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    fmt.Println(<span class="string">&quot;init:&quot;</span>, time.Now)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  &#125; ()</span><br><span class="line"></span><br><span class="line">  &lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main: &quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在多个初始化函数中引用全局变量，那么最好在变量定义处直接赋值。因无法保证执行次序，所以任何初始化函数中的赋值都有可能”延迟无效”。</p><h3 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h3><p>内部包机制相当于增加了新的访问权限控制：所有保存在<code>internal</code>目录下的包(包括自身)仅能被其父目录下的包(包含所有子目录) 访问。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- lib/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- internal/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- a/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- b/</span><br><span class="line">  |         +-- x/</span><br><span class="line">  |             |</span><br><span class="line">  |             +-- y/</span><br><span class="line">  |</span><br></pre></td></tr></table></figure><p>在<code>lib</code>目录外(比如<code>main.go</code>)导入内部包会引发编译错误。</p><blockquote><p>导入内部包必须使用完整路径， 例如： import “lib&#x2F;internal&#x2F;a”</p></blockquote><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>如何使用<code>vendor</code>，专门存放第三方包，实现将源码和依赖完整打包分发。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- vendor/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- github.com/</span><br><span class="line">  |         |              |</span><br><span class="line">  |         |              +-- mercy1101/</span><br><span class="line">                                  |</span><br><span class="line">                                  +-- test/</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/Mercy1101/test&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  test.Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>main.go</code>中导入<code>github.com/mercy1101/test</code>时，优先使用<code>vendor/github.com/mercy1101/test</code></p></blockquote><p>导入<code>vendor</code>中的第三方包，参数是以<code>vendor/</code>为起点的绝对路径。这避免了<code>vendor</code>目录位置带来的麻烦，让导入无论使用<code>vendor</code>,还是<code>GOPATH</code>都能保持一致。</p><blockquote><p>注意：<code>vendor</code>优先级比标准库高</p></blockquote><p>当多个<code>vendor</code>目录嵌套时，匹配规则如下:<br>从当前源文件所在目录开始，逐级向上构造<code>vendor</code>全路径，直到发现路径匹配的目标为止。匹配失败，则依旧搜索<code>GOPATH</code></p><p>要使用<code>vendor</code>机制，须开启<code>GO15VENDOREXPERIMENT=1</code>环境变量开关(Go 1.6默认开启),且必须设置了<code>GOPATH</code>的工作空间。</p><blockquote><p>使用<code>go get</code>下载第三方包时，依旧使用<code>GOPATH</code>第一个工作空间，而非<code>vendor</code>目录。当前工具链中并没有真正意义上的包依赖管理，好在由不少第三放工具可选。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(2)反射</title>
      <link href="/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射能让我们能在运行期探知对象的类型信息和内存结构，同时反射还是实现元编程的重要手段。<br>Go对象头部并没有类型指针，通过自身是无法在运行期获知任何类型相关信息的。反射操作所需的全部信息都源自接口变量。接口变量除自身存储自身类型外，还会保存实际对象的类型数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure><blockquote><p>这两个反射入口函数，会将任何传入的对象转换为接口类型。</p></blockquote><p>在面对类型是，需要区分<code>Type</code>和<code>Kind</code>。前者表示真实类型(静态类型), 后者表示器接触接口(底层类型)类别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X = <span class="number">100</span></span><br><span class="line">  t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">  fmt.Println(t.Name(), t.Kind())</span><br><span class="line">  <span class="comment">/// 输出：X int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := reflect.ArrayOf(<span class="number">10</span>, reflect.TypeOf(<span class="type">byte</span>(<span class="number">0</span>)))</span><br><span class="line">  b := reflect.MapOf(reflect.TypeOf(<span class="string">&quot;&quot;</span>), reflect.TypeOf(<span class="number">0</span>))</span><br><span class="line">  fmt.Println(a, m)</span><br><span class="line">  <span class="comment">/// 输出: [10]uint8 map[string]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>Elem</code>返回指针、数组、切片、字典值或通道的基类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(reflect.TypeOf(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;).Elem())</span><br><span class="line">  fmt.Println(reflect.TypeOf([]<span class="type">int32</span>&#123;&#125;).Elem())</span><br><span class="line">  <span class="comment">/// 输出： int int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在获取结构体指针的基类型后，才能遍历它的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">user</span><br><span class="line">title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m manager</span><br><span class="line">t := reflect.TypeOf(&amp;m)</span><br><span class="line"><span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">t = t.Elem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">f := t.Field(i)</span><br><span class="line">fmt.Println(f.Name, f.Type, f.Offset)</span><br><span class="line"><span class="keyword">if</span> f.Anonymous &#123;</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; f.Type.NumField(); x++ &#123;</span><br><span class="line">af := f.Type.Field(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;  &quot;</span>, af.Name, af.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// user main.user 0</span></span><br><span class="line"><span class="comment">///  name string</span></span><br><span class="line"><span class="comment">///   age int</span></span><br><span class="line"><span class="comment">/// title string 24</span></span><br></pre></td></tr></table></figure><p>对于匿名字段，可用多级索引（按定义顺序）直接访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m manager</span><br><span class="line">t := reflect.TypeOf(m)</span><br><span class="line">name, _ := t.FieldByName(<span class="string">&quot;name&quot;</span>)<span class="comment">///&lt; 按名称查找</span></span><br><span class="line">fmt.Println(name.Name, name.Type)</span><br><span class="line"></span><br><span class="line">age := t.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;)<span class="comment">///&lt; 按多级索引查找</span></span><br><span class="line">fmt.Println(age.Name, age.Type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// name string</span></span><br><span class="line"><span class="comment">/// age int</span></span><br></pre></td></tr></table></figure><blockquote><p><code>FieldByName</code>不支持多级名称，如有同名遮蔽，须通过匿名字段二次获取</p></blockquote><p>反射能探知当前包或外包的非导出结构成员</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s http.Server</span><br><span class="line">t := reflect.TypeOf(s)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">fmt.Println(t.Field(i).Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// Addr</span></span><br><span class="line"><span class="comment">/// Handler</span></span><br><span class="line"><span class="comment">/// TLSConfig</span></span><br><span class="line"><span class="comment">/// ReadTimeout</span></span><br><span class="line"><span class="comment">/// ReadHeaderTimeout</span></span><br><span class="line"><span class="comment">/// WriteTimeout</span></span><br><span class="line"><span class="comment">/// IdleTimeout</span></span><br><span class="line"><span class="comment">/// MaxHeaderBytes</span></span><br><span class="line"><span class="comment">/// TLSNextProto</span></span><br><span class="line"><span class="comment">/// ConnState</span></span><br><span class="line"><span class="comment">/// ErrorLog</span></span><br><span class="line"><span class="comment">/// BaseContext</span></span><br><span class="line"><span class="comment">/// ConnContext</span></span><br><span class="line"><span class="comment">/// inShutdown</span></span><br><span class="line"><span class="comment">/// disableKeepAlives</span></span><br><span class="line"><span class="comment">/// nextProtoOnce</span></span><br><span class="line"><span class="comment">/// nextProtoErr</span></span><br><span class="line"><span class="comment">/// mu</span></span><br><span class="line"><span class="comment">/// listeners</span></span><br><span class="line"><span class="comment">/// activeConn</span></span><br><span class="line"><span class="comment">/// doneChan</span></span><br><span class="line"><span class="comment">/// onShutdown</span></span><br></pre></td></tr></table></figure><blockquote><p>相对<code>reflect</code>而言，当前包和外包都是”外包”</p></blockquote><p>可用反射提取<code>struct tag</code>, 还能自动分解。其常用于ORM映射, 或数据格式验证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span> <span class="string">`field:&quot;name&quot; type:&quot;varchar(50)&quot;`</span></span><br><span class="line">age <span class="type">int</span><span class="string">`field:&quot;age&quot; type:&quot;int&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">f := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %s %s\n&quot;</span>, f.Name, f.Tag.Get(<span class="string">&quot;field&quot;</span>), f.Tag.Get(<span class="string">&quot;type&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: name varchar(50)</span></span><br><span class="line"><span class="comment">/// age: age int</span></span><br></pre></td></tr></table></figure><p>辅助判断方法<code>Implements</code>、<code>ConvertibleTo</code>、<code>AssignableTo</code> 都是运行期进行动态调用和赋值所必需的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a X</span><br><span class="line">t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implements 不能直接使用类型作为参数，导致这种用法特别别扭</span></span><br><span class="line">st := reflect.TypeOf((*fmt.Stringer)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">fmt.Println(t.Implements(st))</span><br><span class="line"></span><br><span class="line">it := reflect.TypeOf(<span class="number">0</span>)</span><br><span class="line">fmt.Println(t.ConvertibleTo(it))</span><br><span class="line"></span><br><span class="line">fmt.Println(t.AssignableTo(st), t.AssignableTo(it))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true false</span></span><br></pre></td></tr></table></figure><h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>和<code>Type</code>获取类型信息不同， <code>Value</code>专注于对象实例数据读写<br>接口变量会赋值对象，且时<code>unaddressable</code>的，所以要修改对象就必须使用指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">100</span></span><br><span class="line">  va, vp := reflect.ValueOf(a), reflect.ValueOf(&amp;a).Elem()</span><br><span class="line"></span><br><span class="line">  fmt.Println(va.CanAddr(), va.CanSet())</span><br><span class="line">  fmt.Println(vp.CpnAddr(), va.CanSet())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// false false</span></span><br><span class="line"><span class="comment">/// true true</span></span><br></pre></td></tr></table></figure><blockquote><p>就算传入指针，一样需要通过<code>Elem</code>获取目标对象。因为被接口存储的指针本身时不能寻址和进行设置操作的。</p></blockquote><p>注意：不能对非导出字段进行设置操作，无论是当前包还是外包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">code <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := <span class="built_in">new</span>(User)</span><br><span class="line">v := reflect.ValueOf(p).Elem()</span><br><span class="line">name := v.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">code := v.FieldByName(<span class="string">&quot;code&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;name: canaddr = %v, canset = %v\n&quot;</span>, name.CanAddr(), name.CanSet())</span><br><span class="line">fmt.Printf(<span class="string">&quot;code: canaddr = %v, canset = %v\n&quot;</span>, code.CanAddr(), code.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name.CanSet() &#123;</span><br><span class="line">name.SetString(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> code.CanAddr() &#123;</span><br><span class="line">*(*<span class="type">int</span>)(unsafe.Pointer(code.UnsafeAddr())) = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, *p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: canaddr = true, canset = true</span></span><br><span class="line"><span class="comment">/// code: canaddr = true, canset = false</span></span><br><span class="line"><span class="comment">/// &#123;Name:Tom code:100&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Value.Pointer</code>和<code>Value.Int</code>等方法类似，将<code>Value.data</code>存储的数据转换为指针，目标必须是指针类型。<br>而<code>UnsafeAddr</code>返回任何<code>CanAddr Value.data</code>地址（相当于&amp;取地址操作）,比如<code>Elem</code>后的<code>Value</code>, 以及字段成员地址。<br>以结构体里的指针类型字段为例，<code>Pointer</code>返回该字段所保存的地址，而<code>UnsafeAddr</code>返回该字段本身的地址(结构对象地址+偏移量)</p></blockquote><p>可通过<code>Interface</code>方法进行类型推断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := user&#123;</span><br><span class="line"><span class="string">&quot;q.yuhen&quot;</span>,</span><br><span class="line"><span class="number">60</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(&amp;u)</span><br><span class="line"><span class="keyword">if</span> !v.CanInterface() &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;CanInterface: fail.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p, ok := v.Interface().(*user)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Interface: fail.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.Age++</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// &#123;Name:q.yuhen Age:61&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以直接使用<code>Value.Int</code>、<code>Bool</code>等方法进行类型转换，但失败时会引发<code>panic</code>, 且不支持<code>ok-idiom</code></p></blockquote><p>复合类型对象设置示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">  v := reflect.ValueOf(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> v.TrySend(reflect.ValueOf(<span class="number">100</span>)) &#123;</span><br><span class="line">    fmt.Println(v.TryRecv())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 100 true</span></span><br></pre></td></tr></table></figure><p>接口有两种<code>nil</code>状态，这一致是个潜在麻烦。解决方法是用<code>IsNil</code>判断值是否为<code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(a == <span class="literal">nil</span>)</span><br><span class="line">  fmt.Println(b == <span class="literal">nil</span>, reflect.ValueOf(b).IsNil())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false true</span></span><br></pre></td></tr></table></figure><p>也可用<code>unsafe</code>转换后直接判断<code>iface.data</code>是否是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">  iface := (*[<span class="number">2</span>]<span class="type">uintptr</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">  fmt.Println(iface, iface[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// &amp;[712160 0] true</span></span><br></pre></td></tr></table></figure><p>让人很无奈的是, <code>Value</code>里的某些方法并未实现<code>ok-idom</code>或返回<code>error</code>, 所以得自行判断返回的是否为<code>Zero Value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  v := reflect.ValueOf(<span class="keyword">struct</span>&#123;name <span class="type">string</span>&#125;)</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;name&quot;</span>).IsValid())</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;xxx&quot;</span>).IsValid())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false</span></span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>动态调用方法，谈不上有多麻烦。只须按<code>In</code>列表准备好所需参数即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Test(x, y <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y, fmt.Errorf(<span class="string">&quot;err: %d&quot;</span>, x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X</span><br><span class="line">  v := reflect.ValueOf(&amp;a)</span><br><span class="line">  m := MethodByName(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  in := []reflect.Value &#123;</span><br><span class="line">    reflect.ValueOf(<span class="number">1</span>),</span><br><span class="line">    reflect.ValueOf(<span class="number">2</span>),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out := m.Call(in)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> out &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="comment">/// err: 3</span></span><br></pre></td></tr></table></figure><p>对于变参来书，用<code>CallSlice</code>要更方便一些</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Format(s <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(s, a...)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a X</span><br><span class="line">   v := reflect.ValueOf(&amp;a)</span><br><span class="line">   m := v.MethodByName(<span class="string">&quot;Format&quot;</span>)</span><br><span class="line">   out := m.Call([]reflect.Value&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;x&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;100&quot;</span>),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"></span><br><span class="line">   out = m.CallSlice([]reflect.ValueP&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf([]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;x&quot;</span>, <span class="number">100</span>&#125;),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br></pre></td></tr></table></figure><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>反射库提供了内置函数<code>make</code>和<code>new</code>的对应操作，其中最有意思的就是<code>MakeFunc</code>。可用它实现通用模板，使用不同数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args []reflect.Value)</span></span> (results []reflect.Value) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret reflect.Value</span><br><span class="line">  <span class="keyword">switch</span> args[<span class="number">0</span>].Kind() &#123;</span><br><span class="line">  <span class="keyword">case</span> reflect.Int:</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">      n += <span class="type">int</span>(a.Int())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = reflect.ValueOf(n)</span><br><span class="line">  <span class="keyword">case</span> reflect.String:</span><br><span class="line">    ss := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> args &#123;</span><br><span class="line">      ss = <span class="built_in">append</span>(ss, s.String())</span><br><span class="line">    &#125;</span><br><span class="line">    ret = reflect.ValueOf(strings.Join(ss, <span class="string">&quot;&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  results = <span class="built_in">append</span>(results, ret)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将函数指针参数指向通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAdd</span><span class="params">(fptr <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  fn := reflect.ValueOf(fptr).Elem()</span><br><span class="line">  v := reflect.MakeFunc(fn.Type(), add) <span class="comment">// 这是关键</span></span><br><span class="line">  fn.Set(v) <span class="comment">// 指向通用算法函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> intAdd <span class="function"><span class="keyword">func</span><span class="params">(s, y <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> strAdd <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  makeAdd(&amp;intAdd)</span><br><span class="line">  makeAdd(&amp;strAdd)</span><br><span class="line">  <span class="built_in">println</span>(intAdd(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">  <span class="built_in">println</span>(strAdd(<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot;world!&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 300</span></span><br><span class="line"><span class="comment">/// hello, world!</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(1)测试</title>
      <link href="/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="11-测试"><a href="#11-测试" class="headerlink" title="11. 测试"></a>11. 测试</h2><p>标准库自带单元测试框架</p><ul><li>测试代码须放在当前包以”_test.go”结尾的文件中</li><li>测试函数以Test为名称前缀</li><li>测试命令(go test) 忽略以”_” 或 “.” 开头的测试文件</li><li>正常编译操作(go build&#x2F;install)会忽略测试文件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">x<span class="type">int</span></span><br><span class="line">y<span class="type">int</span></span><br><span class="line">expect<span class="type">int</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">actual := add(tt.x, tt.y)</span><br><span class="line"><span class="keyword">if</span> actual != tt.expect &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;add(%d, %d): expect %d, actual %d&quot;</span>, tt.x, tt.y, tt.expect, actual)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">t.Parallel()</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">t.Parallel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>-arg</td><td>命令行参数</td><td></td></tr><tr><td>-v</td><td>输出详细信息</td><td></td></tr><tr><td>-parallel</td><td>并发执行, 默认执行GOMAXPROCS</td><td>-parallel 2</td></tr><tr><td>-run</td><td>指定测试函数，正则表达式</td><td>-run “Add”</td></tr><tr><td>-timeout</td><td>全部测试累计时间超时将引发panic, 默认值为10ms</td><td>-timeout 1m30s</td></tr><tr><td>-count</td><td>重复测试次数，默认次数为1</td><td></td></tr></tbody></table><h3 id="test-main"><a href="#test-main" class="headerlink" title="test main"></a>test main</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span>&#123;</span><br><span class="line"><span class="comment">// setup</span></span><br><span class="line">code := m.Run()<span class="comment">// 调用测试函数</span></span><br><span class="line"><span class="comment">// tear down</span></span><br><span class="line">os.Exit(code)<span class="comment">// 注意： os.Exit 不会执行defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多测试用例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span> &#123;</span><br><span class="line">match := <span class="function"><span class="keyword">func</span><span class="params">(pat, str <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;<span class="comment">// pat: 命令行参数-run 提供的过滤条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span><span class="comment">// str: InternalTest.Name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tests := []testing.InternalTest &#123;</span><br><span class="line">&#123;<span class="string">&quot;b&quot;</span>, TestB&#125;,</span><br><span class="line">&#123;<span class="string">&quot;a&quot;</span>, TestA&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">benchmarks := []testing.InternalBenchmark&#123;&#125;</span><br><span class="line">examples := []testing.InternalExample&#123;&#125;</span><br><span class="line"></span><br><span class="line">m = testing.MainStart(match, tests, benchmarks, examples)</span><br><span class="line"></span><br><span class="line">os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Println(add(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果没有output注释，该示例就不会被执行。另外，不能使用内置函数print&#x2F;printIn, 因为他们输出到stderr</p><h3 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go test -bench .</p></blockquote><p>如果希望仅执行性能测试，那么可以用<code>run=NONE</code>忽略所有测试用例。<br>性能测试默认以并发方式进行测试，但可用cpu参数设定多个并发限制来观察结果。</p><blockquote><p>go test -bench . -cpu 1,2,4</p></blockquote><p>某些耗时的目标，默认循环测试过少，取平均值不足以准确计量性能。可用<code>benchtime</code>设定最小测试时间来增加循环次数，以便返回更准确的结果。</p><blockquote><p>go test -bench . -benchtime 5s</p></blockquote><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>如果在测试函数中要执行一些额外的操作，那么应该临时i组织计时器工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">b.ResetTimer()<span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">b.StopTimer()<span class="comment">// 暂停</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">b.StartTimer()<span class="comment">// 恢复</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p>性能测试查看内存情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heap</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = heap()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go test -bench . -benchmem -gcflags “-N -l” # 禁止内联和优化， 以便观察结果</p></blockquote><p>也可将测试函数设置为总是输出内存分配信息，无论使用benchmem参数与否</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span> </span>&#123;</span><br><span class="line">b.<span class="built_in">ReportAllocs</span>()</span><br><span class="line">b.<span class="built_in">ReportTimer</span>()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = <span class="built_in">heap</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><blockquote><p>go test -cover</p></blockquote><p>为获取更详细信息，可指定covermode 和coverprofile 参数</p><ul><li>set: 是否执行</li><li>count: 执行次数</li><li>atomic: 执行次数，支持并发模式<blockquote><p>go test -cover -covermode count -coverprofile cover.out</p></blockquote></li></ul><p>还可以在浏览器中查看包括具体的执行次数等信息</p><blockquote><p>go tool cover -html&#x3D;cover.out</p></blockquote><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>引发性能问题的原因无外乎执行时间过长、内存占用过多，以及意外阻塞。通过捕获或监控相关执行状态数据，就可定位引发问题的原因，从而针对性改进算法。</p><blockquote><p>go test -run NONE -bench . -memprofile mem.out -cpuprofile cpu.out net&#x2F;http</p></blockquote><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>-cpuprofile</td><td>保存执行时间采样到指定文件</td><td>-cpuprofile cpu.out</td></tr><tr><td>-memprofile</td><td>保存内存分配采样到指定文件</td><td>-memprofile mem.out</td></tr><tr><td>-memprofilerate</td><td>内存分配采样起始值，默认为512KB</td><td>-memprofilerate 1</td></tr><tr><td>-blockprofile</td><td>保存阻塞时间采样到指定文件</td><td>-blockprofile block.out</td></tr><tr><td>-blockprofilerate</td><td>阻塞时间采样起始值，单位为：ns</td><td></td></tr></tbody></table><p>如果执行性能测试，可能需要设置<code>benchtime</code>参数，以确保有足够的采样时间</p><p>可使用交互模式查看，或用命令行直接输出单向结果。</p><blockquote><p>go tool pprof http.test mem.out<br>(pprof) top5</p></blockquote><ul><li>flat: 仅当前函数，不包括它调用的其他函数。</li><li>sum: 列表前几行所占百分比的总和。</li><li>cum: 当前函数调用堆栈累计。</li></ul><p>top命令可指定排序字段，比如<code>top5 -cum</code><br>找出需要进一步查看的目标，使用<code>peek</code>命令列出调用来源<br>也可用list命令输出源码统计样式，以便更直观的定位<br>除文字模式以外，还可输出svg图形，将其保存或用浏览器查看</p><p>在线采集数据须诸如 <code>http/pprof</code>包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用浏览器访问指定路径，就可看到不同的检测项。</p><blockquote><p>go tool pprof <a href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a></p></blockquote><p>必要时还可抓取数据，进行离线分析。</p><blockquote><p>curl <a href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a> &gt; mem.out<br>go tool pprof test mem.out</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 迭代器介绍</title>
      <link href="/2020/07/31/2020-07-31-C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/07/31/2020-07-31-C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="C-迭代器介绍"><a href="#C-迭代器介绍" class="headerlink" title="C++ 迭代器介绍"></a>C++ 迭代器介绍</h1><h2 id="迭代器概念"><a href="#迭代器概念" class="headerlink" title="迭代器概念"></a>迭代器概念</h2><p><code>Iterator</code>(迭代器)是一种”能够迭代某序列内所有元素”的对象，可通过改变自寻常pointer的一致性接口来完成工作。<code>Iterator</code>奉行一个纯抽象概念：任何东西，只要行为类似iterator，就是一种iterator。然而不同的的iterator具有不同的行进能力。</p><h2 id="迭代器种类"><a href="#迭代器种类" class="headerlink" title="迭代器种类"></a>迭代器种类</h2><table><thead><tr><th>迭代器种类</th><th>能力</th><th>提供者</th></tr></thead><tbody><tr><td>Output 迭代器</td><td>向前写入</td><td>Ostream,inserter</td></tr><tr><td>Input 迭代器</td><td>向前读取一次</td><td>Istream</td></tr><tr><td>Forward 迭代器</td><td>向前读取</td><td>Forward list、unordered containers</td></tr><tr><td>Bidirectional 迭代器</td><td>向前和向后读取</td><td>List、set、multiset、map、multimap</td></tr><tr><td>Random-access 迭代器</td><td>以随机访问方式读取</td><td>Array、vector、deque、string、C-style array</td></tr><tr><td><img src="/resource/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A7%8D%E7%B1%BB/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="迭代器种类"></td><td></td><td></td></tr></tbody></table><h3 id="Output迭代器"><a href="#Output迭代器" class="headerlink" title="Output迭代器"></a>Output迭代器</h3><p>Output迭代器允许一步一步前行并搭配write动作。因此你可以一个一个元素地赋值，不能使用output迭代器对同一区间迭代两次。事实上，甚至不保证你可以将一个value复制两次而其迭代器不累进。我们的目标是将一个value以下列形式写入一个黑洞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">  *pos = ...;</span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output 迭代器无需比较操作。你无法检验output迭代器是否有效，或写入是否成功。你唯一可做的就是写入。通常，一批写入动作是以一个”额外条件定义出”的”特定output迭代器”作为结束。<br>见下表Output迭代器操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter &#x3D; val</td><td>将val写至迭代器所指的位置</td></tr><tr><td>++iter</td><td>向前步进(step forward), 返回新位置</td></tr><tr><td>iter++</td><td>向前步进(step forward), 返回旧位置</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(copy 构造函数)</td></tr></tbody></table><p>通常，迭代器可用来读，也可用来写; 几乎所有reading迭代器都有write的额外功能，这种情况下他们被称为<code>mutable</code>(可产生变化的)迭代器。<br>一个典型的<code>pure output</code>迭代器例子是：”将元素写至标准输出设备”。 如果采用两个output迭代器写至屏幕, 第二个字将跟在第一个字后面，而不是覆盖第一个字。另一个典型的例子是inserter, 那是一种用来将他插入容器。如果随后写入第二个value, 并不会覆盖第一个value, 而是安插进去。</p><h3 id="Input迭代器"><a href="#Input迭代器" class="headerlink" title="Input迭代器"></a>Input迭代器</h3><p>Input迭代器只能一次一个以前行方向读取元素，按此顺序一个个返回元素值。<br>Input迭代器的各项操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter</td><td>读取实际元素</td></tr><tr><td>iter-&gt;member</td><td>读取实际元素的成员(如果有的话)</td></tr><tr><td>++iter</td><td>向前步进(step forward), 返回新位置</td></tr><tr><td>iter++</td><td>向前步进(step forward), 返回旧位置</td></tr><tr><td>iter1 &#x3D;&#x3D; iter2</td><td>判断两个迭代器是否相等</td></tr><tr><td>iter1 !&#x3D; iter2</td><td>判断两个迭代器是否不相等</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(copy 构造函数)</td></tr></tbody></table><p>Input迭代器只能读取元素一次。如果你复制input迭代器, 并令原input迭代器和新产生的拷贝都向前读取, 可能会遍历到不同的值。<br><strong>所有的迭代器都具备input迭代器的能力，而且往往更强。</strong><code>Pure input</code>迭代器的典型例子就是”从标准输入设备读取数据”。同一个值不会被读取两次。一旦从<code>input stream</code>读入一个字(离开input缓冲区), 下次读取时就会返回另一个字。</p><p>对于input迭代器, 操作符&#x3D;&#x3D;和!&#x3D;只用来检查”某个迭代器是否等于一个past-the-end迭代器(指指向最末元素的下一个位置)”.这有其必要, 因为处理input迭代器的操作函数通常会有以下行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputIterator pos, end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos != end) &#123;</span><br><span class="line">  ... <span class="comment">// read-only access using *pos</span></span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有任何保证说，两个迭代器如果都不是past-the-end迭代器, 且指向不同位置，他们的比较结果会不相等</strong>(这个条件是和forward迭代器搭配引入的)。</p><p>也请注意, input迭代器的后置式递增操作符(<code>++iter</code>)不一定会返回什么东西。不过通常它会返回旧位置。<br>你应该尽可能优先先选用前置式递增操作符(<code>++iter</code>)而非后置式递增操作符(<code>iter++</code>), 因为前者效能更好。因为后者会返回一个临时对象。</p><h3 id="Forward-前向-迭代器"><a href="#Forward-前向-迭代器" class="headerlink" title="Forward(前向)迭代器"></a>Forward(前向)迭代器</h3><p>Forward迭代器是一种input迭代器且在前进读取时提供额外保证。</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter</td><td>访问实际元素</td></tr><tr><td>iter-&gt;member</td><td>访问实际元素的成员</td></tr><tr><td>++iter</td><td>向前步进(返回新位置)</td></tr><tr><td>iter++</td><td>向前步进(返回旧位置)</td></tr><tr><td>iter1 &#x3D;&#x3D; iter2</td><td>判断两个迭代器是否相等</td></tr><tr><td>iter1 !&#x3D; iter2</td><td>判断两个迭代器是否不等</td></tr><tr><td>TYPE()</td><td>创建迭代器(default构造函数)</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(拷贝构造函数)</td></tr><tr><td>iter1 &#x3D; iter2</td><td>对迭代器赋值(assign)</td></tr><tr><td>和input迭代器不同的是, 两个forward迭代器如果指向同一元素, <code>operator==</code>会获得<code>true</code>, 如果两者都递增, 会再次指向同一元素。</td><td></td></tr><tr><td>例如：</td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ForwardIterator pos1, pos2;</span><br><span class="line"></span><br><span class="line">pos1 = pos2 = begin; <span class="comment">/// both iterator refer to the same element</span></span><br><span class="line"><span class="keyword">if</span>(pos1 != end) &#123;</span><br><span class="line">  ++pos1; <span class="comment">/// pos1 is one element ahead</span></span><br><span class="line">  <span class="keyword">while</span>(pos1 != end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(*pos1 == *pos2) &#123;</span><br><span class="line">      ... <span class="comment">// precess adjacent duplicates</span></span><br><span class="line">      ++pos1;</span><br><span class="line">      ++pos2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Forward迭代器由以下对象和类型提供：</p><ul><li>Class<forward_list></li><li>Unordered container<br>然而标准库也允许<code>unordered</code>容器的实现提供<code>bidirectional</code>迭代器。<br>如果forward迭代器履行了output迭代器应有的条件, 那么它就是一个mutable forward迭代器, 即可用于读取，也可用于涂写。</li></ul><h3 id="Bidirectional-双向-迭代器"><a href="#Bidirectional-双向-迭代器" class="headerlink" title="Bidirectional(双向)迭代器"></a>Bidirectional(双向)迭代器</h3><p><code>Bidirectional</code>迭代器在<code>forward</code>迭代器的基础上增加回头迭代(<code>iterate backward</code>)能力。</p><p><code>Bidirectional</code> 迭代器的新增操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>–iter</td><td>步退(返回新位置)</td></tr><tr><td>iter–</td><td>步退(返回旧位置)</td></tr></tbody></table><p><code>Bidirectional</code>迭代器由以下的对象和类型提供：</p><ul><li>Class list&lt;&gt;.</li><li>Associative(关联式) 关联式容器提供</li></ul><p>如果<code>bidirectional</code>迭代器履行了output迭代器应有的条件, 那么他就是个<code>mutable bidirectional</code>迭代器, 即可用于读取, 也可用于涂写。</p><h3 id="Random-Access-随机访问-迭代器"><a href="#Random-Access-随机访问-迭代器" class="headerlink" title="Random-Access(随机访问)迭代器"></a>Random-Access(随机访问)迭代器</h3><p><code>Random-access</code>迭代器在<code>bidirectional</code>迭代器的基础上增加了随机访问能里。因此它必须提供<code>iterator</code>算数运算。也就是说，它能增减某个偏移量、<br>计算距离(<code>difference</code>), 并运用诸如&lt;和&gt;等管理操作符(<code>relational operator</code>)进行比较。<br>随机访问迭代器的新增操作:</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>iter[n]</td><td>访问索引位置为n的元素</td></tr><tr><td>iter+&#x3D;n</td><td>前进n个元素(如果n是负数, 则改为回退)</td></tr><tr><td>iter-&#x3D;n</td><td>回退n个元素(如果n是负数, 则改为前进)</td></tr><tr><td>iter+n</td><td>返回iter之后的第n个元素</td></tr><tr><td>n+iter</td><td>返回iter之后的第n个元素</td></tr><tr><td>iter-n</td><td>返回iter之前的第n个元素</td></tr><tr><td>iter1-iter2</td><td>返回iter1和iter2之间的距离</td></tr><tr><td>iter1 &lt; iter2</td><td>判断iter1是否在iter2之前</td></tr><tr><td>iter1 &gt; iter2</td><td>判断iter1是否在iter2之后</td></tr><tr><td>iter1 &lt;&#x3D; iter2</td><td>判断iter1是否不在iter2之后</td></tr><tr><td>iter1 &gt;&#x3D; iter2</td><td>判断iter1是否不在iter2之前</td></tr></tbody></table><p><code>Random-access</code>迭代器由以下对象和类型提供:</p><ul><li>可随机访问的容器(<code>array</code>、<code>vector</code>、<code>deque</code>)</li><li>String(<code>string</code>、<code>wstring</code>)</li><li>寻常的C-Style(<code>pointer</code>)</li></ul><h2 id="迭代器相关辅助函数"><a href="#迭代器相关辅助函数" class="headerlink" title="迭代器相关辅助函数"></a>迭代器相关辅助函数</h2><h3 id="std-advance"><a href="#std-advance" class="headerlink" title="std::advance()"></a>std::advance()</h3><p><code>std::advance()</code>可将迭代器的位置增加, 增加的幅度由实参决定, 也就是说它令迭代器一次前进(或后退)多个元素:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; pos, Dist n)</span></span></span><br></pre></td></tr></table></figure><ul><li>令名称为pos的input迭代器前进(或后退)n个元素</li><li>对<code>bidirectinal</code>迭代器和<code>random-access</code>迭代器而言, n可为负值, 表示后退</li><li><code>Dist</code>是个template类型。通常它必须是个整数类型, 因为会调用诸如<code>&lt;</code>、<code>++</code>、<code>--</code>等操作, 还要和0做比较。</li><li><code>std::advance()</code>并不检查迭代器是否超过序列的<code>end()</code>(因为迭代器通常不知道其所操作的容器, 因此并无检查)。所以, 调用<code>std::advance()</code>有可能导致不明确行为–因为”对序列尾端调用<code>operator++</code>“是一种未定义的行为。</li></ul><p>对于<code>random-access</code>迭代器, 此函数只是简单地调用<code>pos+=n</code>, 因此具有常量复杂度。 对于其他任何类型的迭代器, 则调用<code>++pos</code>(或<code>--pos</code>如果n为负值)n次。因此，对于其他任何类型地迭代器, 本函数具有线性复杂度。<br><strong>如果你希望你的程序可以轻松地更换容器和迭代器种类, 你应该使用<code>std::advance()</code>而不是<code>operator+=</code></strong><br><strong>另外, 请注意<code>std::advance()</code>不具有返回值, 而<code>operator+=</code>会返回新位置, 所以后者可作为更大表达式的一部分。</strong></p><p>下面是一个<code>std::advance()</code>的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 输入迭代器的情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_InIt&amp; _Where, _Diff _Off, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 检查该偏移量不能为负值</span></span><br><span class="line">  <span class="keyword">if</span> (_Off &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span> &amp;&amp; <span class="string">&quot;negative offset in advance&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 使用自增运算符来计算</span></span><br><span class="line">  <span class="keyword">for</span> (; <span class="number">0</span> &lt; _Off; --_Off) ++_Where;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 双向迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_BidIt&amp; _Where, _Diff _Off,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 使用自增运算符来计算</span></span><br><span class="line">  <span class="keyword">for</span> (; <span class="number">0</span> &lt; _Off; --_Off) ++_Where;</span><br><span class="line">  <span class="comment">/// 如果偏移量为负值则使用自减运算符</span></span><br><span class="line">  <span class="keyword">for</span> (; _Off &lt; <span class="number">0</span>; ++_Off) --_Where;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 随机访问迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_RanIt&amp; _Where, _Diff _Off,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 使用operator += ，常量复杂度</span></span><br><span class="line">  _Where += _Off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InIt&amp; _Where, _Diff _Off)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">advance_impl</span>(_Where, _Off,</span><br><span class="line">               <span class="comment">/// 在萃取迭代器的特性时去掉其const的属性来提高性能</span></span><br><span class="line">               std::iterator_traits&lt;_Iter&gt;::iterator_category&lt;</span><br><span class="line">                   std::<span class="type">remove_const_t</span>&lt;_InIt&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-next-和std-prev"><a href="#std-next-和std-prev" class="headerlink" title="std::next()和std::prev()"></a>std::next()和std::prev()</h3><p>c++ 提供了两个新增的辅助函数, 允许你前进和后退移动迭代器的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">next</span><span class="params">(ForwardIterator pos)</span></span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">next</span><span class="params">(ForwardIterator pos, Dist n)</span></span></span><br></pre></td></tr></table></figure><ul><li>导致<code>forward</code>迭代器<code>pos</code>前进或n个位置</li><li>如果处理的是<code>bidirectional</code>和<code>random-access</code>迭代器, n可为负值, 导致后退移动</li><li><code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li><li>其内部将对一个临时对象调用<code>std::advance(pos, n)</code></li><li>注意, <code>std::next()</code>并不检查是否会跨越序列的<code>end()</code>。因此调用者必须自行担保其结果有效。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">prev</span><span class="params">(BidirectionalIterator pos)</span></span></span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">prev</span><span class="params">(BidirectionalIterator pos, Dist n)</span></span></span><br></pre></td></tr></table></figure><ul><li>导致<code>bidirectional</code>迭代器<code>pos</code>后退一个或n个位置</li><li>n可为负值, 导致向前移动</li><li><code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li><li>其内部将对一个临时对象调用<code>std::advance(pos, -n)</code></li><li>注意, <code>std::prev()</code>并不检查是否会跨越序列的<code>begin()</code>。因此调用者必须自行担保其结果有效。</li></ul><p>下面写一个简单的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _InIt <span class="title">next</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _InIt _First,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::iterator_traits&lt;_InIt&gt;::iterator_category&lt;_InIt&gt; _Off = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::is_base_of&lt;</span><br><span class="line">          std::input_iterator_tag,</span><br><span class="line">          <span class="keyword">typename</span> std::iterator_traits&lt;_InIt&gt;::iterator_category&gt;::value,</span><br><span class="line">      <span class="string">&quot;next requires input iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">advance</span>(_First, _Off);</span><br><span class="line">  <span class="keyword">return</span> (_First);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidIt</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _BidIt <span class="title">prev</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _BidIt _First,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::iterator_traits&lt;_BidIt&gt;::iterator_category&lt;_BidIt&gt; _Off = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::is_base_of&lt;</span><br><span class="line">          std::bidirectional_iterator_tag,</span><br><span class="line">          <span class="keyword">typename</span> std::iterator_traits&lt;_BidIt&gt;::iterator_category&gt;::value,</span><br><span class="line">      <span class="string">&quot;prev requires bidirectional iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">advance</span>(_First, -_Off);</span><br><span class="line">  <span class="keyword">return</span> (_First);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-distance"><a href="#std-distance" class="headerlink" title="std::distance()"></a>std::distance()</h3><p><code>std::distance()</code>用来处理两个迭代器之间的距离:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dist <span class="title">distance</span><span class="params">(InputIterator pos1, InputIterator pos2)</span></span></span><br></pre></td></tr></table></figure><ul><li>返回两个<code>input</code>迭代器<code>pos1</code>和<code>pos2</code>之间的距离。</li><li>两个迭代器必须指向同一个容器</li><li>如果不是<code>random-access</code>迭代器, 则从<code>pos1</code>开始前进必须能够到达<code>pos2</code>, 亦即<code>pos2</code>的位置必须与<code>pos1</code>相同或在其后。</li><li>返回类型<code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li></ul><p>注意： 处理两个<code>non-random-access</code>迭代器之间的距离时, 必须十分小心。第一个迭代器所指的元素绝不能在第二个迭代器所指元素之后方, 否则会导致不明确的行为。<strong>如果不知道哪个迭代器在前, 你必须先算出两个迭代器分别至容器起点的距离, 在根据这两个距离来判断。</strong></p><p>一个简单的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> it&gt;</span><br><span class="line"><span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(it from, it to)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::iterator_category() ==</span></span></span><br><span class="line"><span class="params"><span class="function">                std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 随机访问迭代器</span></span><br><span class="line">    <span class="keyword">return</span> to - from;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::<span class="built_in">iterator_category</span>() ==</span><br><span class="line">                       std::input_iterator_tag) &#123;</span><br><span class="line">    <span class="comment">/// input 迭代器</span></span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::difference_type res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; from != to; ++from) &#123;</span><br><span class="line">      ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="string">&quot;unknow iterator type.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-iter-swap"><a href="#std-iter-swap" class="headerlink" title="std::iter_swap()"></a>std::iter_swap()</h3><p>这个简单的辅助函数用来交换两个迭代器所指的元素值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator1 pos1, ForwardIterator pos2)</span></span></span><br></pre></td></tr></table></figure><ul><li>交换迭代器pos1和pos2所指的值</li><li>迭代器的类型不必相同, 但其所指的两个值必须<strong>可以相互赋值</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ integer_sequence介绍</title>
      <link href="/2020/07/22/2020-07-22-C++%20integer_sequence%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/07/22/2020-07-22-C++%20integer_sequence%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="integer-sequence"><a href="#integer-sequence" class="headerlink" title="integer_sequence"></a>integer_sequence</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T... ints&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sequence</span><span class="params">(std::integer_sequence&lt;T, ints...&gt; int_seq)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; int_seq.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  ((std::cout &lt;&lt; ints &lt;&lt; <span class="string">&#x27; &#x27;</span>), ...);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 转化数组为tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Array, std::<span class="type">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">a2t_impl</span><span class="params">(<span class="type">const</span> Array&amp; a, std::index_sequence&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(a[I]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N,</span><br><span class="line">          <span class="keyword">typename</span> Indices = std::make_index_sequence&lt;N&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">a2t</span>(<span class="type">const</span> std::array&lt;T, N&gt;&amp; a) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">a2t_impl</span>(a, Indices&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 漂亮地打印 tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ch</span>, <span class="keyword">class</span> <span class="title class_">Tr</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>, std::<span class="type">size_t</span>... Is&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_tuple_impl</span><span class="params">(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, <span class="type">const</span> Tuple&amp; t,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::index_sequence&lt;Is...&gt;)</span> </span>&#123;</span><br><span class="line">  ((os &lt;&lt; (Is == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>) &lt;&lt; std::<span class="built_in">get</span>&lt;Is&gt;(t)), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ch</span>, <span class="keyword">class</span> <span class="title class_">Tr</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span>&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, <span class="type">const</span> std::tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">  <span class="built_in">print_tuple_impl</span>(os, t, std::index_sequence_for&lt;Args...&gt;&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::integer_sequence&lt;<span class="type">unsigned</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::make_integer_sequence&lt;<span class="type">int</span>, <span class="number">20</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::make_index_sequence&lt;<span class="number">10</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::index_sequence_for&lt;<span class="type">float</span>, std::iostream, <span class="type">char</span>&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  std::array&lt;<span class="type">int</span>, 4&gt; array = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> tuple = <span class="built_in">a2t</span>(array);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;<span class="keyword">decltype</span>(tuple), std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; tuple &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 设计模式之单例模式</title>
      <link href="/2020/07/15/2020-07-15-C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/15/2020-07-15-C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正确写法"><a href="#正确写法" class="headerlink" title="正确写法"></a>正确写法</h2><p>该写法在第一次调用<code>get_instance()</code>后构造该实例，线程安全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;object&gt;&amp; <span class="title">get_instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>; <span class="comment">///&lt; 构造函数写为private，防止其他调用者单独构造该对象实例。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;object&gt;&amp; <span class="title">object::get_instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;object&gt; instance;  <span class="comment">///&lt; 该对象的唯一实例</span></span><br><span class="line">  <span class="type">static</span> std::once_flag flag; <span class="comment">///&lt; 标志位, 标记只调用一次</span></span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;]()&#123;</span><br><span class="line">    instance = std::<span class="built_in">make_unique</span>&lt;object&gt;();  <span class="comment">///&lt; C++14以后版本的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    instance = std::unique_ptr&lt;object&gt;(new object()); ///&lt; C++14 到 C++11 可用的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他写法比较"><a href="#其他写法比较" class="headerlink" title="其他写法比较"></a>其他写法比较</h2><p>最简单的写法: 线程不安全<br>由于<code>new object()</code>这个构造的过程需要时间，所以可能造成两个线程同时获取到<code>instance</code>变量为空指针。从而导致实例化两次，从未导致硬件驱动加载两次，而导致崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object* <span class="title">object::get_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  object* instance = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>double check</code>写法： 看起来线程安全，其实有条件竞争。<br>在<code>#1</code>和<code>#2</code>处，可能发生一个线程正在对<code>instance</code>变量赋值(写操作), 而另一个线程在进行在进行判断<code>instance</code>变量是否为空(读操作)，从而导致条件竞争，而导致崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object* <span class="title">object::get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> std::mutex mt;</span><br><span class="line">  <span class="keyword">volatile</span> object* instance = <span class="literal">nullptr</span>;  <span class="comment">///&lt; volatile关键字为了防止编译器优化</span></span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123; <span class="comment">///&lt; #1 读操作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">object</span>();  <span class="comment">///&lt; #2 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 设计模式 单例模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 设计模式 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 信号槽的连接方式</title>
      <link href="/2020/07/15/2020-07-15-Qt%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/15/2020-07-15-Qt%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a>官网解释</h2><h3 id="Qt-ConnectionType"><a href="#Qt-ConnectionType" class="headerlink" title="Qt::ConnectionType"></a>Qt::ConnectionType</h3><p>跨线程的信号和槽<br>Qt支持这些信号槽的连接方式：</p><ol><li>Auto Connection(默认): 假如信号在一个接收者的线程中发射，则行为等同于 Direct Connect. 否则行为等同于Queued Connection.</li><li>Direct Connect: 当信号被发射，槽函数将会被立即调用。槽函数将会在发射者的线程中执行, 而不一定在接收者线程中执行。</li><li>Queued Connect: 槽函数在控制权返回到接收者线程的事件循环时被调用。槽函数在接收者线程中被执行。</li><li>Blocking Queued Connection: 槽函数除了阻塞当前线程直到槽函数返回，其他像Queued Connection一样被调用。备注：在同一线程中使用这个类型的connect会导致死锁。</li><li>Unique Connect: 这个行为等同于Auto Connection，但是这个connection是只能在现有连接不重复的情况下生效。假如相同的信号已经连接到相同的槽函数中，这个连接不会建立且<code>connect()</code>返回<code>false</code>。</li></ol><ul><li>连接的类型可以通过<code>connect()</code>额外的参数指定，注意：在发送者和接收者在不同线程中使用direct connect是不安全的。如同一个事件循环在接收者的线程中，在另一个线程中调用存活对象的任何函数是不安全的。</li><li><code>QObject::connect()</code> 它本身是线程安全的。</li></ul><p> 在使用Queue Connection的时候，参数必须是Qt 元对象系统已知的类型，因为Qt需要拷贝入参并保存在事件背后的场景。假如你使用Queue Connection并得到以下错误信息：</p><blockquote><p>QObject::connect: Cannot queue arguments of type ‘MyType’</p></blockquote><p>在connection建立之前，调用<code>qRegisterMetaType()</code>去注册数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++循环队列的简单实现</title>
      <link href="/2020/07/09/2020-07-09-C++%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/07/09/2020-07-09-C++%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">front_</span>(<span class="number">0</span>), <span class="built_in">end_</span>(<span class="number">0</span>) &#123; data_ = <span class="keyword">new</span> T[size]; &#125;</span><br><span class="line">  ~<span class="built_in">queue</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">const</span> queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">queue</span>(queue&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  queue <span class="keyword">operator</span>=(<span class="type">const</span> queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  queue <span class="keyword">operator</span>=(queue&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> front_ == end_; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_full</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> front_ = (end_ + <span class="number">1</span>) % size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data_[front_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((end_ + <span class="number">1</span>) % size_ != front_) &#123;</span><br><span class="line">      data_[end_] = val;</span><br><span class="line">      end_ = (end_ + <span class="number">1</span>) % size_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front_ != end_) &#123;</span><br><span class="line">      front_ = (front_ + <span class="number">1</span>) % size_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">size_t</span> front_;</span><br><span class="line">  <span class="type">size_t</span> end_;</span><br><span class="line">  <span class="type">size_t</span> size_;</span><br><span class="line">  T* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">is_empty</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不采用哨兵值，使用状态来实现"><a href="#不采用哨兵值，使用状态来实现" class="headerlink" title="不采用哨兵值，使用状态来实现"></a>不采用哨兵值，使用状态来实现</h2><h2 id="spdlog-循环队列实现"><a href="#spdlog-循环队列实现" class="headerlink" title="spdlog 循环队列实现"></a>spdlog 循环队列实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circular_q</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> max_items_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type head_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type tail_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> overrun_counter_ = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;T&gt; v_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// empty ctor - create a disabled queue with no elements allocated at all</span></span><br><span class="line">  <span class="built_in">circular_q</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">circular_q</span><span class="params">(<span class="type">size_t</span> max_items)</span></span></span><br><span class="line"><span class="function">      : max_items_(max_items + <span class="number">1</span>)  // one item is reserved as marker for full q</span></span><br><span class="line"><span class="function">        ,</span></span><br><span class="line"><span class="function">        v_(max_items_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">circular_q</span>(<span class="type">const</span> circular_q &amp;) = <span class="keyword">default</span>;</span><br><span class="line">  circular_q &amp;<span class="keyword">operator</span>=(<span class="type">const</span> circular_q &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move cannot be default,</span></span><br><span class="line">  <span class="comment">// since we need to reset head_, tail_, etc to zero in the moved object</span></span><br><span class="line">  <span class="built_in">circular_q</span>(circular_q &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">copy_moveable</span>(std::<span class="built_in">move</span>(other));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  circular_q &amp;<span class="keyword">operator</span>=(circular_q &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">copy_moveable</span>(std::<span class="built_in">move</span>(other));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push back, overrun (oldest) item if no room left</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_items_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      v_[tail_] = std::<span class="built_in">move</span>(item);</span><br><span class="line">      tail_ = (tail_ + <span class="number">1</span>) % max_items_;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (tail_ == head_)  <span class="comment">// overrun last item if full</span></span><br><span class="line">      &#123;</span><br><span class="line">        head_ = (head_ + <span class="number">1</span>) % max_items_;</span><br><span class="line">        ++overrun_counter_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return reference to the front item.</span></span><br><span class="line">  <span class="comment">// If there are no elements in the container, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> v_[head_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T &amp;<span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> v_[head_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return number of elements actually stored</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail_ &gt;= head_) &#123;</span><br><span class="line">      <span class="keyword">return</span> tail_ - head_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> max_items_ - (head_ - tail_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return const reference to item by index.</span></span><br><span class="line">  <span class="comment">// If index is out of range 0…size()-1, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; <span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> v_[(head_ + i) % max_items_];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pop item from front.</span></span><br><span class="line">  <span class="comment">// If there are no elements in the container, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; head_ = (head_ + <span class="number">1</span>) % max_items_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tail_ == head_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// head is ahead of the tail by 1</span></span><br><span class="line">    <span class="keyword">if</span> (max_items_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((tail_ + <span class="number">1</span>) % max_items_) == head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> overrun_counter_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// copy from other&amp;&amp; and reset it to disabled state</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy_moveable</span><span class="params">(circular_q &amp;&amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    max_items_ = other.max_items_;</span><br><span class="line">    head_ = other.head_;</span><br><span class="line">    tail_ = other.tail_;</span><br><span class="line">    overrun_counter_ = other.overrun_counter_;</span><br><span class="line">    v_ = std::<span class="built_in">move</span>(other.v_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put &amp;&amp;other in disabled, but valid state</span></span><br><span class="line">    other.max_items_ = <span class="number">0</span>;</span><br><span class="line">    other.head_ = other.tail_ = <span class="number">0</span>;</span><br><span class="line">    other.overrun_counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 继承示例</title>
      <link href="/2020/07/09/2020-07-09-C++%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B/"/>
      <url>/2020/07/09/2020-07-09-C++%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Container</span>() &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">      <span class="keyword">auto</span> it = uuid.<span class="built_in">load</span>();</span><br><span class="line">      uuid.<span class="built_in">store</span>(++it);</span><br><span class="line">      serial_number_ = it;</span><br><span class="line">      container_map.<span class="built_in">insert</span>(&#123; serial_number_, <span class="keyword">this</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_fluid_capacity</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">totalFluidCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : container_map) &#123;</span><br><span class="line">      result += it.second-&gt;<span class="built_in">get_fluid_capacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Container* <span class="title">find_container</span><span class="params">(<span class="type">size_t</span> serial_number)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(container_map.<span class="built_in">find</span>(serial_number) != container_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> container_map[serial_number];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> std::mutex mut;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> std::atomic&lt;<span class="type">size_t</span>&gt; uuid;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> std::map&lt;<span class="type">size_t</span>, Container*&gt; container_map;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">size_t</span> serial_number_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">totalFluidCapacity</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Container* <span class="title">find_container</span><span class="params">(<span class="type">size_t</span> serial_number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buckets</span> : <span class="keyword">public</span> Container &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Buckets</span>(<span class="type">int</span> height, <span class="type">int</span> radius) : <span class="built_in">height_</span>(height), <span class="built_in">radius_</span>(radius) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_fluid_capacity</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(radius_ * radius_ * height_ * pi);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> height_;</span><br><span class="line">  <span class="type">int</span> radius_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boxes</span> : <span class="keyword">public</span> Container &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">material_type</span> : <span class="type">int</span> &#123;</span><br><span class="line">    m = <span class="number">0</span>,  <span class="comment">/// for metal</span></span><br><span class="line">    c = <span class="number">1</span>,  <span class="comment">/// for cardboard</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Boxes</span>(<span class="type">const</span> <span class="type">int</span> length, <span class="type">const</span> <span class="type">int</span> width, <span class="type">const</span> <span class="type">int</span> height, material_type type)</span><br><span class="line">      : <span class="built_in">length_</span>(length), <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height), <span class="built_in">type_</span>(type) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_fluid_capacity</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type_ == material_type::c) &#123;</span><br><span class="line">      <span class="keyword">return</span> length_ * width_ * height_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> length_;</span><br><span class="line">  <span class="type">int</span> width_;</span><br><span class="line">  <span class="type">int</span> height_;</span><br><span class="line">  material_type type_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Boxes <span class="title">box_c</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, Boxes::material_type::c)</span></span>;</span><br><span class="line">  <span class="function">Boxes <span class="title">box_m</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, Boxes::material_type::m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Buckets <span class="title">bucket</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> capa = <span class="built_in">totalFluidCapacity</span>();</span><br><span class="line">  <span class="built_in">assert</span>(capa == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> p_container = <span class="built_in">find_container</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">assert</span>(p_container == &amp; box_m);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++序列化与反序列化二叉树</title>
      <link href="/2020/07/05/2020-07-05-C++%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/05/2020-07-05-C++%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="C-序列化与反序列化二叉树"><a href="#C-序列化与反序列化二叉树" class="headerlink" title="C++序列化与反序列化二叉树"></a>C++序列化与反序列化二叉树</h1><p>首先我们定义树节点的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode* left;</span><br><span class="line">  TreeNode* right;</span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="序列化函数"><a href="#序列化函数" class="headerlink" title="序列化函数"></a>序列化函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;TreeNode*&gt; queue;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; result;</span><br><span class="line">  queue.<span class="built_in">push_back</span>(root);</span><br><span class="line">  <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">    !std::<span class="built_in">all_of</span>(queue.<span class="built_in">begin</span>(), queue.<span class="built_in">end</span>(),</span><br><span class="line">      [](<span class="type">const</span> TreeNode* node) &#123; <span class="keyword">return</span> node == <span class="literal">nullptr</span>; &#125;)) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; temp;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">pow</span>(<span class="number">2</span>, height));</span><br><span class="line">    <span class="keyword">while</span> (count-- != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> front = queue.<span class="built_in">front</span>();</span><br><span class="line">      queue.<span class="built_in">erase</span>(queue.<span class="built_in">begin</span>());</span><br><span class="line">      <span class="keyword">if</span> (front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        queue.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        queue.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(std::<span class="built_in">to_string</span>(front-&gt;val));</span><br><span class="line">        queue.<span class="built_in">push_back</span>(front-&gt;left);</span><br><span class="line">        queue.<span class="built_in">push_back</span>(front-&gt;right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    ++height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string str = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="comment">/// 组装字符串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : result) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it1 : it) &#123;</span><br><span class="line">      str += it1 + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (str.<span class="built_in">back</span>() == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">    str.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(str.<span class="built_in">end</span>()));</span><br><span class="line">    str += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反序列化函数"><a href="#反序列化函数" class="headerlink" title="反序列化函数"></a>反序列化函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">const</span> std::string&amp; s, std::vector&lt;std::string&gt;&amp; tokens,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> std::string&amp; delimiters = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  std::string::size_type lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, <span class="number">0</span>);</span><br><span class="line">  std::string::size_type pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  <span class="keyword">while</span> (std::string::npos != pos || std::string::npos != lastPos) &#123;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">    lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, pos);</span><br><span class="line">    pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> TreeNode* <span class="title">deserialize</span><span class="params">(std::string data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">front</span>() != <span class="string">&#x27;[&#x27;</span> || data.<span class="built_in">back</span>() != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  data.<span class="built_in">erase</span>(data.<span class="built_in">begin</span>());</span><br><span class="line">  data.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(data.<span class="built_in">end</span>()));</span><br><span class="line">  std::vector&lt;std::string&gt; vec_str;</span><br><span class="line">  <span class="built_in">split</span>(data, vec_str, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (vec_str.<span class="built_in">empty</span>() || vec_str.<span class="built_in">front</span>() == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;TreeNode*&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : vec_str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">      result.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">stoi</span>(it)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">at</span>(i) != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt; i * <span class="number">2</span> + <span class="number">2</span>) &#123;</span><br><span class="line">      result.<span class="built_in">at</span>(i)-&gt;left = result.<span class="built_in">at</span>(i*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">      result.<span class="built_in">at</span>(i)-&gt;right = result.<span class="built_in">at</span>(i*<span class="number">2</span><span class="number">+2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> result = <span class="built_in">deserialize</span>(<span class="string">&quot;[5,null,7,null,null,6,8]&quot;</span>);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">serialize</span>(result) == <span class="string">&quot;[5,null,7,null,null,6,8]&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> string =</span><br><span class="line">      <span class="string">&quot;[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,&quot;</span></span><br><span class="line">      <span class="string">&quot;27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,&quot;</span></span><br><span class="line">      <span class="string">&quot;51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,&quot;</span></span><br><span class="line">      <span class="string">&quot;75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,&quot;</span></span><br><span class="line">      <span class="string">&quot;99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,&quot;</span></span><br><span class="line">      <span class="string">&quot;117,118,119,120,121,122,123,124,125,126]&quot;</span>;</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="built_in">deserialize</span>(string);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">serialize</span>(result3) == string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化改进版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">  <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::string res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        res += <span class="string">&quot;null,&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res += std::<span class="built_in">to_string</span>(temp-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 去除首尾的&#x27;[]&#x27;</span></span><br><span class="line">    data.<span class="built_in">erase</span>(data.<span class="built_in">begin</span>());</span><br><span class="line">    data.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(data.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="comment">/// 把字符串解析成数组</span></span><br><span class="line">    <span class="keyword">auto</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> lastPos = data.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;,&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> pos = data.<span class="built_in">find_first_of</span>(<span class="string">&#x27;,&#x27;</span>, lastPos);</span><br><span class="line">    std::queue&lt;std::string&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (pos != std::string::npos || std::string::npos != lastPos) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(data.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">      lastPos = data.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;,&#x27;</span>, pos);</span><br><span class="line">      pos = data.<span class="built_in">find_first_of</span>(<span class="string">&#x27;,&#x27;</span>, lastPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 遍历数组建立树</span></span><br><span class="line">    <span class="keyword">auto</span> head = q.<span class="built_in">front</span>();</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q_ceng;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q_next_ceng;</span><br><span class="line">    TreeNode* r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> thead = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">atoi</span>(head.<span class="built_in">c_str</span>()));</span><br><span class="line">      q_ceng.<span class="built_in">push</span>(thead);</span><br><span class="line">      r = thead;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!q_ceng.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q_ceng.<span class="built_in">front</span>();</span><br><span class="line">        q_ceng.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">l_t</span> = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">r_t</span> = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">l_t</span> != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">          t-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">atoi</span>(<span class="type">l_t</span>.<span class="built_in">c_str</span>()));</span><br><span class="line">          q_next_ceng.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">r_t</span> != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">          t-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">atoi</span>(<span class="type">r_t</span>.<span class="built_in">c_str</span>()));</span><br><span class="line">          q_next_ceng.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!q_next_ceng.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        q_ceng.<span class="built_in">push</span>(q_next_ceng.<span class="built_in">front</span>());</span><br><span class="line">        q_next_ceng.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串分割与解析代码学习</title>
      <link href="/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/26328793/how-to-split-string-with-delimiter-using-c">源码链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           把字符串前后的字符串给去除</span></span><br><span class="line"><span class="comment"> * @param           s       [in]    要剪切的字符串</span></span><br><span class="line"><span class="comment"> * @param           chars   [in]    要去除什么的字符串</span></span><br><span class="line"><span class="comment"> * @return          std::string&amp; 剪切后的字符串</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::string&amp; <span class="title">strip</span><span class="params">(std::string&amp; s, <span class="type">const</span> std::string&amp; chars = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(chars.<span class="built_in">c_str</span>()));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(chars.<span class="built_in">c_str</span>()) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           以特定符号为分隔符，切分字符串并放入vector里</span></span><br><span class="line"><span class="comment"> * @param           s           [in]    原字符串</span></span><br><span class="line"><span class="comment"> * @param           tokens      [out]   剪切后的子字符串</span></span><br><span class="line"><span class="comment"> * @param           delimiters  [in]    分隔符</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">const</span> std::string&amp; s, std::vector&lt;std::string&gt;&amp; tokens,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> std::string&amp; delimiters = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  std::string::size_type lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, <span class="number">0</span>);</span><br><span class="line">  std::string::size_type pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  <span class="keyword">while</span> (std::string::npos != pos || std::string::npos != lastPos) &#123;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">    lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, pos);</span><br><span class="line">    pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">parse</span><span class="params">(std::string&amp; s, std::map&lt;std::string, std::string&gt;&amp; items)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; elements;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &#123;&quot;</span>));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;&#125; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">split</span>(s, elements, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : elements) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; kv;</span><br><span class="line">    <span class="built_in">split</span>(iter, kv, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kv.<span class="built_in">size</span>() != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    items[<span class="built_in">strip</span>(kv[<span class="number">0</span>], <span class="string">&quot; \&quot;&quot;</span>)] = <span class="built_in">strip</span>(kv[<span class="number">1</span>], <span class="string">&quot; \&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string data =</span><br><span class="line">      <span class="string">&quot;  &#123;  \&quot;key1\&quot;  :  \&quot;data1\&quot;  ,  \&quot;key2\&quot;  :  \&quot;data2\&quot;    &#125;  &quot;</span>;</span><br><span class="line">  std::map&lt;std::string, std::string&gt; items;</span><br><span class="line">  <span class="built_in">parse</span>(data, items);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iter:items)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key=&quot;</span> &lt;&lt; iter.first &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; iter.second &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读spdlog-rotating_file_sink源码</title>
      <link href="/2020/07/05/2020-07-05-%E9%98%85%E8%AF%BBspdlog-rotating_file_sink%E6%BA%90%E7%A0%81/"/>
      <url>/2020/07/05/2020-07-05-%E9%98%85%E8%AF%BBspdlog-rotating_file_sink%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="thread-pool-源码学习"><a href="#thread-pool-源码学习" class="headerlink" title="thread_pool 源码学习"></a>thread_pool 源码学习</h1><h2 id="rotating-file-sink定义"><a href="#rotating-file-sink定义" class="headerlink" title="rotating_file_sink定义"></a>rotating_file_sink定义</h2><p><a href="https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/sinks/rotating_file_sink.h">rotating_file_sink.h</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Rotating file sink based on size</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rotating_file_sink</span> <span class="keyword">final</span> : <span class="keyword">public</span> base_sink&lt;Mutex&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rotating_file_sink</span>(<span class="type">filename_t</span> base_filename, std::<span class="type">size_t</span> max_size, std::<span class="type">size_t</span> max_files, <span class="type">bool</span> rotate_on_open = <span class="literal">false</span>);</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">filename_t</span> <span class="title">calc_filename</span><span class="params">(<span class="type">const</span> <span class="type">filename_t</span> &amp;filename, std::<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">filename_t</span> <span class="title">filename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sink_it_</span><span class="params">(<span class="type">const</span> details::log_msg &amp;msg)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush_</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Rotate files:</span></span><br><span class="line">    <span class="comment">// log.txt -&gt; log.1.txt</span></span><br><span class="line">    <span class="comment">// log.1.txt -&gt; log.2.txt</span></span><br><span class="line">    <span class="comment">// log.2.txt -&gt; log.3.txt</span></span><br><span class="line">    <span class="comment">// log.3.txt -&gt; delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the target if exists, and rename the src file  to target</span></span><br><span class="line">    <span class="comment">// return true on success, false otherwise.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rename_file_</span><span class="params">(<span class="type">const</span> <span class="type">filename_t</span> &amp;src_filename, <span class="type">const</span> <span class="type">filename_t</span> &amp;target_filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">filename_t</span> base_filename_;          <span class="comment">///&lt; 基础文件名称</span></span><br><span class="line">    std::<span class="type">size_t</span> max_size_;              <span class="comment">///&lt; 最大单个文件大小</span></span><br><span class="line">    std::<span class="type">size_t</span> max_files_;             <span class="comment">///&lt; 最大日志文件数量</span></span><br><span class="line">    std::<span class="type">size_t</span> current_size_;          <span class="comment">///&lt; 当前文件的大小</span></span><br><span class="line">    details::file_helper file_helper_;  <span class="comment">///&lt; 用于辅助写文件的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// @name     rotating_file_sink</span></span><br><span class="line"><span class="comment">/// @brief    构造本对象，</span></span><br><span class="line"><span class="comment">///           1. 打开日志文件</span></span><br><span class="line"><span class="comment">///           2. 获取当前文件大小</span></span><br><span class="line"><span class="comment">///           3. 如果超出了单个文件大小，则重新创建文件并打开</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    base_filename   [in]  基础的文件名</span></span><br><span class="line"><span class="comment">/// @param    max_size        [in]  最大单个文件大小</span></span><br><span class="line"><span class="comment">/// @param    max_files       [in]  最大的文件</span></span><br><span class="line"><span class="comment">/// @param    rotate_on_open  [in]  是否在文件打开时rotate</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-04 21:51:27</span></span><br><span class="line"><span class="built_in">rotating_file_sink</span>(std::string base_filename, std::<span class="type">size_t</span> max_size,</span><br><span class="line">                   std::<span class="type">size_t</span> max_files, <span class="type">bool</span> rotate_on_open = <span class="literal">false</span>)</span><br><span class="line">    : <span class="built_in">base_filename_</span>(std::<span class="built_in">move</span>(base_filename)),</span><br><span class="line">      <span class="built_in">max_size_</span>(max_size),</span><br><span class="line">      <span class="built_in">max_files_</span>(max_files) &#123;</span><br><span class="line">  <span class="comment">/// 打开当前应该写入的文件，并由file_helper对象来持有这个文件指针</span></span><br><span class="line">  file_helper_.<span class="built_in">open</span>(<span class="built_in">calc_filename</span>(base_filename_, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// 该函数时间执行时间很长，在这里只执行一次。</span></span><br><span class="line">  current_size_ = file_helper_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">/// 假如允许rotate且当前文件大小大于零</span></span><br><span class="line">  <span class="keyword">if</span> (rotate_on_open &amp;&amp; current_size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 执行一次rotate</span></span><br><span class="line">    <span class="built_in">rotate_</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotate-函数"><a href="#rotate-函数" class="headerlink" title="rotate_()函数"></a>rotate_()函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     rotate_</span></span><br><span class="line"><span class="comment">/// @brief    执行循环日志文件的创建</span></span><br><span class="line"><span class="comment">/// @details</span></span><br><span class="line"><span class="comment">/// Rotate files:</span></span><br><span class="line"><span class="comment">/// log.txt -&gt; log.1.txt</span></span><br><span class="line"><span class="comment">/// log.1.txt -&gt; log.2.txt</span></span><br><span class="line"><span class="comment">/// log.2.txt -&gt; log.3.txt</span></span><br><span class="line"><span class="comment">/// log.3.txt -&gt; delete</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-04 21:58:24</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 首先关闭该文件</span></span><br><span class="line">  file_helper_.<span class="built_in">close</span>();</span><br><span class="line">  <span class="comment">/// 开始查找要创建的下一个日志文件名称</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = max_files_; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">/// 拼装出上一个该文件名称</span></span><br><span class="line">    std::string src = <span class="built_in">calc_filename</span>(base_filename_, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">path_exists</span>(src)) &#123;</span><br><span class="line">      <span class="comment">/// 该文件如果不存在则到下一个循环</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 这里找到要创建的日志名称了日志文件的名称</span></span><br><span class="line">    std::string target = <span class="built_in">calc_filename</span>(base_filename_, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 把上一个文件改名为当前的文件名</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">rename_file_</span>(src, target)) &#123;</span><br><span class="line">      <span class="comment">/// 如果失败则在一个短暂的延迟后再次尝试</span></span><br><span class="line">      <span class="built_in">sleep_for_millis</span>(<span class="number">100</span>);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">rename_file_</span>(src, target)) &#123;</span><br><span class="line">        <span class="comment">/// 关闭并打开这个日志文件，防止它增长超出限制</span></span><br><span class="line">        file_helper_.<span class="built_in">reopen</span>(<span class="literal">true</span>);</span><br><span class="line">        current_size_ = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/// 抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span>(<span class="string">&quot;rotating_file_sink: failed renaming &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 以追加模式(&quot;a&quot;)重新打开这个文件</span></span><br><span class="line">  file_helper_.<span class="built_in">reopen</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name   sink_it_</span></span><br><span class="line"><span class="comment">/// @brief  写文件日志的函数，如果写入日志大于最大文件大小则创建下一个文件</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param  msg [in]  写入的日志信息</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-05 09:33:12</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink_it_</span><span class="params">(<span class="type">const</span> details::log_msg &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  std::string formatted;</span><br><span class="line">  <span class="comment">/// 拼装日志信息</span></span><br><span class="line">  base_sink&lt;Mutex&gt;::formatter_-&gt;format(msg, formatted);</span><br><span class="line">  <span class="comment">/// 计算这条日志加上原本大小是否超过了最大文件大小</span></span><br><span class="line">  current_size_ += formatted.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (current_size_ &gt; max_size_) &#123;</span><br><span class="line">    <span class="comment">/// 超过了就创建下一个文件</span></span><br><span class="line">    <span class="built_in">rotate_</span>();</span><br><span class="line">    <span class="comment">/// 更新为当前文件大小为这个日志信息的大小</span></span><br><span class="line">    current_size_ = formatted.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 如果没有超过最大大小则继续写该文件</span></span><br><span class="line">  file_helper_.<span class="built_in">write</span>(formatted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @name     flush_</span></span><br><span class="line"><span class="comment">/// @brief    刷新文件</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-05 09:36:23</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flush_</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; file_helper_.<span class="built_in">flush</span>(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>​<strong>异常处理</strong>（<code>exception handling</code>）机制允许程序独立开发的部分能够在运行时就出现问题<strong>进行通信</strong>并作出<strong>相应的处理</strong>。异常是的我们能够将问题的检测和解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无需知道问题处理模块的所有细节，反之亦然。</p><h2 id="1-抛出异常"><a href="#1-抛出异常" class="headerlink" title="1. 抛出异常"></a>1. 抛出异常</h2><p>​在C++语言中，我们通过<strong>抛出</strong>(<code>throwing</code>)一条表达式来<strong>引发</strong>(<code>raised</code>)一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段<strong>处理代码</strong>(<code>handler</code>)将被用来处理该异常。被选中的处理代码实在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分会告知异常处理部分到底发生了什么错误。</p><p>​当执行一个<code>throw</code>时，跟在<code>throw</code>后面的语句将不再被执行。相反，程序的控制权从<code>throw</code>转移到与之匹配的<code>catch</code>模块。该<code>catch</code><strong>可能是同一函数中</strong>的局部<code>catch</code>，<strong>也可能位于直接或间接调用了发生异常的函数的另一个函数中</strong>。控制权从一处转移到另一处，这有两个重要的含义：</p><ul><li><strong>沿着调用链的函数可能会提早退出</strong>。</li><li><strong>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁</strong>。</li></ul><p>因为跟在<code>throw</code>后面的语句将不再被执行，所以<code>throw</code>语句的有类似于<code>return</code>语句：它通常作为条件语句的一部分或者作为某个函数的最后(或者唯一)一条语句。</p><h3 id="1-1-栈展开"><a href="#1-1-栈展开" class="headerlink" title="1.1 栈展开"></a>1.1 栈展开</h3><p>​<strong>当抛出一个异常后</strong>，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的<code>catch</code>子句。</p><ul><li><p>当<code>throw</code>出现在一个<strong>try语句块</strong>(<code>try block</code>)内时，检查与该<code>try</code>块关联的<code>catch</code>子句。</p></li><li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p></li><li><p>如果这一步<strong>没找到匹配</strong>的<code>catch</code><strong>且该<code>try</code>语句嵌套在其他<code>try</code>块中</strong>，则<strong>继续检查与外层<code>try</code>匹配的<code>catch</code>子句</strong>。</p></li><li><p>如果<strong>还是找不到匹配</strong>的<code>catch</code>，则<strong>退出当前函数</strong>，在调<strong>用当前函数的外层函数中</strong>继续寻找。</p></li><li><p>如果对抛出异常的函数的调用语句位于一个<code>try</code>语句块内，则检查与该<code>try</code>块关联的<code>catch</code>子句。</p></li><li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p></li><li><p>否则，如果该<code>try</code>语句嵌套在其他<code>try</code>块中，则继续检查与外层<code>try</code>匹配的<code>catch</code>子句。</p></li><li><p>如果仍然没找到匹配的<code>catch</code>，则退出当前这个主调函数，继续在调用刚刚退出的这个函数的其他函数中寻找，以此类推。</p></li></ul><p>​上述过程被称为<strong>栈展开</strong>(<code>stack unwinding</code>)过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的<code>catch</code>子句为止；或者也可能一致没找到匹配的<code>catch</code>，则退出主函数后过程中止。</p><p>​假设找到了一个匹配的<code>catch</code>子句，则程序进入该子句并执行其中代码。当执行完这个<code>catch</code>子句后，找到与<code>try</code>块关联的最后一个<code>catch</code>子句后的点，并从这里继续执行。</p><p>​<strong>如果没有找到匹配的<code>catch</code>子句，程序将退出</strong>。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的<code>catch</code>时，程序将调用标准库函数<code>terminate</code>，顾名思义，<code>terminate</code>负责中止程序的执行过程。</p><h3 id="1-2-栈展开过程中对象被自动销毁"><a href="#1-2-栈展开过程中对象被自动销毁" class="headerlink" title="1.2 栈展开过程中对象被自动销毁"></a>1.2 栈展开过程中对象被自动销毁</h3><p>​在栈展开过程中，位于调用链上的语句块可能会提前退出。如果在<strong>栈展开过程中</strong>退出了某个块，编译器将负责确保在这个块中<strong>创建的对象都能被正确的销毁</strong>。如果某个局部对象的类型是<strong>类类型</strong>，则<strong>该对象的析构函数将被自动调用</strong>。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。</p><p>​如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经开始初始化了，而另外一些成员在异常发生前也许还没有开始初始化。即使某个对象只构造了一部分，我们也要<strong>确保构造的成员能被正确的销毁</strong>（否则会发生内存泄露）。</p><p>​类似的，异常也可能发生在<strong>数组</strong>或<strong>标准库容器的元素初始化过程</strong>中。与之前类似，如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确的销毁。</p><h3 id="1-3-析构函数与异常"><a href="#1-3-析构函数与异常" class="headerlink" title="1.3 析构函数与异常"></a>1.3 析构函数与异常</h3><p>​析构函数总是会被执行的，但是函数中负责释放资源的代码却可能会被跳过。如果一个块分配了资源，并且在<strong>负责释放这些资源的代码前面发生了异常</strong>，则释放资源的代码将<strong>不会被执行</strong>。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。（<code>RAII</code>的思想，在构造函数中获取资源(i.e <code>new</code>)，在析构函数中释放资源(i.e <code>delete</code>)。）</p><p>​所以出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，<strong>如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理</strong>（如果不这样做的话，程序会马上被终止）。</p><blockquote><p> 注：所有标准库类型都能保证它们的析构函数不会引发异常。</p></blockquote><h3 id="1-4-异常对象"><a href="#1-4-异常对象" class="headerlink" title="1.4 异常对象"></a>1.4 异常对象</h3><p><strong>异常对象</strong>（<code>exception object</code>）是一种特殊的对象，编译器使用<strong>异常抛出表达式</strong>来对<strong>异常对象</strong>进行<strong>拷贝初始化</strong>。因此<code>throw</code>语句中的表达式必须拥有<strong>完整类型</strong>。而且如果该表达式是<strong>类类型</strong>的话，则相应的类必须含有一个<strong>可访问的析构函数</strong>和一个<strong>可访问的拷贝或移动构造函数</strong>。如果该表达式是<strong>数组类型</strong>或<strong>函数类型</strong>，则表达式将被<strong>转换成</strong>与之对应的<strong>指针类型</strong>。</p><p>​异常对象位于有编译器管理的空间中，编译器确保无论调用哪个<code>catch</code>子句都能访问该空间。异常处理完毕后，异常对象被销毁。</p><p>​当一个异常被抛出是，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向<strong>局部对象的指针</strong>几乎肯定是一种<strong>错误</strong>行为。如果指针所指的对象位于某个块中，而该块在<code>catch</code>语句之前就已经退出了，则意味着在执行<code>catch</code>语句之前局部对象已经被销毁了。</p><p>​当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条<code>throw</code>表达式<strong>解引用一个基类指针</strong>，而该指针<strong>实际指向的是派生类对象</strong>，则<strong>抛出的对象将被切掉一部分，只有基类部分被抛出</strong>。</p><blockquote><p>注： 抛出指针要求在任何对应处理代码存在的地方，指针所指的对象都必须存在。</p></blockquote><h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p><code>catch</code>子句（<code>catch clause</code>）中的一场声明（<code>exception declaration</code>）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果<code>catch</code>无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p><p>声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，不能是右值引用。当进入一个<code>catch</code>语句后，入参通过异常对象初始化异常声明中的参数。和函数的参数类似，如果<code>catch</code>的参数类型是非引用类型，则该参数是异常对象的一个副本，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名。</p><p>如果<code>catch</code>的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果<code>catch</code>的参数是非引用类型，则异常对象将被切掉一部分，如果<code>catch</code>的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。</p><p>最后一点需要注意的是，异常声明的静态类型将决定<code>catch</code>语句所能执行的操作。如果<code>catch</code>的参数是基类类型，则<code>catch</code>无法使用派生类特有的任何成员。</p><blockquote><p>Tips: 通常情况下，如果<code>catch</code>接收的异常与某个继承体系有关，则最好将该<code>catch</code>的参数定义成引用类型。</p></blockquote><h3 id="2-1-查找匹配的处理代码"><a href="#2-1-查找匹配的处理代码" class="headerlink" title="2.1 查找匹配的处理代码"></a>2.1 查找匹配的处理代码</h3><p>​在搜寻<code>catch</code>语句的过程中，我们最终找到的<code>catch</code>未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的<code>catch</code>语句。因此，越是专门的<code>catch</code>越应该置于整个<code>catch</code>列表的前端。</p><p>​因为<code>catch</code>语句是按照其出现的顺序逐一匹配的，所以当程序员使用具有继承关系的多个异常时必须对<code>catch</code>语句的顺序进行组织管理，是的派生类异常的处理代码出现在基类异常的处理代码异常之前。</p><p>​与实参和形参的匹配规则相比，异常和<code>catch</code>异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和<code>catch</code>声明的类型时精确匹配的：</p><ul><li>允许从非常量的类型转换，也就是说一条非常量对象的<code>throw</code>语句可以匹配一个接受常量引用的<code>catch</code>语句</li><li>允许从派生类向基类的类型转换。</li><li>数组被转换成指向数组（元素）类型的指针，函数被转化成指向该函数类型的指针。</li></ul><p>除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用。</p><blockquote><p>如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最低端的类（<code>most derived type</code>）放在前面，而将继承链最顶端的类（<code>least derived type</code>）放在后面。</p></blockquote><h3 id="2-2-重新抛出"><a href="#2-2-重新抛出" class="headerlink" title="2.2 重新抛出"></a>2.2 重新抛出</h3><p>​一个单独的<code>catch</code>语句不能完整的处理某个异常。在执行了某些校正操作之后，当前的<code>catch</code>可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出的操作将异常传递给另外一个<code>catch</code>语句。这里的重新抛出仍然是一条<code>throw</code>语句，只不过不包含任何表达式: <code>throw;</code></p><p>​空的<code>throw</code>语句只能出现在<code>catch</code>语句或<code>catch</code>语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空<code>throw</code>语句，编译器将调用<code>terminate</code>。</p><p>​一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。</p><p>​很多时候，catch语句会改变其参数内容。如果在改变了参数的内容后catch语句重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所作的改变才会被保留并继续传播。</p><h3 id="2-3-捕获所有异常的处理代码"><a href="#2-3-捕获所有异常的处理代码" class="headerlink" title="2.3 捕获所有异常的处理代码"></a>2.3 捕获所有异常的处理代码</h3><p>​为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常的处理代码，形如<code>catch(...)</code>.</p><p>​<code>catch(...)</code>通常与重新抛出语句一起使用，其中<code>catch</code>执行当前局部能完成的工作，随后重新抛出异常。</p><blockquote><p>Tips: 如果<code>catch(...)</code>与其他几个<code>catch</code>语句一起出现，则<code>catch(...)</code>必须在最后的位置。出现在捕获所有一场语句后面的<code>catch</code>语句将永远不会被匹配。</p></blockquote><h2 id="3-函数try语句块与构造函数"><a href="#3-函数try语句块与构造函数" class="headerlink" title="3. 函数try语句块与构造函数"></a>3. 函数try语句块与构造函数</h2><p>​通常情况下，程序执行的任何时刻都可能发生异常，特别是一场可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的<code>try</code>语句块还未生效，所以构造函数体内的<code>catch</code>语句无法处理构造函数初始值列表抛出的异常。</p><p>​要想处理构造函数初始值抛出的异常，我们必须将构造函数写成<strong>函数try语句块</strong>（<code>function try block</code>）的形式。函数<code>try</code>语句使得一组<code>catch</code>语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"> : <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;<span class="comment">/** ... */</span>&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">handle_out_of_memory</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-noexcept-异常说明"><a href="#4-noexcept-异常说明" class="headerlink" title="4. noexcept 异常说明"></a>4. noexcept 异常说明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span></span>;           <span class="comment">/** 可能会抛出异常 */</span></span><br></pre></td></tr></table></figure><ul><li><p>对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数应该在函数的尾置返回类型之前。</p></li><li><p>我们也可以在函数指针的声明和定义中指定<code>noexcept</code>。</p></li><li><p>在typedef或类型别名中则不能出现<code>noexcept</code>。</p></li><li><p>在成员函数中，<code>noexcept</code>说明符需要跟在<code>const</code>及引用限定符之后，而在<code>final</code>、<code>override</code>或虚函数<code>=0</code>之前。</p></li></ul><h3 id="4-1-违反异常说明"><a href="#4-1-违反异常说明" class="headerlink" title="4.1 违反异常说明"></a>4.1 违反异常说明</h3><p>​编译器并不会在编译时检查<code>noexcept</code>说明。实际上，如果一个函数说明了<code>noexcept</code>的同时又含有<code>throw</code>语句或者调用了可能抛出异常的其他函数，编译器将顺利通过，并不会因为这种违反异常说明的情况而报错。</p><p>​因此可能会出现一种情况：尽管函数说明了它不会抛出异常，但实际上还是抛出了。一旦一个<code>noexcept</code>函数抛出异常，程序就会调用<code>terminate</code>以确保遵守不在运行时抛出异常的承诺。</p><p>​上述过程是执行栈展开未作约定，因此<code>noexcept</code>可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。</p><h3 id="4-2-noexcept运算符"><a href="#4-2-noexcept运算符" class="headerlink" title="4.2 noexcept运算符"></a>4.2 noexcept运算符</h3><p>​<code>noexcept</code>说明符接受一个可选实参，该实参必须能转换为<code>bool</code>类型：如果实参是<code>true</code>，则函数不会抛出异常；如果实参是<code>false</code>，则函数可能抛出异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;<span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;<span class="comment">/** 可能抛出异常 */</span></span><br></pre></td></tr></table></figure><p>​<code>noexcept</code>说明符的实参常常与<code>noexcept</code>运算符混合使用。<code>noexcept</code>运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和<code>sizeof</code>类似，<code>noexcept</code>也不会求其运算对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">noexcept</span>(<span class="built_in">recoup</span>())<span class="comment">/** 如果recoup不跑出异常则结果为true；否则结果为false */</span></span><br><span class="line"><span class="built_in">noexcept</span>(e)<span class="comment">/** 等价于上一句 */</span></span><br></pre></td></tr></table></figure><p>我们可以使用noexcept运算符得到如下的异常说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>;<span class="comment">// f 和 g的异常说明一致</span></span><br></pre></td></tr></table></figure><p>如果函数<code>g()</code>承诺了不会抛出异常，则f也不会抛出异常；如果<code>g()</code>没有异常说明符，或者g虽然有异常说明符但是允许抛出异常，则<code>f()</code>也可能抛出异常。</p><blockquote><p><code>noexcept</code>有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为<code>noexcept</code>异常说明的<code>bool</code>实参出现时，它是一个运算符。</p></blockquote><h3 id="4-3-异常说明与指针、虚函数和拷贝控制"><a href="#4-3-异常说明与指针、虚函数和拷贝控制" class="headerlink" title="4.3 异常说明与指针、虚函数和拷贝控制"></a>4.3 异常说明与指针、虚函数和拷贝控制</h3><p>​<strong>函数指针及该指针所指的函数必须具有一致的异常说明</strong>。也就是说我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以。</p><p>​如果<strong>虚函数</strong>承诺了它<strong>不会抛出异常</strong>，则后续派生出来的<strong>虚函数</strong>也必须做出<strong>同样的承诺</strong>；与之相反如果<strong>基类的虚函数允许抛出异常</strong>，则派<strong>生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。</strong></p><p>​当编译器<strong>合成拷贝控制成员</strong>时，同时也<strong>生成一个异常说明</strong>。如果对<strong>所有成员</strong>和<strong>基类的所有操作</strong>都承诺了不会抛出异常，则合成的成员是<code>noexcept</code>的。如果合成成员调用的<strong>任意一个函数可能抛出异常</strong>，则合成的成员是<code>noexcept(false)</code>。而且如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将于假设有编译器为类合成析构函数时所得的异常说明一致。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20三路比较符</title>
      <link href="/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/"/>
      <url>/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="三路比较符（C-20）"><a href="#三路比较符（C-20）" class="headerlink" title="三路比较符（C++20）"></a>三路比较符（C++20）</h1><p><a href="https://zh.cppreference.com/w/cpp/utility/compare/compare_three_way">官网解释</a></p><p><a href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/">微软技术博客介绍</a></p><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1186r3.html">When do you actually use <code>&lt;=&gt;</code>?</a></p><p>例子1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rational_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> den; <span class="comment">// &gt; 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> std::weak_ordering <span class="built_in">operator</span>&lt;=&gt;(Rational_2 lhs, Rational_2 rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.num * rhs.den &lt;=&gt; rhs.num * lhs.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::weak_ordering value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;equal\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;less\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;greater\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rational_2 c&#123;<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Rational_2 d&#123;<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(c &lt;=&gt; d);</span><br><span class="line">    <span class="built_in">print</span>(std::compare_three_way&#123;&#125;(c,d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basics</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Basics&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">  <span class="type">int</span> ai[<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">2</span>];</span><br><span class="line">  <span class="type">float</span> af[<span class="number">3</span>];</span><br><span class="line">  <span class="type">double</span> ad[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Arrays&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bases</span> : Basics, Arrays &#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Bases&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases a = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases b = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="built_in">static_assert</span>(a == b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a != b));</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &lt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &lt;= b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &gt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &gt;= b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++严格弱序的介绍</title>
      <link href="/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="严格弱序（strict-weak-ordering）"><a href="#严格弱序（strict-weak-ordering）" class="headerlink" title="严格弱序（strict weak ordering）"></a>严格弱序（strict weak ordering）</h1><p>关联式容器（<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>）的排序准则的定义，和std::sort的排序准则定义必须遵守严格弱序，详细描述见官方解释(<a href="/resource/C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/strict_weak_ordering.pdf">strict weak ordering.pdf</a>)。</p><p><strong>严格弱序的定义</strong>：</p><p><strong>简单的来说就是a&lt;b返回true，a&#x3D;b和a&gt;b返回false。</strong></p><p>详细定义：</p><blockquote><ol><li><p>必须是<strong>非对称的</strong>（antisymmetric）。</p><p> 对<code>operator&lt; </code>而言， 如果x &lt; y为true， 则y &lt; x为false。</p><p> 对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true，则op(y, x)为false。</p></li><li><p>必须是<strong>可传递的</strong>（transitive）。</p></li></ol><p>  对<code>operator&lt; </code>而言，如果x &lt; y 为true且y &lt; z为true， 则x &lt; z 为false。</p><p>  对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true且op(y, z)为tru，则op(x, z)为true。</p><ol start="3"><li><p>必须是<strong>非自反的</strong>（irreflexive）</p><p> 对<code>operator&lt; </code>而言，x &lt; x 永远是false</p><p> 对判断式(predicate) <code>op()</code>而言，op(x, x)永远是false。</p></li><li><p>必须有<strong>等效传递性</strong>（transitivity of equivalence）</p></li></ol><p>对<code>operator&lt; </code>而言，假如 !(a&lt;b) &amp;&amp; !(b&lt;a) 为true且 !(b&lt;c) &amp;&amp; !(c&lt;b) 为 true<br>那么!(a&lt;c) &amp;&amp; !(c&lt;a) 也为true.<br>对判断式(predicate) <code>op()</code>而言， 假如 op(a,b), op(b,a), op(b,c), 和op(c,b) 都为<br>false, 那么op(a,c) and op(c,a) 也为false.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个定义std::set&lt;struct&gt;的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ORDERING_EXAMPLE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 重载遵循严格弱序的运算符&lt;</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> ORDERING_EXAMPLE&amp; OtherStruct) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;x &lt; OtherStruct.x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.x &lt; <span class="keyword">this</span>-&gt;x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x == x则比较y</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;y &lt; OtherStruct.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.y &lt; <span class="keyword">this</span>-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// y == y则比较z</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;z &lt; OtherStruct.z)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;ORDERING_EXAMPLE&gt; setOrderingExample;</span><br><span class="line"></span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample0 = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample1 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample3 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample0);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample1);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample2);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面举一个会崩溃的例子对二维数组排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">5</span>, temp);</span><br><span class="line">  std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;l, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;r) &#123;</span><br><span class="line">              <span class="keyword">if</span> (l.<span class="built_in">size</span>() == r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; l.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (l.<span class="built_in">at</span>(i) == r.<span class="built_in">at</span>(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> l.<span class="built_in">at</span>(i) &lt; r.<span class="built_in">at</span>(i);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/// 这里会崩溃，改为false则不会而不会崩溃(遵循严格弱序)</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> l.<span class="built_in">size</span>() &lt; r.<span class="built_in">size</span>();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个参数的重载符号简单示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于乘法溢出的判断</title>
      <link href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先我们对于乘法溢出的判断，先写测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715337389.png" alt="1592715337389"></p><p>由上图我们简化测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715602260.png" alt="1592715602260"></p><p>我们可以这样设计乘法溢出函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们添加测试用例</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727579022.png" alt="1592727579022"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来为特殊数值来添加判断：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727736048.png" alt="1592727736048"></p><p>添加异号情况的判断：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730284047.png" alt="1592730284047"></p><p>把函数改为模板，一并添加测试用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_multi_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot; is_multi_overflow need integral type!&quot;</span>);</span><br><span class="line">  <span class="type">int</span> num_max = std::numeric_limits&lt;T1&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> num_min = std::numeric_limits&lt;T1&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">1</span> || y == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y == num_min;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x == num_min;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; num_max / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == num_min &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / -y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 3</span></span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 4</span></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = INT_MIN;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 5</span></span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = min_num;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 6</span></span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后附上完整测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730393076.png" alt="1592730393076"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我们既然有了判断乘法溢出的函数，我们可以借此封装一个带有检查溢出的乘法函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">std::optional&lt;T1&gt; <span class="title">multiplies_s</span><span class="params">(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value, <span class="string">&quot;Multiplies_s need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;Multiplies_s need integral type!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_multi_overflow</span>(x, y)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">multiplies_s</span>(x, y).<span class="built_in">value_or</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于虚析构函数</title>
      <link href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="虚析构函数问题"><a href="#虚析构函数问题" class="headerlink" title="虚析构函数问题"></a>虚析构函数问题</h2><blockquote><p>引用标准中原文：  一条有用的方针，是任何基类的析构函数必须为公开且虚， 或受保护且非虚。</p></blockquote><p>虚析构这个概念被设计出来就是<strong>为了解决基类指针指向派生类实例的析构问题</strong>，当一个基类指针指向派生类实例然后进行delete该指针时，只会执行基类析构函数而派生类的析构函数不会被执行，这将导致派生类构造的资源不会被正确释放，造成内存泄漏。如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/// 该析构函数为错误示例，严禁这样写.</span></span><br><span class="line">     ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug.png" alt="Virtual DeConstruct Debug"></p><p>可以看到派生类没有被析构，如要解决该问题在基类析构函数处加上<strong>virtual</strong>关键字即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/** 正确写法： 加上关键字virtual， 后面函数体可写可不写，或者直接使用=default都行。 */</span></span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">/// 或者 virtual ~Derived() override &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug_Correct.png" alt="Virtual DeConstruct Debug Correct"></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PlantUML语法学习</title>
      <link href="/2020/07/02/2020-07-02-PlantUML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/02/2020-07-02-PlantUML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="PlantUML语法学习"><a href="#PlantUML语法学习" class="headerlink" title="PlantUML语法学习"></a>PlantUML语法学习</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>类之间的关系通过下面的符号定义:</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_20-38-31.png" alt="类之间的关系"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class01 &lt;|-- Class02</span><br><span class="line">Class03 *-- Class04</span><br><span class="line">Class05 o-- Class06</span><br><span class="line">Class07 .. Class08</span><br><span class="line">Class09 -- Class10</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_1.png" alt="class1"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class11 &lt;|.. Class12</span><br><span class="line">Class13 --&gt; Class14</span><br><span class="line">Class15 ..&gt; Class16</span><br><span class="line">Class17 ..|&gt; Class18</span><br><span class="line">Class19 &lt;--* Class20</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_2.png" alt="class2"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class21 #-- Class22</span><br><span class="line">Class23 x-- Class24</span><br><span class="line">Class25 &#125;-- Class26</span><br><span class="line">Class27 +-- Class28</span><br><span class="line">Class29 ^-- Class30</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_3.png" alt="class3"></p><h3 id="关系上的标识"><a href="#关系上的标识" class="headerlink" title="关系上的标识"></a>关系上的标识</h3><p>在关系之间使用标签来说明时, 使用: 后接标签文字。<br>对元素的说明，你可以在每一边使用”” 来说明.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class01 &quot;1&quot; *-- &quot;many&quot; Class02 : contains</span><br><span class="line">Class03 o-- Class04 : aggregation</span><br><span class="line">Class05 --&gt; &quot;1&quot; Class06</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_4.png" alt="class4"></p><p>在标签的开始或结束位置添加&lt; 或&gt; 以表明是哪个对象作用到哪个对象上。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Car</span><br><span class="line">Driver - Car : drives &gt;</span><br><span class="line">Car *- Wheel : have 4 &gt;</span><br><span class="line">Car -- Person : &lt; owns</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_5.png" alt="class5"></p><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>为了声明字段(对象属性）或者方法，你可以使用后接字段名或方法名。<br>系统检查是否有括号来判断是方法还是字段。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Object &lt;|-- ArrayList</span><br><span class="line">Object : equals()</span><br><span class="line">ArrayList : Object[] elementData</span><br><span class="line">ArrayList : size()</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_6.png" alt="class6"></p><p>也可以使用{} 把字段或者方法括起来<br>注意，这种语法对于类型&#x2F;名字的顺序是非常灵活的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">String data</span><br><span class="line">void methods()</span><br><span class="line">&#125;</span><br><span class="line">class Flight &#123;</span><br><span class="line">flightNumber : Integer</span><br><span class="line">departureTime : Date</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_7.png" alt="class7"></p><p>你可以（显式地）使用{field} 和{method} 修饰符来覆盖解析器的对于字段和方法的默认行为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">&#123;field&#125; A field (despite parentheses)</span><br><span class="line">&#123;method&#125; Some method</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_8.png" alt="class8"></p><h3 id="定义可访问性"><a href="#定义可访问性" class="headerlink" title="定义可访问性"></a>定义可访问性</h3><p>一旦你定义了域或者方法，你可以定义相应条目的可访问性质。<br><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_20-55-15.png" alt="定义可访问性"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">-field1</span><br><span class="line">#field2</span><br><span class="line">~method1()</span><br><span class="line">+method2()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_9.png" alt="class9"></p><p>你可以采用命令（skinparam classAttributeIconSize 0 ：)停用该特性</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam classAttributeIconSize 0</span><br><span class="line">class Dummy &#123;</span><br><span class="line">-field1</span><br><span class="line">#field2</span><br><span class="line">~method1()</span><br><span class="line">+method2()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_10.png" alt="class10"></p><h3 id="抽象与静态"><a href="#抽象与静态" class="headerlink" title="抽象与静态"></a>抽象与静态</h3><p>通过修饰符{static} 或者{abstract}，可以定义静态或者抽象的方法或者属性。<br>这些修饰符可以写在行的开始或者结束。也可以使用{classifier} 这个修饰符来代替{static}.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">&#123;static&#125; String id</span><br><span class="line">&#123;abstract&#125; void methods()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_11.png" alt="class11"></p><h3 id="高级类体"><a href="#高级类体" class="headerlink" title="高级类体"></a>高级类体</h3><p>PlantUML 默认自动将方法和属性重新分组，你可以自己定义分隔符来重排方法和属性，下面的分隔符都<br>是可用的：– .. &#x3D;&#x3D; __.<br>还可以在分隔符中添加标题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Foo1 &#123;</span><br><span class="line">You can use</span><br><span class="line">several lines</span><br><span class="line">..</span><br><span class="line">as you want</span><br><span class="line">and group</span><br><span class="line">==</span><br><span class="line">things together.</span><br><span class="line">__</span><br><span class="line">You can have as many groups</span><br><span class="line">as you want</span><br><span class="line">--</span><br><span class="line">End of class</span><br><span class="line">&#125;</span><br><span class="line">class User &#123;</span><br><span class="line">.. Simple Getter ..</span><br><span class="line">+ getName()</span><br><span class="line">+ getAddress()</span><br><span class="line">.. Some setter ..</span><br><span class="line">+ setName()</span><br><span class="line">__ private data __</span><br><span class="line">int age</span><br><span class="line">-- encrypted --</span><br><span class="line">String password</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_12.png" alt="class12"></p><h3 id="更多注释"><a href="#更多注释" class="headerlink" title="更多注释"></a>更多注释</h3><p>可以在注释中使用部分html 标签：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Foo</span><br><span class="line">note left: On last defined class</span><br><span class="line">note top of Object</span><br><span class="line">In java, &lt;size:18&gt;every&lt;/size&gt; &lt;u&gt;class&lt;/u&gt;</span><br><span class="line">&lt;b&gt;extends&lt;/b&gt;</span><br><span class="line">&lt;i&gt;this&lt;/i&gt; one.</span><br><span class="line">end note</span><br><span class="line">note as N1</span><br><span class="line">This note is &lt;u&gt;also&lt;/u&gt;</span><br><span class="line">&lt;b&gt;&lt;color:royalBlue&gt;on several&lt;/color&gt;</span><br><span class="line">&lt;s&gt;words&lt;/s&gt; lines</span><br><span class="line">And this is hosted by &lt;img:sourceforge.jpg&gt;</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_13.png" alt="class13"></p><h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>使用关键字object 定义实例。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object firstObject</span><br><span class="line">object &quot;My Second Object&quot; as o2</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_1.png" alt="object1"></p><h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><p>对象之间的关系可以用如下符号定义：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_19-56-04.png" alt="对象之间的关系"></p><p>也可以用.. 来代替– 以使用点线。<br>知道了这些规则，就可以画下面的图：<br>可以用冒号给关系添加标签，标签内容紧跟在冒号之后。<br>用双引号在关系的两边添加基数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object Object01</span><br><span class="line">object Object02</span><br><span class="line">object Object03</span><br><span class="line">object Object04</span><br><span class="line">object Object05</span><br><span class="line">object Object06</span><br><span class="line">object Object07</span><br><span class="line">object Object08</span><br><span class="line">Object01 &lt;|-- Object02</span><br><span class="line">Object03 *-- Object04</span><br><span class="line">Object05 o-- &quot;4&quot; Object06</span><br><span class="line">Object07 .. Object08 : some labels</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_2.png" alt="object2"></p><h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><p>用冒号加属性名的形式声明属性。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object user</span><br><span class="line">user : name = &quot;Dummy&quot;</span><br><span class="line">user : id = 123</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_3.png" alt="object3"></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><h3 id="简单活动"><a href="#简单活动" class="headerlink" title="简单活动"></a>简单活动</h3><p>使用(*) 作为活动图的开始点和结束点。<br>有时，你可能想用(*top) 强制开始点位于图示的顶端。<br>使用–&gt; 绘制箭头。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;First Activity&quot;</span><br><span class="line">&quot;First Activity&quot; --&gt; (*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_1.png" alt="activity1"></p><h3 id="箭头上的标签"><a href="#箭头上的标签" class="headerlink" title="箭头上的标签"></a>箭头上的标签</h3><p>默认情况下，箭头开始于最接近的活动。<br>可以用[ 和 ] 放在箭头定义的后面来添加标签。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;First Activity&quot;</span><br><span class="line">--&gt;[You can put also labels] &quot;Second Activity&quot;</span><br><span class="line">--&gt; (*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_2.png" alt="activity2"></p><h3 id="改变箭头方向"><a href="#改变箭头方向" class="headerlink" title="改变箭头方向"></a>改变箭头方向</h3><p>你可以使用-&gt; 定义水平方向箭头，还可以使用下列语法强制指定箭头的方向：</p><ul><li>-down-&gt; (default arrow)</li><li>-right-&gt; or -&gt;</li><li>-left-&gt;</li><li>-up-&gt;</li></ul><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_3.png" alt="activity3"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>你可以使用关键字if&#x2F;then&#x2F;else 创建分支。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;Initialization&quot;</span><br><span class="line">if &quot;Some Test&quot; then</span><br><span class="line">--&gt;[true] &quot;Some Activity&quot;</span><br><span class="line">--&gt; &quot;Another activity&quot;</span><br><span class="line">-right-&gt; (*)</span><br><span class="line">else</span><br><span class="line">-&gt;[false] &quot;Something else&quot;</span><br><span class="line">--&gt;[Ending process] (*)</span><br><span class="line">endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_4.png" alt="activity4"></p><p>不过，有时你可能需要重复定义同一个活动：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;check input&quot;</span><br><span class="line">If &quot;input is verbose&quot; then</span><br><span class="line">--&gt; [Yes] &quot;turn on verbosity&quot;</span><br><span class="line">--&gt; &quot;run command&quot;</span><br><span class="line">else</span><br><span class="line">--&gt; &quot;run command&quot;</span><br><span class="line">Endif</span><br><span class="line">--&gt;(*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_5.png" alt="activity5"></p><h3 id="更多分支"><a href="#更多分支" class="headerlink" title="更多分支"></a>更多分支</h3><p>默认情况下，一个分支连接上一个最新的活动，但是也可以使用if 关键字进行连接。<br>还可以嵌套定义分支。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; if &quot;Some Test&quot; then</span><br><span class="line">--&gt;[true] &quot;activity 1&quot;</span><br><span class="line">if &quot;&quot; then</span><br><span class="line">-&gt; &quot;activity 3&quot; as a3</span><br><span class="line">else</span><br><span class="line">if &quot;Other test&quot; then</span><br><span class="line">-left-&gt; &quot;activity 5&quot;</span><br><span class="line">else</span><br><span class="line">--&gt; &quot;activity 6&quot;</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">-&gt;[false] &quot;activity 2&quot;</span><br><span class="line">endif</span><br><span class="line">a3 --&gt; if &quot;last test&quot; then</span><br><span class="line">--&gt; &quot;activity 7&quot;</span><br><span class="line">else</span><br><span class="line">-&gt; &quot;activity 8&quot;</span><br><span class="line">endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_6.png" alt="activity6"></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>你可以在活动定义之后用note left, note right, note top or note bottom, 命令给活动添加注释。<br>如果想给开始点添加注释，只需把注释的定义放在活动图最开始的地方即可。<br>也可以用关键字endnote 定义多行注释。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;Some Activity&quot;</span><br><span class="line">note right: This activity has to be defined</span><br><span class="line">&quot;Some Activity&quot; --&gt; (*)</span><br><span class="line">note left</span><br><span class="line">This note is on</span><br><span class="line">several lines</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_7.png" alt="activity7"></p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>用关键字partition 定义分区，还可以设置背景色(用颜色名或者颜色值)。<br>定义活动的时候，它自动被放置到最新的分区中。<br>用} 结束分区的定义。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">partition Conductor &#123;</span><br><span class="line">(*) --&gt; &quot;Climbs on Platform&quot;</span><br><span class="line">--&gt; === S1 ===</span><br><span class="line">--&gt; Bows</span><br><span class="line">&#125;</span><br><span class="line">partition Audience #LightSkyBlue &#123;</span><br><span class="line">=== S1 === --&gt; Applauds</span><br><span class="line">&#125;</span><br><span class="line">partition Conductor &#123;</span><br><span class="line">Bows --&gt; === S2 ===</span><br><span class="line">--&gt; WavesArmes</span><br><span class="line">Applauds --&gt; === S2 ===</span><br><span class="line">&#125;</span><br><span class="line">partition Orchestra #CCCCEE &#123;</span><br><span class="line">WavesArmes --&gt; Introduction</span><br><span class="line">--&gt; &quot;Play music&quot;</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_8.png" alt="activity8"></p><h3 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title Servlet Container</span><br><span class="line">(*) --&gt; &quot;ClickServlet.handleRequest()&quot;</span><br><span class="line">--&gt; &quot;new Page&quot;</span><br><span class="line">if &quot;Page.onSecurityCheck&quot; then</span><br><span class="line">-&gt;[true] &quot;Page.onInit()&quot;</span><br><span class="line">if &quot;isForward?&quot; then</span><br><span class="line">-&gt;[no] &quot;Process controls&quot;</span><br><span class="line">if &quot;continue processing?&quot; then</span><br><span class="line">--&gt;[yes] ===RENDERING===</span><br><span class="line">else</span><br><span class="line">--&gt;[no] ===REDIRECT_CHECK===</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">--&gt;[yes] ===RENDERING===</span><br><span class="line">endif</span><br><span class="line">if &quot;is Post?&quot; then</span><br><span class="line">--&gt;[yes] &quot;Page.onPost()&quot;</span><br><span class="line">--&gt; &quot;Page.onRender()&quot; as render</span><br><span class="line">--&gt; ===REDIRECT_CHECK===</span><br><span class="line">else</span><br><span class="line">--&gt;[no] &quot;Page.onGet()&quot;</span><br><span class="line">--&gt; render</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">--&gt;[false] ===REDIRECT_CHECK===</span><br><span class="line">endif</span><br><span class="line">if &quot;Do redirect?&quot; then</span><br><span class="line">-&gt;[yes] &quot;redirect request&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">else</span><br><span class="line">if &quot;Do Forward?&quot; then</span><br><span class="line">-left-&gt;[yes] &quot;Forward request&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">else</span><br><span class="line">-right-&gt;[no] &quot;Render page template&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">--&gt; &quot;Page.onDestroy()&quot;</span><br><span class="line">--&gt;(*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_9.png" alt="activity9"></p><h3 id="界面格式相关"><a href="#界面格式相关" class="headerlink" title="界面格式相关"></a>界面格式相关</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam SequenceGroupBodyBackgroundColor #FFFFFF90</span><br><span class="line"></span><br><span class="line">box &quot;Internal Service&quot; #LightBlue</span><br><span class="line">    participant Bob</span><br><span class="line">    participant Alice</span><br><span class="line">end box</span><br><span class="line"></span><br><span class="line">box &quot;Other&quot; #LightGreen</span><br><span class="line">    participant Other</span><br><span class="line">end box</span><br><span class="line"></span><br><span class="line">group group</span><br><span class="line">    Bob -&gt; Alice : hello</span><br><span class="line">    Alice -&gt; Other : hello</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/skinparam_uml_0.png" alt="skinparam_uml_0"></p><h3 id="颜色示例"><a href="#颜色示例" class="headerlink" title="颜色示例"></a>颜色示例</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">!unquoted procedure $DrawColor($colour)</span><br><span class="line"></span><br><span class="line">    skinparam rectangle &#123;</span><br><span class="line">            backgroundColor&lt;&lt;$colour&gt;&gt; $colour</span><br><span class="line">            borderColor&lt;&lt;$colour&gt;&gt; $colour</span><br><span class="line">            shadowing&lt;&lt;$colour&gt;&gt; true</span><br><span class="line">            BorderThickness&lt;&lt;$colour&gt;&gt; 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    rectangle $colour &lt;&lt;$colour&gt;&gt; as &quot;&lt;color:$colour&gt;&lt;/color&gt;&quot;</span><br><span class="line"></span><br><span class="line">!endprocedure</span><br><span class="line"></span><br><span class="line">package HexCodes &#123;</span><br><span class="line">$DrawColor(&quot;00ff00&quot;)</span><br><span class="line">$DrawColor(&quot;ff0000&quot;)</span><br><span class="line">$DrawColor(&quot;0000ff&quot;)</span><br><span class="line">$DrawColor(&quot;123456&quot;)</span><br><span class="line">$DrawColor(&quot;654321&quot;)</span><br><span class="line">$DrawColor(&quot;165432&quot;)</span><br><span class="line">$DrawColor(&quot;ff22ff&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package Colours &#123;</span><br><span class="line">$DrawColor(&quot;APPLICATION&quot;)</span><br><span class="line">$DrawColor(&quot;AliceBlue&quot;)</span><br><span class="line">$DrawColor(&quot;AntiqueWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Aqua&quot;)</span><br><span class="line">$DrawColor(&quot;Aquamarine&quot;)</span><br><span class="line">$DrawColor(&quot;Azure&quot;)</span><br><span class="line">$DrawColor(&quot;BUSINESS&quot;)</span><br><span class="line">$DrawColor(&quot;Beige&quot;)</span><br><span class="line">$DrawColor(&quot;Bisque&quot;)</span><br><span class="line">$DrawColor(&quot;Black&quot;)</span><br><span class="line">$DrawColor(&quot;BlanchedAlmond&quot;)</span><br><span class="line">$DrawColor(&quot;Blue&quot;)</span><br><span class="line">$DrawColor(&quot;BlueViolet&quot;)</span><br><span class="line">$DrawColor(&quot;Brown&quot;)</span><br><span class="line">$DrawColor(&quot;BurlyWood&quot;)</span><br><span class="line">$DrawColor(&quot;CadetBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Chartreuse&quot;)</span><br><span class="line">$DrawColor(&quot;Chocolate&quot;)</span><br><span class="line">$DrawColor(&quot;Coral&quot;)</span><br><span class="line">$DrawColor(&quot;CornflowerBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Cornsilk&quot;)</span><br><span class="line">$DrawColor(&quot;Crimson&quot;)</span><br><span class="line">$DrawColor(&quot;Cyan&quot;)</span><br><span class="line">$DrawColor(&quot;DarkBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DarkCyan&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGray&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DarkKhaki&quot;)</span><br><span class="line">$DrawColor(&quot;DarkMagenta&quot;)</span><br><span class="line">$DrawColor(&quot;DarkOliveGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkOrchid&quot;)</span><br><span class="line">$DrawColor(&quot;DarkRed&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSalmon&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DarkTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;DarkViolet&quot;)</span><br><span class="line">$DrawColor(&quot;Darkorange&quot;)</span><br><span class="line">$DrawColor(&quot;DeepPink&quot;)</span><br><span class="line">$DrawColor(&quot;DeepSkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DimGray&quot;)</span><br><span class="line">$DrawColor(&quot;DimGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DodgerBlue&quot;)</span><br><span class="line">$DrawColor(&quot;FireBrick&quot;)</span><br><span class="line">$DrawColor(&quot;FloralWhite&quot;)</span><br><span class="line">$DrawColor(&quot;ForestGreen&quot;)</span><br><span class="line">$DrawColor(&quot;Fuchsia&quot;)</span><br><span class="line">$DrawColor(&quot;Gainsboro&quot;)</span><br><span class="line">$DrawColor(&quot;GhostWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Gold&quot;)</span><br><span class="line">$DrawColor(&quot;GoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;Gray&quot;)</span><br><span class="line">$DrawColor(&quot;Green&quot;)</span><br><span class="line">$DrawColor(&quot;GreenYellow&quot;)</span><br><span class="line">$DrawColor(&quot;Grey&quot;)</span><br><span class="line">$DrawColor(&quot;HoneyDew&quot;)</span><br><span class="line">$DrawColor(&quot;HotPink&quot;)</span><br><span class="line">$DrawColor(&quot;IMPLEMENTATION&quot;)</span><br><span class="line">$DrawColor(&quot;IndianRed&quot;)</span><br><span class="line">$DrawColor(&quot;Indigo&quot;)</span><br><span class="line">$DrawColor(&quot;Ivory&quot;)</span><br><span class="line">$DrawColor(&quot;Khaki&quot;)</span><br><span class="line">$DrawColor(&quot;Lavender&quot;)</span><br><span class="line">$DrawColor(&quot;LavenderBlush&quot;)</span><br><span class="line">$DrawColor(&quot;LawnGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LemonChiffon&quot;)</span><br><span class="line">$DrawColor(&quot;LightBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightCoral&quot;)</span><br><span class="line">$DrawColor(&quot;LightCyan&quot;)</span><br><span class="line">$DrawColor(&quot;LightGoldenRodYellow&quot;)</span><br><span class="line">$DrawColor(&quot;LightGray&quot;)</span><br><span class="line">$DrawColor(&quot;LightGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LightGrey&quot;)</span><br><span class="line">$DrawColor(&quot;LightPink&quot;)</span><br><span class="line">$DrawColor(&quot;LightSalmon&quot;)</span><br><span class="line">$DrawColor(&quot;LightSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LightSkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightSlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;LightSlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;LightSteelBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightYellow&quot;)</span><br><span class="line">$DrawColor(&quot;Lime&quot;)</span><br><span class="line">$DrawColor(&quot;LimeGreen&quot;)</span><br><span class="line">$DrawColor(&quot;Linen&quot;)</span><br><span class="line">$DrawColor(&quot;MOTIVATION&quot;)</span><br><span class="line">$DrawColor(&quot;Magenta&quot;)</span><br><span class="line">$DrawColor(&quot;Maroon&quot;)</span><br><span class="line">$DrawColor(&quot;MediumAquaMarine&quot;)</span><br><span class="line">$DrawColor(&quot;MediumBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MediumOrchid&quot;)</span><br><span class="line">$DrawColor(&quot;MediumPurple&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSpringGreen&quot;)</span><br><span class="line">$DrawColor(&quot;MediumTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;MediumVioletRed&quot;)</span><br><span class="line">$DrawColor(&quot;MidnightBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MintCream&quot;)</span><br><span class="line">$DrawColor(&quot;MistyRose&quot;)</span><br><span class="line">$DrawColor(&quot;Moccasin&quot;)</span><br><span class="line">$DrawColor(&quot;NavajoWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Navy&quot;)</span><br><span class="line">$DrawColor(&quot;OldLace&quot;)</span><br><span class="line">$DrawColor(&quot;Olive&quot;)</span><br><span class="line">$DrawColor(&quot;OliveDrab&quot;)</span><br><span class="line">$DrawColor(&quot;Orange&quot;)</span><br><span class="line">$DrawColor(&quot;OrangeRed&quot;)</span><br><span class="line">$DrawColor(&quot;Orchid&quot;)</span><br><span class="line">$DrawColor(&quot;PHYSICAL&quot;)</span><br><span class="line">$DrawColor(&quot;PaleGoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;PaleGreen&quot;)</span><br><span class="line">$DrawColor(&quot;PaleTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;PaleVioletRed&quot;)</span><br><span class="line">$DrawColor(&quot;PapayaWhip&quot;)</span><br><span class="line">$DrawColor(&quot;PeachPuff&quot;)</span><br><span class="line">$DrawColor(&quot;Peru&quot;)</span><br><span class="line">$DrawColor(&quot;Pink&quot;)</span><br><span class="line">$DrawColor(&quot;Plum&quot;)</span><br><span class="line">$DrawColor(&quot;PowderBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Purple&quot;)</span><br><span class="line">$DrawColor(&quot;Red&quot;)</span><br><span class="line">$DrawColor(&quot;RosyBrown&quot;)</span><br><span class="line">$DrawColor(&quot;RoyalBlue&quot;)</span><br><span class="line">$DrawColor(&quot;STRATEGY&quot;)</span><br><span class="line">$DrawColor(&quot;SaddleBrown&quot;)</span><br><span class="line">$DrawColor(&quot;Salmon&quot;)</span><br><span class="line">$DrawColor(&quot;SandyBrown&quot;)</span><br><span class="line">$DrawColor(&quot;SeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;SeaShell&quot;)</span><br><span class="line">$DrawColor(&quot;Sienna&quot;)</span><br><span class="line">$DrawColor(&quot;Silver&quot;)</span><br><span class="line">$DrawColor(&quot;SkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;SlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;SlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;SlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;Snow&quot;)</span><br><span class="line">$DrawColor(&quot;SpringGreen&quot;)</span><br><span class="line">$DrawColor(&quot;SteelBlue&quot;)</span><br><span class="line">$DrawColor(&quot;TECHNOLOGY&quot;)</span><br><span class="line">$DrawColor(&quot;Tan&quot;)</span><br><span class="line">$DrawColor(&quot;Teal&quot;)</span><br><span class="line">$DrawColor(&quot;Thistle&quot;)</span><br><span class="line">$DrawColor(&quot;Tomato&quot;)</span><br><span class="line">$DrawColor(&quot;Turquoise&quot;)</span><br><span class="line">$DrawColor(&quot;Violet&quot;)</span><br><span class="line">$DrawColor(&quot;Wheat&quot;)</span><br><span class="line">$DrawColor(&quot;White&quot;)</span><br><span class="line">$DrawColor(&quot;WhiteSmoke&quot;)</span><br><span class="line">$DrawColor(&quot;Yellow&quot;)</span><br><span class="line">$DrawColor(&quot;YellowGreen&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/color_uml.png" alt="color_uml"></p><h3 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h3><p><a href="https://crashedmind.github.io/PlantUMLHitchhikersGuide/about/AboutPlantUML.html">PlantUML资料</a></p>]]></content>
      
      
      <categories>
          
          <category> UML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读C++线程池源码</title>
      <link href="/2020/06/27/2020-06-27-%E9%98%85%E8%AF%BBC++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/"/>
      <url>/2020/06/27/2020-06-27-%E9%98%85%E8%AF%BBC++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="progschj-thread-pool"><a href="#progschj-thread-pool" class="headerlink" title="progschj&#x2F;thread_pool"></a>progschj&#x2F;thread_pool</h2><p>Github上这个库(<a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">progschj&#x2F;thread_pool</a>)的点赞最多，学习一下。</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>);</span><br><span class="line">  <span class="comment">/// 任务入列</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line">  ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 所有的工作线程</span></span><br><span class="line">  std::vector&lt;std::thread&gt; workers;</span><br><span class="line">  <span class="comment">/// 任务队列</span></span><br><span class="line">  std::queue&lt;std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 用于同步的互斥锁和条件变量</span></span><br><span class="line">  std::mutex queue_mutex;</span><br><span class="line">  std::condition_variable condition;</span><br><span class="line">  <span class="type">bool</span> stop;  <span class="comment">///&lt; 用于判断所有线程是否需要结束</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数和消费者实现"><a href="#构造函数和消费者实现" class="headerlink" title="构造函数和消费者实现"></a>构造函数和消费者实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     ThreadPool</span></span><br><span class="line"><span class="comment">/// @brief    用于创建若干个线程，并规定消费者函数</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    threads   [in]    要创建的线程数量</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 16:17:50</span></span><br><span class="line"><span class="comment">/// @warning  线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span> : stop(false) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i)</span><br><span class="line">    workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/// 获取同步锁</span></span><br><span class="line">          std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">          <span class="comment">/// 阻塞等待获取任务，直到任务队列不为空</span></span><br><span class="line">          <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(</span><br><span class="line">              lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">          <span class="comment">/// 如果stop标志位为true，且任务列表都执行完毕后，该线程退出</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">/// 从任务队列中拿出来一个任务</span></span><br><span class="line">          task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">          <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;  <span class="comment">///&lt; 这里释放锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 执行该任务函数</span></span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 在stop位, 置为true后通知所有线程执行一次，然后等待所有线程处理完任务后join()</span></span><br><span class="line">  condition.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers) worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者函数"><a href="#生产者函数" class="headerlink" title="生产者函数"></a>生产者函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     enqueue</span></span><br><span class="line"><span class="comment">/// @brief    用于添加任务函数到任务队列中</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    f     [in]    任务函数</span></span><br><span class="line"><span class="comment">/// @param    args  [in]    任务函数的入参列表</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   取决于任务函数的返回值</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 16:06:30</span></span><br><span class="line"><span class="comment">/// @warning  线程安全</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::invoke_result&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 这里封装一个异步的线程并执行刚刚传入的函数，这个函数通过bind改类型为void()</span></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">  <span class="comment">/// 创建一个这个函数的未来的值， 这个未来值不获取就不会进行计算</span></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 假如说没有让这个线程停止则继续，否则抛出异常阻止线程池结束后在入列</span></span><br><span class="line">    <span class="keyword">if</span> (stop) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    <span class="comment">/// 这个封装好的函数放入任务列表中</span></span><br><span class="line">    tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 通知一个阻塞中的线程，任务队列中有任务了</span></span><br><span class="line">  condition.<span class="built_in">notify_one</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 异步运算接口</title>
      <link href="/2020/06/27/2020-06-27-C++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/06/27/2020-06-27-C++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="std-async介绍"><a href="#std-async介绍" class="headerlink" title="std::async介绍"></a>std::async介绍</h2><p>下面是一个很好的并行计算的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** is_prime(700020007)这个函数调用隐藏于主线程，异步执行 */</span></span><br><span class="line">    std::future&lt;<span class="type">bool</span>&gt; fut = std::<span class="built_in">async</span>(is_prime, <span class="number">700020007</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;please wait&quot;</span>;</span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">span</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">/** 这个异步调用函数等待100ms，如果没有计算完就继续等待 */</span></span><br><span class="line">    <span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(span) != std::future_status::ready)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 计算完毕后，获取函数返回值 */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;final result: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::async中的第一个参数是启动策略，它控制std::async的异步行为，我们可以用三种不同的启动策略来创建std::async<br><strong>·std::launch::async</strong><br>保证异步行为，即传递函数将在单独的线程中执行<br><strong>·std::launch::deferred</strong><br>当其他线程调用get()来访问共享状态时，将调用非异步行为<br><strong>·std::launch::async | std::launch::deferred</strong><br>默认行为。有了这个启动策略，它可以异步运行或不运行，这取决于系统的负载，但我们无法控制它。</p><p>见下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保函数要5秒才能执行完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理创建数据库连接、获取数据等事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DB_&quot;</span> + recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromFile</span><span class="params">(std::string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保函数要5秒才能执行完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理获取文件数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;File_&quot;</span> + recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取开始时间</span></span><br><span class="line">    system_clock::time_point start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用std::launch::async，来指定其异步执行 */</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                                                    fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从文件获取数据</span></span><br><span class="line">    std::string fileData = <span class="built_in">fetchDataFromFile</span>(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从DB获取数据</span></span><br><span class="line">    <span class="comment">//数据在future&lt;std::string&gt;对象中可获取之前，将一直阻塞</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结束时间</span></span><br><span class="line">    <span class="keyword">auto</span> end = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> diff = <span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装数据</span></span><br><span class="line">    std::string data = dbData + <span class="string">&quot; :: &quot;</span> + fileData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出组装的数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-promise介绍"><a href="#std-promise介绍" class="headerlink" title="std::promise介绍"></a>std::promise介绍</h2><p>std::promise的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个某种类型的值，并将其传递给对应的future， 即使这个future不在同一个线程中也可以安全的访问到这个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::ref</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>         <span class="comment">// std::promise, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_int</span> <span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fut)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter print_int: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> x = fut.<span class="built_in">get</span>();  <span class="comment">///&lt; 在这里会等待外部std::promise变量set_value进来，否则会一致阻塞在这里</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;                      <span class="comment">// 创建一个std::promise变量</span></span><br><span class="line"></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();    <span class="comment">// 创建一个std::future变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">th1</span> <span class="params">(print_int, std::ref(fut))</span></span>;  <span class="comment">// 创建一个线程执行函数print_int</span></span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    prom.<span class="built_in">set_value</span> (<span class="number">10</span>);                         <span class="comment">// 传值进入线程th1</span></span><br><span class="line"></span><br><span class="line">    th<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-packaged-task介绍"><a href="#std-packaged-task介绍" class="headerlink" title="std::packaged_task介绍"></a>std::packaged_task介绍</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>       <span class="comment">// std::chrono::seconds</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>       <span class="comment">// std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// count down taking a second for each value:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countdown</span> <span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = from; i != to; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lift off!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> from - to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个std::packaged_task对象</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">tsk</span> <span class="params">(countdown)</span></span>;</span><br><span class="line">    <span class="comment">// 创建一个std::future对象，用于跨线程异步获取该线程返回的值</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; ret = tsk.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="comment">// 把线程对象移动进一个可运行的线程中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">th</span> <span class="params">(std::move(tsk), <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 让该线程从主线程中分离</span></span><br><span class="line">    th.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 利用std::future对象来获取已经分离开的线程运行是否结束的返回的值</span></span><br><span class="line">    <span class="type">int</span> value = ret.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The countdown lasted for &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; seconds.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="硬件支持的线程数量"><a href="#硬件支持的线程数量" class="headerlink" title="硬件支持的线程数量"></a>硬件支持的线程数量</h2><p>由于硬件支持的并行线程数量有限，如果创建线程的数量比硬件支持的数量要多，那么CPU进行的上下文切换可能会浪费大量时间，所以了解硬件支持的线程数量是高效并行编程的重点。</p><p>使用<code>std::thread::hardware_concurrency()</code>来获取硬件支持的线程数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; concurrent threads are supported.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-thread-yield介绍"><a href="#std-thread-yield介绍" class="headerlink" title="std::thread::yield介绍"></a>std::thread::yield介绍</h2><p><a href="https://stackoverflow.com/questions/11048946/stdthis-threadyield-vs-stdthis-threadsleep-for">关于std::thread::yield 和 std::sleep_for的比较</a></p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (work_queue.<span class="built_in">try_pop</span>(task)) &#123;</span><br><span class="line">            <span class="comment">/// 获取到任务就运行</span></span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 没有获取到就休息一下</span></span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读spdlog-thread_pool源码</title>
      <link href="/2020/06/26/2020-06-27-%E9%98%85%E8%AF%BBspdlog-thread_pool%E6%BA%90%E7%A0%81/"/>
      <url>/2020/06/26/2020-06-27-%E9%98%85%E8%AF%BBspdlog-thread_pool%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="thread-pool-源码学习"><a href="#thread-pool-源码学习" class="headerlink" title="thread_pool 源码学习"></a>thread_pool 源码学习</h2><h3 id="源码定义"><a href="#源码定义" class="headerlink" title="源码定义"></a>源码定义</h3><p>我们先概览一下<a href="https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/details/thread_pool.h">spdlog-thread_pool定义</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SPDLOG_API</span> thread_pool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> item_type = async_msg;</span><br><span class="line">    <span class="keyword">using</span> q_type = details::mpmc_blocking_queue&lt;item_type&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span><br><span class="line">                std::function&lt;<span class="built_in">void</span>()&gt; on_thread_start);</span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n);</span><br><span class="line">    ~<span class="built_in">thread_pool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_pool &amp;<span class="keyword">operator</span>=(thread_pool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_log</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr, <span class="type">const</span> details::log_msg &amp;msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                  async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_flush</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                    async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    q_type q_; <span class="comment">///&lt; 任务队列</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;  <span class="comment">///&lt; 线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_async_msg_</span><span class="params">(async_msg &amp;&amp;new_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                         async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_loop_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process_next_msg_</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="基本成员函数"><a href="#基本成员函数" class="headerlink" title="基本成员函数"></a>基本成员函数</h3><p>首先我们从thread_pll中最基本的五个成员函数开始看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span><br><span class="line">            std::function&lt;<span class="built_in">void</span>()&gt; on_thread_start);</span><br><span class="line"><span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// message all threads to terminate gracefully join them</span></span><br><span class="line">~<span class="built_in">thread_pool</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">thread_pool &amp;<span class="keyword">operator</span>=(thread_pool &amp;&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>可以看到该类删除了拷贝构造，移动构造，标志该类不可以被拷贝和移动。<br>其中有两个构造函数，我们来详细看看它们的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     thread_pool</span></span><br><span class="line"><span class="comment">/// @brief    构造函数，创建了一定数量的线程，并规定执行哪个函数</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    q_max_item      [in] 用于初始化任务队列最大的数量</span></span><br><span class="line"><span class="comment">/// @param    thread_n        [in] 用于初始化最大线程数量</span></span><br><span class="line"><span class="comment">/// @param    on_thread_start [in] 每个线程执行的初始化函数(只执行一次)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:32:47</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">thread_pool</span><span class="params">(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::function&lt;<span class="type">void</span>()&gt; on_thread_start)</span></span></span><br><span class="line"><span class="function">    : q_(q_max_items) ///&lt; 任务队列的最大数目</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (threads_n == <span class="number">0</span> || threads_n &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span>(</span><br><span class="line">        <span class="string">&quot;spdlog::thread_pool(): invalid threads_n param (valid &quot;</span></span><br><span class="line">        <span class="string">&quot;range is 1-1000)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads_n; i++) &#123;</span><br><span class="line">    threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, on_thread_start] &#123;</span><br><span class="line">      <span class="comment">/// 线程开始时候需要执行的初始函数</span></span><br><span class="line">      <span class="built_in">on_thread_start</span>();</span><br><span class="line">      <span class="comment">/// 主任务循环</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;thread_pool::<span class="built_in">worker_loop_</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 委托构造函数，用于输入默认入参 std::function&lt;void()&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">thread_pool::thread_pool</span><span class="params">(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n)</span></span></span><br><span class="line"><span class="function">    : thread_pool(q_max_items, threads_n, [] &#123;</span>&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure><p>接着我们来看一下析构函数执行了什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 告诉所有线程中止，并且执行join()</span></span><br><span class="line">~<span class="built_in">thread_pool</span>() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">/// 对每一个线程池发送一个中止消息</span></span><br><span class="line">      <span class="built_in">post_async_msg_</span>(<span class="built_in">async_msg</span>(async_msg_type::terminate),</span><br><span class="line">                      async_overflow_policy::block);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads_) &#123;</span><br><span class="line">      <span class="comment">/// 等待每一个线程的结束时的join</span></span><br><span class="line">      t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">/// 析构函数中不能有异常，所以在这里做一个全捕获</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者逻辑"><a href="#生产者逻辑" class="headerlink" title="生产者逻辑"></a>生产者逻辑</h3><p>接着我们来看公有的两个接口函数的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用于发送任务消息，并判断是否需要打印到命令行或写入文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_log</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr, <span class="type">const</span> log_msg &amp;msg,</span></span></span><br><span class="line"><span class="params"><span class="function">              async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="function">async_msg <span class="title">async_m</span><span class="params">(std::move(worker_ptr), async_msg_type::log, msg)</span></span>;</span><br><span class="line">  <span class="built_in">post_async_msg_</span>(std::<span class="built_in">move</span>(async_m), overflow_policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于发送任务消息，并判断是否需要马上写入文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_flush</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">post_async_msg_</span>(<span class="built_in">async_msg</span>(std::<span class="built_in">move</span>(worker_ptr), async_msg_type::flush),</span><br><span class="line">                  overflow_policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于返回任务队列溢出了多少条</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> q_.<span class="built_in">overrun_counter</span>(); &#125;</span><br></pre></td></tr></table></figure><p> <code>post_log</code> 和 <code>post_flush</code> 执行了一个差不多的任务，就是写日志，这两个函数都调用了<code>post_async_msg_()</code>来执行具体的任务们就来看看<code>post_async_msg_()</code>到底执行了什么。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     post_async_msg_</span></span><br><span class="line"><span class="comment">/// @brief    用于从队列中插入消息, 相当于生产者</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    new_msg         [in] 用于传入异步日志消息(使用右值方便移动)</span></span><br><span class="line"><span class="comment">/// @param    overflow_policy [in] 消息数量溢出的策略</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:42:18</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_async_msg_</span><span class="params">(async_msg &amp;&amp;new_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                     async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (overflow_policy == async_overflow_policy::block) &#123;</span><br><span class="line">    <span class="comment">/// 阻塞至消息队列中有空间来插入消息</span></span><br><span class="line">    q_.<span class="built_in">enqueue</span>(std::<span class="built_in">move</span>(new_msg));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 立即插入队列且队列满时丢弃老的消息</span></span><br><span class="line">    q_.<span class="built_in">enqueue_nowait</span>(std::<span class="built_in">move</span>(new_msg));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者逻辑"><a href="#消费者逻辑" class="headerlink" title="消费者逻辑"></a>消费者逻辑</h3><p> 如上面的实现，我们知道这是一个生产者，从外部插入到本对象内的任务队列，等待消费者来处理这些消息<br> 我们来看看消费者到底执行了什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     worker_loop_</span></span><br><span class="line"><span class="comment">/// @brief    用于每个线程执行的死循环，当process_next_msg_返回false时候</span></span><br><span class="line"><span class="comment">///           线程自己退出</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:51:13</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_loop_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 如果处理消息没有返回false，就一致执行该函数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">process_next_msg_</span>()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @name     process_next_msg_</span></span><br><span class="line"><span class="comment">/// @brief    处理队列中的下一个消息，相当于消费者</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   如果不是中止线程消息，则返回true, 反之返回false</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:53:45</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">process_next_msg_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  async_msg incoming_async_msg;</span><br><span class="line">  <span class="comment">/// 从任务消息队列中取消息，如果没有任务则等待获取任务,</span></span><br><span class="line">  <span class="comment">/// 如十秒后仍然没有获取到则直接返回</span></span><br><span class="line">  <span class="type">bool</span> dequeued =</span><br><span class="line">      q_.<span class="built_in">dequeue_for</span>(incoming_async_msg, std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">  <span class="comment">/// 如果获取任务消息失败则直接返回true</span></span><br><span class="line">  <span class="keyword">if</span> (!dequeued) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 获取到消息后则进行处理</span></span><br><span class="line">  <span class="keyword">switch</span> (incoming_async_msg.msg_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> async_msg_type::log: &#123;</span><br><span class="line">      <span class="comment">/// 打印消息到命令行且判断是否要马上刷新文件</span></span><br><span class="line">      incoming_async_msg.worker_ptr-&gt;<span class="built_in">backend_sink_it_</span>(incoming_async_msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> async_msg_type::flush: &#123;</span><br><span class="line">      <span class="comment">/// 刷新文件</span></span><br><span class="line">      incoming_async_msg.worker_ptr-&gt;<span class="built_in">backend_flush_</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> async_msg_type::terminate: &#123;</span><br><span class="line">      <span class="comment">/// 用于终止本线程池的信号</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑我们可以看到：首先由<code>worker_loop()</code>函数来不停的执行消费者函数。<br>而消费者函数在不停地去任务队列中获取任务最后由<code>backend_sink_it_()</code> 和 <code>backend_flush_()</code>两个函数来执行真正地任务。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>很简单的一个消费者和生产者的队列，但最核心的部分被一个任务队列<code>mpmc_blocking_queue&lt;async_msg&gt;</code>给封装了，让我们继续深入来看看这个任务队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mpmc_blocking_queue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> item_type = T;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mpmc_blocking_queue</span><span class="params">(<span class="type">size_t</span> max_items)</span> : q_(max_items) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 尝试入列，如果空间不足则阻塞</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      pop_cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;q_.<span class="built_in">full</span>(); &#125;);</span><br><span class="line">      q_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    push_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 马上入列，如果没有空间则丢弃队列中老的消息</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enqueue_nowait</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      q_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    push_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 尝试出列。如果队列中没有消息，则等待到超时然后再次尝试</span></span><br><span class="line">  <span class="comment">/// 假如出列成功则返回true, 否则返回false</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dequeue_for</span><span class="params">(T &amp;popped_item, std::chrono::milliseconds wait_duration)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (!push_cv_.<span class="built_in">wait_for</span>(lock, wait_duration,</span><br><span class="line">                             [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;q_.<span class="built_in">empty</span>(); &#125;)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      popped_item = std::<span class="built_in">move</span>(q_.<span class="built_in">front</span>());</span><br><span class="line">      q_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pop_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> q_.<span class="built_in">overrun_counter</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex queue_mutex_;           <span class="comment">///&lt; 用于控制整个对象的锁</span></span><br><span class="line">  std::condition_variable push_cv_;  <span class="comment">///&lt; 用于入列的条件变量</span></span><br><span class="line">  std::condition_variable pop_cv_;   <span class="comment">///&lt; 用于出列的条件变量</span></span><br><span class="line">  circular_q&lt;T&gt; q_;                  <span class="comment">///&lt; 用于保存信息的队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看看这个队列是怎么实现线程安全的。<br>其中<code>q_</code>这个循环队列不是线程安全的，所以加上了一个<code>queue_mutex</code> 这个互斥锁用来同步所有成员函数的顺序并配合条件变量实现等待获取的功能。</p><p><code>spdlog-thread_pool</code> 的实现逻辑很清晰，我们可以对比一下Github上另一个thread-pool: <a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">progschj&#x2F;ThreadPool</a> 的实现。<br>由于需要写入的任务很明确，就是处理异步日志，所以任务的队列直接写死了处理异步日志消息。而progschj&#x2F;ThreadPool的实现则更加灵活。我们可以看看我的另一篇博客<a href="./_site/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2020/06/27/%E9%98%85%E8%AF%BB%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81.html">阅读progschj&#x2F;thread_pool源码</a>对progschj&#x2F;ThreadPool的介绍</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于加法溢出的判断</title>
      <link href="/2020/06/26/2020-06-26-C++%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2020/06/26/2020-06-26-C++%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>首先我们知道整型是由有符号和无符号整型所组成。由于有符号整型的判断包含了无符号整型的计算，所以我们现在先讨论<strong>有符号整型</strong>。</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592040132570.png" alt="1592040132570"></p><p>有符号整型的加法包括以下几种情况：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592042113575.png" alt="1592042113575"></p><p>由上图我们可以知道我们只用考虑两个操作数拥有<strong>相同符号</strong>的情况就行了。我们显而易见的可以知道，<strong>两数相加的结果一定大于任一操作数</strong>，写出以下函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来为了测试这个函数能否正确运行，我们添加如下测试用例：case 1.</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592044663011.png" alt="1592044663011"></p><p>完整验证程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑两数都为负数，判断负溢出的情况，同样我们知道<strong>两负数相加结果一定小于任一操作数</strong>, 对函数加以补充，并添加两个测试用例：case 2.</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592044894101.png" alt="1592044894101"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算负溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">-1</span>, <span class="number">-1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_min, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的程序顺利执行完毕后我们可以继续往下看。接着我们能不能使用模板来扩展到其他类型的加法.</p><p>当然可以我们只需要把<code>int</code>换为模板参数T就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    T result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算负溢出的情况</span></span><br><span class="line">    T result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们为模板函数添加上类型限定和静态编译检查。然后同样使用测试用例:case 1 和 case 2 来测试以下这个模板函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参的类型是否一致</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参类型都为整数类型</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need integral type!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  T1 result = x + y;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">-1</span>, <span class="number">-1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(int_min, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来添加上详细的测试用例就大功告成了。</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592130012130.png" alt="1592130012130"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参的类型是否一致</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参类型都为整数类型</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need integral type!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  T1 result = x + y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result &lt; x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result &gt; x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">1</span>, <span class="number">1</span>));       <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(max_num, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">-1</span>, <span class="number">-1</span>));      <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(min_num, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 3</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(max_num, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// case 4</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(max_num, min_num));</span><br><span class="line">  <span class="comment">/// case 5</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, max_num));</span><br><span class="line">  <span class="comment">/// case 6</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// case 7</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, min_num));</span><br><span class="line">  <span class="comment">/// case 8</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(min_num, max_num));</span><br><span class="line">  <span class="comment">/// case 9</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(min_num, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个函数也<strong>可以用作检查减法是否溢出</strong>，只需要对第二个入参求相反数即可。但<strong>需要注意</strong>一个情况。</p><blockquote><p> 就是int值的负数个数(- 2^31)是比正数个数(2^31 - 1)多一个的, 所以在转化为相反数的时候可能在函数入参时出现溢出，导致计算没有溢出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">is_plus_overflow_t</span>(x, y);<span class="comment">/// 正确：等价与计算 2-1 表达式会不会溢出</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">y = INT_MIN;</span><br><span class="line"><span class="built_in">is_plus_overflow_t</span>(x, -y);<span class="comment">/// 错误：当y等于int的最小值的时候，无法求其相反数，会直接溢出</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于数值极限</title>
      <link href="/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/"/>
      <url>/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="关于数值极限"><a href="#关于数值极限" class="headerlink" title="关于数值极限"></a>关于数值极限</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type\t\t\tlowest()\t\tmin()\t\t\tmax()\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned short\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h2><blockquote><p>在64位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/1592038101047.png" alt="1592038101047"></p></blockquote><p>换为2的幂级数表示为（64位系统下）：</p><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table><h2 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h2><blockquote><p>在32位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/Snipaste_2022-10-12_15-36-58.png" alt="1592038101047"></p></blockquote><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
