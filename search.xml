<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面对对象简介与 C++ 类的基本介绍</title>
      <link href="/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C-构造函数与析构函数"><a href="#C-构造函数与析构函数" class="headerlink" title="C++ 构造函数与析构函数"></a>C++ 构造函数与析构函数</h2><p>类的基本组合元素。<br>构造函数、析构函数、拷贝构造函数和拷贝复制符</p><p>构造函数在对象被创建的时候调用，如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;          <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">    A* p = <span class="keyword">new</span> A;   <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数在对象被销毁时刻调用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        A obj;</span><br><span class="line">    &#125;   <span class="comment">///&lt; 临时变量超出作用域，调用析构函数</span></span><br><span class="line"></span><br><span class="line">    A* p = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">///&lt; 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造与析构函数的具体讲解可见 <a href="https://mercy1101.github.io/C++-%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/">类内默认成员函数</a></p><h2 id="面对对象的简介"><a href="#面对对象的简介" class="headerlink" title="面对对象的简介"></a>面对对象的简介</h2><p>对象有三个特点: 封装、继承和多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>封装方法</li><li>聚合数据</li><li>隐藏细节</li></ul><h4 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h4><p>当我们在使用对象时，自然而然可以把一系列方法放在一个类内，就比如我们想要定义一系列读取 <code>Json</code> 字符串的方法。</p><p>下面是 <code>C 语言</code>的封装方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GJSON*  <span class="title">gos_json_init</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>    <span class="title">gos_json_free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span>    <span class="title">gos_json_parse</span><span class="params">(GJSON* Json, <span class="type">char</span> *szJson)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span>*   <span class="title">gos_json_get_string</span> <span class="params">(GJSON* Json, <span class="type">char</span> *szKey)</span></span>;</span><br></pre></td></tr></table></figure><p>我们推断使用顺序是:</p><ol><li>使用 <code>gos_json_init</code> 来获取一个可用的 <code>Json</code> 解析用的结构体, 其中存储了一些信息。</li><li>使用 <code>gos_json_parse</code> 来读取一系列 <code>Json</code> 字符串中的键值。</li><li>使用 <code>gos_json_get_string</code> 来通过键来获取值。</li><li>最后使用 <code>gos_json_free</code> 来释放资源。</li></ol><p>那么调用过程如以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GJSON* pJson = <span class="built_in">gos_json_init</span>();</span><br><span class="line">    <span class="built_in">gos_json_parse</span>(pJson, <span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = <span class="built_in">gos_json_get_string</span>(pJson, <span class="string">&quot;Key&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">gos_json_free</span>(pJson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比面对对象接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span> *szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上面所示: <code>C++</code>的接口</p><p>由于类内保存了一个 <code>GJSON</code> 的指针 <code>m_Json</code>, 所以接口函数不需要 <code>GJSON*</code> 的入参.<br>由于可以被调用的函数只有两个，那我们可以推测调用方法:</p><ol><li>使用 <code>parser</code> 接口函数解析 <code>json</code> 字符串</li><li>使用 <code>get_string</code> 接口函数来获取对应键的值</li></ol><p>调用如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Json obj;</span><br><span class="line">    obj.<span class="built_in">parser</span>(<span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = obj.<span class="built_in">get_string</span>(<span class="string">&quot;Key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的调用可以看到少了调用 <code>init</code> 和 <code>free</code> 两个函数的过程，因为 <code>class</code> 可以使用构造函数中初始化自己，在析构函数中做相反动作，我们下面补充构造函数和析构函数的定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Json = <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(m_Json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span>*szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">    <span class="function">GJSON* <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h4><p><code>class</code> 带来的好处是，类内不仅可以定义函数，也可以聚合成员，定义在一起方便查看与传递。</p><p>例如我们有一堆配置项数据需要保存。</p><p>C 语言可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="type">bool</span>     g_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 给变量赋值</span></span><br><span class="line">    g_ulLogLevel = <span class="number">1</span>;</span><br><span class="line">    g_bLogToStdout = TRUE;</span><br><span class="line">    g_bLogToFile = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他 cpp 文件中访问这些配置项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToFile;</span><br></pre></td></tr></table></figure><p>C++ 可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LocalCfg</span>() &#123; <span class="built_in">GetLogCfg</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> m_ulLogLevel;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToStdout;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他地方访问这些配置项</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogCfg obj;</span><br><span class="line"></span><br><span class="line">    obj.m_ulLogLevel;</span><br><span class="line">    obj.m_bLogToStdout;</span><br><span class="line">    obj.m_bLogToFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们经常在类中见到函数 <code>Get</code> 和 <code>Set</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; value = i; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们为什么要把一个简单的赋值操作封装成函数呢？</p><p>如果我们想要把变量的赋值与其他业务联动，见下面的例子:</p><ol><li>追踪赋值，添加打印</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;value: %d -&gt; %d&quot;</span>, value, i);</span><br><span class="line">        value = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加锁来支持多线程</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        value = i;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> value_temp = value;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> value_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    GMutex mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>业务联动绑定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = i;</span><br><span class="line">        IsSet = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (IsSet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 返回无效值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 用于记录 value 是否有效</span></span><br><span class="line">    <span class="type">bool</span> IsSet = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="隐藏细节"><a href="#隐藏细节" class="headerlink" title="隐藏细节"></a>隐藏细节</h4><p>见下面代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 把大象放进冰箱里</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PutElephantInFreezer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/// 打开冰箱门</span></span><br><span class="line">        <span class="built_in">OpenFreezerDoor</span>();</span><br><span class="line">        <span class="comment">/// 把大象放进去</span></span><br><span class="line">        <span class="built_in">LetElephantIn</span>();</span><br><span class="line">        <span class="comment">/// 关上冰箱门</span></span><br><span class="line">        <span class="built_in">CloseFreezerDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LetElephantIn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    <span class="comment">// 调用 public 函数来把大象放进冰箱里</span></span><br><span class="line">    obj.<span class="built_in">PutElephantInFreezer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍"><a href="#相关语法介绍" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="关于-public-与-private"><a href="#关于-public-与-private" class="headerlink" title="关于 public 与 private"></a>关于 <code>public</code> 与 <code>private</code></h5><p>关于关键字 <code>public</code> 和 <code>private</code>, <code>public</code> 类型的类内成员变量和函数，可以被类的实例调用而 <code>private</code> 不能。</p><p>实例化简单来说就是，把一个就是在代码中定义该对象。(如果把类的定义比作蛋糕模子，那么类的实例就是蛋糕)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OBJECT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象实例化</span></span><br><span class="line">    OBJECT obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例访问 public 类成员</span></span><br><span class="line">    obj.i_public = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例无法访问 private 成员</span></span><br><span class="line">    <span class="comment">// obj.i_private = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="友元函数介绍-friend-function"><a href="#友元函数介绍-friend-function" class="headerlink" title="友元函数介绍 (friend function)"></a>友元函数介绍 (<code>friend function</code>)</h5><p>对于私有变量和私有成员函数, 友元函数可以打破访问权限限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 友元函数不属于某个类，所以定义时</span></span><br><span class="line"><span class="comment">/// 不需要这样写:</span></span><br><span class="line"><span class="comment">/// void count::Set(counter&amp; obj, int num)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 友元函数内，对象实例访问对象私有成员</span></span><br><span class="line">    obj.i_private = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>友元函数本质是普通函数，友元只是描述的是对类的友元。</p></li><li><p>友元函数不属于类，是独立的函数，所以不受作用域描述符的限制。</p></li><li><p>友元函数本身可以同时成为多个类的友元函数。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obja.i_private = num;</span><br><span class="line">    objb.i_private = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj_a;</span><br><span class="line">    B obj_b;</span><br><span class="line">    <span class="built_in">Set</span>(obj_a, obj_b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类内-static-与对象之间的关系"><a href="#类内-static-与对象之间的关系" class="headerlink" title="类内 static 与对象之间的关系"></a>类内 <code>static</code> 与对象之间的关系</h5><p>在对象内的 <code>static</code> 变量和函数，与对象的生命周期无关，每一个对象的所有实例都共享同一个 <code>static</code> 变量和函数。</p><p>类内 <code>static</code> 函数对类内的静态成员函数、构造函数、析构函数和静态成员变量享有访问权限。</p><h6 id="类内静态变量"><a href="#类内静态变量" class="headerlink" title="类内静态变量"></a>类内静态变量</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">///&lt; 记录对象被实例化了多少次</span></span><br><span class="line">    <span class="built_in">A</span>()&#123;count++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    std::cout &lt;&lt; A::counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="类内静态成员函数"><a href="#类内静态成员函数" class="headerlink" title="类内静态成员函数"></a>类内静态成员函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCounter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_non_static = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun_non_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj0;</span><br><span class="line">    A obj1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, A::<span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">0.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">1.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示 类内静态成员函数是可以直接访问类内静态成员变量也可以调用类内静态成员函数<br>但不能调用类内非静态成员变量和函数, 如 <code>i_non_static</code>、 <code>fun_non_static</code></p><p>静态成员函数的使用限制，不能调用非 <code>static</code> 的类内成员函数和成员变量。</p><p>类内静态函数在单例模式中的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleon* pInstance = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pInstance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pInstance = <span class="keyword">new</span> Singleon;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleon</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承用来从基类中继承来函数或成员变量, 省却重复定义。</p><p>假如我们有很多呼叫相关的业务，都需要一个唯一的业务标识号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() : <span class="built_in">strBusinessID</span>(gos::<span class="built_in">GetUUID</span>()) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string strBusinessID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 点呼从基类中继承出来了一个业务 ID</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P2PCall</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P2PCall p2p_call;   <span class="comment">///&lt; 自动生成了一个唯一的业务号</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p2p_call.strBusinessID &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍-1"><a href="#相关语法介绍-1" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span>: <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">derive</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~derive&quot;</span> &lt;&lt; std::endl; &#125; <span class="comment">///&lt; 不定义虚析构函数会导致内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base* p = <span class="keyword">new</span> derive;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="protected-关键字"><a href="#protected-关键字" class="headerlink" title="protected 关键字"></a><code>protected</code> 关键字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_protected</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 可访问基类中的 protected 成员</span></span><br><span class="line">    <span class="keyword">return</span> i_protected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int get_private()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   基类中的 private 成员不能被派生类访问</span></span><br><span class="line">  <span class="comment">//   return i_private;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  base obj0;</span><br><span class="line">  <span class="comment">// 在基类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj0.i_protected = 0;</span></span><br><span class="line">  derive obj;</span><br><span class="line">  <span class="comment">// 在派生类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj.i_protected = 0;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>假设一个程序员又想拥有使用 <code>VSCode</code> 的能力 又想拥有使用 <code>source insight</code> 能力，<code>UML</code> 图如下</p><p><img src="/../resource/C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/multiple_inheritance.png" alt="multiple_inheritance"></p><p>写成代码为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseVSCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseSourceInsight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Programmer 拥有了 class VSCode 和</span></span><br><span class="line"><span class="comment">// class SourceInsight 中的方法函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">UseVSCode</span>();</span><br><span class="line">    lijiancong.<span class="built_in">UserSourceInsight</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个基类中拥有同名成员变量或函数，则派生类使用时应标注该成员变量或函数的作用域，避免产生编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果两个基类中拥有同名成员变量或函数，</span></span><br><span class="line">    <span class="comment">/// 派生类使用时应该标注哪个类的成员变量或函数， 否则编译错误</span></span><br><span class="line">    <span class="keyword">return</span> A::i_protected;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="使用-virtual-阻隔菱形继承"><a href="#使用-virtual-阻隔菱形继承" class="headerlink" title="使用 virtual 阻隔菱形继承"></a>使用 <code>virtual</code> 阻隔菱形继承</h5><p>我们在使用多重继承时，可能会出现如下的情况。</p><p>可能出现如下情况:</p><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5Cmultiple_inheritance2.png" alt="multiple_inheritance2"></p><p>菱形继承不仅会出现二义性成员变量名或函数名，而且在虚函数的继承中，中间类每一个类都会保存一个继承的副本，导致未知问题。使用 <code>virtual</code> 关键字避免菱形继承导致的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Tool</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Tool::i: &quot;</span> &lt;&lt; &amp;i</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VSCode</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;VSCode::i: &quot;</span> &lt;&lt; &amp;(VSCode::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SourceInsight</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SourceInsight::i: &quot;</span></span><br><span class="line">              &lt;&lt; &amp;(SourceInsight::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5CSnipaste_2021-10-23_14-41-51.png" alt="Snipaste_2021-10-23_14-41-51"></p><p>如上图， <code>VSCode</code> 和 <code>SourceInsight</code> 两个类都保存了一份基类 <code>Tool::i</code> 的副本, 造成了二义性。使用 <code>virtual</code> 来避免菱形继承带来的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">///&lt; 正常使用 Tool 类中的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述对象 <code>VSCode</code> 和 <code>SourceInsight</code> 没有使用关键字 <code>virtual</code> 来标注继承方式，那么 <code>Programmer</code> 类中正常使用 <code>Tool::i</code>。</p><h5 id="继承的方式与访问权限"><a href="#继承的方式与访问权限" class="headerlink" title="继承的方式与访问权限"></a>继承的方式与访问权限</h5><p><code>public</code>、<code>private</code>、<code>protected</code> 三种继承方式</p><p>见基类定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>public</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>public</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// public 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `public`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive obj;</span><br><span class="line">    obj.i_public = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;  不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>protected</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>protected</code> 继承与 <code>public</code> 继承相比， 区别在于 基类中 <code>public</code> 成员在 <code>protected</code> 继承后的派生类中降级为 <code>protected</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">protected</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `protected`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;</span><br><span class="line">    i_protected = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private</code> 继承：</p><ul><li>基类中 <code>public</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>private</code> 继承与 <code>public</code> 继承相比，区别在于基类中 <code>public</code> 成员和 <code>protected</code> 成员在 <code>private</code> 继承后的派生类中都降级为 <code>private</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">private</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `private`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `private`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// i_public = 0;</span></span><br><span class="line">    <span class="comment">/// i_protected = 0;</span></span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，什么类型的继承，在派生类中最高的类成员访问权限就降级为什么类型。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态用于接口与多态实现的分离</p><p>下面代码示例为多态在工厂模式中的应用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Interface* <span class="title">getInterface</span><span class="params">(<span class="type">bool</span> bIsUseMySQL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bIsUseMySQL)</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">MySqlImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">RedisImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Interface* p = factory.<span class="built_in">GetInterface</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 通过基类指针指向派生类</span></span><br><span class="line">    <span class="comment">// 调用基类中的虚函数，会通过编译器自动识别</span></span><br><span class="line">    <span class="comment">// 是使用 MySQL 的实现还是 Redis 的实现</span></span><br><span class="line">    p-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">    p-&gt;<span class="built_in">Query</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用多态进行了函数覆盖(<code>override</code>), 但是在基类和派生类中出现了同名但不同入参的函数名，则会发生函数隐藏(<code>hide</code>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">///  这里没有使用多态对基类中的 `Insert` 函数进行覆盖(override), 而是单独创建了一个新的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;RedisImpl::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Interface* pRedis = <span class="keyword">new</span> RedisImpl;</span><br><span class="line">  pRedis-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常使用多态，访问派生类的 `Insert` 函数的实现</span></span><br><span class="line"></span><br><span class="line">  Interface* pMySQL = <span class="keyword">new</span> MySqlImpl;</span><br><span class="line">  <span class="comment">/// pMySQL-&gt;Insert(&quot;Hello World!&quot;); 无法使用基类指针访问多态函数 `Insert`</span></span><br><span class="line">  pMySQL-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 只能访问基类 `Insert` 函数的实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用关键字 <code>override</code> 关键字避免因输入错误而导致函数覆盖不正确的现象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 由于 `override` 要求必须该函数对基类函数进行覆盖，这里由于入参不一致, 会出现编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>一个基类的虚函数，在不同派生类中实现，会产生多个虚函数表。</p><p>派生类的多个实例都会保存一个指针，该指针指向对应虚函数的实现（即对应的虚函数表）。</p><p>虚函数表中放入特定实现的函数指针，被调用时，通过函数指针来调用对应的汇编。</p><h4 id="类成员变量初始化顺序"><a href="#类成员变量初始化顺序" class="headerlink" title="类成员变量初始化顺序"></a>类成员变量初始化顺序</h4><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">a</span>(): <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">x</span>(y<span class="number">+1</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; obj.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出:<br>x: -858993459, y: 0</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 基本操作</title>
      <link href="/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>最简单的查询语句： 查询 <code>dcuser</code> 表中所有字段。</p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>以上语句在代码中禁止使用，因为在数据库扩展时，<code>SELECT *</code> 语句对应的结构体如果没有增加字段，则会出现未知错误。</p><h3 id="指定字段查询"><a href="#指定字段查询" class="headerlink" title="指定字段查询"></a>指定字段查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">UserID</th><th align="center">Name</th><th align="center">DCType</th><th align="center">DepotID</th></tr></thead><tbody><tr><td align="center">3000</td><td align="center">dis01</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3001</td><td align="center">dis02</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3002</td><td align="center">dis03</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3003</td><td align="center">dis04</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">9999</td><td align="center">test</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><h3 id="查询添加过滤条件"><a href="#查询添加过滤条件" class="headerlink" title="查询添加过滤条件"></a>查询添加过滤条件</h3><p>查询 <code>dcuser</code> 表中具有行车调度权限(<code>DCType = 1</code>)的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 为 <code>13003</code> 或 <code>13004</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="number">13003</span>, <span class="number">13004</span>);</span><br></pre></td></tr></table></figure><h4 id="BETWEEN-AND"><a href="#BETWEEN-AND" class="headerlink" title="BETWEEN AND"></a>BETWEEN AND</h4><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 介于 <code>13003</code> 到 <code>13005</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID BETWEEN <span class="number">13003</span> AND <span class="number">13005</span>;</span><br><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID &gt;= <span class="number">13003</span> AND DCUserID &lt;= <span class="number">13005</span>;</span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis</code> 开头的内容。 <code>%</code> 代替任意数量字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis%&#x27;</span></span><br></pre></td></tr></table></figure><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis0</code> + 任意一个字符的内容。 <code>_</code> 代替一个任意字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis0_&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h3><p>按时间降序查询 <code>groupcallinfo</code> 表中的数据。</p><p>升序(<code>ASC</code>): 数值小的记录在前。<br>降序(<code>DESC</code>): 数值大的记录在前。</p><p>如果不写关键字, 则默认使用 升序<code>ASC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>也可以使用多字段排序。 按照 <code>Time</code> 字段降序， <code>ASC</code> 字段升序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>, SeqID <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="查询总数量"><a href="#查询总数量" class="headerlink" title="查询总数量"></a>查询总数量</h3><p>查询 <code>dcuser</code> 表中有几个全功能调度员的账号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;记录数&#x27;</span> <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">65535</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">记录数</th></tr></thead><tbody><tr><td align="center">2</td></tr></tbody></table><h3 id="限制查询记录条数"><a href="#限制查询记录条数" class="headerlink" title="限制查询记录条数"></a>限制查询记录条数</h3><p>查询组呼记录，只显示100条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>查询组呼记录表中所有具有行车调度权限调度台处理的记录。</p><p>翻译为 <code>SQL</code> 语句:</p><p>查询 <code>groupcallinfo</code> 表中， <code>DCUserID</code> 等于 <code>dcuser</code> 表中 <code>DCType</code> 等于 <code>1</code> 记录的 <code>UserID</code> 字段的值</p><p>三句话等价:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> A.DCUserID, A.GroupID, A.Time, A.CallType <span class="keyword">FROM</span> groupcallinfo A <span class="keyword">WHERE</span> A.DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> B.UserID <span class="keyword">FROM</span> dcuser B <span class="keyword">WHERE</span> B.DCType <span class="operator">=</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> contacts <span class="keyword">WHERE</span> (surname, firstname) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> surname, firstname <span class="keyword">FROM</span> customer);</span><br></pre></td></tr></table></figure><h3 id="ALL-与-ANY-关键字"><a href="#ALL-与-ANY-关键字" class="headerlink" title="ALL 与 ANY 关键字:"></a>ALL 与 ANY 关键字:</h3><p>找出 class1 中比 class2 所有 source 都高的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> source <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> source <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><p>找出 class1 中 second_name 与 class2 中的重名的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> second_name <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> second_name <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><h3 id="查询最大、最小、平均值"><a href="#查询最大、最小、平均值" class="headerlink" title="查询最大、最小、平均值"></a>查询最大、最小、平均值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最大通话时长&#x27;</span>, <span class="built_in">MIN</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最小通话时长&#x27;</span>, <span class="built_in">AVG</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;平均通话时长&#x27;</span> <span class="keyword">FROM</span> trainposcallinfo;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">最大通话时长</th><th align="center">最小通话时长</th><th align="center">平均通话时长</th></tr></thead><tbody><tr><td align="center">48</td><td align="center">2</td><td align="center">14.667</td></tr></tbody></table><h3 id="查询数据分组"><a href="#查询数据分组" class="headerlink" title="查询数据分组"></a>查询数据分组</h3><p>统计不同的 <code>DCUserID</code> 都有多少条组呼记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr></tbody></table><h4 id="WITH-ROLLUP"><a href="#WITH-ROLLUP" class="headerlink" title="WITH ROLLUP"></a>WITH ROLLUP</h4><p><code>WITH ROLLUP</code> 用来在 <code>GROUP BY</code> 统计的基础上再加一行总数的统计行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr><tr><td align="center"></td><td align="center">859</td></tr></tbody></table><h4 id="HAVING-与-WHERE-区别"><a href="#HAVING-与-WHERE-区别" class="headerlink" title="HAVING 与 WHERE 区别"></a>HAVING 与 WHERE 区别</h4><p>having子句与where都是设定条件筛选的语句，有相似之处也有区别。</p><p>having与where的区别:<br>having是在分组后对数据进行过滤<br>where是在分组前对数据进行过滤<br>having后面可以使用聚合函数<br>where后面不可以使用聚合</p><p>在查询过程中执行顺序：from&gt;where&gt;group（含聚合）&gt;having&gt;order&gt;select。</p><p>所以聚合语句(sum,min,max,avg,count)要比having子句优先执行，而where子句在查询过程中执行优先级别优先于聚合语句(sum,min,max,avg,count)。<br>where子句：<br>select sum(num) as rmb from order where id&gt;10<br>&#x2F;&#x2F;只有先查询出id大于10的记录才能进行聚合语句</p><p><a href="https://blog.csdn.net/ryan007liu/article/details/91441479">Mysql中having和where的区别</a></p><h3 id="查询过滤重复数据"><a href="#查询过滤重复数据" class="headerlink" title="查询过滤重复数据"></a>查询过滤重复数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCType</th></tr></thead><tbody><tr><td align="center">65535</td></tr><tr><td align="center">2</td></tr></tbody></table><p>说明: <code>DISTINCT</code> 关键词修饰的是语句整体，不能对单独字段修饰，并查询其他字段内容。<br>如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType, UserID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>如上语句意义为查询 DCType 且 UserID 同时不重复的列。</p><p>输出:</p><table><thead><tr><th align="center">DCType</th><th align="center">UserID</th></tr></thead><tbody><tr><td align="center">65535</td><td align="center">3000</td></tr><tr><td align="center">65535</td><td align="center">3001</td></tr><tr><td align="center">65535</td><td align="center">3002</td></tr><tr><td align="center">65535</td><td align="center">3003</td></tr><tr><td align="center">2</td><td align="center">9999</td></tr></tbody></table><h3 id="替换特定字段查询结果"><a href="#替换特定字段查询结果" class="headerlink" title="替换特定字段查询结果"></a>替换特定字段查询结果</h3><p>查询 <code>dcuser</code> 表中所有数据， <code>DCType</code> 字段等于 <code>65535</code> 的显示全功能调度员, 等于 <code>1</code> 的显示行车调度员, 其他取值显示原本的值, 该字段结果显示为<code>调度员类型</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> DCType <span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span> &quot;全功能调度员&quot; <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> &quot;行车调度员&quot; <span class="keyword">ELSE</span> UserID <span class="keyword">END</span> <span class="keyword">AS</span> &quot;调度员类型&quot; <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>分段看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CASE</span> DCType</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;全功能调度员&quot;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;行车调度员&quot;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">UserID</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span> &quot;调度员类型&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">调度员类型</th></tr></thead><tbody><tr><td align="center">全功能调度员</td></tr><tr><td align="center">14004</td></tr><tr><td align="center">行车调度员</td></tr></tbody></table><p>关于 <code>CASE... WHEN...</code> 更多用法见下面链接</p><p><a href="https://zhuanlan.zhihu.com/p/63333847">SQL之CASE WHEN用法详解</a><br><a href="https://www.gairuo.com/p/sql-select-case-when-then">SQL 查询：SELECT CASE 条件赋值</a><br><a href="https://blog.csdn.net/qq_31071543/article/details/79666427">关于case when复杂sql语句查询</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><a href="https://blog.csdn.net/lxf512666/article/details/52812146">SQL SELECT(复杂查询)之 自连接 &amp; 子查询 解析</a><br><a href="https://www.cnblogs.com/Hadley-pu/p/sql_selfconnect.html">sql中自连接的使用</a><br><a href="https://zhuanlan.zhihu.com/p/110891010">010-MySQL：自连接查询</a><br><a href="https://cloud.tencent.com/developer/article/1665642">算法工程师-SQL进阶：神奇的自连接与子查询</a></p><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>改变 dcuser 表名称到 dcuser_new</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> dcuser <span class="keyword">TO</span> dcuser_new;</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>删除整个 dcuser 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> dcuser;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p>删除表信息的方式有两种 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> dcuser;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>注 : truncate操作中的table可以省略，delete操作中的*可以省略</p><p>truncate、delete 清空表数据的区别 :<br>1&gt; truncate 是整体删除 (速度较快)，delete是逐条删除 (速度较慢)<br>2&gt; truncate 不写服务器 log，delete 写服务器 log，也就是 truncate 效率比 delete高的原因<br>3&gt; truncate 不激活trigger (触发器)，但是会重置Identity (标识列、自增字段)，相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的 ID数。而 delete 删除以后，identity 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件</p><p>参考资料:<br><a href="https://blog.csdn.net/chenshun123/article/details/79676446">MySQL 清空表(truncate)与删除表中数据(delete) 详解</a></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> runoob_tbl <span class="keyword">SET</span> runoob_title<span class="operator">=</span><span class="string">&#x27;学习 C++&#x27;</span> <span class="keyword">WHERE</span> runoob_id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="过程、函数"><a href="#过程、函数" class="headerlink" title="过程、函数"></a>过程、函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span>  Create10K<span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `Create10K`(<span class="keyword">IN</span> `for_time` <span class="type">INT</span>, <span class="keyword">IN</span> `type_int` <span class="type">INT</span>, <span class="keyword">IN</span> `info_text` <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> for_time <span class="operator">*</span> <span class="number">10000</span> DO</span><br><span class="line">    <span class="keyword">INSERT INTO</span> test_table(Type, Info) <span class="keyword">VALUES</span>(type_int, info_text);</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> Create10K(<span class="number">500</span>, <span class="number">1</span>, &quot;1&quot;);</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/sunada2005/p/3411873.html">常用SQL查询语句</a></p><h3 id="插入主键重复的数据"><a href="#插入主键重复的数据" class="headerlink" title="插入主键重复的数据"></a>插入主键重复的数据</h3><p>插入 <code>dcuser</code> 表中一条数据，如果主键重复则更新原数据的 <code>StationList</code> 字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> dcuser(UserID, Name, DCType, DepotID, StationList) <span class="keyword">VALUES</span>(<span class="number">14005</span>, <span class="string">&#x27;14005&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, &quot;1,2,3,4&quot;) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> StationList <span class="operator">=</span> &quot;1,2,3,4&quot;;</span><br></pre></td></tr></table></figure><h3 id="按天查询数量"><a href="#按天查询数量" class="headerlink" title="按天查询数量"></a>按天查询数量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP(date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d 0:0:0&#x27;</span>)), <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> sds_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL 8.0 Reference Manual</a><br><a href="https://dev.mysql.com/doc/mysql-tutorial-excerpt/8.0/en/examples.html">Chapter 7 Examples of Common Queries</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html">13.2.9 REPLACE Statement</a></p><p>TODO: 合并查询、分页查询、空值判断、Contact 拼接查询结果、REPLACE INTO、多条插入、事务、存储过程、视图、批量插入、my.ini 的配置项的研究、中间表查询<br><a href="https://www.cnblogs.com/zengen/archive/2011/08/10/2133423.html">SQL中的循环、for循环、游标</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用场景</title>
      <link href="/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Git 使用场景</p><h2 id="场景：仓库中的临时文件"><a href="#场景：仓库中的临时文件" class="headerlink" title="场景：仓库中的临时文件"></a>场景：仓库中的临时文件</h2><p>我们编译出来了大量临时文件或很大的二进制文件，如 .o, .lib文件，这些文件不想上传。</p><p>提出问题： 想要在本文件夹中做版本控制，但需要忽略某些特定的文件</p><p>解决方案： 使用.gitignore文件来标记不想要进行版本控制的临时文件。</p><p>.gitignore 文件的用法:</p><p>.gitignore文件是由我们自己创建, 并默认放置在仓库的根目录。<br>Git 默认会忽略<code>.gitignore</code>中的文件名的大小写, 不过我们可以通过<code>git config core.ignorecase false</code>，来设置为不忽略大小写。</p><ol><li>文件内容格式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略.lib为后缀的文件</span></span><br><span class="line">*.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libmysql.lib 这个文件不忽略</span></span><br><span class="line">!libmysql.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的bin文件夹</span></span><br><span class="line">bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略根目录下的bin文件夹</span></span><br><span class="line">/bin/</span><br></pre></td></tr></table></figure><ol start="2"><li>已经被忽略的文件如何添加到暂存区: <code>git add -f &lt;filename&gt;</code></li><li>已经添加到暂存区中的文件如何忽略: <code>git rm --cached &lt;filename&gt;</code></li></ol><h2 id="场景-不小心提交了一个临时文件"><a href="#场景-不小心提交了一个临时文件" class="headerlink" title="场景: 不小心提交了一个临时文件"></a>场景: 不小心提交了一个临时文件</h2><p>我们对<strong>这个临时文件不想做版本跟踪</strong>，但是在<code>.gitignore</code>文件中添加该文件，这个文件仍然会被追踪。</p><p>提出问题: 如何忽略一个已经被追踪的文件?</p><p>解决方案：</p><ol><li><code>git rm filename</code>直接从仓库中删除该文件，并把该改动commit后，随后在<code>.gitignore</code>中添加该文件为忽略。</li><li><code>git update-index --assume-unchanged &lt;filename&gt;</code>, 这个操作不会删除该文件，也不用提交，但命令太长</li></ol><h2 id="场景-需要标记一个特定的版本"><a href="#场景-需要标记一个特定的版本" class="headerlink" title="场景: 需要标记一个特定的版本"></a>场景: 需要标记一个特定的版本</h2><p>当我们的代码进入到比较稳定，或者开发出了一个功能，需要标记一个commit来作为稳定版本的基准。</p><p>提出问题： 如何为commit添加标记和备注信息</p><p>解决方案： 使用<code>git tag</code>为版本打标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a vx.x.x -m &quot;message&quot;</span><br><span class="line">git push origin tags    ///&lt; 推送到远端</span><br></pre></td></tr></table></figure><h2 id="场景-修改远端标签名称"><a href="#场景-修改远端标签名称" class="headerlink" title="场景: 修改远端标签名称"></a>场景: 修改远端标签名称</h2><p>修改tag名 v1.0重命名v2.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag 新tag名称 旧tag名称</span><br><span class="line">git tag -d 旧tag名称</span><br><span class="line">git push origin :refs/tags/旧tag名称</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="场景：-开发一个功能"><a href="#场景：-开发一个功能" class="headerlink" title="场景： 开发一个功能"></a>场景： 开发一个功能</h2><p>某项功能可能开发时间较久，但又想把未完成的代码上传到远端版本库，来实现多台电脑同步。</p><p>例如：在开发随车通信需求时，在<code>linux</code>上编译<code>dis</code>，而我开发的环境在<code>windows</code>上, 当我在本地<code>window</code>开发的临时代码，想要放到<code>linux</code>机器上，这时我们需要分支来对代码的同步。</p><p>提出问题： 怎样才能在不影响远端仓库的代码的情况下，在远端备份开发过程代码？</p><p>解决方法： 使用 git branch<br>brunch 介绍:<br>brunch意味着你可以从主分支中，分叉出来一个分支来提交代码而不影响主分支的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/// 创建并切换到分支</span><br><span class="line">git checkout -b &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 做相应的提交，修改</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 把本地分支上传到远端</span><br><span class="line">git push origin &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 切换到另一台电脑上，拉去自己的分支</span><br><span class="line">git pull origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>合并分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop    ///&lt; 当前处于develop分支下</span><br><span class="line">git merge master   ///&lt; 把master的东西合入到当前分支，方便在自己开发的分支上处理冲突</span><br><span class="line">git checkout master    ///&lt; 切换到master分支</span><br><span class="line">git merge develop    ///&lt; 把develop合并到当前分支</span><br><span class="line">git branch -d future    ///&lt; 把合并过的分支删除</span><br></pre></td></tr></table></figure><h2 id="场景：临时切换分支"><a href="#场景：临时切换分支" class="headerlink" title="场景：临时切换分支"></a>场景：临时切换分支</h2><p>我们会遇到临时切换回主分支的情况。<br>例如： 当我在开发随车通信功能开发一半时，雷总让我在仓库中提交一个文档。如果我在自己的开发分支上上传该文档，那么在<code>master</code>分支上会没有这个文档，其他人也获取不到，所以只能切换回<code>master</code>分支上进行上传。</p><p>提出问题： 快速切换分支，做完提交，切换回开发分支时，工作区应跟切换分支前一样。</p><p>解决方案：<br>那么现在分为两种情况：</p><ol><li>我们工作区没有未被commit的文件，那么我们直接<code>git checkout &lt;branch_name&gt;</code>, 即可切换到相应的分支。</li><li>我们工作区有很多未被commit的代码，这时我们可以选择，把工作区内代码全部commit或者选择使用<code>git stash</code>来临时把未被commit的代码给存储起来， 在我们切换回开发分支时，再把临时存储的代码拿出来。</li></ol><p><code>stash</code>介绍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 把所有未commit的文件(工作区、暂存区里的文件)都放入一个临时的分支，使工作区可以切换分支</span><br><span class="line">git stash</span><br><span class="line">或</span><br><span class="line">git stash save &quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 切换到其他分支，并做一些提交, 并切换回自己的开发分支</span><br><span class="line">git checkout master</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line">/// 把临时存储的代码给拿出来，放入工作区(之前暂存区的文件在pop后的状态是到工作区)</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p><code>git stash --include-untracked</code>或<code>git stash -u</code> 来存储未被跟踪的文件</p><h2 id="场景：-某个commit，提交错分支了"><a href="#场景：-某个commit，提交错分支了" class="headerlink" title="场景： 某个commit，提交错分支了"></a>场景： 某个commit，提交错分支了</h2><p>开发过程中，突然出现了一个<code>BUG</code>需要立即修复，我们急着修复，把修复的代码放入了正在大改开发分支上。<br>提出问题： 我们需要怎样，把主分支上的<code>BUG</code>给修正过来<br>解决方案:</p><ol><li>切换到主分支，再次把刚才修改的文件，同样在主分支上进行修改，再次进行提交。</li><li>切换到主分支，使用<code>git cherry-pick &lt;SHA&gt;</code>把特定提交给放到主分支中。</li></ol><p>方案一存在修改的不一致，当后面需要合并分支时，需要处理冲突。<br>方案二快速提交，不用再次使用手动修改文件。</p><p><code>git cherry-pick &lt;SHA&gt;</code>用法示例：<br>该操作会把特定的commit给，放入当前所在的分支，并产生一个新的提交</p><p>之前分支的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">        \</span><br><span class="line">        e - f - g Feature</span><br></pre></td></tr></table></figure><p><code>cherry-pick</code>操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 切换到</span><br><span class="line">git checkout master</span><br><span class="line">/// 把提交f给提交到本分支</span><br><span class="line">git cherry-pick f</span><br></pre></td></tr></table></figure><p>操作后的分支情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">    \</span><br><span class="line">    e - f - g       Feature</span><br></pre></td></tr></table></figure><h2 id="场景-commit的信息输入错了"><a href="#场景-commit的信息输入错了" class="headerlink" title="场景: commit的信息输入错了"></a>场景: commit的信息输入错了</h2><p>提出问题： 怎么修改提交的commit信息</p><p>解决方案：</p><ol><li>修改最近一次提交的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">/// 进入到提交的文件里面，默认使用vim打开</span><br><span class="line">/// 修改好提交信息，保存后退出</span><br></pre></td></tr></table></figure><ol start="2"><li>如果想要修改之前的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3    ///&lt; 回退到HEAD前面第三个commit处</span><br><span class="line"></span><br><span class="line">/// 想要修改哪一个提交就把pick换成你想要的操作,edit</span><br><span class="line">git commit --amend</span><br><span class="line">/// 然后执行</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><ol start="3"><li>如果该 commit 已经 push 到远端</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line">git push --force-with-lease origin &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h2 id="场景-开发到一半，发现修改的思路有误"><a href="#场景-开发到一半，发现修改的思路有误" class="headerlink" title="场景: 开发到一半，发现修改的思路有误"></a>场景: 开发到一半，发现修改的思路有误</h2><p>我们从远端仓库拉去最新代码，修改过程中，发现修改错误了，想再从已经提交的代码上重新开始。</p><p>提出问题： 如何回退版本</p><p>解决方案：</p><ol><li>没有commit想要回退， 只是清除工作区修改的代码, 如何让当前已经修改过的代码恢复到HEAD的最新提交代码一致, 即清除工作区修改的代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 清除所有没有被暂存的改动</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">/// 清除该文件没有被暂存的改动</span><br><span class="line">git checkout filename</span><br></pre></td></tr></table></figure><ol start="2"><li>想要撤销上一个commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 删除工作区改动的代码，撤销最近一次的commit，撤销git add .</span><br><span class="line">/// 注意完成这个操作后，就恢复到了上一次的commit状态。</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">/// HEAD 指向 commit_id 指向的提交</span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--hard</code>换成<code>--soft</code>, 则会保留已经暂存和修改的文件</li><li><code>HEAD^</code>换成<code>HEAD~2</code>则可以回退两个commit</li></ul><h3 id="清除工作区的修改"><a href="#清除工作区的修改" class="headerlink" title="清除工作区的修改"></a>清除工作区的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_id&gt;    /// 返回到某个节点，不保留修改，已有的改动会丢失</span><br><span class="line">git reset --soft &lt;commit_id&gt;    /// 返回到某个节点，保留修改，已有的改动会保留，在未提交中， `git status` 或 `git diff` 查看</span><br><span class="line"></span><br><span class="line">git clean -df /// 返回到某个节点(未跟踪文件的删除)</span><br><span class="line">git clean -n  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -f  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -i  /// 显示将要删除的文件</span><br><span class="line">git clean -d  /// 递归删除目录及文件(未跟踪的文件)</span><br><span class="line">git clean -q  /// 仅显示错误，成功删除的文件不显示</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clean -nxdf /// 查看要删除的文件及目录，确认无误后再使用下面的命令进行删除</span><br><span class="line">git checkout . &amp;&amp; git clean -xdf</span><br></pre></td></tr></table></figure><h3 id="revert-和-reset"><a href="#revert-和-reset" class="headerlink" title="revert 和 reset"></a>revert 和 reset</h3><ol><li><p>revert<br>首先肯定的是 <code>revert</code>，<code>git revert commit_id</code> 能产生一个 与 <code>commit_id</code> 完全相反的提交，即 <code>commit_id</code> 里是添加， <code>revert</code> 提交里就是删除。<br><code>revert</code> 会生成一个新的提交记录，但不适合回退多个提交。</p></li><li><p>reset<br><code>reset</code> 的原理是把 <code>HEAD</code> 的指向，并删除回退后的版本之后的提交(被删除的提交可以通过 git reflog 查看)。<code>git reset --hard &lt;commit_id&gt;</code><br>但是由于是本地回退版本，所以在推送至远端时，需要使用 <code>git push -f origin master</code> 的命令象只覆盖远端分支。由于我们的远端仓库大部分都是对 <code>master</code> 分支进行保护不允许使用 <code>-f</code> 强制覆盖。我们可以先回退 <code>develop</code> 分支, 在 <code>develop</code> 分支上在创建一次提交(该提交已经领先于远端<code>master</code>分支), 再提交至远端 <code>develop</code> 分支后 <code>merge</code>。</p></li></ol><h2 id="场景：-想要找到某个特定业务的所有提交"><a href="#场景：-想要找到某个特定业务的所有提交" class="headerlink" title="场景： 想要找到某个特定业务的所有提交"></a>场景： 想要找到某个特定业务的所有提交</h2><p>假设我们的commit的信息都是采用模板来填写的，且已经有大量的<code>commit</code>时候，需要过滤检索一些特定提交信息的<code>commit</code>。</p><p>提出问题： 如何使用关键字搜索提交信息</p><p>解决方案：<br>使用git自带的文字搜索功能<code>git log --all --grep=&#39;TrainPosCall&#39;</code>, 搜索提交信息中带有<code>TrainPosCall</code>的<code>commit</code>。</p><h2 id="场景：-想要确认代码的改动"><a href="#场景：-想要确认代码的改动" class="headerlink" title="场景： 想要确认代码的改动"></a>场景： 想要确认代码的改动</h2><p>想要分步提交修改库函数的文件和修改业务逻辑的文件，需要确认每个文件的改动。</p><p>提出问题： 怎么查看已修改的代码对比之前的版本</p><p>解决方案：</p><ol><li>查看尚未缓存的改动：<code>git diff</code></li><li>查看已缓存的改动： <code>git diff --cached</code>, <code>git diff --staged</code></li><li>查看已缓存的与未缓存的所有改动：<code>git diff HEAD</code></li><li>显示摘要而非整个 diff： <code>git diff --stat</code></li><li>版本号与版本号之间的差别: <code>git diff &lt;SHA&gt; &lt;SHA&gt;</code></li></ol><h2 id="场景误删除分支"><a href="#场景误删除分支" class="headerlink" title="场景误删除分支"></a>场景误删除分支</h2><p>在误删除分支后，可以使用 <code>git reflog</code> 来查看分支的<code>commit id</code>并使用该<code>commit id</code>来创建一个新的分支<br><code>git branch recover-branch [commit id]</code></p><h2 id="场景-git-账户修改密码"><a href="#场景-git-账户修改密码" class="headerlink" title="场景: git 账户修改密码"></a>场景: git 账户修改密码</h2><p>操作<code>git</code>时, 出现错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: HTTP Basic: Access denied</span><br></pre></td></tr></table></figure><p>管理员权限输入以下命令后在命令行中操作<code>git</code>，重新输入用户名，密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/docs">git Reference</a></p><p><a href="https://git-scm.com/book/en/v2">Pro Git</a></p><p><a href="https://juejin.cn/post/6844903965625155597">Git新手教程-添加忽略文件(十)</a></p><p><a href="https://www.freecodecamp.org/news/git-cheat-sheet/">Git Cheat Sheet – 50 Git Commands You Should Know</a></p><p><a href="https://www.runoob.com/git/git-diff.html">git diff 命令</a></p><p><a href="https://www.atlassian.com/git/tutorials/saving-changes/git-diff">Git diff</a></p><p><a href="https://www.cnblogs.com/ibingshan/p/10783552.html">git clean 删除忽略文件 和 未被跟踪文件及文件夹</a></p><p><a href="https://git-scm.com/docs/git-branch">git-branch - List, create, or delete branches</a></p><p><a href="https://stackoverflow.com/questions/7124914/how-to-search-a-git-repository-by-commit-message/7124949#7124949">How to search a Git repository by commit message?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类型大小(32bit 与 64bit)</title>
      <link href="/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/"/>
      <url>/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/</url>
      
        <content type="html"><![CDATA[<p>C++ 类型大小 (32bit 与 64bit)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---标准类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int size:                &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long size:          &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size_t size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned char size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;signed char size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">signed</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pointer size:            &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---自定义类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SHORT(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT(int) size:                   &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;LONG(long) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT8(unsigned char) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT16(unsigned short) size:     &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT32(unsigned int) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT64(unsigned long long) size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT8(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT16(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT32(int) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT64(long long) size:           &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;FLOAT(float) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DOUBLE(double) size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CHAR(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BOOL(int) size:                  &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BYTE(unsigned char) size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;HANDLE(void*) size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>VS2010 32bit</th><th>VS2010 64bit</th><th>VS2019 32bit</th><th>VS2019 64bit</th><th>Linux 32bit</th><th>Linux 64bit</th><th>备注</th></tr></thead><tbody><tr><td>short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>unsigned short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>unsigned int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>unsigned long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>unsigned long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>size_t</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>signed char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>pointer</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>SHORT(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>LONG(long)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>UINT8(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>UINT16(unsigned short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>UINT32(unsigned int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>UINT64(unsigned long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>INT8(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>INT16(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT32(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>INT64(long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>FLOAT(float)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>DOUBLE(double)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>CHAR(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>BOOL(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>BYTE(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>HANDLE(void*)</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr></tbody></table><p>结论:</p><ol><li><code>size_t</code>、<code>pointer</code>、<code>long</code>、<code>unsigned long</code>、<code>HANDLE</code>这三种类型在<code>32bit</code>和<code>64bit</code>的大小有差别。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华为C++编程规范摘录</title>
      <link href="/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/"/>
      <url>/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bookstack.cn/read/openharmony-1.0-zh-cn/contribute-OpenHarmony-cpp-coding-style-guide.md">华为C++语言编程规范</a></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="3-7-1-if-循环语句必须使用大括号"><a href="#3-7-1-if-循环语句必须使用大括号" class="headerlink" title="3.7.1 if&#x2F;循环语句必须使用大括号"></a>3.7.1 if&#x2F;循环语句必须使用大括号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>();  <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-不用的代码段直接删除，不要注释掉"><a href="#4-4-3-不用的代码段直接删除，不要注释掉" class="headerlink" title="4.4.3 不用的代码段直接删除，不要注释掉"></a>4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入容易被忽略的缺陷。正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。使用版本控制来，记录代码。</p><h3 id="5-2-3-禁止通过声明的方式引用外部函数接口、变量"><a href="#5-2-3-禁止通过声明的方式引用外部函数接口、变量" class="headerlink" title="5.2.3 禁止通过声明的方式引用外部函数接口、变量"></a>5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。通过<code>extern</code>声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。同时这种隐式依赖，容易导致架构腐化。</p><h3 id="5-2-4-禁止在extern-C-中包含头文件"><a href="#5-2-4-禁止在extern-C-中包含头文件" class="headerlink" title="5.2.4 禁止在extern &quot;C&quot;中包含头文件"></a>5.2.4 禁止在<code>extern &quot;C&quot;</code>中包含头文件</h3><p>在<code>extern &quot;C&quot;</code> 中包含头文件，有可能导致<code>extern &quot;C&quot;</code>嵌套，部分编译器对<code>extern &quot;C&quot;</code>嵌套层次有限制，嵌套层次太多会编译错误。</p><h3 id="7-1-1-类的成员变量必须显式初始化"><a href="#7-1-1-类的成员变量必须显式初始化" class="headerlink" title="7.1.1 类的成员变量必须显式初始化"></a>7.1.1 类的成员变量必须显式初始化</h3><p>如果类有成员变量，没有定义构造函数，有没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。<br>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化</p><h3 id="7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。"><a href="#7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。" class="headerlink" title="7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。"></a>7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。</h3><p>可以将拷贝构造函数或者赋值操作符设置为<code>private</code>，并且不实现。<br>C++11以后可以使用关键字<code>delete</code>, 来删除该成员函数。</p><h3 id="7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"><a href="#7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止" class="headerlink" title="7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"></a>7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><h3 id="7-1-6-禁止在构造函数和析构函数中调用虚函数"><a href="#7-1-6-禁止在构造函数和析构函数中调用虚函数" class="headerlink" title="7.1.6 禁止在构造函数和析构函数中调用虚函数"></a>7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>在构造函数和析构函数中调用当前对象的虚函数，会导致未定义的行为。在C++中，一个基类一次只构造一个完整的对象。</p><h3 id="7-2-1-基类的析构函数应该声明为virtual"><a href="#7-2-1-基类的析构函数应该声明为virtual" class="headerlink" title="7.2.1 基类的析构函数应该声明为virtual"></a>7.2.1 基类的析构函数应该声明为<code>virtual</code></h3><p><code>虚析构函数</code></p><h3 id="7-2-2-禁止虚函数使用缺省参数值"><a href="#7-2-2-禁止虚函数使用缺省参数值" class="headerlink" title="7.2.2 禁止虚函数使用缺省参数值"></a>7.2.2 禁止虚函数使用缺省参数值</h3><p>在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着你最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。为了避免虚函数重载时，因参数声明不一致给使用者带来的困惑和由此导致的问题，规定所有虚函数均不允许声明缺省参数值。</p><h3 id="7-2-3-禁止重新定义继承而来的非虚函数"><a href="#7-2-3-禁止重新定义继承而来的非虚函数" class="headerlink" title="7.2.3 禁止重新定义继承而来的非虚函数"></a>7.2.3 禁止重新定义继承而来的非虚函数</h3><p>因为非虚函数无法实现动态绑定，只有虚函数才能实现动态绑定：只要操作基类的指针，即可获得正确的结果。</p><h3 id="8-1-1-避免函数过长，函数不超过50行-非空非注释"><a href="#8-1-1-避免函数过长，函数不超过50行-非空非注释" class="headerlink" title="8.1.1 避免函数过长，函数不超过50行(非空非注释)"></a>8.1.1 避免函数过长，函数不超过50行(非空非注释)</h3><p>函数应该可以一屏显示完(50行以内), 只做一件事情，而且把它做好。<br>过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步抽象。<br>例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。<br>即使一个长函数现在工作的很好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的BUG。建议将其拆分为更加简短并易于管理的若干函数，以便于他人阅读和修改代码。</p><h3 id="9-1-1-不允许使用宏来表示常量"><a href="#9-1-1-不允许使用宏来表示常量" class="headerlink" title="9.1.1 不允许使用宏来表示常量"></a>9.1.1 不允许使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名；宏没有类型检查，不安全；宏没有作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MSI_SDN_LEN 20  <span class="comment">///&lt; Bad</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>; <span class="comment">///&lt; Good</span></span><br><span class="line"><span class="comment">/// C++11以上的版本，可以使用`constexpr`</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="9-1-2不允许使用魔鬼数字"><a href="#9-1-2不允许使用魔鬼数字" class="headerlink" title="9.1.2不允许使用魔鬼数字"></a>9.1.2不允许使用魔鬼数字</h3><p>魔鬼数字是看不懂、难以理解的数字。<br>例如<code>type = 12</code>，看不懂，但改成<code>mouthsCount = yearsCount * 12</code>, 就容易理解。<br>数字<code>0</code>有时候也难以理解。<code>status = 0</code>并不能表达是什么状态。<br>解决途径： 对于局部使用的数字，可以增加注释说明，对于多处使用的数字，必须定义<code>const</code>常量，并通过符号命名自注释。<br>禁止出现下列情况： 没有通过符号来解释数字含义，如<code>const int ZERO = 0</code>，符号命名限制了其取值，如<code>const int XXX_TIMER_INTERVAL_300MS = 300</code>，<br>直接使用<code>XX_TIMER_INTERVAL_MS</code>来表示该常量是定时器的时间间隔。</p><h3 id="9-1-3-常量应该保证单一职责"><a href="#9-1-3-常量应该保证单一职责" class="headerlink" title="9.1.3 常量应该保证单一职责"></a>9.1.3 常量应该保证单一职责</h3><p>一个常量只用来标识一个特定功能，即一个常量不能有多种用途。</p><p>好的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> A_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Namespace1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Namespace2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-4-禁止用memcpy-s、memset-s初始化非POD对象"><a href="#9-1-4-禁止用memcpy-s、memset-s初始化非POD对象" class="headerlink" title="9.1.4 禁止用memcpy_s、memset_s初始化非POD对象"></a>9.1.4 禁止用<code>memcpy_s</code>、<code>memset_s</code>初始化非<code>POD</code>对象</h3><p><code>POD</code>类型主要包括<code>int</code>, <code>char</code>, <code>float</code>, <code>double</code>, <code>enumeration</code>, <code>void</code>, <code>pointer</code>等原始类ing以及聚合类型，不能使用封装和面向对象特性(如用户定义的构造&#x2F;赋值&#x2F;析构函数、基类、虚函数)<br>由于非<code>POD</code>类型比如非聚合类型的<code>class</code>对象，可能存在虚函数，内存布局不确定，跟编译器有关，滥用内存拷贝可能会导致严重的问题。<br>即使对聚合类型的<code>class</code>,使用直接的内存拷贝和比较，破坏了信息隐蔽和数据保护的作用，也不提倡使用<code>memcpy_s</code>、<code>memset_s</code></p><h3 id="9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量"><a href="#9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量" class="headerlink" title="9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量"></a>9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量</h3><p>含有变量自增或自减的表达式中，如果再引用该变量，其结果在C++标准中未明确定义。会产生未定义的结果。<br>注意，运算次序的问题不能使用括号来解决，因为之不是优先级的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i++; <span class="comment">///&lt; Bad: b[i]运算跟i++, 先后顺序并不明确。</span></span><br></pre></td></tr></table></figure><p>正确的写法是将自增或自减运算单独放一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i;</span><br><span class="line">i++;    <span class="comment">///&lt; Good， 单独一行</span></span><br></pre></td></tr></table></figure><p>函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Func</span>(i++, i)    <span class="comment">///&lt; Bad</span></span><br><span class="line"></span><br><span class="line">i++;    <span class="comment">///&lt; Good， 自增运算单独放一行</span></span><br><span class="line"><span class="built_in">Func</span>(i, i)</span><br></pre></td></tr></table></figure><h3 id="9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换"><a href="#9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换" class="headerlink" title="9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换"></a>9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换</h3><p>C++提供的类型转换操作比C风格更具有针对性，更易读，也更安全，C++提供的转换有：</p><ol><li><code>dynamic_cast</code>: 主要用于继承体系下行转换，<code>dynamic_cast</code>具有类型检查的功能，请做好基类和派生类的设计，避免使用<code>dynamec_cast</code>来进行转换。</li><li><code>static_cast</code>: 和C风格相似可做值的强制转换，或上行转换(把派生类的指着或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。</li><li><code>reinterpret_cast</code>: 用于转换不相关的类型。<code>reinterpret_cast</code>强制编译器将某个类型对象的内存重新解释成另一种类型，这是一种不安全的转换，建议尽可能少用<code>reinterpret_cast</code></li><li><code>const_cast</code>: 用于移除对象的<code>const</code>属性，使对象变得可修改，这样会破坏数据的不变性，建议尽可能少用。</li></ol><h3 id="9-5-1-不要保存std-string的c-str-返回的指针"><a href="#9-5-1-不要保存std-string的c-str-返回的指针" class="headerlink" title="9.5.1 不要保存std::string的c_str()返回的指针"></a>9.5.1 不要保存<code>std::string</code>的<code>c_str()</code>返回的指针</h3><p>C++标准中并未规定<code>c_str()</code>返回的指针持久有效，所以不要保存。</p><h3 id="9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const"><a href="#9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const" class="headerlink" title="9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用const"></a>9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用<code>const</code></h3><p>不变的值更易于理解&#x2F;跟踪和分析， 把<code>const</code>作为默认悬念，在编译时会对其进行检查，使代码更安全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-6-2-对于不会修改成员变量的成员函数请使用const修饰"><a href="#9-6-2-对于不会修改成员变量的成员函数请使用const修饰" class="headerlink" title="9.6.2 对于不会修改成员变量的成员函数请使用const修饰"></a>9.6.2 对于不会修改成员变量的成员函数请使用<code>const</code>修饰</h3><p>尽可能将成员函数声明为<code>const</code>。访问函数应该总是<code>const</code>。只要不修改数据成员的成员函数，都声明为<code>const</code>。对于虚函数，应当从设计意图上考虑继承链上的所有类是否需要在此虚函数中修改数据成员，而不是仅关注单个类的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">PrintValue</span><span class="params">()</span> <span class="type">const</span> <span class="comment">///&lt; 修饰成员函数, 不会修改成员变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="2-4-1-避免滥用typedef或者-define对基本类型起别名"><a href="#2-4-1-避免滥用typedef或者-define对基本类型起别名" class="headerlink" title="2.4.1 避免滥用typedef或者#define对基本类型起别名"></a>2.4.1 避免滥用<code>typedef</code>或者<code>#define</code>对基本类型起别名</h3><p>除有明确的必要性，否则不要用<code>typedef</code>、<code>#define</code>对基本数据类型进行重定义。优先使用<code>&lt;cstdint&gt;</code>头文件中的基本。</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有、无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有、无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有、无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有、无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有、无符号整数类型</td></tr></tbody></table><h3 id="3-1-1-行宽不超过120个字符"><a href="#3-1-1-行宽不超过120个字符" class="headerlink" title="3.1.1 行宽不超过120个字符"></a>3.1.1 行宽不超过120个字符</h3><h3 id="3-9-1-表达式换行要保持换行的一致性，运算符放行末"><a href="#3-9-1-表达式换行要保持换行的一致性，运算符放行末" class="headerlink" title="3.9.1 表达式换行要保持换行的一致性，运算符放行末"></a>3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">IsCorrect</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsValid</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsSomething</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-1-合理安排空行，保持代码紧凑"><a href="#3-14-1-合理安排空行，保持代码紧凑" class="headerlink" title="3.14.1 合理安排空行，保持代码紧凑"></a>3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。</p><ul><li>根据上下内容的相关程度，合理安排空行</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不适用连续三个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但<code>namespace</code>的大括号内不做要求</li></ul><h3 id="5-2-1-尽量避免使用前置声明"><a href="#5-2-1-尽量避免使用前置声明" class="headerlink" title="5.2.1 尽量避免使用前置声明"></a>5.2.1 尽量避免使用前置声明</h3><h3 id="6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"><a href="#6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰" class="headerlink" title="6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"></a>6.1.1 对于<code>cpp</code>文件中不需要导出的变量，常量或者函数，请使用匿名<code>namespace</code>封装或者用<code>static</code>修饰</h3><p>更加推荐使用匿名<code>namespace</code>：</p><ol><li><code>static</code>在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数， 静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li><code>static</code>只能保证变量，常量和函数的文件作用域，但是<code>namespace</code>还可以封装类型等。</li><li>统一<code>namespace</code>来处理C++的作用域，而不需要同时使用<code>static</code>和<code>namespace</code>来管理</li><li><code>static</code>修饰的函数不能用来实例化模板，而匿名<code>namespace</code>可以</li></ol><p>注意： 不要<code>.h</code>中使用匿名<code>namespace</code>或者<code>static</code></p><h3 id="6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"><a href="#6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数" class="headerlink" title="6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"></a>6.2.1 优先使用命名空间来管理全局函数，如果和某个<code>class</code>有直接关系的，可以使用静态成员函数</h3><p>非成员函数放在名字控件内可避免污染全局作用域，也不要用类+静态成员方法来简单管理全局函数。如果某个全局函数和某个类有紧密联系，那么可以作为类的静态成员函数。<br>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><h3 id="6-4-1-尽量避免使用全局变量，考虑使用单例模式"><a href="#6-4-1-尽量避免使用全局变量，考虑使用单例模式" class="headerlink" title="6.4.1 尽量避免使用全局变量，考虑使用单例模式"></a>6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><h3 id="8-3-1-函数参数使用引用代替指针"><a href="#8-3-1-函数参数使用引用代替指针" class="headerlink" title="8.3.1 函数参数使用引用代替指针"></a>8.3.1 函数参数使用引用代替指针</h3><p>引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。</p><h3 id="8-3-2-使用强类型参数，避免使用void"><a href="#8-3-2-使用强类型参数，避免使用void" class="headerlink" title="8.3.2 使用强类型参数，避免使用void*"></a>8.3.2 使用强类型参数，避免使用void*</h3><p>一般认为<code>C/C++</code>是强类型语言，既然我们使用的是强类型语言，就应该保持这样的风格。好处是尽量让编译器在编译阶段就检查出类型不匹配的问题。</p><h3 id="8-3-3-函数的参数个数不超过5个"><a href="#8-3-3-函数的参数个数不超过5个" class="headerlink" title="8.3.3 函数的参数个数不超过5个"></a>8.3.3 函数的参数个数不超过5个</h3><p>函数的参数过多，会使得该函数易于受外部变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。<br>如果超过可以考虑</p><ul><li>看能否拆分函数</li><li>看能否将相关参数合在一起，定义结构体</li></ul><h3 id="9-1-1-一组相关的整型变量应定义未枚举。"><a href="#9-1-1-一组相关的整型变量应定义未枚举。" class="headerlink" title="9.1.1 一组相关的整型变量应定义未枚举。"></a>9.1.1 一组相关的整型变量应定义未枚举。</h3><p>枚举比<code>#define</code>或<code>const int</code>更安全。编译器会检查参数值是否位于枚举取值范围内，避免错误发生。</p><h3 id="9-1-2-变量使用时才声明并初始化"><a href="#9-1-2-变量使用时才声明并初始化" class="headerlink" title="9.1.2 变量使用时才声明并初始化"></a>9.1.2 变量使用时才声明并初始化</h3><p>变量在使用前未赋初值，是常见的低级编程错误。使用前才声明变量并初始化，非常方便地避免了此类低级错误。<br>在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：</p><ul><li>程序难以理解与维护： 变量定义与使用分离</li><li>变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值（0）来初始化。如果变量在被赋予有效值以前使用，还会导致错误。</li></ul><p>遵循变量作用域最小化原则与就近声明原则，使得代码更容易阅读，方便了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string name;   <span class="comment">///&lt; Bad</span></span><br><span class="line">name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>)</span></span>;   <span class="comment">///&lt; Good</span></span><br></pre></td></tr></table></figure><h3 id="9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"><a href="#9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则" class="headerlink" title="9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"></a>9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则</h3><p>当变量与常量进行比较时，如果常量放左边， 如<code>if(MAX == v)</code>不符合阅读习惯，而<code>if(MAX &gt; v)</code>更难以理解，应当按人的正常阅读、表达习惯，将常量放右边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value &lt; MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有特殊情况， 如： <code>if(MIN &lt; value &amp;&amp; value &lt; MAX)</code>用来描述区间时，前半段是常量在左的。<br>不用担心将<code>==</code>误写成<code>=</code>, 因为<code>if(value = MAX)</code>会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><h3 id="9-2-2-使用括号明确操作符的优先级"><a href="#9-2-2-使用括号明确操作符的优先级" class="headerlink" title="9.2.2 使用括号明确操作符的优先级"></a>9.2.2 使用括号明确操作符的优先级</h3><p>使用括号明确操作符的优先级，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b + ; <span class="comment">///&lt; 操作符相同,可以不加括号</span></span><br><span class="line">x = <span class="number">1</span> &lt;&lt; (<span class="number">2</span> + <span class="number">3</span>);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br><span class="line">x = (a == b) ? a : (a - b);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br></pre></td></tr></table></figure><h3 id="9-3-1-避免使用dynamic-cast"><a href="#9-3-1-避免使用dynamic-cast" class="headerlink" title="9.3.1 避免使用dynamic_cast"></a>9.3.1 避免使用<code>dynamic_cast</code></h3><ol><li><code>dynamic_cast</code>依赖于C++的<code>RTTI</code>, 让程序员在运行时识别C++类对象的类型</li><li><code>dynamic_cast</code>的出现一般说明我们的基类和派生类设计出现了问题，派生类破坏了基类的七月，不得不通过</li><li><code>dynamic_cast</code>转换到子类进行特殊处理，这个时候更希望来改善类的设计，而不是通过<code>dynamic_cast</code>来解决问题</li></ol><h3 id="9-3-2-避免使用reinterpret-cast"><a href="#9-3-2-避免使用reinterpret-cast" class="headerlink" title="9.3.2 避免使用reinterpret_cast"></a>9.3.2 避免使用<code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code>用于转换不相关类型。尝试用<code>reinterpret_cast</code>将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。</p><h3 id="9-3-3-避免使用const-cast"><a href="#9-3-3-避免使用const-cast" class="headerlink" title="9.3.3 避免使用const_cast"></a>9.3.3 避免使用<code>const_cast</code></h3><p><code>cosnt_cast</code>用于移除对象的<code>const</code>和<code>volatile</code>性质。<br>使用<code>const_cast</code>转换后的指针或者引用来修改<code>const</code>对象，行为是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不好的例子</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i);</span><br><span class="line">*p = <span class="number">2048</span>;  <span class="comment">///&lt; 未定义行为</span></span><br></pre></td></tr></table></figure><h3 id="9-4-1-使用RAII特性来帮助跟踪动态分配"><a href="#9-4-1-使用RAII特性来帮助跟踪动态分配" class="headerlink" title="9.4.1 使用RAII特性来帮助跟踪动态分配"></a>9.4.1 使用<code>RAII</code>特性来帮助跟踪动态分配</h3><p><code>RAII</code>是”资源获取就是初始化”的简写(Resource Acquisition Is Initialization), 是一种利用对象生命周期来控制程序资源(如内存、文件句柄、网络连接、互斥量等等)的简单技术。<br><code>RAII</code>的一般做法是这样的： 在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内之中有效，最后在对象析构的时候释放资源，这种做法有两大好处:</p><ul><li>我们不需要显式地释放资源</li><li>对象所需的资源在其生命期内始终有效。这样，就不必检查资源有效性问题，可以简化逻辑、提高效率。</li></ul><h3 id="9-5-1-使用std-string代替char"><a href="#9-5-1-使用std-string代替char" class="headerlink" title="9.5.1 使用std::string代替char*"></a>9.5.1 使用<code>std::string</code>代替<code>char*</code></h3><p>说明: 使用<code>string</code>代替<code>char*</code>有很多优势，比如:</p><ol><li>不用考虑结尾的<code>&#39;\0&#39;</code></li><li>可以直接使用<code>+</code>, <code>=</code>, <code>==</code>等运算符以及其他字符串操作函数</li><li>不需要考虑内存分配操作，避免了显式的<code>new</code>、<code>delete</code>, 以及由此导致的错误</li></ol><p>需要注意的是</p><h3 id="9-5-2-使用新的标准头文件"><a href="#9-5-2-使用新的标准头文件" class="headerlink" title="9.5.2 使用新的标准头文件"></a>9.5.2 使用新的标准头文件</h3><p>使用C++的标准头文件时，请使用<code>&lt;cstdlib&gt;</code>这样的，而不是<code>&lt;stdlib.h&gt;</code></p><h3 id="9-6-1-初始化后不会再修改的成员变量定义为const"><a href="#9-6-1-初始化后不会再修改的成员变量定义为const" class="headerlink" title="9.6.1 初始化后不会再修改的成员变量定义为const"></a>9.6.1 初始化后不会再修改的成员变量定义为<code>const</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> length): <span class="built_in">dataLength_</span>(length)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dataLength_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现代C-since-C-11"><a href="#现代C-since-C-11" class="headerlink" title="现代C++(since C++11)"></a>现代C++(since C++11)</h2><h2 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h2><h3 id="10-1-1-在重写虚函数时请使用override或final关键字"><a href="#10-1-1-在重写虚函数时请使用override或final关键字" class="headerlink" title="10.1.1 在重写虚函数时请使用override或final关键字"></a>10.1.1 在重写虚函数时请使用<code>override</code>或<code>final</code>关键字</h3><p><code>override</code>和<code>final</code>关键字都能保证函数是虚函数，且重写了基类的虚函数。如果子类函数与基类函数圆形不一致，则产生编译错误。<code>final</code>还保证u函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>还保证虚函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现，也可以避免有多个子类时，重写虚函数的修改遗漏。</p><h3 id="10-1-2-使用delete关键字删除函数"><a href="#10-1-2-使用delete关键字删除函数" class="headerlink" title="10.1.2 使用delete关键字删除函数"></a>10.1.2 使用<code>delete</code>关键字删除函数</h3><p>相比于将类成员函数声明为<code>private</code>但不实现， <code>delete</code>关键字更明确，且适用范围更广。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    <span class="comment">///&lt; 只看头文件不知道拷贝构造函数是否被删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 明确删除拷贝赋值符</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，<code>delete</code>关键字还支持删除非成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> Process&lt;<span class="type">void</span>&gt; </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="10-1-3-使用nullptr-而不是NULL或0"><a href="#10-1-3-使用nullptr-而不是NULL或0" class="headerlink" title="10.1.3 使用nullptr, 而不是NULL或0"></a>10.1.3 使用<code>nullptr</code>, 而不是<code>NULL</code>或<code>0</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;   <span class="comment">///&lt; 错误: void* 不能自动转为 char*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span>(C::pmf)() = &amp;C::Func;</span><br><span class="line"><span class="keyword">if</span>(pmf == <span class="literal">NULL</span>) &#123;&#125; <span class="comment">///&lt; 错误： void* 不能自动转换为指向成员函数的指针</span></span><br></pre></td></tr></table></figure><p>如果把<code>NULL</code>定义为<code>0</code>, 或者在需要空指针的地方直接使用<code>0</code>。这样引入了另外的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 无法判断返回的是整数还是空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载也会出现重载的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用F(int)， 而不是F(int*)</span></span><br></pre></td></tr></table></figure><p>另外<code>sizeof(NULL) == sizeof(void*)</code>并不总是成立的。</p><p><code>nullptr</code>的又是不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。<br><code>nullptr</code>是<code>std::nullptr_t</code>类型， 而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 调用F(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 正确的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h2><h3 id="10-1-1-合理使用auto"><a href="#10-1-1-合理使用auto" class="headerlink" title="10.1.1 合理使用auto"></a>10.1.1 合理使用<code>auto</code></h3><ul><li><code>auto</code>可以避免编写冗长、重复的类型名，也可以保证定义变量时初始化</li><li><code>auto</code>类型推导规则复杂，需要仔细理解</li><li>如果能够使代码更清晰，继续使用明确的类型，且旨在局部变量使用<code>auto</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 避免冗长的类型名</span></span><br><span class="line">std::map&lt;std::string, std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 保证初始化</span></span><br><span class="line"><span class="type">int</span> x;  <span class="comment">///&lt; 编译正确，没有初始化</span></span><br><span class="line"><span class="keyword">auto</span> x; <span class="comment">///&lt; 编译失败，没有初始化</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于对象的复制</title>
      <link href="/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>通常我们使用对象内的拷贝构造函数和拷贝构造符来进行初始化和拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        i = other.i;</span><br><span class="line">        vec = other.vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝赋值符</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            i = other.i;</span><br><span class="line">            vec = other.vec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A foo;</span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">(foo)</span></span>; <span class="comment">///&lt; 在这里调用拷贝构造函数</span></span><br><span class="line">A bar2;</span><br><span class="line">bar2 = foo; <span class="comment">///&lt; 这里调用拷贝赋值符</span></span><br></pre></td></tr></table></figure><h2 id="关于memset"><a href="#关于memset" class="headerlink" title="关于memset"></a>关于memset</h2><p>首先说结论，不推荐使用<code>memset</code>对某个对象进行擦写内存。因为可能导致未定义行为。<br>具体可以查看<code>stackflow</code>上的这个问题 <a href="https://stackoverflow.com/questions/2481654/memset-for-initialization-in-c">memset for initialization in C++</a>和<a href="https://stackoverflow.com/questions/6421818/c-use-memset-or-a-struct-constructor-whats-the-fastest">Use memset or a struct constructor? What’s the fastest?</a></p><p>你可以使用构造函数进行初始化，也可以定义成员函数<code>clear()</code>， 或是使用<code>std::fill</code>, <code>std::fill_n</code>。<br>在使用函数<code>memset</code>时，有部分限定条件，只有目标对象为POD类型才可以使用。</p><p>简单来说就是，该对象如果没有继承，都是基础类型(如: <code>int</code>、<code>char</code>或其他<code>POD</code>类型), 没有包含如<code>std::array</code>, <code>std::vector</code>等STL容器, 该对象可以称为<code>POD</code>类型。如下面示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pod</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">12</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>POD</code>具体查看<a href="https://en.cppreference.com/w/cpp/named_req/PODType">C++ named requirements: PODType</a></p><h2 id="关于memcpy"><a href="#关于memcpy" class="headerlink" title="关于memcpy"></a>关于memcpy</h2><p>结论是，不推荐使用，同样除了你能确保该对象为<code>POD</code>类型，否则则会导致未定义现象。<br>可以使用拷贝构造函数或拷贝赋值符，或是<code>std::copy</code>或<code>std::copy_n</code>来代替<code>memcpy</code>;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《代码大全》</title>
      <link href="/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="强制类型转换的应用"><a href="#强制类型转换的应用" class="headerlink" title="强制类型转换的应用"></a>强制类型转换的应用</h2><h2 id="C语言中void-可以转换为任意指针"><a href="#C语言中void-可以转换为任意指针" class="headerlink" title="C语言中void* 可以转换为任意指针"></a>C语言中void* 可以转换为任意指针</h2><p>size_t 到 unsigned</p><p>变量初始化</p><ul><li>从未对变量赋值。它的值只是程序启动时变量所处内存区域的值</li><li>变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效</li><li>变量的一部分被赋值，而另一部分没有</li></ul><h2 id="在声明变量的时候初始化"><a href="#在声明变量的时候初始化" class="headerlink" title="在声明变量的时候初始化"></a>在声明变量的时候初始化</h2><h2 id="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"><a href="#理想情况下，在靠近第一次使用变量的位置声明和定义该变量" class="headerlink" title="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"></a>理想情况下，在靠近第一次使用变量的位置声明和定义该变量</h2><ul><li>在有可能的情况下使用<code>const</code>， 定义常量，入参。</li><li>特别注意计数器和累加器，在下一次使用时忘记重置其值。</li><li>在类的构造函数中，初始化该类的数据成员</li><li>检查是否需要重新初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尽可能缩短变量存活时间"><a href="#尽可能缩短变量存活时间" class="headerlink" title="尽可能缩短变量存活时间"></a>尽可能缩短变量存活时间</h2><p>短的变量存活时间减少了初始化错误的可能。</p><p>变量存活时间短还会使代码具有可读性。阅读者同一时间内需要阅读的代码越少，越容易理解代码。</p><p>当需要把一个大的函数，拆分成几个小程序，短的存活时间方便拆分。</p><p>在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。</p><p>直到变量即将被使用时再为其赋值。</p><p>把相关语句放在一起。把相关语句提取成单独的子程序。</p><p>开始时采用最严格的可见性，然后根据扩展变量的作用域。比如，把一个循环内的变量挪到循环外的难度要比反过来难度低，或把一个<code>private</code>转变为<code>public</code>的难度远比反过来难度低。</p><p>避免采用硬编码，宏定义总是好于硬编码。</p><ul><li><code>TITLE_BAR_COLOR</code> 比 <code>0xFFFFFF</code> 更能反应出所代表的信息</li><li>同时，也方便修改宏定义时，同时改变所有的颜色的RGB值</li></ul><h2 id="为变量指定单一用途"><a href="#为变量指定单一用途" class="headerlink" title="为变量指定单一用途"></a>为变量指定单一用途</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + temp) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - temp) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">temp = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discriminant = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + discriminant) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - discriminant) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">oldRoot = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = oldRoot;</span><br></pre></td></tr></table></figure><p>避免让代码具有隐含含义，把同一变量用于多个多个用途的另外一种方式是当变量代表不同事务时让其具有不同的取值集合。</p><ul><li>变量<code>count</code>的取值可能表示某个计数，除非他等于<code>-1</code>，在这种情况下表明有错误发生</li><li>变量<code>customerId</code>可能代表某个客户账号，除非他的取值大于50000，在这种情况下，你通过减去50000来得到过期账号。</li><li>变量<code>bytesWritten</code>可能表示写入输出文件的字节数，除非它的取值为负，在这种情况下他表示的是用于输出磁盘驱动器的号码。</li></ul><h2 id="变量名的注意事项"><a href="#变量名的注意事项" class="headerlink" title="变量名的注意事项"></a>变量名的注意事项</h2><p>糟糕的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x - xx;</span><br><span class="line">xxx = fido + <span class="built_in">SalesTax</span>(fido);</span><br><span class="line">x = x + <span class="built_in">LateFee</span>(x1, x) + xxx;</span><br><span class="line">x = x + <span class="built_in">Interest</span>(x1, x);</span><br></pre></td></tr></table></figure><p>良好的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">balance = balance - lastPayment;</span><br><span class="line">monthlyTotal = newPurchases + <span class="built_in">SalesTax</span>(newPurchases);</span><br><span class="line">balance = balance + <span class="built_in">LateFee</span>(customerID, balance) + monthlyTotal;</span><br><span class="line">balance = balance + <span class="built_in">Interest</span>(customerID, balance);</span><br></pre></td></tr></table></figure><p>为变量命名时最重要的考虑事项时，改名字要完全、准确地描述该变量所代表的事物<br>不包含晦涩的缩写，同时也没有歧义。<br>对于一个表示中国奥林匹克代表团成员数量的变量，你可能会使用<code>NumberOfPeopleOnTheChineseOlympicTeam</code><br>表示当前利率的变量最好为<code>rate</code>而不是<code>r</code>.</p><p>变量名太长: <code>numberOfPeopleOnTheChineseOlympicTeam</code>,<code>numberOfSeatsInTheStadium</code>, <code>maximumNumberOfPointsInModernOlympics</code><br>变量名太短: <code>n</code>, <code>np</code>, <code>ntm</code>, <code>ms</code>, <code>nsisd</code>, <code>m</code>, <code>max</code>, <code>min</code><br>变量名正好： <code>numTeamMembers</code>, <code>teamMemberCount</code>, <code>numSeatsInStadium</code>, <code>seatCount</code>, <code>teamPointsMax</code>, <code>pointSRecord</code></p><p>很多程序有表示计算机结果的变量：总额、平均值、最大值，等等。如果你要用类似于<code>Total</code>、<code>Sum</code>、<code>Average</code>、<code>Max</code>、<code>Min</code>、<code>Record</code>这样的限定词，那么请一定记住把限定词加到名字最后。<br>变量名中最重要的部分应该被放置在最前面，限定词在最后。<br>这样做会避免，<code>totalRevenue</code>和<code>revenueTotal</code>异议词语</p><p>为状态变量起一个比<code>flag</code>更好的名字。最好把标记<code>flag</code>看作状态变量，标记的名字中不应该含有<code>flag</code>，因为你从中丝毫看不出该标记是做什么的。<br>含义模糊的标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) ...</span><br><span class="line"><span class="keyword">if</span> (statusFlag &amp; <span class="number">0xF</span>) ...</span><br><span class="line"><span class="keyword">if</span> (printFlag == <span class="number">16</span>) ...</span><br><span class="line"><span class="keyword">if</span> (computeFlag == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure><p>更好的状态变量命名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dataReady) ...</span><br><span class="line"><span class="keyword">if</span> (characterType &amp; PRINTABLE_CHAR) ...</span><br><span class="line"><span class="keyword">if</span> (reportType == ReportType_Annual) ...</span><br><span class="line"><span class="keyword">if</span> (recalcNeeded == <span class="literal">false</span>) ...</span><br></pre></td></tr></table></figure><p>为布尔变量命名</p><ul><li><code>done</code> 用<code>done</code>表示某件事情已经发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>error</code> 用<code>error</code>表示有错误发生。在错误发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>found</code> 用<code>found</code>来表明某个值已经找到了。在没有找到设为<code>false</code>, 找到后设为<code>true</code>.</li><li><code>success</code>和<code>ok</code>, 操作失败时设为<code>false</code>, 操作成功后设为<code>true</code></li></ul><p>给布尔变量赋予隐含“真、假”含义的名字: <code>status</code>和<code>sourceFile</code>是很糟糕的布尔变量名。<br>应该把<code>status</code>替换为类似<code>error</code>或者<code>statusOK</code>这样的名称，把<code>sourceFile</code>替换为<code>sourceFileAvailable</code>、<code>sourceFileFound</code></p><p>使用肯定的布尔变量名，否定的布尔名如<code>notFound</code>、<code>notDone</code>以及<code>notSuccessful</code>比较难阅读。使用肯定的语义避免双重否定带来的阅读难度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnsiString strTmp;</span><br><span class="line">strTmp = edtAccount-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Account = strTmp;</span><br><span class="line">&#125;</span><br><span class="line">strTmp = edtPassword-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Password = strTmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩写的一般指导原则：</p><ul><li>使用标准的缩写(列在字典中的那些常见缩写)</li><li>去掉虚词<code>and</code>, <code>or</code>, <code>the</code>等</li><li>去掉无用的后缀<code>ing</code>, <code>end</code></li><li>确保不要改变变量的含义</li><li>反复使用上述技术，知道你把每个变量名的长度缩减到了8到20个字符，或者达到你所用的编程语言对变量名的限制字符数。</li></ul><h2 id="不要用每个单词中删除一个字符的方式来缩写"><a href="#不要用每个单词中删除一个字符的方式来缩写" class="headerlink" title="不要用每个单词中删除一个字符的方式来缩写"></a>不要用每个单词中删除一个字符的方式来缩写</h2><p>键入一个字符算不上是什么额外工作，而节省一个字符带来的便利却很难抵消由此而造成的可读性的损失。</p><h2 id="缩写要一致"><a href="#缩写要一致" class="headerlink" title="缩写要一致"></a>缩写要一致</h2><p>应该一直使用相同的缩写。要么全用<code>Num</code>，要么全用<code>No</code>，也不要有些地方使用全写<code>Number</code>, 同时在其他地方使用缩写<code>Num</code></p><h2 id="创建你能读出来的名字"><a href="#创建你能读出来的名字" class="headerlink" title="创建你能读出来的名字"></a>创建你能读出来的名字</h2><p>使用<code>xPos</code>而不是<code>xPstn</code>, 用<code>needsCompu</code>而不用<code>ndsCmptg</code>。这里可以使用电话沟通，如果你无法向他人读出你的代码，就请重新给变量起一个更清晰的名字。</p><h2 id="名字对于代码的读者的意义要比对作者更重要"><a href="#名字对于代码的读者的意义要比对作者更重要" class="headerlink" title="名字对于代码的读者的意义要比对作者更重要"></a>名字对于代码的读者的意义要比对作者更重要</h2><h2 id="避免使用令人误解的名字或缩写"><a href="#避免使用令人误解的名字或缩写" class="headerlink" title="避免使用令人误解的名字或缩写"></a>避免使用令人误解的名字或缩写</h2><p>要确保名字的含义是明确的</p><h2 id="避免使用具有相似含义的名字"><a href="#避免使用具有相似含义的名字" class="headerlink" title="避免使用具有相似含义的名字"></a>避免使用具有相似含义的名字</h2><p>如果你能够交换两个变量的名字而不会妨碍对程序的理解，那么你就需要为这两个变量重新命名了。</p><h2 id="避免在名字中使用数字"><a href="#避免在名字中使用数字" class="headerlink" title="避免在名字中使用数字"></a>避免在名字中使用数字</h2><p>如果名字中的数字真的非常重要，就请使用数组来代替一组单个的变量。如果数组不合适，那么数字就更不合适。</p><h2 id="避免在名字中拼错单词"><a href="#避免在名字中拼错单词" class="headerlink" title="避免在名字中拼错单词"></a>避免在名字中拼错单词</h2><h2 id="避免在名字中使用容易混淆的字符"><a href="#避免在名字中使用容易混淆的字符" class="headerlink" title="避免在名字中使用容易混淆的字符"></a>避免在名字中使用容易混淆的字符</h2><ul><li>数字<code>1</code>和小写的<code>l</code></li><li>数字<code>1</code>和大写的<code>L</code></li><li>数字<code>0</code>和大写的<code>O</code></li><li>数字<code>2</code>和小写的<code>z</code></li><li>数字<code>6</code>和大写的<code>G</code></li></ul><h2 id="避免浮点数的数量级相差巨大的数字之间的四则运算"><a href="#避免浮点数的数量级相差巨大的数字之间的四则运算" class="headerlink" title="避免浮点数的数量级相差巨大的数字之间的四则运算"></a>避免浮点数的数量级相差巨大的数字之间的四则运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">100000000.0</span> + <span class="number">0.1</span>;</span><br><span class="line">    std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免浮点数的等量比较"><a href="#避免浮点数的等量比较" class="headerlink" title="避免浮点数的等量比较"></a>避免浮点数的等量比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp += <span class="number">0.1</span>;</span><br><span class="line">        std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">IncreaseA</span>() || !<span class="built_in">IncreaseB</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为空语句创建一个DoNothing-预处理宏或者内联函数"><a href="#为空语句创建一个DoNothing-预处理宏或者内联函数" class="headerlink" title="为空语句创建一个DoNothing()预处理宏或者内联函数"></a>为空语句创建一个DoNothing()预处理宏或者内联函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(recordArray.<span class="built_in">Read</span>(index++) != recordArray.<span class="built_in">EmptyRecord</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DoNothing()</span></span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoNothing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UML语法简介</title>
      <link href="/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example.png" alt="generalize_example"></p><p>eg：猫是一种动物；猫与动物之间为泛化关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example(2).png" alt="generalize_example(2)"></p><h2 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h2><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”猫”和”鸟”运动方式不同，它们的运动方式一个为走一个为飞，必须要在派生类”动物”中提供具体实现，那么”猫”和”鸟”对于基类动物来说为实现关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/realize_example.png" alt="realize_example"></p><h2 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h2><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/aggregation_example.png" alt="aggregation_example"></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，<strong>整体和部分不是强依赖的</strong>，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h2 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/composition_example.png" alt="composition_example"></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种<strong>强依赖的特殊聚合关系</strong>，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h2 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h2><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/association_example.png" alt="association_example"></p><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h2 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h2><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/dependency_example.png" alt="dependency_example"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ POD的介绍</title>
      <link href="/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="POD-plain-old-data-介绍"><a href="#POD-plain-old-data-介绍" class="headerlink" title="POD(plain old data)介绍"></a><code>POD</code>(<code>plain old data</code>)介绍</h2><h3 id="简旧类型-plain-old-data"><a href="#简旧类型-plain-old-data" class="headerlink" title="简旧类型(plain old data)"></a>简旧类型(<code>plain old data</code>)</h3><ul><li>一个标量类型(<code>scalar type</code>)</li><li>简旧类型(POD)数组</li><li>一个符合以下要求的<code>class</code>类型(<code>class</code> or <code>struct</code> or <code>union</code>)<ul><li>C++11以前:<ul><li>是一个聚合类型(<code>aggregate type</code>)</li><li>所有非静态成员都是简旧类型(<code>POD</code>)</li><li>没有成员是引用类型</li><li>没有用户定义的拷贝构造函数</li><li>没有用户定义的析构函数</li></ul></li><li>C++11以后<ul><li>是一个平凡类型(<code>trivial type</code>)</li><li>是一个标准布局类型</li><li>所有非静态成员是简旧类型(<code>POD</code>)</li></ul></li></ul></li></ul><h3 id="POD类型特别在哪里？"><a href="#POD类型特别在哪里？" class="headerlink" title="POD类型特别在哪里？"></a>POD类型特别在哪里？</h3><p><a href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special">What are Aggregates and PODs and how&#x2F;why are they special?</a></p><p>像<code>POD-classes</code>，<code>PD-unions</code>, <code>scalar type</code>和<code>数组</code>这样的类型被统一的叫做<code>POD-types</code>， <code>PODs</code>在很多地方都非常特别。下面一些例子。</p><ul><li><code>POD-classes</code>最接近C语言形式的结构体。不同的是，<code>PODs</code>可以有成员函数和任意静态成员，但他们两者都不能改变对象的内存排布。所以假如你想要写一个或多或少可移植型的可以被C语言甚至<code>.NET</code>使用的动态库，你应该尝试你所有导出的函数和返回值都是<code>POD-types</code>.</li><li>一个<code>non-POD</code>类类型对象的生存周期开始于当构造函数结束，结束于当析构函数结束。对于<code>POD</code>类型类，生命周期开始于内存空间被对象占用，结束于内存空间被释放或者被重用后。</li><li>对于<code>POD</code>类型的对象， 标准保证它当你使用<code>memcpy</code>对你对象中内容转化为<code>char</code>或<code>unsigned</code>数组时，然后<code>memcpy</code>这个内容回到你的对象内，这个对象将持有原始的值。请注意：对于<code>non-POD</code>类型对象没有这样的保证。下面的例子假设类型<code>T</code>是<code>POD</code>类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N sizeof(T)</span></span><br><span class="line"><span class="type">char</span> buf[N];</span><br><span class="line">T obj;  <span class="comment">///&lt; obj initialized to its original value</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;obj, N);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;obj, buf, N);</span><br><span class="line"><span class="comment">/// 保持它的原始值</span></span><br></pre></td></tr></table></figure><ul><li><code>goto</code>语句. 你可能知道，通过goto从一个一些变量还没有在这个作用域中定义的点跳转到一个已经定义的点是非法的（编译器会报错）。这个限制应用在只有当这个变量是一个<code>non-POD</code>类型。看下面例子中<code>f()</code>是语义错误, <code>g()</code>则符合语义。注意，微软编译器在这条规则上特别松散，它在这两个情况下只是抛出一个警告。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">NonPOD</span> &#123;<span class="built_in">NonPOD</span>()&#123;&#125;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  NonPOD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">POD</span>&#123;<span class="type">int</span> i; <span class="type">char</span> c;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  POD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它保证了在<code>POD</code>对象的开始处没有内存填充位。其他情况下，假如一个<code>POD-class： A</code>使一个类型<code>T</code>的第一个成员，你可以安全的使用<code>reinterpret_cast</code>从<code>A*</code>到<code>T*</code>然后获取指向第一个成员的指针，反之亦然。</li></ul><h3 id="补充定义"><a href="#补充定义" class="headerlink" title="补充定义"></a>补充定义</h3><h4 id="标量类型-scalar-type"><a href="#标量类型-scalar-type" class="headerlink" title="标量类型(scalar type)"></a>标量类型(<code>scalar type</code>)</h4><p><code>scalar type</code>是一个不是数组类型或<code>class</code>类型的(可能<code>const</code>或<code>volatile</code>限定的[^2])<code>object</code>类型.<br>英文原文[^1]</p><blockquote><p>scalar types are (possibly cv-qualified) object types that are not array types or class types</p></blockquote><h4 id="聚合类型-aggregate-type"><a href="#聚合类型-aggregate-type" class="headerlink" title="聚合类型(aggregate type)"></a>聚合类型(<code>aggregate type</code>)</h4><p>首先介绍一下<code>聚合类型</code>:<br>聚合类型是以下类型的其中一种[^3]:</p><ul><li>数组类型</li><li><code>class</code>类型(典型的例子, <code>struct</code>, <code>union</code>):<ul><li>没有<code>private</code>和<code>protected</code>非静态数据成员(到C++11)</li><li>没有用户定义的构造函数(显式的默认或删除的构造函数) (C++11起, 到C++17)</li><li>没有用户提供的继承的或显式的构造函数(显式的默认或删除的构造函数)(C++17起，到C++20)</li><li>没有用户定义的或继承的构造函数(C++20起)</li><li>没有基类(C++17之前)， 没有<code>virtual</code>,<code>private</code>,<code>protected</code>基类(C++17起)</li><li>没有虚成员函数</li><li>没有默认成员的初始化器(从C++11到C++14)</li></ul></li></ul><h4 id="平凡类型-TrivialType"><a href="#平凡类型-TrivialType" class="headerlink" title="平凡类型 (TrivialType)"></a>平凡类型 (<code>TrivialType</code>)</h4><p>要求[^4]:</p><ul><li>可平凡复制(<code>TrivialCopyable</code>)</li><li>若该类型是类类型或其数组，则该类拥有一个或多个合格的默认构造函数，均为平凡的</li></ul><h4 id="可平凡可复制-Trivially-Copyable"><a href="#可平凡可复制-Trivially-Copyable" class="headerlink" title="可平凡可复制(Trivially Copyable)"></a>可平凡可复制(<code>Trivially Copyable</code>)</h4><p>下面列举的类型称作平凡可复制类型[^5]:</p><ul><li>标量类型</li><li>平凡可复制的类<ul><li>至少有一个拷贝构造函数，移动构造函数，拷贝赋值符是符合要求的</li><li>每个合格的拷贝构造函数(假如有的话)是平凡的</li><li>每个合格的移动构造函数(假如有的话)是平凡的</li><li>每个合格的拷贝赋值符(假如有的话)是平凡的</li><li>每个合格的移动赋值符(假如有的话)是平凡的</li><li>有一个平凡的没有被删除的析构函数</li></ul></li><li>可平凡复制的数组类型<br>这意味着一个平凡可拷贝的<code>class</code>没有虚函数和虚基类函数。</li></ul><h3 id="参考文献和扩展阅读"><a href="#参考文献和扩展阅读" class="headerlink" title="参考文献和扩展阅读"></a>参考文献和扩展阅读</h3><p>[^1]:<a href="https://stackoverflow.com/questions/14821936/what-is-a-scalar-object-in-c">What is a scalar Object in C++?</a></p><p>[^2]:<a href="https://stackoverflow.com/questions/15413037/what-does-cv-unqualified-mean-in-c">What does “cv-unqualified” mean in C++?</a>, <a href="https://en.cppreference.com/w/cpp/language/cv">cv (const and volatile) type qualifiers</a></p><p>[^3]:<a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">C++ standard: aggregate type</a></p><p>[^4]:<a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">C++ standard: C++ named requirements: TrivialType</a></p><p>[^5]: <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">C++ standard: C++ named requirements: TriviallyCopyable</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 观察者设计模式</title>
      <link href="/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subscriber</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;subscriber&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">subscriber</span>(<span class="type">const</span> std::string&amp; user_name) : <span class="built_in">user_name_</span>(user_name) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; user_name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string user_name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">boardcast</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = it-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sp) &#123;</span><br><span class="line">        sp-&gt;<span class="built_in">callback</span>(message);</span><br><span class="line">        it++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">regist</span><span class="params">(std::weak_ptr&lt;subscriber&gt; wp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(wp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::weak_ptr&lt;subscriber&gt;&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ob = std::<span class="built_in">make_shared</span>&lt;observer&gt;();</span><br><span class="line">  <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber1&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp1-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber2&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp2-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp3 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber3&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp3-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    <span class="keyword">auto</span> sp4 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber4&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp4-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;start boardcast!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;boardcast again!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 指针与引用</title>
      <link href="/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
      <url>/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-指针与引用"><a href="#C-指针与引用" class="headerlink" title="C++指针与引用"></a>C++指针与引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>可以为空（万恶之首）</li><li>可以做指针的偏移操作</li><li>可以用做修改一个变量</li><li>可以用来用来快速传递一个对象，没有复制的成本(只有指针复制的成本)<br>见下面代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* i)</span> </span>&#123;</span><br><span class="line">  *i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">f1</span>(&amp;num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num为2</span></span><br><span class="line">  <span class="built_in">f2</span>(num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num仍为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>引用同指针一样可以直接修改对象本身，减少传递对象的复制成本</li><li>引用不可为空，即创建必须初始化</li><li>引用不能同指针一样，进行四则运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> &amp;r = i;</span><br><span class="line">  r = <span class="number">1</span>;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为1</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为1</span></span><br><span class="line">  <span class="built_in">f1</span>(r);</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为100</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可见<a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(2)</title>
      <link href="/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
      <url>/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="《Effective-Modern-C-》读书笔记-2"><a href="#《Effective-Modern-C-》读书笔记-2" class="headerlink" title="《Effective Modern C++》读书笔记(2)"></a>《Effective Modern C++》读书笔记(2)</h1><ol><li><p>裸指针在声明中并没有指出，裸指针指涉到的是单个对象还是一个数组。</p></li><li><p>裸指针在声明中也没有提示在使用完指涉到的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象。</p></li><li><p>即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用<code>delete</code>运算符，还是有其他用途。</p></li><li><p>即使知道了使用<code>delete</code>运算符，还是会发生到底应该用的那个对象形式（<code>delete</code>）还是数组形式（<code>delete[]</code>）。</p></li><li><p>即启用够确信，指针拥有其指涉对象，并且也确知应该如何析构，要保证析构在所有代码路径上都仅执行一次（包括那些异常导致的路径）仍然困难重重。只要少在一条路径上执行，就会导致资源泄露。而如果析构在一条路径上执行了多次，则会导致未定义行为。</p></li><li><p>没有什么正规的方式能检测出指针是否空悬，也就是说，它指涉的内存是否已经不再持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然指涉到它，就会产生空悬指针。</p></li></ol><p>在创建对象时注意区分<code>()</code>和<code>&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;  <span class="comment">///&lt; 调用默认构造函数</span></span><br><span class="line">Widget w2 = w1; <span class="comment">///&lt; 调用复制构造函数</span></span><br><span class="line">w1 = w2;  <span class="comment">///&lt; 赋值运算符</span></span><br></pre></td></tr></table></figure><p>大括号可以用来为非静态成员指定默认初始化值，却不能使用小括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 不可行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不可复制的对象可以采用大括号和小括号来进行初始化，却不能使用<code>=</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">///&lt; 不可行</span></span><br></pre></td></tr></table></figure><p>大括号适用所有场合。<br>大括号初始化有一项新特性，就是它禁止内建型别之间进行隐式窄化型别转换。而采用小括号和<code>=</code>的初始化则不会进行窄化型别转换检查，因为如果那样的化就会破坏太多的遗留代码了。</p><p>大括号初始化的另一项值得一提的特征是，它对于C++最令人苦恼之解析语法免疫。C++规定：任何能够解析为声明的都要解析为声明。本来想要以默认方式构造一个对象，结果却一不小心声明了一个函数。这个错误的根本原因构造函数调用语法。<br>当你想要以传参的方式调用构造函数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">///&lt; 调用Widget的构造函数，传入形参10</span></span><br></pre></td></tr></table></figure><p>但你如果试图用相同的语法构造一个没有形参的Widget的话，结果却变成了声明了一个函数而非对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;  <span class="comment">///&lt; 最令人苦恼之解析语法现身</span></span><br></pre></td></tr></table></figure><p>由于函数声明不能使用大括号来指定形参列表，所以使用大括号来完成对象的默认构造上面这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;  <span class="comment">///&lt; 调用没有形参的Widget构造函数</span></span><br></pre></td></tr></table></figure><p>大括号初始化的缺陷在于伴随它有时会出现的意外行为。这种行为源于大括号初始化物、<code>std::initializer_list</code>以及构造函数重载决议之间的纠结。</p><p>如果一个或多个构造函数声明了任何一个具备<code>std::initializer_list</code>型别的形参那么采用了大括号初始化语法的调用语句会强烈地优先选用带有<code>std::initializer_list</code>型别形参的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;  <span class="comment">///&lt; 调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;  <span class="comment">///&lt; 使用最后一个构造函数, 10, true 被强制转化为long double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你的确想要调用一个带有<code>std::initializer_list</code>型别形参的构造函数，并传入一个空的<code>std::initializer_list</code>的话，你可以通过把空大括号对作为构造函数实参的方式实现这个目的，即把一对空大括号放入一对小括号或大括号的方式来清楚地表明你传递地是什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;  <span class="comment">///&lt; 带有std::initializer_list型别形参地构造函数</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;  <span class="comment">///&lt; 同上</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有十个元素，每个元素值都为20的vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有两个元素，值分别为10、20 的vector</span></span><br></pre></td></tr></table></figure><p><code>std::make_unique</code>和<code>std::make_shared</code>在函数内部使用的小括号，作为其接口的一部分。</p><ul><li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫</li><li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有<code>std::initializer_list</code>型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个<code>std::vector&lt;数值型别&gt;</code>对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li></ul><h2 id="理解特种成员函数的生成机制"><a href="#理解特种成员函数的生成机制" class="headerlink" title="理解特种成员函数的生成机制"></a>理解特种成员函数的生成机制</h2><p>两种复制操作是彼此独立的：声明了其中一个，并不会阻止编译器生成另外一个。如果你生成了一个复制构造函数，同时未声明复制赋值运算符，并撰写了要求复制赋值的代码，则编译器会为你生成复制赋值运算符。反过来一样。</p><p>两种移动操作并不彼此独立：声明了其中一个就会阻止编译器生成另外一个。假设你声明了一个移动构造函数，你实际上表明了移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。综上声明一个移动构造函数会阻止编译器去生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器去生成移动构造函数。</p><p>一旦显式声明了赋值操作，这个类也就不再会生成移动操作了。依据在于，声明复制操作的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。从而判定既然按成员复制不适用于赋值操作，则按成员移动极有可能也不适用于移动操作。<br>一旦声明了移动操作，编译器就会删除复制操作。</p><p>三大律：如果你声明了复制构造函数、复制复制运算符，或析构函数中的任何一个，你就得同时声明所有这三个。<br>如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：1. 在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行。 2. 该类的析构函数也会参与到该资源的管理之中。</p><p>大三律的一个推论是，如果存在用户声明的析构函数，则平凡的按成员赋值也不适用于该类。如果声明了析构函数，则复制操作就不该被自动生成，因为他们呢的行为不可能正确。所以在C++11中：只要用户声明了析构函数，就不会生成移动操作。</p><p>移动操作的生成条件（如果需要生成）仅当以下三者同时成立：</p><ul><li>该类未声明任何复制操作</li><li>该类未声明任何移动操作</li><li>该类未声明任何析构操作</li></ul><p>总而言之， C++11中， 支配特种成员函数的机制如下：</p><ul><li>默认构造函数： 仅当类中不包含用户声明的构造函数时才生成</li><li>析构函数：与C++98中基本相同，唯一的区别在于析构函数默认为<code>noexcept</code>.仅当基类的析构函数为虚的，派生类析构函数才是虚的。</li><li>复制构造函数： 按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。</li><li>移动构造函数和移动赋值运算符<br>都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</li></ul><p>成员函数模板的存在会阻止编译器生成任何特种成员函数。</p><ul><li><p>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成</p></li><li><p>复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数时才生成，复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</p></li><li><p>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</p></li><li><p>auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别少打一些字</p></li><li><p>在模板推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</p></li><li><p>对万能引用形参进行推导时，左值实参会进行特殊处理。</p></li><li><p>对按值传递的形参进行推导时，若实参型别中带有<code>const</code>或<code>volatile</code>饰词，则它们还是会被当作不带<code>const</code>或<code>volatile</code>饰词的型别来处理。</p></li><li><p>在模板型别推导过程中， 数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</p></li><li><p>在一般情况下，auto型别推导和模板型推导是一模一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>, 但模板型别推导却不会。</p></li><li><p>在函数返回值或lambda式的形参中使用auto， 意思是使用模板型别推导而非auto型推导。</p></li><li><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的型别而不做任何修改</p></li><li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，<code>decltype</code>总是得出型别<code>T&amp;</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ nullptr与NULL</title>
      <link href="/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/"/>
      <url>/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/</url>
      
        <content type="html"><![CDATA[<h1 id="NULL与nullptr的区别"><a href="#NULL与nullptr的区别" class="headerlink" title="NULL与nullptr的区别"></a>NULL与nullptr的区别</h1><p>NULL为宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure><p>NULL的类型不明显，而一下情况会出现函数重载不明确的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用函数不确定，编译器警告或报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>nullptr</code>是一个特殊类型(<code>nullptr_t</code>)专门用来指代空指针。见下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;  <span class="comment">///&lt; #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125; <span class="comment">///&lt; #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 明确调用#2函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(1)</title>
      <link href="/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/"/>
      <url>/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/</url>
      
        <content type="html"><![CDATA[<h1 id="《Effective-Modern-C-》读书笔记-1"><a href="#《Effective-Modern-C-》读书笔记-1" class="headerlink" title="《Effective Modern C++》读书笔记(1)"></a>《Effective Modern C++》读书笔记(1)</h1><p>在运行期， <code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>(); <span class="comment">///&lt; 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; 非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span>  <span class="comment">///&lt; 右值引用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span> <span class="comment">///&lt; 非右值引用</span></span></span><br></pre></td></tr></table></figure><p><code>T&amp;&amp;</code>有两种不同的含义</p><ol><li>右值引用</li><li>表示既可以是右值引用也可以是左值引用</li></ol><p>万能引用会在两个地方现身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">///&lt; param是个万能引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; var2是个万能引用</span></span><br></pre></td></tr></table></figure><p>而不涉及型别推导<code>&amp;&amp;</code>就是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 不涉及型别推导</span></span><br></pre></td></tr></table></figure><p><code>const</code>关键字也可以确定<code>const T&amp;&amp;</code>是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>在一个模板中的<code>T&amp;&amp;</code>也不一定是万能引用， 见下面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为<code>push_back</code>是<code>vector</code>的成员函数， 如果<code>vector</code>实例存在的话就一定有确定的类型，所以并不存在型别推导。</p><p>另外，声明<code>auto&amp;&amp;</code>都是万能引用。</p><p>针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></p><p>当转发右值引用给其他函数是，应当对其实施向右值的无条件强制型别转换(通过<code>std::move</code>)，因为它们一定绑定到右值，而当转发万能引用时，应当对其实施向右值的有条件强制型别转换(通过<code>std::forward</code>), 因为它们不一定绑定到右值。<br>应当避免针对右值引用实施<code>std::forward</code>。而另一方面，针对万能引用使用<code>std::move</code>的想法更为糟糕，因为那样做的后果是某些左值会遭到意外改动(例如某些临时变量)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(newName);  <span class="comment">///&lt; 可以编译但糟糕透顶</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;  <span class="comment">///&lt; 工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>(); <span class="comment">///&lt; n是个局部变量</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">setName</span>(n); <span class="comment">///&lt; 将n移入了w</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">///&lt; n的值变得未知了</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ... <span class="comment">///&lt; 对w进行操作</span></span><br><span class="line">  <span class="keyword">return</span> w; <span class="comment">///&lt; 没有任何东西被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(w);  <span class="comment">///&lt; 将w移入返回值, 千万不要这么做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RVO</code>(return value optimization): 编译器若要在一个按值返回的函数里省略对局部对象的复制（或者移动）, 则需要满足两个前提条件： 1. 局部对象型别和函数返回值型别相同. 2. 返回的就是局部对象本身。即使实施<code>RVO</code>的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。当<code>RVO</code>的前提条件允许时，要么发生复制省略，要么<code>std::move</code>隐式地被实施于返回的局部对象。</p><ul><li>针对右值引用的最后一次使用实施<code>std::move</code>, 针对万能引用的最后一次使用实施<code>std::forward</code>。</li><li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行动。</li><li>若局部对象可能适用于返回值优化，则请勿针对其实施<code>std::move</code>或<code>std::forward</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::<span class="built_in">is_integral</span>&lt;T&gt;());  <span class="comment">///&lt; std::is_integral不够正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::is_integral&lt;&gt;</code>不够正确是因为如果传给万能引用<code>name</code>实参是个左值，那么<code>T</code>就会被推导为左值引用。因为<code>int&amp;</code>不是<code>int</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美转发的含义是我们不仅转发对象，还转发其显著特征：型别、左值还是右值，以及是否带有<code>const</code>和<code>volation</code>饰词等等。</p><p>大括号初始化物<br>假设<code>f</code>的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std:vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure><p>在此情况下，以大括号初始化物调用<code>f</code>可以通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>但如果把同一大括号初始化物的运用，就是一种完美转发失败的情形。编译器采用推导的手法来取得传递给<code>fwd</code>实参的型别结果，而后它会比较推导型别结果和<code>f</code>声明的形参型别。完美转发会在下面两个条件中的任何一个成立时失败：</p><ul><li>编译器无法为一个或多个<code>fwd</code>的形参推导出型别结果。编译器无法编译通过。</li><li>编译器为一个或多个<code>fwd</code>的形参推导出了”错误的”型别结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(Widget::MinVals); <span class="comment">///&lt; 没问题, 当f(28)处理</span></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals); <span class="comment">///&lt; 错误，无法链接</span></span><br></pre></td></tr></table></figure><p>无法链接的原因是，完美转发，转发的是入参(<code>Widget::MinVals</code>)的引用，而引用在编译器底层是指针实现的。由于<code>static</code>变量并没有被分配实际的地址，所以产生了链接错误。</p><p>完美转发的失败情形还包括：重载的函数名字和模板名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">///&lt; 一个接受函数指针入参的函数f</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 然后调用</span></span><br><span class="line"><span class="built_in">f</span>(processVal);</span><br></pre></td></tr></table></figure><p>上面在调用函数<code>f</code>的时候，其中<code>processVal</code>仅仅只是函数的名字，但编译器知道匹配的是单入参版本的函数。</p><p>而使用完美转发时，编译器是无法知道使用的是什么版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(processVal);  <span class="comment">///&lt; 编译不过</span></span><br></pre></td></tr></table></figure><p>最后一种完美转发失败的情形是位域被用作函数实参的时候。<br>标准中：非<code>const</code>引用不得绑定到位域。既然没有办法创建指涉到任意比特的指针(C++标准规定，可以指涉的最小实体是单个char)，那自然没有办法把引用绑定到任意比特上了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPV4Header</span> &#123;</span><br><span class="line">  std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">  IHL:<span class="number">4</span>,</span><br><span class="line">  DSCP:<span class="number">6</span>,</span><br><span class="line">  ECN:<span class="number">2</span>,</span><br><span class="line">  totalLength:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength); <span class="comment">///&lt; 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(h.totalLength); <span class="comment">///&lt; 错误！</span></span><br></pre></td></tr></table></figure><p>把位域传递给完美转发函数的关键，就是利用转发目的函数接收的总是位域值的副本这一事实。可以自己复制一份，并以该副本调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"><span class="built_in">fwd</span>(length);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于数值极限</title>
      <link href="/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/"/>
      <url>/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="关于数值极限"><a href="#关于数值极限" class="headerlink" title="关于数值极限"></a>关于数值极限</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type\t\t\tlowest()\t\tmin()\t\t\tmax()\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned short\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h2><blockquote><p>在64位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/1592038101047.png" alt="1592038101047"></p></blockquote><p>换为2的幂级数表示为（64位系统下）：</p><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table><h2 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h2><blockquote><p>在32位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/Snipaste_2022-10-12_15-36-58.png" alt="1592038101047"></p></blockquote><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
