<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面对对象简介与 C++ 类的基本介绍</title>
      <link href="/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C-构造函数与析构函数"><a href="#C-构造函数与析构函数" class="headerlink" title="C++ 构造函数与析构函数"></a>C++ 构造函数与析构函数</h2><p>类的基本组合元素。<br>构造函数、析构函数、拷贝构造函数和拷贝复制符</p><p>构造函数在对象被创建的时候调用，如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;          <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">    A* p = <span class="keyword">new</span> A;   <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数在对象被销毁时刻调用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        A obj;</span><br><span class="line">    &#125;   <span class="comment">///&lt; 临时变量超出作用域，调用析构函数</span></span><br><span class="line"></span><br><span class="line">    A* p = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">///&lt; 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造与析构函数的具体讲解可见 <a href="https://mercy1101.github.io/C++-%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/">类内默认成员函数</a></p><h2 id="面对对象的简介"><a href="#面对对象的简介" class="headerlink" title="面对对象的简介"></a>面对对象的简介</h2><p>对象有三个特点: 封装、继承和多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>封装方法</li><li>聚合数据</li><li>隐藏细节</li></ul><h4 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h4><p>当我们在使用对象时，自然而然可以把一系列方法放在一个类内，就比如我们想要定义一系列读取 <code>Json</code> 字符串的方法。</p><p>下面是 <code>C 语言</code>的封装方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GJSON*  <span class="title">gos_json_init</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>    <span class="title">gos_json_free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span>    <span class="title">gos_json_parse</span><span class="params">(GJSON* Json, <span class="type">char</span> *szJson)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span>*   <span class="title">gos_json_get_string</span> <span class="params">(GJSON* Json, <span class="type">char</span> *szKey)</span></span>;</span><br></pre></td></tr></table></figure><p>我们推断使用顺序是:</p><ol><li>使用 <code>gos_json_init</code> 来获取一个可用的 <code>Json</code> 解析用的结构体, 其中存储了一些信息。</li><li>使用 <code>gos_json_parse</code> 来读取一系列 <code>Json</code> 字符串中的键值。</li><li>使用 <code>gos_json_get_string</code> 来通过键来获取值。</li><li>最后使用 <code>gos_json_free</code> 来释放资源。</li></ol><p>那么调用过程如以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GJSON* pJson = <span class="built_in">gos_json_init</span>();</span><br><span class="line">    <span class="built_in">gos_json_parse</span>(pJson, <span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = <span class="built_in">gos_json_get_string</span>(pJson, <span class="string">&quot;Key&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">gos_json_free</span>(pJson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比面对对象接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span> *szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上面所示: <code>C++</code>的接口</p><p>由于类内保存了一个 <code>GJSON</code> 的指针 <code>m_Json</code>, 所以接口函数不需要 <code>GJSON*</code> 的入参.<br>由于可以被调用的函数只有两个，那我们可以推测调用方法:</p><ol><li>使用 <code>parser</code> 接口函数解析 <code>json</code> 字符串</li><li>使用 <code>get_string</code> 接口函数来获取对应键的值</li></ol><p>调用如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Json obj;</span><br><span class="line">    obj.<span class="built_in">parser</span>(<span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = obj.<span class="built_in">get_string</span>(<span class="string">&quot;Key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的调用可以看到少了调用 <code>init</code> 和 <code>free</code> 两个函数的过程，因为 <code>class</code> 可以使用构造函数中初始化自己，在析构函数中做相反动作，我们下面补充构造函数和析构函数的定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Json = <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(m_Json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span>*szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">    <span class="function">GJSON* <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h4><p><code>class</code> 带来的好处是，类内不仅可以定义函数，也可以聚合成员，定义在一起方便查看与传递。</p><p>例如我们有一堆配置项数据需要保存。</p><p>C 语言可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="type">bool</span>     g_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 给变量赋值</span></span><br><span class="line">    g_ulLogLevel = <span class="number">1</span>;</span><br><span class="line">    g_bLogToStdout = TRUE;</span><br><span class="line">    g_bLogToFile = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他 cpp 文件中访问这些配置项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToFile;</span><br></pre></td></tr></table></figure><p>C++ 可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LocalCfg</span>() &#123; <span class="built_in">GetLogCfg</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> m_ulLogLevel;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToStdout;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他地方访问这些配置项</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogCfg obj;</span><br><span class="line"></span><br><span class="line">    obj.m_ulLogLevel;</span><br><span class="line">    obj.m_bLogToStdout;</span><br><span class="line">    obj.m_bLogToFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们经常在类中见到函数 <code>Get</code> 和 <code>Set</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; value = i; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们为什么要把一个简单的赋值操作封装成函数呢？</p><p>如果我们想要把变量的赋值与其他业务联动，见下面的例子:</p><ol><li>追踪赋值，添加打印</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;value: %d -&gt; %d&quot;</span>, value, i);</span><br><span class="line">        value = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加锁来支持多线程</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        value = i;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> value_temp = value;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> value_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    GMutex mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>业务联动绑定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = i;</span><br><span class="line">        IsSet = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (IsSet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 返回无效值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 用于记录 value 是否有效</span></span><br><span class="line">    <span class="type">bool</span> IsSet = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="隐藏细节"><a href="#隐藏细节" class="headerlink" title="隐藏细节"></a>隐藏细节</h4><p>见下面代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 把大象放进冰箱里</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PutElephantInFreezer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/// 打开冰箱门</span></span><br><span class="line">        <span class="built_in">OpenFreezerDoor</span>();</span><br><span class="line">        <span class="comment">/// 把大象放进去</span></span><br><span class="line">        <span class="built_in">LetElephantIn</span>();</span><br><span class="line">        <span class="comment">/// 关上冰箱门</span></span><br><span class="line">        <span class="built_in">CloseFreezerDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LetElephantIn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    <span class="comment">// 调用 public 函数来把大象放进冰箱里</span></span><br><span class="line">    obj.<span class="built_in">PutElephantInFreezer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍"><a href="#相关语法介绍" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="关于-public-与-private"><a href="#关于-public-与-private" class="headerlink" title="关于 public 与 private"></a>关于 <code>public</code> 与 <code>private</code></h5><p>关于关键字 <code>public</code> 和 <code>private</code>, <code>public</code> 类型的类内成员变量和函数，可以被类的实例调用而 <code>private</code> 不能。</p><p>实例化简单来说就是，把一个就是在代码中定义该对象。(如果把类的定义比作蛋糕模子，那么类的实例就是蛋糕)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OBJECT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象实例化</span></span><br><span class="line">    OBJECT obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例访问 public 类成员</span></span><br><span class="line">    obj.i_public = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例无法访问 private 成员</span></span><br><span class="line">    <span class="comment">// obj.i_private = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="友元函数介绍-friend-function"><a href="#友元函数介绍-friend-function" class="headerlink" title="友元函数介绍 (friend function)"></a>友元函数介绍 (<code>friend function</code>)</h5><p>对于私有变量和私有成员函数, 友元函数可以打破访问权限限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 友元函数不属于某个类，所以定义时</span></span><br><span class="line"><span class="comment">/// 不需要这样写:</span></span><br><span class="line"><span class="comment">/// void count::Set(counter&amp; obj, int num)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 友元函数内，对象实例访问对象私有成员</span></span><br><span class="line">    obj.i_private = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>友元函数本质是普通函数，友元只是描述的是对类的友元。</p></li><li><p>友元函数不属于类，是独立的函数，所以不受作用域描述符的限制。</p></li><li><p>友元函数本身可以同时成为多个类的友元函数。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obja.i_private = num;</span><br><span class="line">    objb.i_private = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj_a;</span><br><span class="line">    B obj_b;</span><br><span class="line">    <span class="built_in">Set</span>(obj_a, obj_b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类内-static-与对象之间的关系"><a href="#类内-static-与对象之间的关系" class="headerlink" title="类内 static 与对象之间的关系"></a>类内 <code>static</code> 与对象之间的关系</h5><p>在对象内的 <code>static</code> 变量和函数，与对象的生命周期无关，每一个对象的所有实例都共享同一个 <code>static</code> 变量和函数。</p><p>类内 <code>static</code> 函数对类内的静态成员函数、构造函数、析构函数和静态成员变量享有访问权限。</p><h6 id="类内静态变量"><a href="#类内静态变量" class="headerlink" title="类内静态变量"></a>类内静态变量</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">///&lt; 记录对象被实例化了多少次</span></span><br><span class="line">    <span class="built_in">A</span>()&#123;count++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    std::cout &lt;&lt; A::counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="类内静态成员函数"><a href="#类内静态成员函数" class="headerlink" title="类内静态成员函数"></a>类内静态成员函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCounter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_non_static = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun_non_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj0;</span><br><span class="line">    A obj1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, A::<span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">0.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">1.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示 类内静态成员函数是可以直接访问类内静态成员变量也可以调用类内静态成员函数<br>但不能调用类内非静态成员变量和函数, 如 <code>i_non_static</code>、 <code>fun_non_static</code></p><p>静态成员函数的使用限制，不能调用非 <code>static</code> 的类内成员函数和成员变量。</p><p>类内静态函数在单例模式中的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleon* pInstance = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pInstance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pInstance = <span class="keyword">new</span> Singleon;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleon</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承用来从基类中继承来函数或成员变量, 省却重复定义。</p><p>假如我们有很多呼叫相关的业务，都需要一个唯一的业务标识号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() : <span class="built_in">strBusinessID</span>(gos::<span class="built_in">GetUUID</span>()) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string strBusinessID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 点呼从基类中继承出来了一个业务 ID</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P2PCall</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P2PCall p2p_call;   <span class="comment">///&lt; 自动生成了一个唯一的业务号</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p2p_call.strBusinessID &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍-1"><a href="#相关语法介绍-1" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span>: <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">derive</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~derive&quot;</span> &lt;&lt; std::endl; &#125; <span class="comment">///&lt; 不定义虚析构函数会导致内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base* p = <span class="keyword">new</span> derive;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="protected-关键字"><a href="#protected-关键字" class="headerlink" title="protected 关键字"></a><code>protected</code> 关键字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_protected</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 可访问基类中的 protected 成员</span></span><br><span class="line">    <span class="keyword">return</span> i_protected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int get_private()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   基类中的 private 成员不能被派生类访问</span></span><br><span class="line">  <span class="comment">//   return i_private;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  base obj0;</span><br><span class="line">  <span class="comment">// 在基类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj0.i_protected = 0;</span></span><br><span class="line">  derive obj;</span><br><span class="line">  <span class="comment">// 在派生类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj.i_protected = 0;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>假设一个程序员又想拥有使用 <code>VSCode</code> 的能力 又想拥有使用 <code>source insight</code> 能力，<code>UML</code> 图如下</p><p><img src="/../resource/C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/multiple_inheritance.png" alt="multiple_inheritance"></p><p>写成代码为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseVSCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseSourceInsight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Programmer 拥有了 class VSCode 和</span></span><br><span class="line"><span class="comment">// class SourceInsight 中的方法函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">UseVSCode</span>();</span><br><span class="line">    lijiancong.<span class="built_in">UserSourceInsight</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个基类中拥有同名成员变量或函数，则派生类使用时应标注该成员变量或函数的作用域，避免产生编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果两个基类中拥有同名成员变量或函数，</span></span><br><span class="line">    <span class="comment">/// 派生类使用时应该标注哪个类的成员变量或函数， 否则编译错误</span></span><br><span class="line">    <span class="keyword">return</span> A::i_protected;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="使用-virtual-阻隔菱形继承"><a href="#使用-virtual-阻隔菱形继承" class="headerlink" title="使用 virtual 阻隔菱形继承"></a>使用 <code>virtual</code> 阻隔菱形继承</h5><p>我们在使用多重继承时，可能会出现如下的情况。</p><p>可能出现如下情况:</p><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5Cmultiple_inheritance2.png" alt="multiple_inheritance2"></p><p>菱形继承不仅会出现二义性成员变量名或函数名，而且在虚函数的继承中，中间类每一个类都会保存一个继承的副本，导致未知问题。使用 <code>virtual</code> 关键字避免菱形继承导致的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Tool</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Tool::i: &quot;</span> &lt;&lt; &amp;i</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VSCode</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;VSCode::i: &quot;</span> &lt;&lt; &amp;(VSCode::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SourceInsight</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SourceInsight::i: &quot;</span></span><br><span class="line">              &lt;&lt; &amp;(SourceInsight::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5CSnipaste_2021-10-23_14-41-51.png" alt="Snipaste_2021-10-23_14-41-51"></p><p>如上图， <code>VSCode</code> 和 <code>SourceInsight</code> 两个类都保存了一份基类 <code>Tool::i</code> 的副本, 造成了二义性。使用 <code>virtual</code> 来避免菱形继承带来的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">///&lt; 正常使用 Tool 类中的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述对象 <code>VSCode</code> 和 <code>SourceInsight</code> 没有使用关键字 <code>virtual</code> 来标注继承方式，那么 <code>Programmer</code> 类中正常使用 <code>Tool::i</code>。</p><h5 id="继承的方式与访问权限"><a href="#继承的方式与访问权限" class="headerlink" title="继承的方式与访问权限"></a>继承的方式与访问权限</h5><p><code>public</code>、<code>private</code>、<code>protected</code> 三种继承方式</p><p>见基类定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>public</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>public</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// public 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `public`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive obj;</span><br><span class="line">    obj.i_public = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;  不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>protected</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>protected</code> 继承与 <code>public</code> 继承相比， 区别在于 基类中 <code>public</code> 成员在 <code>protected</code> 继承后的派生类中降级为 <code>protected</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">protected</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `protected`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;</span><br><span class="line">    i_protected = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private</code> 继承：</p><ul><li>基类中 <code>public</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>private</code> 继承与 <code>public</code> 继承相比，区别在于基类中 <code>public</code> 成员和 <code>protected</code> 成员在 <code>private</code> 继承后的派生类中都降级为 <code>private</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">private</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `private`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `private`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// i_public = 0;</span></span><br><span class="line">    <span class="comment">/// i_protected = 0;</span></span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，什么类型的继承，在派生类中最高的类成员访问权限就降级为什么类型。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态用于接口与多态实现的分离</p><p>下面代码示例为多态在工厂模式中的应用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Interface* <span class="title">getInterface</span><span class="params">(<span class="type">bool</span> bIsUseMySQL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bIsUseMySQL)</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">MySqlImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">RedisImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Interface* p = factory.<span class="built_in">GetInterface</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 通过基类指针指向派生类</span></span><br><span class="line">    <span class="comment">// 调用基类中的虚函数，会通过编译器自动识别</span></span><br><span class="line">    <span class="comment">// 是使用 MySQL 的实现还是 Redis 的实现</span></span><br><span class="line">    p-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">    p-&gt;<span class="built_in">Query</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用多态进行了函数覆盖(<code>override</code>), 但是在基类和派生类中出现了同名但不同入参的函数名，则会发生函数隐藏(<code>hide</code>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">///  这里没有使用多态对基类中的 `Insert` 函数进行覆盖(override), 而是单独创建了一个新的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;RedisImpl::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Interface* pRedis = <span class="keyword">new</span> RedisImpl;</span><br><span class="line">  pRedis-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常使用多态，访问派生类的 `Insert` 函数的实现</span></span><br><span class="line"></span><br><span class="line">  Interface* pMySQL = <span class="keyword">new</span> MySqlImpl;</span><br><span class="line">  <span class="comment">/// pMySQL-&gt;Insert(&quot;Hello World!&quot;); 无法使用基类指针访问多态函数 `Insert`</span></span><br><span class="line">  pMySQL-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 只能访问基类 `Insert` 函数的实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用关键字 <code>override</code> 关键字避免因输入错误而导致函数覆盖不正确的现象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 由于 `override` 要求必须该函数对基类函数进行覆盖，这里由于入参不一致, 会出现编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>一个基类的虚函数，在不同派生类中实现，会产生多个虚函数表。</p><p>派生类的多个实例都会保存一个指针，该指针指向对应虚函数的实现（即对应的虚函数表）。</p><p>虚函数表中放入特定实现的函数指针，被调用时，通过函数指针来调用对应的汇编。</p><h4 id="类成员变量初始化顺序"><a href="#类成员变量初始化顺序" class="headerlink" title="类成员变量初始化顺序"></a>类成员变量初始化顺序</h4><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">a</span>(): <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">x</span>(y<span class="number">+1</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; obj.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出:<br>x: -858993459, y: 0</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 基本操作</title>
      <link href="/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>最简单的查询语句： 查询 <code>dcuser</code> 表中所有字段。</p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>以上语句在代码中禁止使用，因为在数据库扩展时，<code>SELECT *</code> 语句对应的结构体如果没有增加字段，则会出现未知错误。</p><h3 id="指定字段查询"><a href="#指定字段查询" class="headerlink" title="指定字段查询"></a>指定字段查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">UserID</th><th align="center">Name</th><th align="center">DCType</th><th align="center">DepotID</th></tr></thead><tbody><tr><td align="center">3000</td><td align="center">dis01</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3001</td><td align="center">dis02</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3002</td><td align="center">dis03</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3003</td><td align="center">dis04</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">9999</td><td align="center">test</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><h3 id="查询添加过滤条件"><a href="#查询添加过滤条件" class="headerlink" title="查询添加过滤条件"></a>查询添加过滤条件</h3><p>查询 <code>dcuser</code> 表中具有行车调度权限(<code>DCType = 1</code>)的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 为 <code>13003</code> 或 <code>13004</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="number">13003</span>, <span class="number">13004</span>);</span><br></pre></td></tr></table></figure><h4 id="BETWEEN-AND"><a href="#BETWEEN-AND" class="headerlink" title="BETWEEN AND"></a>BETWEEN AND</h4><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 介于 <code>13003</code> 到 <code>13005</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID BETWEEN <span class="number">13003</span> AND <span class="number">13005</span>;</span><br><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID &gt;= <span class="number">13003</span> AND DCUserID &lt;= <span class="number">13005</span>;</span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis</code> 开头的内容。 <code>%</code> 代替任意数量字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis%&#x27;</span></span><br></pre></td></tr></table></figure><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis0</code> + 任意一个字符的内容。 <code>_</code> 代替一个任意字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis0_&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h3><p>按时间降序查询 <code>groupcallinfo</code> 表中的数据。</p><p>升序(<code>ASC</code>): 数值小的记录在前。<br>降序(<code>DESC</code>): 数值大的记录在前。</p><p>如果不写关键字, 则默认使用 升序<code>ASC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>也可以使用多字段排序。 按照 <code>Time</code> 字段降序， <code>ASC</code> 字段升序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>, SeqID <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="查询总数量"><a href="#查询总数量" class="headerlink" title="查询总数量"></a>查询总数量</h3><p>查询 <code>dcuser</code> 表中有几个全功能调度员的账号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;记录数&#x27;</span> <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">65535</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">记录数</th></tr></thead><tbody><tr><td align="center">2</td></tr></tbody></table><h3 id="限制查询记录条数"><a href="#限制查询记录条数" class="headerlink" title="限制查询记录条数"></a>限制查询记录条数</h3><p>查询组呼记录，只显示100条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>查询组呼记录表中所有具有行车调度权限调度台处理的记录。</p><p>翻译为 <code>SQL</code> 语句:</p><p>查询 <code>groupcallinfo</code> 表中， <code>DCUserID</code> 等于 <code>dcuser</code> 表中 <code>DCType</code> 等于 <code>1</code> 记录的 <code>UserID</code> 字段的值</p><p>三句话等价:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> A.DCUserID, A.GroupID, A.Time, A.CallType <span class="keyword">FROM</span> groupcallinfo A <span class="keyword">WHERE</span> A.DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> B.UserID <span class="keyword">FROM</span> dcuser B <span class="keyword">WHERE</span> B.DCType <span class="operator">=</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> contacts <span class="keyword">WHERE</span> (surname, firstname) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> surname, firstname <span class="keyword">FROM</span> customer);</span><br></pre></td></tr></table></figure><h3 id="ALL-与-ANY-关键字"><a href="#ALL-与-ANY-关键字" class="headerlink" title="ALL 与 ANY 关键字:"></a>ALL 与 ANY 关键字:</h3><p>找出 class1 中比 class2 所有 source 都高的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> source <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> source <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><p>找出 class1 中 second_name 与 class2 中的重名的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> second_name <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> second_name <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><h3 id="查询最大、最小、平均值"><a href="#查询最大、最小、平均值" class="headerlink" title="查询最大、最小、平均值"></a>查询最大、最小、平均值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最大通话时长&#x27;</span>, <span class="built_in">MIN</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最小通话时长&#x27;</span>, <span class="built_in">AVG</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;平均通话时长&#x27;</span> <span class="keyword">FROM</span> trainposcallinfo;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">最大通话时长</th><th align="center">最小通话时长</th><th align="center">平均通话时长</th></tr></thead><tbody><tr><td align="center">48</td><td align="center">2</td><td align="center">14.667</td></tr></tbody></table><h3 id="查询数据分组"><a href="#查询数据分组" class="headerlink" title="查询数据分组"></a>查询数据分组</h3><p>统计不同的 <code>DCUserID</code> 都有多少条组呼记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr></tbody></table><h4 id="WITH-ROLLUP"><a href="#WITH-ROLLUP" class="headerlink" title="WITH ROLLUP"></a>WITH ROLLUP</h4><p><code>WITH ROLLUP</code> 用来在 <code>GROUP BY</code> 统计的基础上再加一行总数的统计行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr><tr><td align="center"></td><td align="center">859</td></tr></tbody></table><h4 id="HAVING-与-WHERE-区别"><a href="#HAVING-与-WHERE-区别" class="headerlink" title="HAVING 与 WHERE 区别"></a>HAVING 与 WHERE 区别</h4><p>having子句与where都是设定条件筛选的语句，有相似之处也有区别。</p><p>having与where的区别:<br>having是在分组后对数据进行过滤<br>where是在分组前对数据进行过滤<br>having后面可以使用聚合函数<br>where后面不可以使用聚合</p><p>在查询过程中执行顺序：from&gt;where&gt;group（含聚合）&gt;having&gt;order&gt;select。</p><p>所以聚合语句(sum,min,max,avg,count)要比having子句优先执行，而where子句在查询过程中执行优先级别优先于聚合语句(sum,min,max,avg,count)。<br>where子句：<br>select sum(num) as rmb from order where id&gt;10<br>&#x2F;&#x2F;只有先查询出id大于10的记录才能进行聚合语句</p><p><a href="https://blog.csdn.net/ryan007liu/article/details/91441479">Mysql中having和where的区别</a></p><h3 id="查询过滤重复数据"><a href="#查询过滤重复数据" class="headerlink" title="查询过滤重复数据"></a>查询过滤重复数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCType</th></tr></thead><tbody><tr><td align="center">65535</td></tr><tr><td align="center">2</td></tr></tbody></table><p>说明: <code>DISTINCT</code> 关键词修饰的是语句整体，不能对单独字段修饰，并查询其他字段内容。<br>如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType, UserID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>如上语句意义为查询 DCType 且 UserID 同时不重复的列。</p><p>输出:</p><table><thead><tr><th align="center">DCType</th><th align="center">UserID</th></tr></thead><tbody><tr><td align="center">65535</td><td align="center">3000</td></tr><tr><td align="center">65535</td><td align="center">3001</td></tr><tr><td align="center">65535</td><td align="center">3002</td></tr><tr><td align="center">65535</td><td align="center">3003</td></tr><tr><td align="center">2</td><td align="center">9999</td></tr></tbody></table><h3 id="替换特定字段查询结果"><a href="#替换特定字段查询结果" class="headerlink" title="替换特定字段查询结果"></a>替换特定字段查询结果</h3><p>查询 <code>dcuser</code> 表中所有数据， <code>DCType</code> 字段等于 <code>65535</code> 的显示全功能调度员, 等于 <code>1</code> 的显示行车调度员, 其他取值显示原本的值, 该字段结果显示为<code>调度员类型</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> DCType <span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span> &quot;全功能调度员&quot; <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> &quot;行车调度员&quot; <span class="keyword">ELSE</span> UserID <span class="keyword">END</span> <span class="keyword">AS</span> &quot;调度员类型&quot; <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>分段看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CASE</span> DCType</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;全功能调度员&quot;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;行车调度员&quot;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">UserID</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span> &quot;调度员类型&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">调度员类型</th></tr></thead><tbody><tr><td align="center">全功能调度员</td></tr><tr><td align="center">14004</td></tr><tr><td align="center">行车调度员</td></tr></tbody></table><p>关于 <code>CASE... WHEN...</code> 更多用法见下面链接</p><p><a href="https://zhuanlan.zhihu.com/p/63333847">SQL之CASE WHEN用法详解</a><br><a href="https://www.gairuo.com/p/sql-select-case-when-then">SQL 查询：SELECT CASE 条件赋值</a><br><a href="https://blog.csdn.net/qq_31071543/article/details/79666427">关于case when复杂sql语句查询</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><a href="https://blog.csdn.net/lxf512666/article/details/52812146">SQL SELECT(复杂查询)之 自连接 &amp; 子查询 解析</a><br><a href="https://www.cnblogs.com/Hadley-pu/p/sql_selfconnect.html">sql中自连接的使用</a><br><a href="https://zhuanlan.zhihu.com/p/110891010">010-MySQL：自连接查询</a><br><a href="https://cloud.tencent.com/developer/article/1665642">算法工程师-SQL进阶：神奇的自连接与子查询</a></p><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>改变 dcuser 表名称到 dcuser_new</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> dcuser <span class="keyword">TO</span> dcuser_new;</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>删除整个 dcuser 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> dcuser;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p>删除表信息的方式有两种 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> dcuser;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>注 : truncate操作中的table可以省略，delete操作中的*可以省略</p><p>truncate、delete 清空表数据的区别 :<br>1&gt; truncate 是整体删除 (速度较快)，delete是逐条删除 (速度较慢)<br>2&gt; truncate 不写服务器 log，delete 写服务器 log，也就是 truncate 效率比 delete高的原因<br>3&gt; truncate 不激活trigger (触发器)，但是会重置Identity (标识列、自增字段)，相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的 ID数。而 delete 删除以后，identity 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件</p><p>参考资料:<br><a href="https://blog.csdn.net/chenshun123/article/details/79676446">MySQL 清空表(truncate)与删除表中数据(delete) 详解</a></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> runoob_tbl <span class="keyword">SET</span> runoob_title<span class="operator">=</span><span class="string">&#x27;学习 C++&#x27;</span> <span class="keyword">WHERE</span> runoob_id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="过程、函数"><a href="#过程、函数" class="headerlink" title="过程、函数"></a>过程、函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span>  Create10K<span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `Create10K`(<span class="keyword">IN</span> `for_time` <span class="type">INT</span>, <span class="keyword">IN</span> `type_int` <span class="type">INT</span>, <span class="keyword">IN</span> `info_text` <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> for_time <span class="operator">*</span> <span class="number">10000</span> DO</span><br><span class="line">    <span class="keyword">INSERT INTO</span> test_table(Type, Info) <span class="keyword">VALUES</span>(type_int, info_text);</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> Create10K(<span class="number">500</span>, <span class="number">1</span>, &quot;1&quot;);</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/sunada2005/p/3411873.html">常用SQL查询语句</a></p><h3 id="插入主键重复的数据"><a href="#插入主键重复的数据" class="headerlink" title="插入主键重复的数据"></a>插入主键重复的数据</h3><p>插入 <code>dcuser</code> 表中一条数据，如果主键重复则更新原数据的 <code>StationList</code> 字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> dcuser(UserID, Name, DCType, DepotID, StationList) <span class="keyword">VALUES</span>(<span class="number">14005</span>, <span class="string">&#x27;14005&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, &quot;1,2,3,4&quot;) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> StationList <span class="operator">=</span> &quot;1,2,3,4&quot;;</span><br></pre></td></tr></table></figure><h3 id="按天查询数量"><a href="#按天查询数量" class="headerlink" title="按天查询数量"></a>按天查询数量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP(date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d 0:0:0&#x27;</span>)), <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> sds_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL 8.0 Reference Manual</a><br><a href="https://dev.mysql.com/doc/mysql-tutorial-excerpt/8.0/en/examples.html">Chapter 7 Examples of Common Queries</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html">13.2.9 REPLACE Statement</a></p><p>TODO: 合并查询、分页查询、空值判断、Contact 拼接查询结果、REPLACE INTO、多条插入、事务、存储过程、视图、批量插入、my.ini 的配置项的研究、中间表查询<br><a href="https://www.cnblogs.com/zengen/archive/2011/08/10/2133423.html">SQL中的循环、for循环、游标</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用场景</title>
      <link href="/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Git 使用场景</p><h2 id="场景：仓库中的临时文件"><a href="#场景：仓库中的临时文件" class="headerlink" title="场景：仓库中的临时文件"></a>场景：仓库中的临时文件</h2><p>我们编译出来了大量临时文件或很大的二进制文件，如 .o, .lib文件，这些文件不想上传。</p><p>提出问题： 想要在本文件夹中做版本控制，但需要忽略某些特定的文件</p><p>解决方案： 使用.gitignore文件来标记不想要进行版本控制的临时文件。</p><p>.gitignore 文件的用法:</p><p>.gitignore文件是由我们自己创建, 并默认放置在仓库的根目录。<br>Git 默认会忽略<code>.gitignore</code>中的文件名的大小写, 不过我们可以通过<code>git config core.ignorecase false</code>，来设置为不忽略大小写。</p><ol><li>文件内容格式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略.lib为后缀的文件</span></span><br><span class="line">*.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libmysql.lib 这个文件不忽略</span></span><br><span class="line">!libmysql.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的bin文件夹</span></span><br><span class="line">bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略根目录下的bin文件夹</span></span><br><span class="line">/bin/</span><br></pre></td></tr></table></figure><ol start="2"><li>已经被忽略的文件如何添加到暂存区: <code>git add -f &lt;filename&gt;</code></li><li>已经添加到暂存区中的文件如何忽略: <code>git rm --cached &lt;filename&gt;</code></li></ol><h2 id="场景-不小心提交了一个临时文件"><a href="#场景-不小心提交了一个临时文件" class="headerlink" title="场景: 不小心提交了一个临时文件"></a>场景: 不小心提交了一个临时文件</h2><p>我们对<strong>这个临时文件不想做版本跟踪</strong>，但是在<code>.gitignore</code>文件中添加该文件，这个文件仍然会被追踪。</p><p>提出问题: 如何忽略一个已经被追踪的文件?</p><p>解决方案：</p><ol><li><code>git rm filename</code>直接从仓库中删除该文件，并把该改动commit后，随后在<code>.gitignore</code>中添加该文件为忽略。</li><li><code>git update-index --assume-unchanged &lt;filename&gt;</code>, 这个操作不会删除该文件，也不用提交，但命令太长</li></ol><h2 id="场景-需要标记一个特定的版本"><a href="#场景-需要标记一个特定的版本" class="headerlink" title="场景: 需要标记一个特定的版本"></a>场景: 需要标记一个特定的版本</h2><p>当我们的代码进入到比较稳定，或者开发出了一个功能，需要标记一个commit来作为稳定版本的基准。</p><p>提出问题： 如何为commit添加标记和备注信息</p><p>解决方案： 使用<code>git tag</code>为版本打标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a vx.x.x -m &quot;message&quot;</span><br><span class="line">git push origin tags    ///&lt; 推送到远端</span><br></pre></td></tr></table></figure><h2 id="场景-修改远端标签名称"><a href="#场景-修改远端标签名称" class="headerlink" title="场景: 修改远端标签名称"></a>场景: 修改远端标签名称</h2><p>修改tag名 v1.0重命名v2.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag 新tag名称 旧tag名称</span><br><span class="line">git tag -d 旧tag名称</span><br><span class="line">git push origin :refs/tags/旧tag名称</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="场景：-开发一个功能"><a href="#场景：-开发一个功能" class="headerlink" title="场景： 开发一个功能"></a>场景： 开发一个功能</h2><p>某项功能可能开发时间较久，但又想把未完成的代码上传到远端版本库，来实现多台电脑同步。</p><p>例如：在开发随车通信需求时，在<code>linux</code>上编译<code>dis</code>，而我开发的环境在<code>windows</code>上, 当我在本地<code>window</code>开发的临时代码，想要放到<code>linux</code>机器上，这时我们需要分支来对代码的同步。</p><p>提出问题： 怎样才能在不影响远端仓库的代码的情况下，在远端备份开发过程代码？</p><p>解决方法： 使用 git branch<br>brunch 介绍:<br>brunch意味着你可以从主分支中，分叉出来一个分支来提交代码而不影响主分支的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/// 创建并切换到分支</span><br><span class="line">git checkout -b &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 做相应的提交，修改</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 把本地分支上传到远端</span><br><span class="line">git push origin &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 切换到另一台电脑上，拉去自己的分支</span><br><span class="line">git pull origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>合并分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop    ///&lt; 当前处于develop分支下</span><br><span class="line">git merge master   ///&lt; 把master的东西合入到当前分支，方便在自己开发的分支上处理冲突</span><br><span class="line">git checkout master    ///&lt; 切换到master分支</span><br><span class="line">git merge develop    ///&lt; 把develop合并到当前分支</span><br><span class="line">git branch -d future    ///&lt; 把合并过的分支删除</span><br></pre></td></tr></table></figure><h2 id="场景：临时切换分支"><a href="#场景：临时切换分支" class="headerlink" title="场景：临时切换分支"></a>场景：临时切换分支</h2><p>我们会遇到临时切换回主分支的情况。<br>例如： 当我在开发随车通信功能开发一半时，雷总让我在仓库中提交一个文档。如果我在自己的开发分支上上传该文档，那么在<code>master</code>分支上会没有这个文档，其他人也获取不到，所以只能切换回<code>master</code>分支上进行上传。</p><p>提出问题： 快速切换分支，做完提交，切换回开发分支时，工作区应跟切换分支前一样。</p><p>解决方案：<br>那么现在分为两种情况：</p><ol><li>我们工作区没有未被commit的文件，那么我们直接<code>git checkout &lt;branch_name&gt;</code>, 即可切换到相应的分支。</li><li>我们工作区有很多未被commit的代码，这时我们可以选择，把工作区内代码全部commit或者选择使用<code>git stash</code>来临时把未被commit的代码给存储起来， 在我们切换回开发分支时，再把临时存储的代码拿出来。</li></ol><p><code>stash</code>介绍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 把所有未commit的文件(工作区、暂存区里的文件)都放入一个临时的分支，使工作区可以切换分支</span><br><span class="line">git stash</span><br><span class="line">或</span><br><span class="line">git stash save &quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 切换到其他分支，并做一些提交, 并切换回自己的开发分支</span><br><span class="line">git checkout master</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line">/// 把临时存储的代码给拿出来，放入工作区(之前暂存区的文件在pop后的状态是到工作区)</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p><code>git stash --include-untracked</code>或<code>git stash -u</code> 来存储未被跟踪的文件</p><h2 id="场景：-某个commit，提交错分支了"><a href="#场景：-某个commit，提交错分支了" class="headerlink" title="场景： 某个commit，提交错分支了"></a>场景： 某个commit，提交错分支了</h2><p>开发过程中，突然出现了一个<code>BUG</code>需要立即修复，我们急着修复，把修复的代码放入了正在大改开发分支上。<br>提出问题： 我们需要怎样，把主分支上的<code>BUG</code>给修正过来<br>解决方案:</p><ol><li>切换到主分支，再次把刚才修改的文件，同样在主分支上进行修改，再次进行提交。</li><li>切换到主分支，使用<code>git cherry-pick &lt;SHA&gt;</code>把特定提交给放到主分支中。</li></ol><p>方案一存在修改的不一致，当后面需要合并分支时，需要处理冲突。<br>方案二快速提交，不用再次使用手动修改文件。</p><p><code>git cherry-pick &lt;SHA&gt;</code>用法示例：<br>该操作会把特定的commit给，放入当前所在的分支，并产生一个新的提交</p><p>之前分支的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">        \</span><br><span class="line">        e - f - g Feature</span><br></pre></td></tr></table></figure><p><code>cherry-pick</code>操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 切换到</span><br><span class="line">git checkout master</span><br><span class="line">/// 把提交f给提交到本分支</span><br><span class="line">git cherry-pick f</span><br></pre></td></tr></table></figure><p>操作后的分支情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">    \</span><br><span class="line">    e - f - g       Feature</span><br></pre></td></tr></table></figure><h2 id="场景-commit的信息输入错了"><a href="#场景-commit的信息输入错了" class="headerlink" title="场景: commit的信息输入错了"></a>场景: commit的信息输入错了</h2><p>提出问题： 怎么修改提交的commit信息</p><p>解决方案：</p><ol><li>修改最近一次提交的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">/// 进入到提交的文件里面，默认使用vim打开</span><br><span class="line">/// 修改好提交信息，保存后退出</span><br></pre></td></tr></table></figure><ol start="2"><li>如果想要修改之前的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3    ///&lt; 回退到HEAD前面第三个commit处</span><br><span class="line"></span><br><span class="line">/// 想要修改哪一个提交就把pick换成你想要的操作,edit</span><br><span class="line">git commit --amend</span><br><span class="line">/// 然后执行</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><ol start="3"><li>如果该 commit 已经 push 到远端</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line">git push --force-with-lease origin &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h2 id="场景-开发到一半，发现修改的思路有误"><a href="#场景-开发到一半，发现修改的思路有误" class="headerlink" title="场景: 开发到一半，发现修改的思路有误"></a>场景: 开发到一半，发现修改的思路有误</h2><p>我们从远端仓库拉去最新代码，修改过程中，发现修改错误了，想再从已经提交的代码上重新开始。</p><p>提出问题： 如何回退版本</p><p>解决方案：</p><ol><li>没有commit想要回退， 只是清除工作区修改的代码, 如何让当前已经修改过的代码恢复到HEAD的最新提交代码一致, 即清除工作区修改的代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 清除所有没有被暂存的改动</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">/// 清除该文件没有被暂存的改动</span><br><span class="line">git checkout filename</span><br></pre></td></tr></table></figure><ol start="2"><li>想要撤销上一个commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 删除工作区改动的代码，撤销最近一次的commit，撤销git add .</span><br><span class="line">/// 注意完成这个操作后，就恢复到了上一次的commit状态。</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">/// HEAD 指向 commit_id 指向的提交</span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--hard</code>换成<code>--soft</code>, 则会保留已经暂存和修改的文件</li><li><code>HEAD^</code>换成<code>HEAD~2</code>则可以回退两个commit</li></ul><h3 id="清除工作区的修改"><a href="#清除工作区的修改" class="headerlink" title="清除工作区的修改"></a>清除工作区的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_id&gt;    /// 返回到某个节点，不保留修改，已有的改动会丢失</span><br><span class="line">git reset --soft &lt;commit_id&gt;    /// 返回到某个节点，保留修改，已有的改动会保留，在未提交中， `git status` 或 `git diff` 查看</span><br><span class="line"></span><br><span class="line">git clean -df /// 返回到某个节点(未跟踪文件的删除)</span><br><span class="line">git clean -n  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -f  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -i  /// 显示将要删除的文件</span><br><span class="line">git clean -d  /// 递归删除目录及文件(未跟踪的文件)</span><br><span class="line">git clean -q  /// 仅显示错误，成功删除的文件不显示</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clean -nxdf /// 查看要删除的文件及目录，确认无误后再使用下面的命令进行删除</span><br><span class="line">git checkout . &amp;&amp; git clean -xdf</span><br></pre></td></tr></table></figure><h3 id="revert-和-reset"><a href="#revert-和-reset" class="headerlink" title="revert 和 reset"></a>revert 和 reset</h3><ol><li><p>revert<br>首先肯定的是 <code>revert</code>，<code>git revert commit_id</code> 能产生一个 与 <code>commit_id</code> 完全相反的提交，即 <code>commit_id</code> 里是添加， <code>revert</code> 提交里就是删除。<br><code>revert</code> 会生成一个新的提交记录，但不适合回退多个提交。</p></li><li><p>reset<br><code>reset</code> 的原理是把 <code>HEAD</code> 的指向，并删除回退后的版本之后的提交(被删除的提交可以通过 git reflog 查看)。<code>git reset --hard &lt;commit_id&gt;</code><br>但是由于是本地回退版本，所以在推送至远端时，需要使用 <code>git push -f origin master</code> 的命令象只覆盖远端分支。由于我们的远端仓库大部分都是对 <code>master</code> 分支进行保护不允许使用 <code>-f</code> 强制覆盖。我们可以先回退 <code>develop</code> 分支, 在 <code>develop</code> 分支上在创建一次提交(该提交已经领先于远端<code>master</code>分支), 再提交至远端 <code>develop</code> 分支后 <code>merge</code>。</p></li></ol><h2 id="场景：-想要找到某个特定业务的所有提交"><a href="#场景：-想要找到某个特定业务的所有提交" class="headerlink" title="场景： 想要找到某个特定业务的所有提交"></a>场景： 想要找到某个特定业务的所有提交</h2><p>假设我们的commit的信息都是采用模板来填写的，且已经有大量的<code>commit</code>时候，需要过滤检索一些特定提交信息的<code>commit</code>。</p><p>提出问题： 如何使用关键字搜索提交信息</p><p>解决方案：<br>使用git自带的文字搜索功能<code>git log --all --grep=&#39;TrainPosCall&#39;</code>, 搜索提交信息中带有<code>TrainPosCall</code>的<code>commit</code>。</p><h2 id="场景：-想要确认代码的改动"><a href="#场景：-想要确认代码的改动" class="headerlink" title="场景： 想要确认代码的改动"></a>场景： 想要确认代码的改动</h2><p>想要分步提交修改库函数的文件和修改业务逻辑的文件，需要确认每个文件的改动。</p><p>提出问题： 怎么查看已修改的代码对比之前的版本</p><p>解决方案：</p><ol><li>查看尚未缓存的改动：<code>git diff</code></li><li>查看已缓存的改动： <code>git diff --cached</code>, <code>git diff --staged</code></li><li>查看已缓存的与未缓存的所有改动：<code>git diff HEAD</code></li><li>显示摘要而非整个 diff： <code>git diff --stat</code></li><li>版本号与版本号之间的差别: <code>git diff &lt;SHA&gt; &lt;SHA&gt;</code></li></ol><h2 id="场景误删除分支"><a href="#场景误删除分支" class="headerlink" title="场景误删除分支"></a>场景误删除分支</h2><p>在误删除分支后，可以使用 <code>git reflog</code> 来查看分支的<code>commit id</code>并使用该<code>commit id</code>来创建一个新的分支<br><code>git branch recover-branch [commit id]</code></p><h2 id="场景-git-账户修改密码"><a href="#场景-git-账户修改密码" class="headerlink" title="场景: git 账户修改密码"></a>场景: git 账户修改密码</h2><p>操作<code>git</code>时, 出现错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: HTTP Basic: Access denied</span><br></pre></td></tr></table></figure><p>管理员权限输入以下命令后在命令行中操作<code>git</code>，重新输入用户名，密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/docs">git Reference</a></p><p><a href="https://git-scm.com/book/en/v2">Pro Git</a></p><p><a href="https://juejin.cn/post/6844903965625155597">Git新手教程-添加忽略文件(十)</a></p><p><a href="https://www.freecodecamp.org/news/git-cheat-sheet/">Git Cheat Sheet – 50 Git Commands You Should Know</a></p><p><a href="https://www.runoob.com/git/git-diff.html">git diff 命令</a></p><p><a href="https://www.atlassian.com/git/tutorials/saving-changes/git-diff">Git diff</a></p><p><a href="https://www.cnblogs.com/ibingshan/p/10783552.html">git clean 删除忽略文件 和 未被跟踪文件及文件夹</a></p><p><a href="https://git-scm.com/docs/git-branch">git-branch - List, create, or delete branches</a></p><p><a href="https://stackoverflow.com/questions/7124914/how-to-search-a-git-repository-by-commit-message/7124949#7124949">How to search a Git repository by commit message?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类型大小(32bit 与 64bit)</title>
      <link href="/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/"/>
      <url>/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/</url>
      
        <content type="html"><![CDATA[<p>C++ 类型大小 (32bit 与 64bit)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---标准类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int size:                &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long size:          &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size_t size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned char size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;signed char size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">signed</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pointer size:            &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---自定义类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SHORT(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT(int) size:                   &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;LONG(long) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT8(unsigned char) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT16(unsigned short) size:     &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT32(unsigned int) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT64(unsigned long long) size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT8(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT16(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT32(int) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT64(long long) size:           &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;FLOAT(float) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DOUBLE(double) size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CHAR(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BOOL(int) size:                  &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BYTE(unsigned char) size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;HANDLE(void*) size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>VS2010 32bit</th><th>VS2010 64bit</th><th>VS2019 32bit</th><th>VS2019 64bit</th><th>Linux 32bit</th><th>Linux 64bit</th><th>备注</th></tr></thead><tbody><tr><td>short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>unsigned short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>unsigned int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>unsigned long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>unsigned long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>size_t</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>signed char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>pointer</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>SHORT(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>LONG(long)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>UINT8(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>UINT16(unsigned short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>UINT32(unsigned int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>UINT64(unsigned long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>INT8(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>INT16(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT32(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>INT64(long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>FLOAT(float)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>DOUBLE(double)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>CHAR(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>BOOL(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>BYTE(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>HANDLE(void*)</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr></tbody></table><p>结论:</p><ol><li><code>size_t</code>、<code>pointer</code>、<code>long</code>、<code>unsigned long</code>、<code>HANDLE</code>这三种类型在<code>32bit</code>和<code>64bit</code>的大小有差别。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《代码大全》</title>
      <link href="/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="强制类型转换的应用"><a href="#强制类型转换的应用" class="headerlink" title="强制类型转换的应用"></a>强制类型转换的应用</h2><h2 id="C语言中void-可以转换为任意指针"><a href="#C语言中void-可以转换为任意指针" class="headerlink" title="C语言中void* 可以转换为任意指针"></a>C语言中void* 可以转换为任意指针</h2><p>size_t 到 unsigned</p><p>变量初始化</p><ul><li>从未对变量赋值。它的值只是程序启动时变量所处内存区域的值</li><li>变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效</li><li>变量的一部分被赋值，而另一部分没有</li></ul><h2 id="在声明变量的时候初始化"><a href="#在声明变量的时候初始化" class="headerlink" title="在声明变量的时候初始化"></a>在声明变量的时候初始化</h2><h2 id="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"><a href="#理想情况下，在靠近第一次使用变量的位置声明和定义该变量" class="headerlink" title="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"></a>理想情况下，在靠近第一次使用变量的位置声明和定义该变量</h2><ul><li>在有可能的情况下使用<code>const</code>， 定义常量，入参。</li><li>特别注意计数器和累加器，在下一次使用时忘记重置其值。</li><li>在类的构造函数中，初始化该类的数据成员</li><li>检查是否需要重新初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尽可能缩短变量存活时间"><a href="#尽可能缩短变量存活时间" class="headerlink" title="尽可能缩短变量存活时间"></a>尽可能缩短变量存活时间</h2><p>短的变量存活时间减少了初始化错误的可能。</p><p>变量存活时间短还会使代码具有可读性。阅读者同一时间内需要阅读的代码越少，越容易理解代码。</p><p>当需要把一个大的函数，拆分成几个小程序，短的存活时间方便拆分。</p><p>在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。</p><p>直到变量即将被使用时再为其赋值。</p><p>把相关语句放在一起。把相关语句提取成单独的子程序。</p><p>开始时采用最严格的可见性，然后根据扩展变量的作用域。比如，把一个循环内的变量挪到循环外的难度要比反过来难度低，或把一个<code>private</code>转变为<code>public</code>的难度远比反过来难度低。</p><p>避免采用硬编码，宏定义总是好于硬编码。</p><ul><li><code>TITLE_BAR_COLOR</code> 比 <code>0xFFFFFF</code> 更能反应出所代表的信息</li><li>同时，也方便修改宏定义时，同时改变所有的颜色的RGB值</li></ul><h2 id="为变量指定单一用途"><a href="#为变量指定单一用途" class="headerlink" title="为变量指定单一用途"></a>为变量指定单一用途</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + temp) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - temp) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">temp = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discriminant = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + discriminant) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - discriminant) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">oldRoot = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = oldRoot;</span><br></pre></td></tr></table></figure><p>避免让代码具有隐含含义，把同一变量用于多个多个用途的另外一种方式是当变量代表不同事务时让其具有不同的取值集合。</p><ul><li>变量<code>count</code>的取值可能表示某个计数，除非他等于<code>-1</code>，在这种情况下表明有错误发生</li><li>变量<code>customerId</code>可能代表某个客户账号，除非他的取值大于50000，在这种情况下，你通过减去50000来得到过期账号。</li><li>变量<code>bytesWritten</code>可能表示写入输出文件的字节数，除非它的取值为负，在这种情况下他表示的是用于输出磁盘驱动器的号码。</li></ul><h2 id="变量名的注意事项"><a href="#变量名的注意事项" class="headerlink" title="变量名的注意事项"></a>变量名的注意事项</h2><p>糟糕的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x - xx;</span><br><span class="line">xxx = fido + <span class="built_in">SalesTax</span>(fido);</span><br><span class="line">x = x + <span class="built_in">LateFee</span>(x1, x) + xxx;</span><br><span class="line">x = x + <span class="built_in">Interest</span>(x1, x);</span><br></pre></td></tr></table></figure><p>良好的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">balance = balance - lastPayment;</span><br><span class="line">monthlyTotal = newPurchases + <span class="built_in">SalesTax</span>(newPurchases);</span><br><span class="line">balance = balance + <span class="built_in">LateFee</span>(customerID, balance) + monthlyTotal;</span><br><span class="line">balance = balance + <span class="built_in">Interest</span>(customerID, balance);</span><br></pre></td></tr></table></figure><p>为变量命名时最重要的考虑事项时，改名字要完全、准确地描述该变量所代表的事物<br>不包含晦涩的缩写，同时也没有歧义。<br>对于一个表示中国奥林匹克代表团成员数量的变量，你可能会使用<code>NumberOfPeopleOnTheChineseOlympicTeam</code><br>表示当前利率的变量最好为<code>rate</code>而不是<code>r</code>.</p><p>变量名太长: <code>numberOfPeopleOnTheChineseOlympicTeam</code>,<code>numberOfSeatsInTheStadium</code>, <code>maximumNumberOfPointsInModernOlympics</code><br>变量名太短: <code>n</code>, <code>np</code>, <code>ntm</code>, <code>ms</code>, <code>nsisd</code>, <code>m</code>, <code>max</code>, <code>min</code><br>变量名正好： <code>numTeamMembers</code>, <code>teamMemberCount</code>, <code>numSeatsInStadium</code>, <code>seatCount</code>, <code>teamPointsMax</code>, <code>pointSRecord</code></p><p>很多程序有表示计算机结果的变量：总额、平均值、最大值，等等。如果你要用类似于<code>Total</code>、<code>Sum</code>、<code>Average</code>、<code>Max</code>、<code>Min</code>、<code>Record</code>这样的限定词，那么请一定记住把限定词加到名字最后。<br>变量名中最重要的部分应该被放置在最前面，限定词在最后。<br>这样做会避免，<code>totalRevenue</code>和<code>revenueTotal</code>异议词语</p><p>为状态变量起一个比<code>flag</code>更好的名字。最好把标记<code>flag</code>看作状态变量，标记的名字中不应该含有<code>flag</code>，因为你从中丝毫看不出该标记是做什么的。<br>含义模糊的标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) ...</span><br><span class="line"><span class="keyword">if</span> (statusFlag &amp; <span class="number">0xF</span>) ...</span><br><span class="line"><span class="keyword">if</span> (printFlag == <span class="number">16</span>) ...</span><br><span class="line"><span class="keyword">if</span> (computeFlag == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure><p>更好的状态变量命名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dataReady) ...</span><br><span class="line"><span class="keyword">if</span> (characterType &amp; PRINTABLE_CHAR) ...</span><br><span class="line"><span class="keyword">if</span> (reportType == ReportType_Annual) ...</span><br><span class="line"><span class="keyword">if</span> (recalcNeeded == <span class="literal">false</span>) ...</span><br></pre></td></tr></table></figure><p>为布尔变量命名</p><ul><li><code>done</code> 用<code>done</code>表示某件事情已经发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>error</code> 用<code>error</code>表示有错误发生。在错误发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>found</code> 用<code>found</code>来表明某个值已经找到了。在没有找到设为<code>false</code>, 找到后设为<code>true</code>.</li><li><code>success</code>和<code>ok</code>, 操作失败时设为<code>false</code>, 操作成功后设为<code>true</code></li></ul><p>给布尔变量赋予隐含“真、假”含义的名字: <code>status</code>和<code>sourceFile</code>是很糟糕的布尔变量名。<br>应该把<code>status</code>替换为类似<code>error</code>或者<code>statusOK</code>这样的名称，把<code>sourceFile</code>替换为<code>sourceFileAvailable</code>、<code>sourceFileFound</code></p><p>使用肯定的布尔变量名，否定的布尔名如<code>notFound</code>、<code>notDone</code>以及<code>notSuccessful</code>比较难阅读。使用肯定的语义避免双重否定带来的阅读难度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnsiString strTmp;</span><br><span class="line">strTmp = edtAccount-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Account = strTmp;</span><br><span class="line">&#125;</span><br><span class="line">strTmp = edtPassword-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Password = strTmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩写的一般指导原则：</p><ul><li>使用标准的缩写(列在字典中的那些常见缩写)</li><li>去掉虚词<code>and</code>, <code>or</code>, <code>the</code>等</li><li>去掉无用的后缀<code>ing</code>, <code>end</code></li><li>确保不要改变变量的含义</li><li>反复使用上述技术，知道你把每个变量名的长度缩减到了8到20个字符，或者达到你所用的编程语言对变量名的限制字符数。</li></ul><h2 id="不要用每个单词中删除一个字符的方式来缩写"><a href="#不要用每个单词中删除一个字符的方式来缩写" class="headerlink" title="不要用每个单词中删除一个字符的方式来缩写"></a>不要用每个单词中删除一个字符的方式来缩写</h2><p>键入一个字符算不上是什么额外工作，而节省一个字符带来的便利却很难抵消由此而造成的可读性的损失。</p><h2 id="缩写要一致"><a href="#缩写要一致" class="headerlink" title="缩写要一致"></a>缩写要一致</h2><p>应该一直使用相同的缩写。要么全用<code>Num</code>，要么全用<code>No</code>，也不要有些地方使用全写<code>Number</code>, 同时在其他地方使用缩写<code>Num</code></p><h2 id="创建你能读出来的名字"><a href="#创建你能读出来的名字" class="headerlink" title="创建你能读出来的名字"></a>创建你能读出来的名字</h2><p>使用<code>xPos</code>而不是<code>xPstn</code>, 用<code>needsCompu</code>而不用<code>ndsCmptg</code>。这里可以使用电话沟通，如果你无法向他人读出你的代码，就请重新给变量起一个更清晰的名字。</p><h2 id="名字对于代码的读者的意义要比对作者更重要"><a href="#名字对于代码的读者的意义要比对作者更重要" class="headerlink" title="名字对于代码的读者的意义要比对作者更重要"></a>名字对于代码的读者的意义要比对作者更重要</h2><h2 id="避免使用令人误解的名字或缩写"><a href="#避免使用令人误解的名字或缩写" class="headerlink" title="避免使用令人误解的名字或缩写"></a>避免使用令人误解的名字或缩写</h2><p>要确保名字的含义是明确的</p><h2 id="避免使用具有相似含义的名字"><a href="#避免使用具有相似含义的名字" class="headerlink" title="避免使用具有相似含义的名字"></a>避免使用具有相似含义的名字</h2><p>如果你能够交换两个变量的名字而不会妨碍对程序的理解，那么你就需要为这两个变量重新命名了。</p><h2 id="避免在名字中使用数字"><a href="#避免在名字中使用数字" class="headerlink" title="避免在名字中使用数字"></a>避免在名字中使用数字</h2><p>如果名字中的数字真的非常重要，就请使用数组来代替一组单个的变量。如果数组不合适，那么数字就更不合适。</p><h2 id="避免在名字中拼错单词"><a href="#避免在名字中拼错单词" class="headerlink" title="避免在名字中拼错单词"></a>避免在名字中拼错单词</h2><h2 id="避免在名字中使用容易混淆的字符"><a href="#避免在名字中使用容易混淆的字符" class="headerlink" title="避免在名字中使用容易混淆的字符"></a>避免在名字中使用容易混淆的字符</h2><ul><li>数字<code>1</code>和小写的<code>l</code></li><li>数字<code>1</code>和大写的<code>L</code></li><li>数字<code>0</code>和大写的<code>O</code></li><li>数字<code>2</code>和小写的<code>z</code></li><li>数字<code>6</code>和大写的<code>G</code></li></ul><h2 id="避免浮点数的数量级相差巨大的数字之间的四则运算"><a href="#避免浮点数的数量级相差巨大的数字之间的四则运算" class="headerlink" title="避免浮点数的数量级相差巨大的数字之间的四则运算"></a>避免浮点数的数量级相差巨大的数字之间的四则运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">100000000.0</span> + <span class="number">0.1</span>;</span><br><span class="line">    std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免浮点数的等量比较"><a href="#避免浮点数的等量比较" class="headerlink" title="避免浮点数的等量比较"></a>避免浮点数的等量比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp += <span class="number">0.1</span>;</span><br><span class="line">        std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">IncreaseA</span>() || !<span class="built_in">IncreaseB</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为空语句创建一个DoNothing-预处理宏或者内联函数"><a href="#为空语句创建一个DoNothing-预处理宏或者内联函数" class="headerlink" title="为空语句创建一个DoNothing()预处理宏或者内联函数"></a>为空语句创建一个DoNothing()预处理宏或者内联函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(recordArray.<span class="built_in">Read</span>(index++) != recordArray.<span class="built_in">EmptyRecord</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DoNothing()</span></span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoNothing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华为C++编程规范摘录</title>
      <link href="/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/"/>
      <url>/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bookstack.cn/read/openharmony-1.0-zh-cn/contribute-OpenHarmony-cpp-coding-style-guide.md">华为C++语言编程规范</a></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="3-7-1-if-循环语句必须使用大括号"><a href="#3-7-1-if-循环语句必须使用大括号" class="headerlink" title="3.7.1 if&#x2F;循环语句必须使用大括号"></a>3.7.1 if&#x2F;循环语句必须使用大括号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>();  <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-不用的代码段直接删除，不要注释掉"><a href="#4-4-3-不用的代码段直接删除，不要注释掉" class="headerlink" title="4.4.3 不用的代码段直接删除，不要注释掉"></a>4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入容易被忽略的缺陷。正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。使用版本控制来，记录代码。</p><h3 id="5-2-3-禁止通过声明的方式引用外部函数接口、变量"><a href="#5-2-3-禁止通过声明的方式引用外部函数接口、变量" class="headerlink" title="5.2.3 禁止通过声明的方式引用外部函数接口、变量"></a>5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。通过<code>extern</code>声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。同时这种隐式依赖，容易导致架构腐化。</p><h3 id="5-2-4-禁止在extern-C-中包含头文件"><a href="#5-2-4-禁止在extern-C-中包含头文件" class="headerlink" title="5.2.4 禁止在extern &quot;C&quot;中包含头文件"></a>5.2.4 禁止在<code>extern &quot;C&quot;</code>中包含头文件</h3><p>在<code>extern &quot;C&quot;</code> 中包含头文件，有可能导致<code>extern &quot;C&quot;</code>嵌套，部分编译器对<code>extern &quot;C&quot;</code>嵌套层次有限制，嵌套层次太多会编译错误。</p><h3 id="7-1-1-类的成员变量必须显式初始化"><a href="#7-1-1-类的成员变量必须显式初始化" class="headerlink" title="7.1.1 类的成员变量必须显式初始化"></a>7.1.1 类的成员变量必须显式初始化</h3><p>如果类有成员变量，没有定义构造函数，有没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。<br>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化</p><h3 id="7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。"><a href="#7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。" class="headerlink" title="7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。"></a>7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。</h3><p>可以将拷贝构造函数或者赋值操作符设置为<code>private</code>，并且不实现。<br>C++11以后可以使用关键字<code>delete</code>, 来删除该成员函数。</p><h3 id="7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"><a href="#7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止" class="headerlink" title="7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"></a>7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><h3 id="7-1-6-禁止在构造函数和析构函数中调用虚函数"><a href="#7-1-6-禁止在构造函数和析构函数中调用虚函数" class="headerlink" title="7.1.6 禁止在构造函数和析构函数中调用虚函数"></a>7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>在构造函数和析构函数中调用当前对象的虚函数，会导致未定义的行为。在C++中，一个基类一次只构造一个完整的对象。</p><h3 id="7-2-1-基类的析构函数应该声明为virtual"><a href="#7-2-1-基类的析构函数应该声明为virtual" class="headerlink" title="7.2.1 基类的析构函数应该声明为virtual"></a>7.2.1 基类的析构函数应该声明为<code>virtual</code></h3><p><code>虚析构函数</code></p><h3 id="7-2-2-禁止虚函数使用缺省参数值"><a href="#7-2-2-禁止虚函数使用缺省参数值" class="headerlink" title="7.2.2 禁止虚函数使用缺省参数值"></a>7.2.2 禁止虚函数使用缺省参数值</h3><p>在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着你最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。为了避免虚函数重载时，因参数声明不一致给使用者带来的困惑和由此导致的问题，规定所有虚函数均不允许声明缺省参数值。</p><h3 id="7-2-3-禁止重新定义继承而来的非虚函数"><a href="#7-2-3-禁止重新定义继承而来的非虚函数" class="headerlink" title="7.2.3 禁止重新定义继承而来的非虚函数"></a>7.2.3 禁止重新定义继承而来的非虚函数</h3><p>因为非虚函数无法实现动态绑定，只有虚函数才能实现动态绑定：只要操作基类的指针，即可获得正确的结果。</p><h3 id="8-1-1-避免函数过长，函数不超过50行-非空非注释"><a href="#8-1-1-避免函数过长，函数不超过50行-非空非注释" class="headerlink" title="8.1.1 避免函数过长，函数不超过50行(非空非注释)"></a>8.1.1 避免函数过长，函数不超过50行(非空非注释)</h3><p>函数应该可以一屏显示完(50行以内), 只做一件事情，而且把它做好。<br>过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步抽象。<br>例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。<br>即使一个长函数现在工作的很好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的BUG。建议将其拆分为更加简短并易于管理的若干函数，以便于他人阅读和修改代码。</p><h3 id="9-1-1-不允许使用宏来表示常量"><a href="#9-1-1-不允许使用宏来表示常量" class="headerlink" title="9.1.1 不允许使用宏来表示常量"></a>9.1.1 不允许使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名；宏没有类型检查，不安全；宏没有作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MSI_SDN_LEN 20  <span class="comment">///&lt; Bad</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>; <span class="comment">///&lt; Good</span></span><br><span class="line"><span class="comment">/// C++11以上的版本，可以使用`constexpr`</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="9-1-2不允许使用魔鬼数字"><a href="#9-1-2不允许使用魔鬼数字" class="headerlink" title="9.1.2不允许使用魔鬼数字"></a>9.1.2不允许使用魔鬼数字</h3><p>魔鬼数字是看不懂、难以理解的数字。<br>例如<code>type = 12</code>，看不懂，但改成<code>mouthsCount = yearsCount * 12</code>, 就容易理解。<br>数字<code>0</code>有时候也难以理解。<code>status = 0</code>并不能表达是什么状态。<br>解决途径： 对于局部使用的数字，可以增加注释说明，对于多处使用的数字，必须定义<code>const</code>常量，并通过符号命名自注释。<br>禁止出现下列情况： 没有通过符号来解释数字含义，如<code>const int ZERO = 0</code>，符号命名限制了其取值，如<code>const int XXX_TIMER_INTERVAL_300MS = 300</code>，<br>直接使用<code>XX_TIMER_INTERVAL_MS</code>来表示该常量是定时器的时间间隔。</p><h3 id="9-1-3-常量应该保证单一职责"><a href="#9-1-3-常量应该保证单一职责" class="headerlink" title="9.1.3 常量应该保证单一职责"></a>9.1.3 常量应该保证单一职责</h3><p>一个常量只用来标识一个特定功能，即一个常量不能有多种用途。</p><p>好的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> A_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Namespace1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Namespace2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-4-禁止用memcpy-s、memset-s初始化非POD对象"><a href="#9-1-4-禁止用memcpy-s、memset-s初始化非POD对象" class="headerlink" title="9.1.4 禁止用memcpy_s、memset_s初始化非POD对象"></a>9.1.4 禁止用<code>memcpy_s</code>、<code>memset_s</code>初始化非<code>POD</code>对象</h3><p><code>POD</code>类型主要包括<code>int</code>, <code>char</code>, <code>float</code>, <code>double</code>, <code>enumeration</code>, <code>void</code>, <code>pointer</code>等原始类ing以及聚合类型，不能使用封装和面向对象特性(如用户定义的构造&#x2F;赋值&#x2F;析构函数、基类、虚函数)<br>由于非<code>POD</code>类型比如非聚合类型的<code>class</code>对象，可能存在虚函数，内存布局不确定，跟编译器有关，滥用内存拷贝可能会导致严重的问题。<br>即使对聚合类型的<code>class</code>,使用直接的内存拷贝和比较，破坏了信息隐蔽和数据保护的作用，也不提倡使用<code>memcpy_s</code>、<code>memset_s</code></p><h3 id="9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量"><a href="#9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量" class="headerlink" title="9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量"></a>9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量</h3><p>含有变量自增或自减的表达式中，如果再引用该变量，其结果在C++标准中未明确定义。会产生未定义的结果。<br>注意，运算次序的问题不能使用括号来解决，因为之不是优先级的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i++; <span class="comment">///&lt; Bad: b[i]运算跟i++, 先后顺序并不明确。</span></span><br></pre></td></tr></table></figure><p>正确的写法是将自增或自减运算单独放一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i;</span><br><span class="line">i++;    <span class="comment">///&lt; Good， 单独一行</span></span><br></pre></td></tr></table></figure><p>函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Func</span>(i++, i)    <span class="comment">///&lt; Bad</span></span><br><span class="line"></span><br><span class="line">i++;    <span class="comment">///&lt; Good， 自增运算单独放一行</span></span><br><span class="line"><span class="built_in">Func</span>(i, i)</span><br></pre></td></tr></table></figure><h3 id="9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换"><a href="#9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换" class="headerlink" title="9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换"></a>9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换</h3><p>C++提供的类型转换操作比C风格更具有针对性，更易读，也更安全，C++提供的转换有：</p><ol><li><code>dynamic_cast</code>: 主要用于继承体系下行转换，<code>dynamic_cast</code>具有类型检查的功能，请做好基类和派生类的设计，避免使用<code>dynamec_cast</code>来进行转换。</li><li><code>static_cast</code>: 和C风格相似可做值的强制转换，或上行转换(把派生类的指着或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。</li><li><code>reinterpret_cast</code>: 用于转换不相关的类型。<code>reinterpret_cast</code>强制编译器将某个类型对象的内存重新解释成另一种类型，这是一种不安全的转换，建议尽可能少用<code>reinterpret_cast</code></li><li><code>const_cast</code>: 用于移除对象的<code>const</code>属性，使对象变得可修改，这样会破坏数据的不变性，建议尽可能少用。</li></ol><h3 id="9-5-1-不要保存std-string的c-str-返回的指针"><a href="#9-5-1-不要保存std-string的c-str-返回的指针" class="headerlink" title="9.5.1 不要保存std::string的c_str()返回的指针"></a>9.5.1 不要保存<code>std::string</code>的<code>c_str()</code>返回的指针</h3><p>C++标准中并未规定<code>c_str()</code>返回的指针持久有效，所以不要保存。</p><h3 id="9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const"><a href="#9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const" class="headerlink" title="9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用const"></a>9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用<code>const</code></h3><p>不变的值更易于理解&#x2F;跟踪和分析， 把<code>const</code>作为默认悬念，在编译时会对其进行检查，使代码更安全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-6-2-对于不会修改成员变量的成员函数请使用const修饰"><a href="#9-6-2-对于不会修改成员变量的成员函数请使用const修饰" class="headerlink" title="9.6.2 对于不会修改成员变量的成员函数请使用const修饰"></a>9.6.2 对于不会修改成员变量的成员函数请使用<code>const</code>修饰</h3><p>尽可能将成员函数声明为<code>const</code>。访问函数应该总是<code>const</code>。只要不修改数据成员的成员函数，都声明为<code>const</code>。对于虚函数，应当从设计意图上考虑继承链上的所有类是否需要在此虚函数中修改数据成员，而不是仅关注单个类的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">PrintValue</span><span class="params">()</span> <span class="type">const</span> <span class="comment">///&lt; 修饰成员函数, 不会修改成员变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="2-4-1-避免滥用typedef或者-define对基本类型起别名"><a href="#2-4-1-避免滥用typedef或者-define对基本类型起别名" class="headerlink" title="2.4.1 避免滥用typedef或者#define对基本类型起别名"></a>2.4.1 避免滥用<code>typedef</code>或者<code>#define</code>对基本类型起别名</h3><p>除有明确的必要性，否则不要用<code>typedef</code>、<code>#define</code>对基本数据类型进行重定义。优先使用<code>&lt;cstdint&gt;</code>头文件中的基本。</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有、无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有、无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有、无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有、无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有、无符号整数类型</td></tr></tbody></table><h3 id="3-1-1-行宽不超过120个字符"><a href="#3-1-1-行宽不超过120个字符" class="headerlink" title="3.1.1 行宽不超过120个字符"></a>3.1.1 行宽不超过120个字符</h3><h3 id="3-9-1-表达式换行要保持换行的一致性，运算符放行末"><a href="#3-9-1-表达式换行要保持换行的一致性，运算符放行末" class="headerlink" title="3.9.1 表达式换行要保持换行的一致性，运算符放行末"></a>3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">IsCorrect</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsValid</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsSomething</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-1-合理安排空行，保持代码紧凑"><a href="#3-14-1-合理安排空行，保持代码紧凑" class="headerlink" title="3.14.1 合理安排空行，保持代码紧凑"></a>3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。</p><ul><li>根据上下内容的相关程度，合理安排空行</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不适用连续三个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但<code>namespace</code>的大括号内不做要求</li></ul><h3 id="5-2-1-尽量避免使用前置声明"><a href="#5-2-1-尽量避免使用前置声明" class="headerlink" title="5.2.1 尽量避免使用前置声明"></a>5.2.1 尽量避免使用前置声明</h3><h3 id="6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"><a href="#6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰" class="headerlink" title="6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"></a>6.1.1 对于<code>cpp</code>文件中不需要导出的变量，常量或者函数，请使用匿名<code>namespace</code>封装或者用<code>static</code>修饰</h3><p>更加推荐使用匿名<code>namespace</code>：</p><ol><li><code>static</code>在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数， 静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li><code>static</code>只能保证变量，常量和函数的文件作用域，但是<code>namespace</code>还可以封装类型等。</li><li>统一<code>namespace</code>来处理C++的作用域，而不需要同时使用<code>static</code>和<code>namespace</code>来管理</li><li><code>static</code>修饰的函数不能用来实例化模板，而匿名<code>namespace</code>可以</li></ol><p>注意： 不要<code>.h</code>中使用匿名<code>namespace</code>或者<code>static</code></p><h3 id="6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"><a href="#6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数" class="headerlink" title="6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"></a>6.2.1 优先使用命名空间来管理全局函数，如果和某个<code>class</code>有直接关系的，可以使用静态成员函数</h3><p>非成员函数放在名字控件内可避免污染全局作用域，也不要用类+静态成员方法来简单管理全局函数。如果某个全局函数和某个类有紧密联系，那么可以作为类的静态成员函数。<br>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><h3 id="6-4-1-尽量避免使用全局变量，考虑使用单例模式"><a href="#6-4-1-尽量避免使用全局变量，考虑使用单例模式" class="headerlink" title="6.4.1 尽量避免使用全局变量，考虑使用单例模式"></a>6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><h3 id="8-3-1-函数参数使用引用代替指针"><a href="#8-3-1-函数参数使用引用代替指针" class="headerlink" title="8.3.1 函数参数使用引用代替指针"></a>8.3.1 函数参数使用引用代替指针</h3><p>引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。</p><h3 id="8-3-2-使用强类型参数，避免使用void"><a href="#8-3-2-使用强类型参数，避免使用void" class="headerlink" title="8.3.2 使用强类型参数，避免使用void*"></a>8.3.2 使用强类型参数，避免使用void*</h3><p>一般认为<code>C/C++</code>是强类型语言，既然我们使用的是强类型语言，就应该保持这样的风格。好处是尽量让编译器在编译阶段就检查出类型不匹配的问题。</p><h3 id="8-3-3-函数的参数个数不超过5个"><a href="#8-3-3-函数的参数个数不超过5个" class="headerlink" title="8.3.3 函数的参数个数不超过5个"></a>8.3.3 函数的参数个数不超过5个</h3><p>函数的参数过多，会使得该函数易于受外部变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。<br>如果超过可以考虑</p><ul><li>看能否拆分函数</li><li>看能否将相关参数合在一起，定义结构体</li></ul><h3 id="9-1-1-一组相关的整型变量应定义未枚举。"><a href="#9-1-1-一组相关的整型变量应定义未枚举。" class="headerlink" title="9.1.1 一组相关的整型变量应定义未枚举。"></a>9.1.1 一组相关的整型变量应定义未枚举。</h3><p>枚举比<code>#define</code>或<code>const int</code>更安全。编译器会检查参数值是否位于枚举取值范围内，避免错误发生。</p><h3 id="9-1-2-变量使用时才声明并初始化"><a href="#9-1-2-变量使用时才声明并初始化" class="headerlink" title="9.1.2 变量使用时才声明并初始化"></a>9.1.2 变量使用时才声明并初始化</h3><p>变量在使用前未赋初值，是常见的低级编程错误。使用前才声明变量并初始化，非常方便地避免了此类低级错误。<br>在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：</p><ul><li>程序难以理解与维护： 变量定义与使用分离</li><li>变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值（0）来初始化。如果变量在被赋予有效值以前使用，还会导致错误。</li></ul><p>遵循变量作用域最小化原则与就近声明原则，使得代码更容易阅读，方便了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string name;   <span class="comment">///&lt; Bad</span></span><br><span class="line">name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>)</span></span>;   <span class="comment">///&lt; Good</span></span><br></pre></td></tr></table></figure><h3 id="9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"><a href="#9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则" class="headerlink" title="9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"></a>9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则</h3><p>当变量与常量进行比较时，如果常量放左边， 如<code>if(MAX == v)</code>不符合阅读习惯，而<code>if(MAX &gt; v)</code>更难以理解，应当按人的正常阅读、表达习惯，将常量放右边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value &lt; MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有特殊情况， 如： <code>if(MIN &lt; value &amp;&amp; value &lt; MAX)</code>用来描述区间时，前半段是常量在左的。<br>不用担心将<code>==</code>误写成<code>=</code>, 因为<code>if(value = MAX)</code>会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><h3 id="9-2-2-使用括号明确操作符的优先级"><a href="#9-2-2-使用括号明确操作符的优先级" class="headerlink" title="9.2.2 使用括号明确操作符的优先级"></a>9.2.2 使用括号明确操作符的优先级</h3><p>使用括号明确操作符的优先级，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b + ; <span class="comment">///&lt; 操作符相同,可以不加括号</span></span><br><span class="line">x = <span class="number">1</span> &lt;&lt; (<span class="number">2</span> + <span class="number">3</span>);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br><span class="line">x = (a == b) ? a : (a - b);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br></pre></td></tr></table></figure><h3 id="9-3-1-避免使用dynamic-cast"><a href="#9-3-1-避免使用dynamic-cast" class="headerlink" title="9.3.1 避免使用dynamic_cast"></a>9.3.1 避免使用<code>dynamic_cast</code></h3><ol><li><code>dynamic_cast</code>依赖于C++的<code>RTTI</code>, 让程序员在运行时识别C++类对象的类型</li><li><code>dynamic_cast</code>的出现一般说明我们的基类和派生类设计出现了问题，派生类破坏了基类的七月，不得不通过</li><li><code>dynamic_cast</code>转换到子类进行特殊处理，这个时候更希望来改善类的设计，而不是通过<code>dynamic_cast</code>来解决问题</li></ol><h3 id="9-3-2-避免使用reinterpret-cast"><a href="#9-3-2-避免使用reinterpret-cast" class="headerlink" title="9.3.2 避免使用reinterpret_cast"></a>9.3.2 避免使用<code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code>用于转换不相关类型。尝试用<code>reinterpret_cast</code>将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。</p><h3 id="9-3-3-避免使用const-cast"><a href="#9-3-3-避免使用const-cast" class="headerlink" title="9.3.3 避免使用const_cast"></a>9.3.3 避免使用<code>const_cast</code></h3><p><code>cosnt_cast</code>用于移除对象的<code>const</code>和<code>volatile</code>性质。<br>使用<code>const_cast</code>转换后的指针或者引用来修改<code>const</code>对象，行为是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不好的例子</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i);</span><br><span class="line">*p = <span class="number">2048</span>;  <span class="comment">///&lt; 未定义行为</span></span><br></pre></td></tr></table></figure><h3 id="9-4-1-使用RAII特性来帮助跟踪动态分配"><a href="#9-4-1-使用RAII特性来帮助跟踪动态分配" class="headerlink" title="9.4.1 使用RAII特性来帮助跟踪动态分配"></a>9.4.1 使用<code>RAII</code>特性来帮助跟踪动态分配</h3><p><code>RAII</code>是”资源获取就是初始化”的简写(Resource Acquisition Is Initialization), 是一种利用对象生命周期来控制程序资源(如内存、文件句柄、网络连接、互斥量等等)的简单技术。<br><code>RAII</code>的一般做法是这样的： 在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内之中有效，最后在对象析构的时候释放资源，这种做法有两大好处:</p><ul><li>我们不需要显式地释放资源</li><li>对象所需的资源在其生命期内始终有效。这样，就不必检查资源有效性问题，可以简化逻辑、提高效率。</li></ul><h3 id="9-5-1-使用std-string代替char"><a href="#9-5-1-使用std-string代替char" class="headerlink" title="9.5.1 使用std::string代替char*"></a>9.5.1 使用<code>std::string</code>代替<code>char*</code></h3><p>说明: 使用<code>string</code>代替<code>char*</code>有很多优势，比如:</p><ol><li>不用考虑结尾的<code>&#39;\0&#39;</code></li><li>可以直接使用<code>+</code>, <code>=</code>, <code>==</code>等运算符以及其他字符串操作函数</li><li>不需要考虑内存分配操作，避免了显式的<code>new</code>、<code>delete</code>, 以及由此导致的错误</li></ol><p>需要注意的是</p><h3 id="9-5-2-使用新的标准头文件"><a href="#9-5-2-使用新的标准头文件" class="headerlink" title="9.5.2 使用新的标准头文件"></a>9.5.2 使用新的标准头文件</h3><p>使用C++的标准头文件时，请使用<code>&lt;cstdlib&gt;</code>这样的，而不是<code>&lt;stdlib.h&gt;</code></p><h3 id="9-6-1-初始化后不会再修改的成员变量定义为const"><a href="#9-6-1-初始化后不会再修改的成员变量定义为const" class="headerlink" title="9.6.1 初始化后不会再修改的成员变量定义为const"></a>9.6.1 初始化后不会再修改的成员变量定义为<code>const</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> length): <span class="built_in">dataLength_</span>(length)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dataLength_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现代C-since-C-11"><a href="#现代C-since-C-11" class="headerlink" title="现代C++(since C++11)"></a>现代C++(since C++11)</h2><h2 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h2><h3 id="10-1-1-在重写虚函数时请使用override或final关键字"><a href="#10-1-1-在重写虚函数时请使用override或final关键字" class="headerlink" title="10.1.1 在重写虚函数时请使用override或final关键字"></a>10.1.1 在重写虚函数时请使用<code>override</code>或<code>final</code>关键字</h3><p><code>override</code>和<code>final</code>关键字都能保证函数是虚函数，且重写了基类的虚函数。如果子类函数与基类函数圆形不一致，则产生编译错误。<code>final</code>还保证u函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>还保证虚函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现，也可以避免有多个子类时，重写虚函数的修改遗漏。</p><h3 id="10-1-2-使用delete关键字删除函数"><a href="#10-1-2-使用delete关键字删除函数" class="headerlink" title="10.1.2 使用delete关键字删除函数"></a>10.1.2 使用<code>delete</code>关键字删除函数</h3><p>相比于将类成员函数声明为<code>private</code>但不实现， <code>delete</code>关键字更明确，且适用范围更广。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    <span class="comment">///&lt; 只看头文件不知道拷贝构造函数是否被删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 明确删除拷贝赋值符</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，<code>delete</code>关键字还支持删除非成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> Process&lt;<span class="type">void</span>&gt; </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="10-1-3-使用nullptr-而不是NULL或0"><a href="#10-1-3-使用nullptr-而不是NULL或0" class="headerlink" title="10.1.3 使用nullptr, 而不是NULL或0"></a>10.1.3 使用<code>nullptr</code>, 而不是<code>NULL</code>或<code>0</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;   <span class="comment">///&lt; 错误: void* 不能自动转为 char*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span>(C::pmf)() = &amp;C::Func;</span><br><span class="line"><span class="keyword">if</span>(pmf == <span class="literal">NULL</span>) &#123;&#125; <span class="comment">///&lt; 错误： void* 不能自动转换为指向成员函数的指针</span></span><br></pre></td></tr></table></figure><p>如果把<code>NULL</code>定义为<code>0</code>, 或者在需要空指针的地方直接使用<code>0</code>。这样引入了另外的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 无法判断返回的是整数还是空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载也会出现重载的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用F(int)， 而不是F(int*)</span></span><br></pre></td></tr></table></figure><p>另外<code>sizeof(NULL) == sizeof(void*)</code>并不总是成立的。</p><p><code>nullptr</code>的又是不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。<br><code>nullptr</code>是<code>std::nullptr_t</code>类型， 而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 调用F(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 正确的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h2><h3 id="10-1-1-合理使用auto"><a href="#10-1-1-合理使用auto" class="headerlink" title="10.1.1 合理使用auto"></a>10.1.1 合理使用<code>auto</code></h3><ul><li><code>auto</code>可以避免编写冗长、重复的类型名，也可以保证定义变量时初始化</li><li><code>auto</code>类型推导规则复杂，需要仔细理解</li><li>如果能够使代码更清晰，继续使用明确的类型，且旨在局部变量使用<code>auto</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 避免冗长的类型名</span></span><br><span class="line">std::map&lt;std::string, std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 保证初始化</span></span><br><span class="line"><span class="type">int</span> x;  <span class="comment">///&lt; 编译正确，没有初始化</span></span><br><span class="line"><span class="keyword">auto</span> x; <span class="comment">///&lt; 编译失败，没有初始化</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于对象的复制</title>
      <link href="/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>通常我们使用对象内的拷贝构造函数和拷贝构造符来进行初始化和拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        i = other.i;</span><br><span class="line">        vec = other.vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝赋值符</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            i = other.i;</span><br><span class="line">            vec = other.vec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A foo;</span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">(foo)</span></span>; <span class="comment">///&lt; 在这里调用拷贝构造函数</span></span><br><span class="line">A bar2;</span><br><span class="line">bar2 = foo; <span class="comment">///&lt; 这里调用拷贝赋值符</span></span><br></pre></td></tr></table></figure><h2 id="关于memset"><a href="#关于memset" class="headerlink" title="关于memset"></a>关于memset</h2><p>首先说结论，不推荐使用<code>memset</code>对某个对象进行擦写内存。因为可能导致未定义行为。<br>具体可以查看<code>stackflow</code>上的这个问题 <a href="https://stackoverflow.com/questions/2481654/memset-for-initialization-in-c">memset for initialization in C++</a>和<a href="https://stackoverflow.com/questions/6421818/c-use-memset-or-a-struct-constructor-whats-the-fastest">Use memset or a struct constructor? What’s the fastest?</a></p><p>你可以使用构造函数进行初始化，也可以定义成员函数<code>clear()</code>， 或是使用<code>std::fill</code>, <code>std::fill_n</code>。<br>在使用函数<code>memset</code>时，有部分限定条件，只有目标对象为POD类型才可以使用。</p><p>简单来说就是，该对象如果没有继承，都是基础类型(如: <code>int</code>、<code>char</code>或其他<code>POD</code>类型), 没有包含如<code>std::array</code>, <code>std::vector</code>等STL容器, 该对象可以称为<code>POD</code>类型。如下面示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pod</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">12</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>POD</code>具体查看<a href="https://en.cppreference.com/w/cpp/named_req/PODType">C++ named requirements: PODType</a></p><h2 id="关于memcpy"><a href="#关于memcpy" class="headerlink" title="关于memcpy"></a>关于memcpy</h2><p>结论是，不推荐使用，同样除了你能确保该对象为<code>POD</code>类型，否则则会导致未定义现象。<br>可以使用拷贝构造函数或拷贝赋值符，或是<code>std::copy</code>或<code>std::copy_n</code>来代替<code>memcpy</code>;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ POD的介绍</title>
      <link href="/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="POD-plain-old-data-介绍"><a href="#POD-plain-old-data-介绍" class="headerlink" title="POD(plain old data)介绍"></a><code>POD</code>(<code>plain old data</code>)介绍</h2><h3 id="简旧类型-plain-old-data"><a href="#简旧类型-plain-old-data" class="headerlink" title="简旧类型(plain old data)"></a>简旧类型(<code>plain old data</code>)</h3><ul><li>一个标量类型(<code>scalar type</code>)</li><li>简旧类型(POD)数组</li><li>一个符合以下要求的<code>class</code>类型(<code>class</code> or <code>struct</code> or <code>union</code>)<ul><li>C++11以前:<ul><li>是一个聚合类型(<code>aggregate type</code>)</li><li>所有非静态成员都是简旧类型(<code>POD</code>)</li><li>没有成员是引用类型</li><li>没有用户定义的拷贝构造函数</li><li>没有用户定义的析构函数</li></ul></li><li>C++11以后<ul><li>是一个平凡类型(<code>trivial type</code>)</li><li>是一个标准布局类型</li><li>所有非静态成员是简旧类型(<code>POD</code>)</li></ul></li></ul></li></ul><h3 id="POD类型特别在哪里？"><a href="#POD类型特别在哪里？" class="headerlink" title="POD类型特别在哪里？"></a>POD类型特别在哪里？</h3><p><a href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special">What are Aggregates and PODs and how&#x2F;why are they special?</a></p><p>像<code>POD-classes</code>，<code>PD-unions</code>, <code>scalar type</code>和<code>数组</code>这样的类型被统一的叫做<code>POD-types</code>， <code>PODs</code>在很多地方都非常特别。下面一些例子。</p><ul><li><code>POD-classes</code>最接近C语言形式的结构体。不同的是，<code>PODs</code>可以有成员函数和任意静态成员，但他们两者都不能改变对象的内存排布。所以假如你想要写一个或多或少可移植型的可以被C语言甚至<code>.NET</code>使用的动态库，你应该尝试你所有导出的函数和返回值都是<code>POD-types</code>.</li><li>一个<code>non-POD</code>类类型对象的生存周期开始于当构造函数结束，结束于当析构函数结束。对于<code>POD</code>类型类，生命周期开始于内存空间被对象占用，结束于内存空间被释放或者被重用后。</li><li>对于<code>POD</code>类型的对象， 标准保证它当你使用<code>memcpy</code>对你对象中内容转化为<code>char</code>或<code>unsigned</code>数组时，然后<code>memcpy</code>这个内容回到你的对象内，这个对象将持有原始的值。请注意：对于<code>non-POD</code>类型对象没有这样的保证。下面的例子假设类型<code>T</code>是<code>POD</code>类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N sizeof(T)</span></span><br><span class="line"><span class="type">char</span> buf[N];</span><br><span class="line">T obj;  <span class="comment">///&lt; obj initialized to its original value</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;obj, N);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;obj, buf, N);</span><br><span class="line"><span class="comment">/// 保持它的原始值</span></span><br></pre></td></tr></table></figure><ul><li><code>goto</code>语句. 你可能知道，通过goto从一个一些变量还没有在这个作用域中定义的点跳转到一个已经定义的点是非法的（编译器会报错）。这个限制应用在只有当这个变量是一个<code>non-POD</code>类型。看下面例子中<code>f()</code>是语义错误, <code>g()</code>则符合语义。注意，微软编译器在这条规则上特别松散，它在这两个情况下只是抛出一个警告。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">NonPOD</span> &#123;<span class="built_in">NonPOD</span>()&#123;&#125;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  NonPOD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">POD</span>&#123;<span class="type">int</span> i; <span class="type">char</span> c;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  POD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它保证了在<code>POD</code>对象的开始处没有内存填充位。其他情况下，假如一个<code>POD-class： A</code>使一个类型<code>T</code>的第一个成员，你可以安全的使用<code>reinterpret_cast</code>从<code>A*</code>到<code>T*</code>然后获取指向第一个成员的指针，反之亦然。</li></ul><h3 id="补充定义"><a href="#补充定义" class="headerlink" title="补充定义"></a>补充定义</h3><h4 id="标量类型-scalar-type"><a href="#标量类型-scalar-type" class="headerlink" title="标量类型(scalar type)"></a>标量类型(<code>scalar type</code>)</h4><p><code>scalar type</code>是一个不是数组类型或<code>class</code>类型的(可能<code>const</code>或<code>volatile</code>限定的[^2])<code>object</code>类型.<br>英文原文[^1]</p><blockquote><p>scalar types are (possibly cv-qualified) object types that are not array types or class types</p></blockquote><h4 id="聚合类型-aggregate-type"><a href="#聚合类型-aggregate-type" class="headerlink" title="聚合类型(aggregate type)"></a>聚合类型(<code>aggregate type</code>)</h4><p>首先介绍一下<code>聚合类型</code>:<br>聚合类型是以下类型的其中一种[^3]:</p><ul><li>数组类型</li><li><code>class</code>类型(典型的例子, <code>struct</code>, <code>union</code>):<ul><li>没有<code>private</code>和<code>protected</code>非静态数据成员(到C++11)</li><li>没有用户定义的构造函数(显式的默认或删除的构造函数) (C++11起, 到C++17)</li><li>没有用户提供的继承的或显式的构造函数(显式的默认或删除的构造函数)(C++17起，到C++20)</li><li>没有用户定义的或继承的构造函数(C++20起)</li><li>没有基类(C++17之前)， 没有<code>virtual</code>,<code>private</code>,<code>protected</code>基类(C++17起)</li><li>没有虚成员函数</li><li>没有默认成员的初始化器(从C++11到C++14)</li></ul></li></ul><h4 id="平凡类型-TrivialType"><a href="#平凡类型-TrivialType" class="headerlink" title="平凡类型 (TrivialType)"></a>平凡类型 (<code>TrivialType</code>)</h4><p>要求[^4]:</p><ul><li>可平凡复制(<code>TrivialCopyable</code>)</li><li>若该类型是类类型或其数组，则该类拥有一个或多个合格的默认构造函数，均为平凡的</li></ul><h4 id="可平凡可复制-Trivially-Copyable"><a href="#可平凡可复制-Trivially-Copyable" class="headerlink" title="可平凡可复制(Trivially Copyable)"></a>可平凡可复制(<code>Trivially Copyable</code>)</h4><p>下面列举的类型称作平凡可复制类型[^5]:</p><ul><li>标量类型</li><li>平凡可复制的类<ul><li>至少有一个拷贝构造函数，移动构造函数，拷贝赋值符是符合要求的</li><li>每个合格的拷贝构造函数(假如有的话)是平凡的</li><li>每个合格的移动构造函数(假如有的话)是平凡的</li><li>每个合格的拷贝赋值符(假如有的话)是平凡的</li><li>每个合格的移动赋值符(假如有的话)是平凡的</li><li>有一个平凡的没有被删除的析构函数</li></ul></li><li>可平凡复制的数组类型<br>这意味着一个平凡可拷贝的<code>class</code>没有虚函数和虚基类函数。</li></ul><h3 id="参考文献和扩展阅读"><a href="#参考文献和扩展阅读" class="headerlink" title="参考文献和扩展阅读"></a>参考文献和扩展阅读</h3><p>[^1]:<a href="https://stackoverflow.com/questions/14821936/what-is-a-scalar-object-in-c">What is a scalar Object in C++?</a></p><p>[^2]:<a href="https://stackoverflow.com/questions/15413037/what-does-cv-unqualified-mean-in-c">What does “cv-unqualified” mean in C++?</a>, <a href="https://en.cppreference.com/w/cpp/language/cv">cv (const and volatile) type qualifiers</a></p><p>[^3]:<a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">C++ standard: aggregate type</a></p><p>[^4]:<a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">C++ standard: C++ named requirements: TrivialType</a></p><p>[^5]: <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">C++ standard: C++ named requirements: TriviallyCopyable</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UML语法简介</title>
      <link href="/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example.png" alt="generalize_example"></p><p>eg：猫是一种动物；猫与动物之间为泛化关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example(2).png" alt="generalize_example(2)"></p><h2 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h2><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”猫”和”鸟”运动方式不同，它们的运动方式一个为走一个为飞，必须要在派生类”动物”中提供具体实现，那么”猫”和”鸟”对于基类动物来说为实现关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/realize_example.png" alt="realize_example"></p><h2 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h2><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/aggregation_example.png" alt="aggregation_example"></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，<strong>整体和部分不是强依赖的</strong>，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h2 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/composition_example.png" alt="composition_example"></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种<strong>强依赖的特殊聚合关系</strong>，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h2 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h2><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/association_example.png" alt="association_example"></p><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h2 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h2><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/dependency_example.png" alt="dependency_example"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(2)</title>
      <link href="/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
      <url>/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="《Effective-Modern-C-》读书笔记-2"><a href="#《Effective-Modern-C-》读书笔记-2" class="headerlink" title="《Effective Modern C++》读书笔记(2)"></a>《Effective Modern C++》读书笔记(2)</h1><ol><li><p>裸指针在声明中并没有指出，裸指针指涉到的是单个对象还是一个数组。</p></li><li><p>裸指针在声明中也没有提示在使用完指涉到的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象。</p></li><li><p>即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用<code>delete</code>运算符，还是有其他用途。</p></li><li><p>即使知道了使用<code>delete</code>运算符，还是会发生到底应该用的那个对象形式（<code>delete</code>）还是数组形式（<code>delete[]</code>）。</p></li><li><p>即启用够确信，指针拥有其指涉对象，并且也确知应该如何析构，要保证析构在所有代码路径上都仅执行一次（包括那些异常导致的路径）仍然困难重重。只要少在一条路径上执行，就会导致资源泄露。而如果析构在一条路径上执行了多次，则会导致未定义行为。</p></li><li><p>没有什么正规的方式能检测出指针是否空悬，也就是说，它指涉的内存是否已经不再持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然指涉到它，就会产生空悬指针。</p></li></ol><p>在创建对象时注意区分<code>()</code>和<code>&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;  <span class="comment">///&lt; 调用默认构造函数</span></span><br><span class="line">Widget w2 = w1; <span class="comment">///&lt; 调用复制构造函数</span></span><br><span class="line">w1 = w2;  <span class="comment">///&lt; 赋值运算符</span></span><br></pre></td></tr></table></figure><p>大括号可以用来为非静态成员指定默认初始化值，却不能使用小括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 不可行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不可复制的对象可以采用大括号和小括号来进行初始化，却不能使用<code>=</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">///&lt; 不可行</span></span><br></pre></td></tr></table></figure><p>大括号适用所有场合。<br>大括号初始化有一项新特性，就是它禁止内建型别之间进行隐式窄化型别转换。而采用小括号和<code>=</code>的初始化则不会进行窄化型别转换检查，因为如果那样的化就会破坏太多的遗留代码了。</p><p>大括号初始化的另一项值得一提的特征是，它对于C++最令人苦恼之解析语法免疫。C++规定：任何能够解析为声明的都要解析为声明。本来想要以默认方式构造一个对象，结果却一不小心声明了一个函数。这个错误的根本原因构造函数调用语法。<br>当你想要以传参的方式调用构造函数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">///&lt; 调用Widget的构造函数，传入形参10</span></span><br></pre></td></tr></table></figure><p>但你如果试图用相同的语法构造一个没有形参的Widget的话，结果却变成了声明了一个函数而非对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;  <span class="comment">///&lt; 最令人苦恼之解析语法现身</span></span><br></pre></td></tr></table></figure><p>由于函数声明不能使用大括号来指定形参列表，所以使用大括号来完成对象的默认构造上面这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;  <span class="comment">///&lt; 调用没有形参的Widget构造函数</span></span><br></pre></td></tr></table></figure><p>大括号初始化的缺陷在于伴随它有时会出现的意外行为。这种行为源于大括号初始化物、<code>std::initializer_list</code>以及构造函数重载决议之间的纠结。</p><p>如果一个或多个构造函数声明了任何一个具备<code>std::initializer_list</code>型别的形参那么采用了大括号初始化语法的调用语句会强烈地优先选用带有<code>std::initializer_list</code>型别形参的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;  <span class="comment">///&lt; 调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;  <span class="comment">///&lt; 使用最后一个构造函数, 10, true 被强制转化为long double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你的确想要调用一个带有<code>std::initializer_list</code>型别形参的构造函数，并传入一个空的<code>std::initializer_list</code>的话，你可以通过把空大括号对作为构造函数实参的方式实现这个目的，即把一对空大括号放入一对小括号或大括号的方式来清楚地表明你传递地是什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;  <span class="comment">///&lt; 带有std::initializer_list型别形参地构造函数</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;  <span class="comment">///&lt; 同上</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有十个元素，每个元素值都为20的vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有两个元素，值分别为10、20 的vector</span></span><br></pre></td></tr></table></figure><p><code>std::make_unique</code>和<code>std::make_shared</code>在函数内部使用的小括号，作为其接口的一部分。</p><ul><li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫</li><li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有<code>std::initializer_list</code>型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个<code>std::vector&lt;数值型别&gt;</code>对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li></ul><h2 id="理解特种成员函数的生成机制"><a href="#理解特种成员函数的生成机制" class="headerlink" title="理解特种成员函数的生成机制"></a>理解特种成员函数的生成机制</h2><p>两种复制操作是彼此独立的：声明了其中一个，并不会阻止编译器生成另外一个。如果你生成了一个复制构造函数，同时未声明复制赋值运算符，并撰写了要求复制赋值的代码，则编译器会为你生成复制赋值运算符。反过来一样。</p><p>两种移动操作并不彼此独立：声明了其中一个就会阻止编译器生成另外一个。假设你声明了一个移动构造函数，你实际上表明了移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。综上声明一个移动构造函数会阻止编译器去生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器去生成移动构造函数。</p><p>一旦显式声明了赋值操作，这个类也就不再会生成移动操作了。依据在于，声明复制操作的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。从而判定既然按成员复制不适用于赋值操作，则按成员移动极有可能也不适用于移动操作。<br>一旦声明了移动操作，编译器就会删除复制操作。</p><p>三大律：如果你声明了复制构造函数、复制复制运算符，或析构函数中的任何一个，你就得同时声明所有这三个。<br>如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：1. 在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行。 2. 该类的析构函数也会参与到该资源的管理之中。</p><p>大三律的一个推论是，如果存在用户声明的析构函数，则平凡的按成员赋值也不适用于该类。如果声明了析构函数，则复制操作就不该被自动生成，因为他们呢的行为不可能正确。所以在C++11中：只要用户声明了析构函数，就不会生成移动操作。</p><p>移动操作的生成条件（如果需要生成）仅当以下三者同时成立：</p><ul><li>该类未声明任何复制操作</li><li>该类未声明任何移动操作</li><li>该类未声明任何析构操作</li></ul><p>总而言之， C++11中， 支配特种成员函数的机制如下：</p><ul><li>默认构造函数： 仅当类中不包含用户声明的构造函数时才生成</li><li>析构函数：与C++98中基本相同，唯一的区别在于析构函数默认为<code>noexcept</code>.仅当基类的析构函数为虚的，派生类析构函数才是虚的。</li><li>复制构造函数： 按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。</li><li>移动构造函数和移动赋值运算符<br>都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</li></ul><p>成员函数模板的存在会阻止编译器生成任何特种成员函数。</p><ul><li><p>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成</p></li><li><p>复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数时才生成，复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</p></li><li><p>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</p></li><li><p>auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别少打一些字</p></li><li><p>在模板推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</p></li><li><p>对万能引用形参进行推导时，左值实参会进行特殊处理。</p></li><li><p>对按值传递的形参进行推导时，若实参型别中带有<code>const</code>或<code>volatile</code>饰词，则它们还是会被当作不带<code>const</code>或<code>volatile</code>饰词的型别来处理。</p></li><li><p>在模板型别推导过程中， 数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</p></li><li><p>在一般情况下，auto型别推导和模板型推导是一模一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>, 但模板型别推导却不会。</p></li><li><p>在函数返回值或lambda式的形参中使用auto， 意思是使用模板型别推导而非auto型推导。</p></li><li><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的型别而不做任何修改</p></li><li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，<code>decltype</code>总是得出型别<code>T&amp;</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 观察者设计模式</title>
      <link href="/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subscriber</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;subscriber&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">subscriber</span>(<span class="type">const</span> std::string&amp; user_name) : <span class="built_in">user_name_</span>(user_name) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; user_name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string user_name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">boardcast</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = it-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sp) &#123;</span><br><span class="line">        sp-&gt;<span class="built_in">callback</span>(message);</span><br><span class="line">        it++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">regist</span><span class="params">(std::weak_ptr&lt;subscriber&gt; wp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(wp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::weak_ptr&lt;subscriber&gt;&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ob = std::<span class="built_in">make_shared</span>&lt;observer&gt;();</span><br><span class="line">  <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber1&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp1-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber2&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp2-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp3 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber3&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp3-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    <span class="keyword">auto</span> sp4 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber4&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp4-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;start boardcast!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;boardcast again!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 指针与引用</title>
      <link href="/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
      <url>/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-指针与引用"><a href="#C-指针与引用" class="headerlink" title="C++指针与引用"></a>C++指针与引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>可以为空（万恶之首）</li><li>可以做指针的偏移操作</li><li>可以用做修改一个变量</li><li>可以用来用来快速传递一个对象，没有复制的成本(只有指针复制的成本)<br>见下面代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* i)</span> </span>&#123;</span><br><span class="line">  *i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">f1</span>(&amp;num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num为2</span></span><br><span class="line">  <span class="built_in">f2</span>(num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num仍为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>引用同指针一样可以直接修改对象本身，减少传递对象的复制成本</li><li>引用不可为空，即创建必须初始化</li><li>引用不能同指针一样，进行四则运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> &amp;r = i;</span><br><span class="line">  r = <span class="number">1</span>;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为1</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为1</span></span><br><span class="line">  <span class="built_in">f1</span>(r);</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为100</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可见<a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 智能指针简介与错误使用情况</title>
      <link href="/2023/07/21/2020-12-11-C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/"/>
      <url>/2023/07/21/2020-12-11-C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>智能指针是为了更方便的管理内存而设计的，设计思想就是让使用者不再管理内存，而是由智能指针来进行管理。<br>换句话说以后不用再考虑<code>new</code>出来的对象什么时候需要<code>delete</code>，智能指针能帮你管理内存。<br>智能指针分为三种: <code>std::shared_ptr</code>、<code>std::weak_ptr</code>和<code>std::unique_ptr</code>。</p><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><code>std::unique_ptr</code>指针拥有其管理对象的所有权，该智能指针不能被复制，只能被移动。当<code>std::unique_ptr</code>智能指针被析构，则其管理的对象也会被析构。<br>举一个简单的例子，高中宿管大爷，早六点开灯，晚十点关灯，其他人没有办法参与开关灯的事情。这里开关灯指的就是内存的分配与释放。</p><p>用法示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);  <span class="comment">///&lt; 分配一个int的内存，其值为0</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(p);  <span class="comment">///&lt; 使用指针p来创建一个智能指针对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      /// 由于std::unique_ptr对象不可复制，所以下面三句话编译不过</span></span><br><span class="line"><span class="comment">      std::unique_ptr&lt;int&gt; up_copy1(up);</span></span><br><span class="line"><span class="comment">      std::unique_ptr&lt;int&gt; up_copy2;</span></span><br><span class="line"><span class="comment">      up_copy2 = up;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125; <span class="comment">///&lt; 在这个地方智能指针up被析构，up的析构函数对指针p执行delete操作，从而达到智能回收内存的作用</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> up = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>); <span class="comment">///&lt; 这句话等价于上面的两句话</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面看一下<code>std::unique_ptr</code>简单实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJECT&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 构造函数</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(OBJECT* p) : <span class="built_in">p_</span>(p) &#123;&#125;</span><br><span class="line">  <span class="comment">/// 析构函数</span></span><br><span class="line">  ~<span class="built_in">unique_ptr</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(p_ != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> p_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 删除拷贝构造函数, 标识这个类不可拷贝</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&lt;OBJECT&gt;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">/// 删除拷贝构造赋值符, 标识这个类不可拷贝</span></span><br><span class="line">  unique_ptr&lt;OBJECT&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&lt;OBJECT&gt;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">/// 移动构造函数</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; other) &#123;</span><br><span class="line">    p_ = other.p_;</span><br><span class="line">    other.p_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 移动赋值符</span></span><br><span class="line">  <span class="function">unique_ptr&lt;OBJECT&gt;&amp; <span class="title">unique_ptr</span><span class="params">(unique_ptr&amp;&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p_;</span><br><span class="line">    p_ = other.p_;</span><br><span class="line">    other.p_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  OBJECT* p_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>见示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="function">unique_ptr&lt;object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> object)</span></span>;</span><br><span class="line">     <span class="function">unique_ptr&lt;object&gt; <span class="title">other</span><span class="params">(std::move(p))</span></span>;  <span class="comment">///&lt; 调用移动构造函数</span></span><br><span class="line">     <span class="comment">/// 此时other智能指针拥有对象的管理权，而p失去了该对象的管理权</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../resource/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/Snipaste_2020-12-03_15-42-50.png" alt="Snipaste_2020-12-03_15-42-50"></p><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p><code>std::shared_ptr</code>使用引用计数的方法来决定是否需要释放掉管理对象的内存。<br>举一个很简单的例子，办公室中每一个人下班出门前都会看一下还有没有人在办公室中，如果有就直接走掉不关灯，如办公室内没有人了就执行关灯操作。<br>见下面简单实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OBJECT&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 构造函数</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(OBJECT* object):<span class="built_in">p_</span>(object), <span class="built_in">count_</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">    ++(*count_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 析构函数</span></span><br><span class="line">  ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(--(*count_) == <span class="number">0</span>) &#123;  <span class="comment">///&lt; 如果自己是最后一个管理该对象的人，自己被析构时负责做善后工作即delete对象</span></span><br><span class="line">      <span class="keyword">delete</span> p_;</span><br><span class="line">      <span class="keyword">delete</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; other) &#123;</span><br><span class="line">    count_ = other.count_;  <span class="comment">///&lt; 把引用计数的指针复制过来</span></span><br><span class="line">    ++(*count_);  <span class="comment">///&lt; 所有shared_ptr中的count_都自加一下</span></span><br><span class="line">    p_ = other.p_;  <span class="comment">///&lt; 复制管理对象的指针</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝赋值运算符</span></span><br><span class="line">  shared_ptr&lt;OBJECT&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;<span class="keyword">this</span>; <span class="comment">///&lt; 如果复制的对象是自己，则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    count_ = other.count_;  <span class="comment">///&lt; 把引用计数的指针复制过来</span></span><br><span class="line">    ++(*count_);  <span class="comment">///&lt; 所有shared_ptr中的count_都自加一下</span></span><br><span class="line">    <span class="keyword">delete</span> p_;</span><br><span class="line">    p_ = other.p_;  <span class="comment">///&lt; 复制管理对象的指针</span></span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  OBJECT* p_ = <span class="literal">nullptr</span>; <span class="comment">///&lt; 指向管理对象的指针</span></span><br><span class="line">  <span class="type">int</span>* count_ = <span class="literal">nullptr</span>;  <span class="comment">///&lt; 引用计数, 之所以使用指针是为了让管理同一个对象的引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行一下例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;object&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> object)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp1</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp2</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp4</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp5</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp6</span><span class="params">(sp)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/..%5Cresource%5CC++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%5CSnipaste_2020-12-03_10-47-05.png" alt="Snipaste_2020-12-03_10-47-05"><br>\resource\C++智能指针简介与错误使用情况</p><p>可以看到该对象被构造了一次，又被析构了一次。</p><p>上面的实现虽然让内存管理变得简单，但也带来了一些麻烦。<br>由于智能指针拥有了对象的管理权，<strong>万一两个智能指针管理同一对象，那么这两个智能指针在析构时会对同一对象执行两次<code>delete</code>， 从而造成崩溃</strong>。见下面代码举例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    object* p = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="function">shared_ptr&lt;object&gt; <span class="title">sp1</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;object&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码运行会崩溃。因为两个截然不同的智能指针<code>sp1</code>和<code>sp2</code>同时管理了同一个<code>object</code>对象， 它们分别析构时会对指针<code>p</code>，<code>delete</code>两次。<br>所以我们更加推荐使用<code>std::make_shared</code>来代替使用裸指针初始化智能指针。见下面举例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;object&gt; sp = std::<span class="built_in">make_shared</span>&lt;object&gt;();</span><br><span class="line"><span class="comment">/// 代替下面的初始化的方法</span></span><br><span class="line"><span class="comment">/// std::shared_ptr&lt;object&gt; sp = std::shared_ptr&lt;object&gt;(new object);</span></span><br></pre></td></tr></table></figure><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>我们有时会在代码里遇到这样一种情况，见下面代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">error_object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;error_object&gt; <span class="title">get_sp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;error_object&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中<code>get_sp()</code>的函数，目的是想返回一个能够管理自己的智能指针，但是我们可以看到<strong>每调用一次get_sp()，我们都会用同一个指针<code>this</code>, 创建一个不同的智能指针</strong>。<br>这意味着我们调用两次<code>get_sp()</code>函数后，程序运行时会崩溃。</p><p>为了应对这种情况标准库中设计了一个工具函数<code>std::enable_shared_from_this</code>, 具体用法如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">correct_object</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;correct_object&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> instance = std::<span class="built_in">make_shared</span>&lt;correct_object&gt;();</span><br><span class="line">  std::shared_ptr&lt;correct_object&gt; sp1 = instance.<span class="built_in">shared_from_this</span>();</span><br><span class="line">  std::shared_ptr&lt;correct_object&gt; sp2 = instance.<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以正常运行。<br>关于<code>std::enable_shared_from_this</code>的实现原理，见<code>C++ enable_shared_from_this原理与简单实现</code>。</p><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p><code>std::weak_ptr</code>不能被称为一个独立的智能指针，它是<code>std::shared_ptr</code>智能指针的一种扩展。</p><p><code>std::weak_ptr</code>的功能是，观察一个被<code>std::shared_ptr</code>管理的对象, 但不会影响<code>std::shared_ptr</code>的引用计数。</p><p><code>std::weak_ptr</code>可以观察一个对象有没有被释放，或是用来防止<code>std::shared_ptr</code>的循环引用问题。</p><p>下面代码用于检查资源是否已经释放。用于解决裸指针的野指针的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">object</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~object()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::weak_ptr&lt;object&gt; weak;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;object&gt;();</span><br><span class="line">      weak = sp;</span><br><span class="line">      std::shared_ptr&lt;object&gt; sp1 = weak.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span>(sp1)&#123;</span><br><span class="line">         sp1-&gt;<span class="built_in">doSomeThing</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (weak.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;资源没有释放&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;资源已经释放&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码出现了引用回环，会导致智能指针对象被销毁了，但资源没有被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">list_node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;list_node&gt; next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp0 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    sp0-&gt;next = sp1;</span><br><span class="line">    sp1-&gt;next = sp2;</span><br><span class="line">    sp2-&gt;next = sp0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/..%5Cresource%5CC++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%5CSnipaste_2020-12-03_14-50-26.png" alt="Snipaste_2020-12-03_14-50-26"></p><p>我们可以看到该对象的析构函数一个也没有执行，说明内存没有释放。</p><p>我们现在换成<code>std::weak_ptr</code>来保存指向下一个节点的智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">list_node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">list_node</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~list_node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::weak_ptr&lt;list_node&gt; next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp0 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;list_node&gt;();</span><br><span class="line">    sp0-&gt;next = sp1;</span><br><span class="line">    sp1-&gt;next = sp2;</span><br><span class="line">    sp2-&gt;next = sp0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/..%5Cresource%5CC++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%5CSnipaste_2020-12-03_15-00-25.png" alt="Snipaste_2020-12-03_15-00-25"></p><p>现在指针形成的环路被<code>std::weak_ptr</code>完美解决了。内存能够正确释放了。</p><p>实际使用用例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subscriber</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 订阅者被观察器调用的函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123; std::cout &lt;&lt; str &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 广播者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boardcaster</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/// 广播者注册订阅者</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">regist</span><span class="params">(std::shared_ptr&lt;subscriber&gt; sp)</span> </span>&#123; vec.<span class="built_in">push_back</span>(sp); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 广播事件</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">boardcast</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = it-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sp) &#123;</span><br><span class="line">        <span class="comment">/// 让订阅者接受消息</span></span><br><span class="line">        sp-&gt;<span class="built_in">read</span>(str);</span><br><span class="line">        it++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;subscriber is delete!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);  <span class="comment">///&lt; 擦除这个订阅者的指针</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::weak_ptr&lt;subscriber&gt;&gt; vec; <span class="comment">///&lt; 用于保存订阅者的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boardcaster obj;</span><br><span class="line">  <span class="keyword">auto</span> reader0 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt;();</span><br><span class="line">  obj.<span class="built_in">regist</span>(reader0);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> reader1 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt;();</span><br><span class="line">    obj.<span class="built_in">regist</span>(reader1);</span><br><span class="line">    <span class="keyword">auto</span> reader2 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt;();</span><br><span class="line">    obj.<span class="built_in">regist</span>(reader2);</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">boardcast</span>(<span class="string">&quot;start boardcast!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  obj.<span class="built_in">boardcast</span>(<span class="string">&quot;reader1 and reader2 is deleted， boardcast angin!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170">智能指针（现代 C++）</a></p><p><a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html">C&#x2F;C++内存泄漏及检测</a></p><p><a href="https://www.zhihu.com/question/63946754">知乎 C++ 怎么检测内存泄露，怎么定位内存泄露？</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> new new(_NORMAL_BLOCK,__FILE__,__LINE__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">_CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG)|_CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/finding-memory-leaks-using-the-crt-library?view=vs-2022">使用 CRT 库查找内存泄漏</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类内默认成员函数</title>
      <link href="/2023/07/21/2020-12-11-C++%20%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/21/2020-12-11-C++%20%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>C++ 类内默认成员函数</p><p>当我们在创建一个类时， 如果你没有主动定义六个默认函数的话，编译器将为你自动创建。<br>如下面两个类完全等价</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">object</span>(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">object</span>(object&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(object&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面代码示例默认函数的调用场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>; <span class="comment">///&lt; 构造函数 #1</span></span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;  <span class="comment">///&lt; 析构函数 #2</span></span><br><span class="line">  <span class="built_in">object</span>(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>;  <span class="comment">///&lt; 拷贝构造函数 #3</span></span><br><span class="line">  <span class="built_in">object</span>(object&amp;&amp; other) = <span class="keyword">default</span>; <span class="comment">///&lt; 移动构造函数 #4</span></span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> object&amp; other) = <span class="keyword">default</span>; <span class="comment">///&lt; 拷贝赋值符 #5</span></span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(object&amp;&amp; other) = <span class="keyword">default</span>;  <span class="comment">///&lt; 移动赋值符 #6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 构造函数#1示例</span></span><br><span class="line">  object x; <span class="comment">///&lt; 调用默认构造函数#1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 析构函数#2示例</span></span><br><span class="line">  &#123;</span><br><span class="line">    object x2;</span><br><span class="line">  &#125; <span class="comment">///&lt; 超出作用域临时变量x2,调用析构函数#2</span></span><br><span class="line"></span><br><span class="line">  object* p3 = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  <span class="keyword">delete</span> p3;  <span class="comment">///&lt; 调用析构函数#2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝构造函数#3示例</span></span><br><span class="line">  object base;</span><br><span class="line">  <span class="function">object <span class="title">copy1</span><span class="params">(base)</span></span>;  <span class="comment">///&lt; 调用拷贝构造函数 #3</span></span><br><span class="line">  object copy2 = base;  <span class="comment">///&lt; 调用拷贝构造赋值符#3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 移动构造函数#4示例</span></span><br><span class="line">  object base_move;</span><br><span class="line">  <span class="function">object <span class="title">copy_move</span><span class="params">(std::move(base_move))</span></span>; <span class="comment">///&lt; 由于入参为右值, 调用移动构造函数#4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 拷贝构造赋值符#5示例</span></span><br><span class="line">  object base_operator;</span><br><span class="line">  object copy_operator;</span><br><span class="line">  copy_operator = base_operator;  <span class="comment">///&lt; 调用拷贝构造赋值符#5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 移动构造赋值符#6示例</span></span><br><span class="line">  object move_base;</span><br><span class="line">  object move_operator = std::<span class="built_in">move</span>(move_base);  <span class="comment">///&lt; 调用移动构造赋值符#6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>当一个类的析构函数被定为<code>private</code>或是<code>delete</code>时，该类只能构造而无法析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  object1* p = <span class="keyword">new</span> object1; <span class="comment">///&lt; 编译通过</span></span><br><span class="line">  <span class="comment">/// delete p; ///&lt; 编译错误</span></span><br><span class="line">  <span class="comment">/// object1 obj;  ///&lt; 编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个类<code>object2</code>等同于上面<code>object1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="各个默认合成函数的生成关系"><a href="#各个默认合成函数的生成关系" class="headerlink" title="各个默认合成函数的生成关系"></a>各个默认合成函数的生成关系</h2><p>构造析构与拷贝构造与拷贝赋值运算符的默认生成关系</p><p>原则：<br>需要析构函数的类也需要拷贝和赋值操作。<br>需要拷贝和赋值操作函数的类，不一定需要析构函数。<br>需要拷贝操作的类也需要赋值操作，反之亦然。<br>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p><p>原因：</p><p>一个成员有删除的或不可访问的析构函数会导致合成的默认拷贝和拷贝构造函数被定义为删除的，为了防止创建出无法销毁的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ~<span class="built_in">a</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a obj0; <span class="comment">///&lt; 没有默认构造函数, 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于具有引用成员或无法默认构造的<code>const</code>成员的类，编译器不会为其合成默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> i;   <span class="comment">///&lt; 未赋值的 const 变量</span></span><br><span class="line">  <span class="type">int</span>&amp; j;        <span class="comment">///&lt; 未指向的引用变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// a obj0; ///&lt; 没有默认构造函数, 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有<code>const</code>成员，则它不能使用合成的拷贝复制运算符，因为<code>const</code>成员被创建后无法再次赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a obj0;</span><br><span class="line">  a obj1;</span><br><span class="line">  obj0 = obj1;  <span class="comment">///&lt; 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于具有引用成员的类， 其合成拷贝构造函数也是被删除的。因为无法使引用改变指向。</p><p>管理类外资源的类必须定义拷贝控制成员。</p><p>赋值运算符有两个要求：</p><ul><li>如果将一个对象赋予它自身，赋值运算符必须能正常工作。</li><li>大多数赋值运算符组合了析构函数和拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>&#123;</span><br><span class="line">  std::string* p;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> object&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">      p = <span class="keyword">new</span> std::<span class="built_in">string</span>(*other.p);  <span class="comment">///&lt; 当传入对象就是自己时会出错。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，编译器总会为我们合成这些操作，而编译器不会为某些类合成移动操作。特别是，当一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。<br>如果一个类没有移动操作，通过正常的函数匹配，<strong>类会使用对应的拷贝操作来代替移动操作</strong>。</p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时编译器才会为合成移动构造函数或移动赋值运算符。</p><p>与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式要求编译器生成<code>=default</code>的移动操作，且编译器不能移动所有成员移动所有成员，则编译器会将移动操作定义为删除的函数。</p><ul><li><p>与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。</p></li><li><p>类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。</p><p><img src="/%5Cresource%5CC++%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%5CSnipaste_2020-12-07_14-14-02.png" alt="Snipaste_2020-12-07_14-14-02"></p></li><li><p>类似拷贝赋值运算符，如果有类成员是<code>const</code>的或是引用，则类的移动赋值运算符被定义为删除的。</p><p><img src="/%5Cresource%5CC++%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%5CSnipaste_2020-12-07_14-16-31.png" alt="Snipaste_2020-12-07_14-16-31"></p></li></ul><p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地定义为删除的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  object&amp;&amp; <span class="keyword">operator</span>=(object&amp;&amp; other) &#123;&#125;</span><br><span class="line">  <span class="built_in">object</span>(object&amp;&amp; other) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  object obj;</span><br><span class="line">  <span class="keyword">auto</span> obj_copy1 = std::<span class="built_in">move</span>(obj);</span><br><span class="line">  <span class="keyword">auto</span> obj_copy2 = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/%5Cresource%5CC++%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%5CSnipaste_2020-12-07_11-15-47.png" alt="Snipaste_2020-12-07_11-15-47"></p><p>下面代码中<code>#1</code>拷贝构造函数由于接收的是<code>const</code>的引用，所以也能够匹配右值入参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">object</span>(<span class="type">const</span> object&amp; obj) = <span class="keyword">default</span>;  <span class="comment">///&lt; #1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  object obj1;</span><br><span class="line">  <span class="function">object <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有一个拷贝构造函数但未定义移动构造函数时，编译器不会合成移动构造函数。但是函数匹配规则保证该类型的对象会被拷贝，即使我们试图使用<code>std::move</code>来移动他们时也是如此。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">///  默认构造函数</span></span><br><span class="line">  <span class="built_in">a</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">a</span>(<span class="type">const</span> a&amp; other)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a obj0;</span><br><span class="line">  a obj1 = std::<span class="built_in">move</span>(obj0); <span class="comment">///&lt; 此处会调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="特殊成员函数之间的依赖关系"><a href="#特殊成员函数之间的依赖关系" class="headerlink" title="特殊成员函数之间的依赖关系"></a>特殊成员函数之间的依赖关系</h1><p>编译器隐式声明</p><table><thead><tr><th align="center"></th><th align="center"><strong>默认构造函数</strong></th><th align="center"><strong>析构函数</strong></th><th align="center"><strong>拷贝构造函数</strong></th><th align="center"><strong>拷贝赋值</strong></th><th align="center"><strong>移动构造函数</strong></th><th align="center"><strong>移动赋值</strong></th></tr></thead><tbody><tr><td align="center"><strong>全部不声明</strong></td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td></tr><tr><td align="center"><strong>任意构造函数</strong></td><td align="center">不声明</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td></tr><tr><td align="center"><strong>默认构造函数</strong></td><td align="center">用户声明</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td></tr><tr><td align="center"><strong>析构函数</strong></td><td align="center">预置</td><td align="center">用户声明</td><td align="center">预置</td><td align="center">预置</td><td align="center">不声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>拷贝构造函数</strong></td><td align="center">不声明</td><td align="center">预置</td><td align="center">用户声明</td><td align="center">预置</td><td align="center">不声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>拷贝赋值</strong></td><td align="center">预置</td><td align="center">预置</td><td align="center">预置</td><td align="center">用户声明</td><td align="center">不声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>移动构造函数</strong></td><td align="center">不声明</td><td align="center">预置</td><td align="center">弃置</td><td align="center">弃置</td><td align="center">用户声明</td><td align="center">不声明</td></tr><tr><td align="center"><strong>移动赋值</strong></td><td align="center">预置</td><td align="center">预置</td><td align="center">弃置</td><td align="center">弃置</td><td align="center">不声明</td><td align="center">用户声明</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ nullptr与NULL</title>
      <link href="/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/"/>
      <url>/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/</url>
      
        <content type="html"><![CDATA[<h1 id="NULL与nullptr的区别"><a href="#NULL与nullptr的区别" class="headerlink" title="NULL与nullptr的区别"></a>NULL与nullptr的区别</h1><p>NULL为宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure><p>NULL的类型不明显，而一下情况会出现函数重载不明确的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用函数不确定，编译器警告或报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>nullptr</code>是一个特殊类型(<code>nullptr_t</code>)专门用来指代空指针。见下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;  <span class="comment">///&lt; #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125; <span class="comment">///&lt; #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 明确调用#2函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(1)</title>
      <link href="/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/"/>
      <url>/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/</url>
      
        <content type="html"><![CDATA[<h1 id="《Effective-Modern-C-》读书笔记-1"><a href="#《Effective-Modern-C-》读书笔记-1" class="headerlink" title="《Effective Modern C++》读书笔记(1)"></a>《Effective Modern C++》读书笔记(1)</h1><p>在运行期， <code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>(); <span class="comment">///&lt; 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; 非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span>  <span class="comment">///&lt; 右值引用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span> <span class="comment">///&lt; 非右值引用</span></span></span><br></pre></td></tr></table></figure><p><code>T&amp;&amp;</code>有两种不同的含义</p><ol><li>右值引用</li><li>表示既可以是右值引用也可以是左值引用</li></ol><p>万能引用会在两个地方现身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">///&lt; param是个万能引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; var2是个万能引用</span></span><br></pre></td></tr></table></figure><p>而不涉及型别推导<code>&amp;&amp;</code>就是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 不涉及型别推导</span></span><br></pre></td></tr></table></figure><p><code>const</code>关键字也可以确定<code>const T&amp;&amp;</code>是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>在一个模板中的<code>T&amp;&amp;</code>也不一定是万能引用， 见下面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为<code>push_back</code>是<code>vector</code>的成员函数， 如果<code>vector</code>实例存在的话就一定有确定的类型，所以并不存在型别推导。</p><p>另外，声明<code>auto&amp;&amp;</code>都是万能引用。</p><p>针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></p><p>当转发右值引用给其他函数是，应当对其实施向右值的无条件强制型别转换(通过<code>std::move</code>)，因为它们一定绑定到右值，而当转发万能引用时，应当对其实施向右值的有条件强制型别转换(通过<code>std::forward</code>), 因为它们不一定绑定到右值。<br>应当避免针对右值引用实施<code>std::forward</code>。而另一方面，针对万能引用使用<code>std::move</code>的想法更为糟糕，因为那样做的后果是某些左值会遭到意外改动(例如某些临时变量)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(newName);  <span class="comment">///&lt; 可以编译但糟糕透顶</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;  <span class="comment">///&lt; 工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>(); <span class="comment">///&lt; n是个局部变量</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">setName</span>(n); <span class="comment">///&lt; 将n移入了w</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">///&lt; n的值变得未知了</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ... <span class="comment">///&lt; 对w进行操作</span></span><br><span class="line">  <span class="keyword">return</span> w; <span class="comment">///&lt; 没有任何东西被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(w);  <span class="comment">///&lt; 将w移入返回值, 千万不要这么做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RVO</code>(return value optimization): 编译器若要在一个按值返回的函数里省略对局部对象的复制（或者移动）, 则需要满足两个前提条件： 1. 局部对象型别和函数返回值型别相同. 2. 返回的就是局部对象本身。即使实施<code>RVO</code>的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。当<code>RVO</code>的前提条件允许时，要么发生复制省略，要么<code>std::move</code>隐式地被实施于返回的局部对象。</p><ul><li>针对右值引用的最后一次使用实施<code>std::move</code>, 针对万能引用的最后一次使用实施<code>std::forward</code>。</li><li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行动。</li><li>若局部对象可能适用于返回值优化，则请勿针对其实施<code>std::move</code>或<code>std::forward</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::<span class="built_in">is_integral</span>&lt;T&gt;());  <span class="comment">///&lt; std::is_integral不够正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::is_integral&lt;&gt;</code>不够正确是因为如果传给万能引用<code>name</code>实参是个左值，那么<code>T</code>就会被推导为左值引用。因为<code>int&amp;</code>不是<code>int</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美转发的含义是我们不仅转发对象，还转发其显著特征：型别、左值还是右值，以及是否带有<code>const</code>和<code>volation</code>饰词等等。</p><p>大括号初始化物<br>假设<code>f</code>的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std:vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure><p>在此情况下，以大括号初始化物调用<code>f</code>可以通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>但如果把同一大括号初始化物的运用，就是一种完美转发失败的情形。编译器采用推导的手法来取得传递给<code>fwd</code>实参的型别结果，而后它会比较推导型别结果和<code>f</code>声明的形参型别。完美转发会在下面两个条件中的任何一个成立时失败：</p><ul><li>编译器无法为一个或多个<code>fwd</code>的形参推导出型别结果。编译器无法编译通过。</li><li>编译器为一个或多个<code>fwd</code>的形参推导出了”错误的”型别结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(Widget::MinVals); <span class="comment">///&lt; 没问题, 当f(28)处理</span></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals); <span class="comment">///&lt; 错误，无法链接</span></span><br></pre></td></tr></table></figure><p>无法链接的原因是，完美转发，转发的是入参(<code>Widget::MinVals</code>)的引用，而引用在编译器底层是指针实现的。由于<code>static</code>变量并没有被分配实际的地址，所以产生了链接错误。</p><p>完美转发的失败情形还包括：重载的函数名字和模板名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">///&lt; 一个接受函数指针入参的函数f</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 然后调用</span></span><br><span class="line"><span class="built_in">f</span>(processVal);</span><br></pre></td></tr></table></figure><p>上面在调用函数<code>f</code>的时候，其中<code>processVal</code>仅仅只是函数的名字，但编译器知道匹配的是单入参版本的函数。</p><p>而使用完美转发时，编译器是无法知道使用的是什么版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(processVal);  <span class="comment">///&lt; 编译不过</span></span><br></pre></td></tr></table></figure><p>最后一种完美转发失败的情形是位域被用作函数实参的时候。<br>标准中：非<code>const</code>引用不得绑定到位域。既然没有办法创建指涉到任意比特的指针(C++标准规定，可以指涉的最小实体是单个char)，那自然没有办法把引用绑定到任意比特上了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPV4Header</span> &#123;</span><br><span class="line">  std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">  IHL:<span class="number">4</span>,</span><br><span class="line">  DSCP:<span class="number">6</span>,</span><br><span class="line">  ECN:<span class="number">2</span>,</span><br><span class="line">  totalLength:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength); <span class="comment">///&lt; 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(h.totalLength); <span class="comment">///&lt; 错误！</span></span><br></pre></td></tr></table></figure><p>把位域传递给完美转发函数的关键，就是利用转发目的函数接收的总是位域值的副本这一事实。可以自己复制一份，并以该副本调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"><span class="built_in">fwd</span>(length);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ lambda表达式</title>
      <link href="/2020/12/09/2020-12-09-C++%20lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/12/09/2020-12-09-C++%20lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>C++11 中有两种捕获模式： 按引用和按值。按引用的默认捕获模式可能导致空悬引用，按值的默认捕获模式也无法对空悬引用免疫，而且会让你认为你的闭包是独立的(事实上它们可能不是独立的)。</p><p>按引用捕获会导致闭包包含指涉到局部变量的引用，或者指涉到定义<code>lambda</code>式的作用域内的形参的引用。一旦由<code>lambda</code>式所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会空悬。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">  vec.<span class="built_in">push_back</span>([&amp;](<span class="type">int</span> val)&#123; <span class="keyword">return</span> val / divisor;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> lamdba = vec.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">lambda</span>(<span class="number">1</span>);  <span class="comment">///&lt; 此处可能会出现空悬引用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会觉得如果把上面的按引用捕获换为按值捕获这样的空悬引用就不会出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  std::vector&lt;std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;&gt; vec;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>([=](<span class="type">int</span> val)&#123; <span class="keyword">return</span> val / divisor;&#125;);  <span class="comment">///&lt; 这里是引用捕获</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>  divisor = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用捕获只能针对于在创建<code>lambda</code>式的作用域内可见的非静态局部变量（包括形参）；</p><p>上面代码等价于这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>([=](<span class="type">int</span> val)&#123; <span class="keyword">return</span> val / divisor;&#125;);</span><br><span class="line">    <span class="comment">/// 等价于下面这句</span></span><br><span class="line">    <span class="comment">/// vec.push_back([this](int val)&#123; return val / this-&gt;divisor;&#125;);</span></span><br><span class="line">    <span class="comment">/// 默认捕获列表捕获的是this的副本，而不是divisor的副本</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>  divisor = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lambda</code>表达式同样不能捕获<code>static</code>变量， 在<code>lambda</code>表达式中使用<code>static</code>变量只能是按引用。</p><h3 id="lambda-表达式与-std-bind-优先选用lambda"><a href="#lambda-表达式与-std-bind-优先选用lambda" class="headerlink" title="lambda 表达式与 std::bind 优先选用lambda"></a>lambda 表达式与 std::bind 优先选用lambda</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(setAlarm, steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h, _1, <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><p>在创建setSoundB这函数对象的时候，通过<code>std::bind</code>去创建的时候<code>steady_clock::now()</code>已经进行了计算，而不是在调用时刻进行计算，<br>同样在具有函数重载的情况时，<code>std::bind</code>接收的只是函数名称无法参与函数重载的判断，会导致编译不过。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(4)</title>
      <link href="/2020/11/05/2020-11-04-%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/"/>
      <url>/2020/11/05/2020-11-04-%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/</url>
      
        <content type="html"><![CDATA[<h2 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h2><p>屏障的这些操作可以强制内存顺序约束，而无需修改任何数据，并且与使用<code>memory_order_relaxed</code>顺序约束的原子操作组合起来使用。屏障是全局操作，能在执行该屏障的线程里影响其他原子操作的顺序。<br>屏障一般也被称为内存障碍(memory barriers), 它们之所以这样命名, 是因为他们在代码中放置了一行代码，是的特定的操作无法穿越。<br>在独立变量上的松散操作通常可以自由地被编译器或硬件重新排序。屏障限制了这一自由，并且在之前并不存在的地方引入<code>happens-before</code>和<code>synchronizes-with</code>关系。</p><p>松散操作可以使用平常排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_relaxed);</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h2><p>数据结构的线程安全的基本原理</p><ul><li>保证当数据结构不变性被别的线程破坏时的状态不被任何别的线程看到。</li><li>注意避免数据结构结构所固有的竞争现象，通过为完整操作提供函数，而不是提供操作步骤。</li><li>注意当出现例外时，数据结构是怎么样来保证不变性不被破坏。</li><li>当使用数据结构时，通过限制锁的范围和避免使用嵌套锁，来降低产生死锁的机会。</li></ul><p>第二个要考虑的是实现真正的并发读取</p><ul><li>锁的范围能否被限定，使得一个操作的部分可以在锁外被执行？</li><li>数据结构的不同部分能否被不同的互斥元保护？</li><li>能否所有操作需要同样级别的保护？</li><li>数据结构的一个小改变能否在不影响操作语义情况下提高并发机会？</li></ul><h3 id="无锁数据结构："><a href="#无锁数据结构：" class="headerlink" title="无锁数据结构："></a>无锁数据结构：</h3><p>对于有资格称为无锁的数据结构,就必须能够让多于一个线程可以并发的访问此数据结构。这些线程不需要做相同的操作，无所队列可以允许一个线程push的同时，另一个线程pop，到那时如果两个吸纳成同时试图插入新数据的时候，就会打破无锁队列。不仅如此，如果一个访问数据结构的线程在操作中途被调度器挂起的话别的线程必须仍然能够完成操作而无需等待挂起的线程。</p><h4 id="无等待数据结构"><a href="#无等待数据结构" class="headerlink" title="无等待数据结构"></a>无等待数据结构</h4><p>无等待的数据结构是一种无锁的数据结构，并且有着额外的特性，每个访问数据结构的线程都可以在有限数量的步骤内完成它的操作，而不用管别的线程的行为，因为其他线程的冲突而可能卷入无限次重试的算法不是无等待。<br>为了确保每个线程都能够在有限步骤内完成它的操作，就必须保证每个操作都可以在一个操作周期内执行，并且一个线程执行的操作不会导致另一个线程上操作的失败。</p><h4 id="无锁数据结构的优点与缺点"><a href="#无锁数据结构的优点与缺点" class="headerlink" title="无锁数据结构的优点与缺点"></a>无锁数据结构的优点与缺点</h4><p>使用无锁数据结构的最主要的原因就是为了实现最大程度的并发。对于基于锁的容器，总是有可能一个线程必须阻塞，并在可以继续前等待另一个线程完成其操作。互斥元锁的目的就是通过互斥来阻止并发。<br>使用无锁数据结构的第二个原因是健壮性。当一个线程在持有锁的时候终止，哪个数据结构就永远被破坏了。但是如果一个线程在操作无所数据结构时终止了，就不会丢失任何数据。</p><p>因为不使用任何锁，因此无锁数据结构是不会发生死锁的，尽管有可能存在活锁.<br>当两个线程都试图修改数据结构，但是对于每个线程来说，另一个线程所作的修改都会要求此线程的操作重新被执行，因此这两个线程都会一直循环和不断尝试，在这种情况下就会发生活锁。除非某个线程先到达（通过协议，通过更快或完全靠运气）, 不然此循环会一直继续下去。活锁通常是短暂的，因为它们取决于线程的精确调度，因此活锁会降低性能而不会导致长期问题。<br>这就是无锁数据结构的缺点，尽管它可以增加在数据结构上操作的并发能力，并且减少了线程等待的时间，但是它可能降低整体性能。首先，无锁代码使用的原子操作可能比非原子操作要慢很多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    node* next;</span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_) : <span class="built_in">data</span>(data_) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::atomic&lt;node*&gt; head;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span></span>&#123;</span><br><span class="line">    node* <span class="type">const</span> new_node = <span class="keyword">new</span> <span class="built_in">node</span>(data);</span><br><span class="line">    new_node-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(new_node-&gt;next, new_node));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; result)</span></span>&#123;</span><br><span class="line">    node* old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next));</span><br><span class="line">    result = old_head-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; threads_in_pop;</span><br><span class="line">  std::atomic&lt;node*&gt; to_be_deleted;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">try_reclaim</span><span class="params">(node* old_head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threads_in_pop == <span class="number">1</span>) &#123;</span><br><span class="line">      node* nodes_to_delete = to_be_deleted.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (!--threads_in_pop) &#123;</span><br><span class="line">        <span class="built_in">delete_nodes</span>(nodes_to_delete);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodes_to_delete) &#123;</span><br><span class="line">        <span class="built_in">chanin_pending_nodes</span>(nodes_to_delete);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nodes) &#123;</span><br><span class="line">      node* next = nodes-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> nodes;</span><br><span class="line">      nodes = next;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++threads_in_pop;</span><br><span class="line">    node* old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span> (old_head &amp;&amp; !head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next));</span><br><span class="line">    std::shared_ptr&lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">      res.<span class="built_in">swap</span>(old_head-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">try_reclaim</span>(old_head);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(3)</title>
      <link href="/2020/11/04/2020-11-04%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/"/>
      <url>/2020/11/04/2020-11-04%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/</url>
      
        <content type="html"><![CDATA[<h2 id="synchronizes-with关系"><a href="#synchronizes-with关系" class="headerlink" title="synchronizes-with关系"></a>synchronizes-with关系</h2><p><code>synchronizes-with</code> 关系是你只能在原子类型上的操作之间得到的东西。如果一个数据结构包含原子类型，并且在该数据结构上的操作会内部执行适当的原子操作，该数据结构上的操作（如锁定互斥元）可能会提供这种关系，但是从根本上说<code>synchronizes-with</code>关系只出自原子类型上的操作。</p><p>基本思想： 在一个变量<code>x</code>上的一个被适当标记的原子写操作<code>w</code>， 与在<code>x</code>上的一个被适当标记的，通过写入<code>(W)</code>，或是由与执行最初的写操作<code>W</code>相同的线程在<code>x</code>上的后续原子写操作，或是由任意线程在<code>x</code>上一系列的原子的读-修改-写操作（<code>fetch_add()</code>或<code>compare_exchange_weak()</code>）来读取所存储的值的原子读操作同步，其中随后通过第一个线程读取的值是通过<code>W</code>写入的值。<br>换个说法：如果线程A存储一个值而线程B读取该值，那么线程A中存储和线程B中的载入之间存在一种<code>synchronizes-with</code>关系。</p><h2 id="happens-before-关系"><a href="#happens-before-关系" class="headerlink" title="happens-before 关系"></a>happens-before 关系</h2><p><code>happens-before</code>(发生于之前)关系是程序中操作顺序的基本构件，它指定了哪些操作看到其他操作的结果。对于单个线程，它是直观的，如果一个操作排在另一个操作之前，那么该操作就发生于另一个操作之前。这就意味着，如果一个操作（A）发生于另一个操作(B)之前的语句里，那么A就发生于B之前。</p><p>有时候，单条语句中的操作是有顺序的，例如使用内置的逗号操作符或者使用一个表达式的结果作为另一个表达式的参数。<br>但一般来说，单条语句中的操作是非顺序的，而且也没有<code>sequenced-before</code>（因此也没有<code>happens-before</code>）.当然，一条语句的所有操作在下一句的所有操作之前发生。<br>对于多线程中，如果线程间的一个线程上的操作A发生于另一个线程上的操作B之前，那么A发生于B之前。</p><h2 id="原子操作的内存顺序"><a href="#原子操作的内存顺序" class="headerlink" title="原子操作的内存顺序"></a>原子操作的内存顺序</h2><p>有六种内存顺序选项可以应用到原子类型上的操作：</p><ul><li>memory_order_relaxed</li><li>memory_order_consume</li><li>memory_order_acquire</li><li>memory_order_release</li><li>memory_order_acq_rel</li><li>memory_order_seq_cst</li></ul><p>除非你为某个特定的操作做出指定，原子类型上的所有操作的内存顺序选项都是<code>memory_order_seq_cst</code>, 这是最严格的可用选项。</p><p>尽管有六种选项，它们其实代表了三种模型：</p><ul><li>顺序一致(sequentially consistent)顺序(<code>memory_order_seq_cst</code>)</li><li>获得-释放(acquire_release)顺序(<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>和<code>memory_order_acq_rel</code>)</li><li>松散(relaxed)顺序(<code>memory_order_relaxed</code>)<br>这些不同的内存顺序模型在不同的CPU架构上可能有着不同的成本。<br>例如：在基于具有通过处理器而非做更改者对操作的可见性进行良好的控制架构上的系统中，<br>顺序一致的顺序相对于获取-释放顺序或松散顺序，可能会要求额外的同步指令。<br>获取-释放相对于松散顺序，可能会要求额外的同步指令。</li></ul><p>如果这些系统拥有很多处理器，这些额外的同步指令可能占据显著的时间量，从而降低该系统的整体性能。<br>另一方面，为了确保原子性，对于超出需要的获得&#x3D;释放排序，使用x86或x86-64架构的CPU不会要求额外的指令，甚至对于载入操作，顺序一致顺序不需要任何特殊的处理，尽管在存储时会有一点额外的成本。</p><p>不同的内存顺序模型的可用性，允许高手们利用更细粒度的顺序关系来提升性能，在不太关键的情况下，当允许使用默认的顺序一致顺序时，它们是有优势的。</p><h3 id="1-顺序一致顺序"><a href="#1-顺序一致顺序" class="headerlink" title="1. 顺序一致顺序"></a>1. 顺序一致顺序</h3><p>默认的顺序被命名为顺序一致(<code>sequentially consistent</code>), 因为这意味着程序的行为与一个简单的顺序的世界观时一致的。<br>如果所有原子类型实例上的操作时顺序一致的，多线程程序的行为，就好像是所有这些操作由单个线程以某种特定的顺序执行一致的，多线程程序的行为，就好像是所有这些操作由单个线程以某种特定的顺序进行执行一样。<br>这意味着如果你的代码在一个线程中有一个操作在另一个之前，其顺序必须对所有其他的线程可见。<br>从同步的观点来看，顺序一致的存储与读取该存储值的同一个变量的顺序一致载入是同步的。这提供了一种两个（或多个）线程操作的顺序约束，但顺序一致比它更加强大。<br>在使用顺序一致原子操作的系统中，所有在载入后完成的顺序一致原子操作，也必须出现在其他线程的存储之后。该约束并不会推荐使用具有松散内存顺序的原子操作，它们仍然可以看到操作处于不同的顺序，所以你必须在所有的线程上使用顺序一致的操作。<br>但易于理解就产生了代价，在一个带有许多处理器的弱顺序机器上，他可能导致显著的性能惩罚，因为操作的整体顺序必须与处理器之间保持一致，可能需要处理器之间密集且昂贵的同步操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line"></span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">  d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">///&lt; 这里永不触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序一致时最直观和直觉的排序，但也是最昂贵的内存顺序，因为它要求所有线程之间的全局同步。在多处理器系统中，这可能需要处理器之间相当密集和耗时的通信。</p><h3 id="2-非顺序一致的内存顺序"><a href="#2-非顺序一致的内存顺序" class="headerlink" title="2. 非顺序一致的内存顺序"></a>2. 非顺序一致的内存顺序</h3><p>时间不再有单一的全局顺序，这意味着不同的线程可能看到相同的操作的不同方面。你不仅得考虑事情真正的并行发生，而且线程不必和事件的顺序一致。<br>即使线程正在运行完全相同的代码，由于其他线程中的操作没有明确的顺序约束，它们可能与时间的顺序不一致，因为不同的CPU缓存和内部缓冲区可能为相同的内存保存了不同的值。<br>在没有其他的顺序约束时，唯一的要求是所有的线程对每个独立变量的修改顺序达成一致。</p><h3 id="3-松散顺序"><a href="#3-松散顺序" class="headerlink" title="3. 松散顺序"></a>3. 松散顺序</h3><p>以松散顺序执行的原子类型上的操作不参与<code>synchronzes-with</code>关系。单线程中的同一个变量的操作仍然服从<code>happens-before</code>关系，但对于其他线程的顺序几乎没有任何要求。唯一的要求是，从同一个线程对单个原子变量的访问不能被重排，一旦给定的线程看到了原子变量的特定值，该线程之后的读取就不能获取该变量更早的值。<br>在没有任何线程同步的情况下，每个变量的修改顺序时使用<code>memory_order_relaxed</code>的线程之间唯一共享的东西。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line"></span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">///&lt; 可能会触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>assert</code>可以触发，因为x的载入能够读到false，即使y的载入读到了true，并且x的存储发生于y存储之前。x和y是不同的变量，所以关于每个操作所产生的值的可见性没有顺序保证。</p><p>不同变量的松散操作可以被自由地重排前提是它们服从所有约束下的<code>happens-before</code>关系（例如在同一个线程中）。<br>它们并不引入<code>synchronizes-with</code>关系。即便在存储操作中存在<code>happens-before</code>关系，但任一存储和任一载入之间却不存在，所以载入可以在顺序之外看到存储。</p><h3 id="4-获取-释放顺序"><a href="#4-获取-释放顺序" class="headerlink" title="4. 获取-释放顺序"></a>4. 获取-释放顺序</h3><p>获取-释放顺序是松散顺序的进步，操作仍然没有总的顺序，但的确引入了一些同步。在这用顺序模型下，原子载入时获取操作(<code>memory_order_acquire</code>)，原子存储时释放操作(<code>memory_order_release</code>), 原子的读-修改-写操作是获取、释放或两者兼备(<code>memory_order_acq_rel</code>)。同步在进行释放的线程和进行获取的线程之间是对偶的。释放操作与读取写入值的获取操作同步。这意味着，不同的线程仍然可以看到不同的排序，但这些顺序是受到限制的</p><h3 id="5-使用获取-释放顺序和MEMORY-ORDER-CONSUME的数据依赖"><a href="#5-使用获取-释放顺序和MEMORY-ORDER-CONSUME的数据依赖" class="headerlink" title="5. 使用获取-释放顺序和MEMORY_ORDER_CONSUME的数据依赖"></a>5. 使用获取-释放顺序和MEMORY_ORDER_CONSUME的数据依赖</h3><p>有两个处理数据历来的新的关系：依赖顺序在其之前(dependency-ordered-before)和带有对其的以来(carries-a-dependency-to)。<br>与<code>sequenced-before</code>相似，<code>carries-a-dependency-to</code>严格适用于的单个线程之内，是操作间数据以来的基本模型。如果操作A的结果被用于操作B的操作数，那么A带有对B的依赖。如果操作A的结果是类似int的标量类型的值，那么如果A的结果存储一个变量中，并且该变量随后被用作操作B的操作数，此关系也是适用的。这种操作具有传递性，所以如果A带有对B的以来且B带有对C的依赖，那么A带有对C的依赖。</p><p>另一方面，<code>depency-order-before</code>的关系可以适用于线程之间。它是通过使用标记了<code>memory_order_consume</code>的原子载入操作引入的。<br>这是<code>memory_order_acquire</code>的一种特例，它限制了对直接依赖的数据同步。标记为<code>memroy_order_release</code>、<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>的存储操作A的依赖顺序在标记为<code>memory_order_acquire</code>，那么这与<code>synchronizes-with</code>关系所得到的是相反的。如果操作B带有对操作C的某种依赖，那么A也是依赖顺序在C之前。</p><p>如果这对线程间<code>happens-before</code>关系没有影响，那么在同步目的上就无法为你带来任何好处，但它的却实现了：如果A依赖顺序在B之前，则A也是线程间发生于B之前。</p><p>这种内存顺序的一个重要用途，是在原子操作载入指向某数据的指针的场合。通过在载入上使用<code>memory_order_consume</code>以及在之前的存储上使用<code>memory_order_release</code>, 你可以确保所指向的数据得到正确的同步，无需在其他非依赖的数据上强加任何同步需求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  std::string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;X*&gt; p;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X* x = <span class="keyword">new</span> X;</span><br><span class="line">  x-&gt;i = <span class="number">42</span>;</span><br><span class="line">  x-&gt;s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  a.<span class="built_in">store</span>(<span class="number">99</span>, std::memory_order_relaxed);</span><br><span class="line">  p.<span class="built_in">store</span>(x, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X* x;</span><br><span class="line">  <span class="keyword">while</span> (!(x = p.<span class="built_in">load</span>(std::memory_order_consume))) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(x-&gt;i == <span class="number">42</span>);</span><br><span class="line">  <span class="built_in">assert</span>(x-&gt;s == <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="built_in">assert</span>(a.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">99</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(use_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(create_x)</span></span>;</span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ std::visit介绍</title>
      <link href="/2020/11/03/2020-11-03-C++%20visit%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/11/03/2020-11-03-C++%20visit%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>见一个简单的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> d)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">var1</span><span class="params">(<span class="number">42</span>)</span>, <span class="title">var2</span><span class="params">(<span class="number">3.14</span>)</span>, <span class="title">var3</span><span class="params">(<span class="string">&quot;visit&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var1); <span class="comment">// calls operator() for matching int type</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var2); <span class="comment">// calls operator() for matching double type</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var3); <span class="comment">// calls operator() for matching std::string type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看官网给的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the variant to visit</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">var_t</span> = std::variant&lt;<span class="type">int</span>, <span class="type">long</span>, <span class="type">double</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helper type for the visitor #4</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">overloaded</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">var_t</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">15l</span>, <span class="number">1.5</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">    <span class="comment">/// 1. void visitor, only called for side-effects(here, for I/O)</span></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;std::cout &lt;&lt; arg; &#125;, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 2. value-returning visitor, demonstrates the idiom of returning another variant</span></span><br><span class="line">    <span class="type">var_t</span> w = std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg)-&gt;<span class="type">var_t</span> &#123;<span class="keyword">return</span> arg + arg; &#125;, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 3. type-matching visitor: a lambda that that handles each type differently.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;. After doubling, variant holds.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std:<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;int with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">long</span>&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;long with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;double with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;std::string with value &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">static_assert</span>(always_false_v&lt;T&gt;, <span class="string">&quot;non-exhaustive visitor!&quot;</span>);</span><br><span class="line">    &#125;, w);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">    <span class="comment">/// 4. another type-matching visitor: a class with 3 overloaded operator()&#x27;s</span></span><br><span class="line">    std::<span class="built_in">visit</span>(overloaded&#123;</span><br><span class="line">      [](<span class="keyword">auto</span> arg) &#123;std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;,</span><br><span class="line">      [](<span class="type">double</span> arg) &#123;std::cout &lt;&lt; std::fixed &lt;&lt; arg &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;,</span><br><span class="line">      [](<span class="type">const</span> std::string arg) &#123;std::cout &lt;&lt; std::<span class="built_in">quoted</span>(arg) &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;,</span><br><span class="line">      &#125;, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最为核心的代码片段为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="keyword">struct</span> <span class="title class_">overload</span> : Fs... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Fs::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="title">overload</span><span class="params">(Fs...)</span> -&gt; overload&lt;Fs...&gt;</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">visit</span>(overload</span><br><span class="line">&#123;</span><br><span class="line">    [](<span class="type">int</span> x)&#123; ... &#125;,</span><br><span class="line">    [](<span class="type">long</span> x)&#123; ... &#125;,</span><br><span class="line">    [](<span class="keyword">auto</span>...)&#123; ... &#125;</span><br><span class="line">&#125;, v);</span><br></pre></td></tr></table></figure><p>使用宏封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="keyword">struct</span> <span class="title class_">overload</span> :Fs... &#123;<span class="function"><span class="keyword">using</span> <span class="title">Fs::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Fs&gt; <span class="title">overload</span><span class="params">(Fs...)</span>-&gt;overload&lt;Fs...&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matcher</span> &#123;</span><br><span class="line">  std::tuple&lt;Ts...&gt; vs;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Vs&gt; <span class="keyword">constexpr</span> <span class="title">matcher</span><span class="params">(Vs&amp;&amp;... vs)</span> : vs(std::forward&lt;Vs&gt;(vs)...) &#123;</span>&#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Fs</span>&gt; <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>-&gt;*(Fs&amp;&amp; f) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> curry = [&amp;](<span class="keyword">auto</span>&amp;&amp;... vs) &#123;<span class="keyword">return</span> std::<span class="built_in">visit</span>(std::forward&lt;Fs&gt;(f), vs...); &#125;;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">apply</span>(curry, std::<span class="built_in">move</span>(vs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="title">matcher</span><span class="params">(Ts&amp;&amp;...)</span>-&gt;matcher&lt;Ts&amp;&amp;...&gt;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Match(...) matcher&#123;__VA_ARGS__&#125;-&gt;* overload</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt;&gt; vec&#123;<span class="number">1</span>, <span class="number">1.0</span>, <span class="string">&quot;ljslkfjskd&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : vec) &#123;</span><br><span class="line">    <span class="built_in">Match</span>(it) &#123;</span><br><span class="line">      [](<span class="keyword">auto</span>&amp;&amp; x) &#123;std::cout &lt;&lt; <span class="string">&quot;unknow type!&quot;</span> &lt;&lt; std::endl; &#125;,</span><br><span class="line">      [](<span class="type">int</span> x) &#123;std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;,</span><br><span class="line">      [](<span class="type">double</span> x) &#123;std::cout &lt;&lt; <span class="string">&quot;double: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(2)</title>
      <link href="/2020/11/03/2020-11-03%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
      <url>/2020/11/03/2020-11-03%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="《C-并发编程实战》读书笔记-2"><a href="#《C-并发编程实战》读书笔记-2" class="headerlink" title="《C++ 并发编程实战》读书笔记(2)"></a>《C++ 并发编程实战》读书笔记(2)</h1><p>等待一个具有超时条件的条件变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condiiton_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> timeout = std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lk, timeout) == std::cv_status::timeout) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的启动线程的实现，不推荐实际使用， 因为创建一个线程时间成本很高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> A&gt;</span><br><span class="line">std::future&lt;std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type&gt;</span><br><span class="line"><span class="built_in">spawn_task</span>(F&amp;&amp; f, A&amp;&amp; a) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type result_type;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">(A&amp;&amp;)</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line">  <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), std::move(a))</span></span>;</span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>C++程序中的所有数据均是<code>对象(object)</code>组成的。这并不是说你可以创建一个派生自<code>int</code>的新类，或是基本类型具有成员函数。这只是一句关于C++中数据的构造块的一种陈述。C++标准定义对象那个为存储区域，尽管它会为这些对象分配属性，如它们的类型和生存周期。<br>无论什么类型，对象均被存储与一个或多个内存位置中。每个内存位置要么是一个标量类型的对象，比如<code>unsigned short</code>或<code>my_class*</code>, 要么是相邻位域的序列。如果使用位域，有非常重要的一点必须注意：虽然相邻的位域是不同的对象，但他们仍然算作相同的内存位置。</p><ul><li>每个变量都是一个对象，包括其他对象的成员。</li><li>每个对象占据至少一个内存位置。</li><li>如<code>int</code>或<code>char</code>这样的基本类型的变量恰好一个内存位置，不论其大小，即使它们相邻或是数组的一部分。</li><li>相邻的位域是相同内存位置的一部分。</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作是一个不可分割的操作。从系统中的任何一个线程中，你都无法观察到一个完成到一半的这种操作，他要么做完了要么没做完。</p><p>传统意义上，标准原子类型是不可复制且不可赋值的，因为它们没有拷贝构造函数和拷贝赋值运算符。但是，它们确实支持从相应的内置类型的赋值进行隐式转换并赋值。由于他是一个泛型类模板，操作只限为<code>load()</code>、<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。<br>在原子类型上的每一个操作均具有一个可选的内存顺序参数，它可以用来指定所需的内存顺序语义。顺序运算分为三种类型：</p><ul><li>存储（<code>store</code>）操作, 可以包括<code>memory_order_relaxed</code>、<code>memory_order_release</code>或<code>memory_order_seq_cst</code>顺序</li><li>载入(<code>load</code>)操作，可以包括<code>memory_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>或<code>memory_order_seq_cst</code>顺序。</li><li>读-修改-写(<code>read_modify_write</code>)操作， 可以包括<code>memory_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>顺序。<br>所有操作的默认顺序为<code>memory_order_seq_cst</code>。</li></ul><p>使用<code>std::atomic_flag</code>实现一个自旋锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock_mutex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">spinlock_mutex</span>():<span class="built_in">flag</span>(ATOMIC_FLAG_INIT)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  std::atomic_flag flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="根据当前值存储一个新值"><a href="#根据当前值存储一个新值" class="headerlink" title="根据当前值存储一个新值"></a>根据当前值存储一个新值</h2><p>这个新的操作被称为比较&#x2F;交换，它以<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>成员函数形式出现。<br>比较&#x2F;交换操作是是使用原子类型编程的基石，它比较原子变量值和所提供的期望值，<br>如果两者相等，则存储提供的期望值。<br>如果两者不等，则期望值更新为原子变量的实际值。<br>比较&#x2F;交换函数的返回类型为<code>bool</code>, 如果执行了存储即为<code>true</code>, 反之则为<code>false</code>。</p><p>对于<code>compare_exchange_weak()</code>,<br>即使原始值等于期望值也可能出现存储不成功，在这种情况下变量的值是不变的， <code>compare_exchange_weak()</code>的返回值为<code>false</code>。<br>这最有可能发生在缺少单个的比较并交换指令的机器上，此时处理器无法保证该操作被完成–这就是所谓的伪失败，因为失败的原因是时间的函数而不是变量的值。<br>由于<code>compare_exchange_weak()</code>可能会伪失败，它通常必须用在循环中。</p><p>另一方面，仅当实际值不等于<code>expected</code>值时<code>compare_exchange_strong()</code>才保证返回<code>false</code>。这样可以消除对循环的需求。</p><p>如果你想要改变变量，无论其初始值是多少， <code>expected</code>的更新就变得很有用，每次经过循环时，<code>excepted</code>被重新载入，因此如果没有其他线程在此期间修改其值，那么<code>compare_exchange_weak()</code>或<code>compare_exchange_strong()</code>的调用在下一次循环中应该是成功的。</p><p>如果计算待存储的值很简单，为了避免在<code>compare_exchange_weak()</code>可能会伪失败的平台上的双重循环，（于是<code>compare_exchange_strong</code>包含一个循环), 则使用<code>compare_exchange_weak()</code>可能是有好处的。另一方面，<br>如果计算待存储的值本身是耗时的，当<code>expected</code>值没有变化时，使用<code>compare_exchange_strong()</code>来避免被迫重新计算待存储的值可能时有意义的。对于<code>std::atomic&lt;bool&gt;</code>而言这并不重要，毕竟只有两个值，但对于较大的原子类型这会有所不同。</p><p>比较&#x2F;交换函数还有一点非同寻常，他们可以接受两个内存顺序参数。这就允许内存顺序的语义在成功和失败的情况下有所区别。对于一次成功调用具有<code>memory_order_acq_rel</code>语义而一次失败的调用有着<code>memory_order_relaxed</code>语义，这想必是极好的。一次失败的比较&#x2F;交换并不进行存储，因此它无法具有<code>memory_order_release</code>或<code>memory_order_acq_rel</code>语义。因此再失败时禁止提供这些值作为顺序。你也不应为失败提供比成功更严格的内存顺序。如果你希望<code>memory_order_acquire</code>或者<code>memory_order_seq_cst</code>作为失败的语义，你也必须为成功指定这些语义。</p><p>如果你没有为失败指定一个顺序，就会假定它与成功是相同的，除了顺序的<code>release</code>部分被除去：<code>memory_order_release</code>变成<code>memory_order_relaxed</code>, <code>memory_order_acq_rel</code>变成<code>memory_order_acquire</code>。如果你都没有指定，他们它们通常默认为<code>memory_order_seq_cst</code>， 这为成功和失败都提供了完整的序列顺序。以下对<code>compare_exchange_weak()</code>的两个调用时等价的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; b;</span><br><span class="line"><span class="type">bool</span> expected;</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected, <span class="literal">true</span>, memory_order_acq_rel, memory_order_acquire);</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(exprected, <span class="literal">true</span>, memory_order_acq_rel);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 快速排序的实现</title>
      <link href="/2020/11/02/2020-11-02-C++%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/11/02/2020-11-02-C++%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序并行版实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIt&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">quick_sort</span><span class="params">(ForwardIt first, ForwardIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">decltype</span>(std::<span class="built_in">distance</span>(first, last)) temp = <span class="built_in">rand</span>() % std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">  <span class="keyword">auto</span> pivot = *std::<span class="built_in">next</span>(first, temp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> middle1 = std::<span class="built_in">partition</span>(std::execution::par, first, last, [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em)&#123;</span><br><span class="line">    <span class="keyword">return</span> em &lt; pivot;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> middle2 = std::<span class="built_in">partition</span>(std::execution::par, middle1, last, [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em)&#123;</span><br><span class="line">    <span class="keyword">return</span> !(pivot &lt; em);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">quick_sort</span>(first, middle1);</span><br><span class="line">  <span class="built_in">quick_sort</span>(middle2, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用要求：</p><ol><li>必须是前进迭代器</li><li>元素必须是可比较的，或有<code>operator&lt;</code>运算符重载</li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ 并发编程实战》读书笔记(1)</title>
      <link href="/2020/11/02/2020-11-02%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/"/>
      <url>/2020/11/02/2020-11-02%E3%80%8AC++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="《C-并发编程实战》读书笔记-1"><a href="#《C-并发编程实战》读书笔记-1" class="headerlink" title="《C++ 并发编程实战》读书笔记(1)"></a>《C++ 并发编程实战》读书笔记(1)</h1><p>在交换操作中使用<code>std::lock()</code>和<code>std::lock_guard</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd) : <span class="built_in">some_detail</span>(sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(&amp;lhs == &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      std::<span class="built_in">lock</span>(lhs.m, rhs.m);  <span class="comment">///&lt; 这一行执行完后，两个锁都已经加锁了</span></span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, std::adopt_lock)</span></span>; <span class="comment">///&lt; 获取这个锁便于函数执行完毕后再解锁</span></span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, std::adopt_lock)</span></span>;</span><br><span class="line">      <span class="built_in">swap</span>(lhs.some_detail, rhs.some_detail); <span class="comment">///&lt; 交换数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="避免死锁的提示"><a href="#避免死锁的提示" class="headerlink" title="避免死锁的提示"></a>避免死锁的提示</h2><ol><li><p>避免嵌套锁。<br>如果你已经持有一个锁，就别再获取其他锁, 原因很简单因为每个线程仅持有一个锁。如果需要获取多个锁，就使用<code>std::lock()</code>这样单个动作来执行。</p></li><li><p>在持有锁时，避免调用用户提供的代码。<br>因为代码是程序员写的，你不知道它会做什么。如果用户提供的代码也在获取一个锁的话，可能导致死锁。</p></li><li><p>以固定的顺序获取锁<br>如果你绝对需要获取两个或更多的锁，并且不能以<code>std::lock</code>的单个操作取得，次优的做法是在每个线程中以相同的顺序获取它们。<br>见下面例子定义的层级锁。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function">      : hierarchy_value_(value), previous_hierarchy_value_(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @name     lock</span></span><br><span class="line">  <span class="comment">/// @brief    用来锁定自己的函数，</span></span><br><span class="line">  <span class="comment">///           锁定顺序依照本线程中小的数值先锁定，到锁定大的数值</span></span><br><span class="line">  <span class="comment">///           如果顺序反过来则会抛出异常</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// @author   Lijiancong, pipinstall@163.com</span></span><br><span class="line">  <span class="comment">/// @date     2020-02-17 13:22:50</span></span><br><span class="line">  <span class="comment">/// @warning  线程安全</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    internal_mutex_.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value_ = previous_hierarchy_value_;</span><br><span class="line">    internal_mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    <span class="keyword">if</span> (!internal_mutex_.<span class="built_in">try_lock</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex internal_mutex_;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchy_value_;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchy_value_;</span><br><span class="line">  <span class="comment">/// thread_local 变量会在每个线程都有一个实例</span></span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this_thread_hierarchy_value_ &gt;= hierarchy_value_) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previous_hierarchy_value_ = this_thread_hierarchy_value_;</span><br><span class="line">    this_thread_hierarchy_value_ = hierarchy_value_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在交换操作中使用<code>std::lock()</code>和<code>std::unique_lock</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd) : <span class="built_in">some_detail</span>(sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">firend <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(&amp;lhs == &amp; rhs) <span class="keyword">return</span>;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, std::defer_lock)</span></span>;  <span class="comment">///&lt; 获取并延迟(defer)锁定</span></span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, std::defer_lock)</span></span>;</span><br><span class="line">      std::<span class="built_in">lock</span>(lock_a, lock_b);  <span class="comment">///&lt; 锁定两个锁</span></span><br><span class="line">      <span class="built_in">swap</span>(lhs.some_detail, rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>std::call_once</code>的线程安全的类成员延迟初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  connection_info connection_details;</span><br><span class="line">  connection_handle connection;</span><br><span class="line"></span><br><span class="line">  std::once_flag connection_init_flag;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">open_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connection = connection_manager.<span class="built_in">open</span>(connection_details);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(connection_info <span class="type">const</span>&amp; connection_details_) : <span class="built_in">connection_details</span>(conection_details_) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="type">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);</span><br><span class="line">    connection.<span class="built_in">send_data</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> connection.<span class="built_in">receive_data</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>c++11</code>中，初始化被定义在只发生在一个线程上，并且其他线程不可以继续直到初始化完成，所以竞争条件仅仅在于哪个线程会执行初始化，而不会有更多别的问题。对于需要单一全局实例的场合，这可以用作<code>std::call_once</code>的替代品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>;</span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> my_class instance;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>std::condition_variable</code> 等待数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(threadsafe_queue <span class="type">const</span>&amp; other) &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">      data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">      data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">      value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">      data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">      <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">      data_queue.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">      <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU的简单实现</title>
      <link href="/2020/09/21/2020-09-21-C++%20LRU%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/09/21/2020-09-21-C++%20LRU%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LRU的简单实现"><a href="#LRU的简单实现" class="headerlink" title="LRU的简单实现"></a>LRU的简单实现</h2><p>最近最少使用缓存(LRU)，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 最近最少使用缓存(LRU)，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">max_size</span>(capacity) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///  获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(res != map.<span class="built_in">end</span>())&#123;</span><br><span class="line">        list.<span class="built_in">splice</span>(list.<span class="built_in">begin</span>(), list, res-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> res-&gt;second-&gt;second;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">      list.<span class="built_in">push_front</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">      <span class="keyword">if</span>(res != map.<span class="built_in">end</span>())&#123;</span><br><span class="line">        list.<span class="built_in">erase</span>(res-&gt;second);</span><br><span class="line">        map.<span class="built_in">erase</span>(res);</span><br><span class="line">      &#125;</span><br><span class="line">      map[key] = list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(map.<span class="built_in">size</span>() &gt; max_size)&#123;</span><br><span class="line">        <span class="keyword">auto</span> last = list.<span class="built_in">end</span>();</span><br><span class="line">        --last;</span><br><span class="line">        map.<span class="built_in">erase</span>(last-&gt;first);</span><br><span class="line">        list.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::list&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; map;</span><br><span class="line">    std::list&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; list;</span><br><span class="line">    <span class="type">int</span> max_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 跳表简单实现</title>
      <link href="/2020/09/20/2020-09-20-C++%20%E8%B7%B3%E8%A1%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/09/20/2020-09-20-C++%20%E8%B7%B3%E8%A1%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="跳表简单实现"><a href="#跳表简单实现" class="headerlink" title="跳表简单实现"></a>跳表简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">int</span> i, Node *r, Node *d) : <span class="built_in">val</span>(i), <span class="built_in">right</span>(r), <span class="built_in">down</span>(d) &#123;&#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *down;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Skiplist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &lt; target) &#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r_level &lt;= max_level &amp;&amp; (<span class="built_in">rand</span>() &amp; <span class="number">1</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">      ++r_level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r_level &gt; max_level) &#123;</span><br><span class="line">      max_level = r_level;</span><br><span class="line">      head = <span class="keyword">new</span> <span class="built_in">Node</span>(num, <span class="literal">nullptr</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    Node *last = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = max_level; l &gt;= <span class="number">1</span>; --l) &#123;</span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &lt; num) &#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= r_level) &#123;</span><br><span class="line">        cur-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(num, cur-&gt;right, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (last) &#123;</span><br><span class="line">          last-&gt;down = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        last = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = head;</span><br><span class="line">    <span class="type">bool</span> seen = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = max_level; l &gt;= <span class="number">1</span>; --l) &#123;</span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &lt; num) &#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val == num) &#123;</span><br><span class="line">        seen = <span class="literal">true</span>;</span><br><span class="line">        Node *temp = cur-&gt;right;</span><br><span class="line">        cur-&gt;right = cur-&gt;right-&gt;right;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> max_level = <span class="number">0</span>;</span><br><span class="line">  Node *head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 回调函数示例</title>
      <link href="/2020/09/19/2020-09-19-C++%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B/"/>
      <url>/2020/09/19/2020-09-19-C++%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C-回调函数示例"><a href="#C-回调函数示例" class="headerlink" title="C++ 回调函数示例"></a>C++ 回调函数示例</h2><p>简单示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">callback</span>(print);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>Enter: callback()</p><p>print()</p><p>Leave: callback()</p></blockquote><p>接下来我们把这两个函数放入类中实现，在调用的时候绑定函数名和其对应实例就可以按以上例子方法调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller control;</span><br><span class="line">  operation op;</span><br><span class="line">  <span class="comment">/// 绑定实例和对应的操作函数</span></span><br><span class="line">  <span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(&amp;operation::print, &amp;op);</span><br><span class="line">  control.<span class="built_in">callback</span>(f);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们把绑定函数对象的过程封装起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_print_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">bind</span>(&amp;operation::print, <span class="keyword">this</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller control;</span><br><span class="line">  operation op;</span><br><span class="line">  control.<span class="built_in">callback</span>(op.<span class="built_in">get_print_function</span>());</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(7)数据结构</title>
      <link href="/2020/08/31/2020-08-31-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/08/31/2020-08-31-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是不可变字节(<code>byte</code>)序列，其本身是一个符合结构.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  str unsafe.Pointer</span><br><span class="line">  <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头部指针指向字节数组，但没有<code>NULL</code>结尾。默认以<code>UTF-8</code>编码存储<code>Unicode</code>字符，字面量里允许使用十六进制、八进制和<code>UTF</code>编码格式。</p><blockquote><p>内置函数<code>len</code>返回字节数组长度，<code>cap</code>不接受字符串类型参数。</p></blockquote><p>字符串默认值不是<code>nil</code>, 而是<code>&quot;&quot;</code>.</p><p>使用<code>for</code>遍历字符串是，分<code>byte</code>和<code>rune</code>两种方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;<span class="comment">// byte</span></span><br><span class="line">s:=<span class="string">&quot;李建聪&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;<span class="comment">// rune: 返回数组索引号，以及Unicode字符</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///0: [æ]</span></span><br><span class="line"><span class="comment">///1: [</span></span><br><span class="line"><span class="comment">///2: []</span></span><br><span class="line"><span class="comment">///3: [å]</span></span><br><span class="line"><span class="comment">///4: [»]</span></span><br><span class="line"><span class="comment">///5: [º]</span></span><br><span class="line"><span class="comment">///6: [è]</span></span><br><span class="line"><span class="comment">///7: []</span></span><br><span class="line"><span class="comment">///8: [ª]</span></span><br><span class="line"><span class="comment">///0: [李]</span></span><br><span class="line"><span class="comment">///3: [建]</span></span><br><span class="line"><span class="comment">///6: [聪]</span></span><br></pre></td></tr></table></figure><p>要修改字符串，须将其转换为可变类型(<code>[]rune</code>或<code>[]byte</code>), 待完成后再转换回来。但不管怎么转换，都须重新分配内存，并复制数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(format <span class="type">string</span>, ptr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">p := reflect.ValueOf(ptr).Pointer()</span><br><span class="line">h := (*<span class="type">uintptr</span>)(unsafe.Pointer(p))</span><br><span class="line">fmt.Printf(format, *h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;<span class="comment">// byte</span></span><br><span class="line">s:=<span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">pp(<span class="string">&quot;s: %x\n&quot;</span>, &amp;s)</span><br><span class="line"></span><br><span class="line">bs := []<span class="type">byte</span>(s)</span><br><span class="line">s2 := <span class="type">string</span>(bs)</span><br><span class="line"></span><br><span class="line">pp(<span class="string">&quot;string to []byte, bs:%x\n&quot;</span>, &amp;bs)</span><br><span class="line">pp(<span class="string">&quot;[]byte to string, s2:%x\n&quot;</span>, &amp;s2)</span><br><span class="line"></span><br><span class="line">rs := []<span class="type">rune</span>(s)</span><br><span class="line">s3 := <span class="type">string</span>(rs)</span><br><span class="line"></span><br><span class="line">pp(<span class="string">&quot;string to []byte, rs:%x\n&quot;</span>, &amp;rs)</span><br><span class="line">pp(<span class="string">&quot;[]byte to string, s3:%x\n&quot;</span>, &amp;s3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// s: 2bcc91</span></span><br><span class="line"><span class="comment">/// string to []byte, bs:c0000a20a0</span></span><br><span class="line"><span class="comment">/// []byte to string, s2:c0000a20b0</span></span><br><span class="line"><span class="comment">/// string to []byte, rs:c0000b80c0</span></span><br><span class="line"><span class="comment">/// []byte to string, s3:c0000a20d0</span></span><br></pre></td></tr></table></figure><p>编译器会为了某些场合进行专门优化，避免额外分配和复制操作：</p><ul><li>将<code>[]byte</code>转换为<code>string key</code>, 去<code>map[string]</code>查询的时候。</li><li>将<code>string</code>转换为<code>[]byte</code>, 进行<code>for range</code>迭代时，直接取字节赋值给局部变量。</li></ul><p>除了类型转换外，动态构建字符串也容易造成性能问题。<br>用加法操作符拼接字符串时，每次都须重新分配内存。如此，在构建超大字符串时，性能就显得极差。<br>改进思路时预分配i足够大的空间。常用方法是用<code>string.Join</code>函数，他会统计所有参数长度，并一次性完成内存分配操作。<br>另外<br>utf8.ValidString(s) 返回s是不是一个有效的字符串<br>utf8.RuneCountInString(s) 替代<code>len</code>返回<code>unicode</code>的字符数量</p>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(6)方法</title>
      <link href="/2020/08/27/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E6%96%B9%E6%B3%95/"/>
      <url>/2020/08/27/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是与对象实例绑定的特殊函数。<br>方法是面向对象编程的基本概念，用于维护和展示对象的自身状态。对象是内敛的，每个实例都有各自不同的独立特征，以属性和方法来暴露对外通信接口。普通函数则专注于算法流程，通过接收参数来完成特定逻辑运算，并返回最终结果。换句话说，方法是有关联的而函数通常没有。<br>方法和函数定义语法区别，在于前者有前置实例接收参数，编译器以此确定方法所数类型。<br>可以为当前包，以及除接口和指针以外的任何类型定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%#x&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  <span class="built_in">println</span>(a.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// 0x19</span></span><br></pre></td></tr></table></figure><p>方法同样不支持重载(<code>overload</code>)。<code>receiver</code>参数名没有限制，按惯例会选用简短有意义的名称。如方法内部并不引用实例，可省略参数名，仅保留类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span></span> test() &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;hi~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法可看作特殊的函数，那么<code>receiver</code>的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> value() &#123;</span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;v: %p, %v\n&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span></span> pointer() &#123;</span><br><span class="line">  (*n)++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;p: %p, %v\n&quot;</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  a.value()</span><br><span class="line">  a.pointer()</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;a: %p, %v\n&quot;</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// v: 0xc8200741c8, 26 /// receiver 被复制</span></span><br><span class="line"><span class="comment">/// p: 0xc8200741c0, 26</span></span><br><span class="line"><span class="comment">/// a: 0xc8200741c0, 26</span></span><br></pre></td></tr></table></figure><p>可使用实例值或指针调用方法，编译器会根据方法<code>receiver</code>类型自动在基础类型和指针类型间转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  p := &amp;a</span><br><span class="line">  a.value()</span><br><span class="line">  a.pointer()</span><br><span class="line">  p.value()</span><br><span class="line">  p.pointer()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// p2 := &amp;p   错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// v: 0xc82999a2c0, 26</span></span><br><span class="line"><span class="comment">/// p: 0xc82999a298, 26</span></span><br><span class="line"><span class="comment">/// v: 0xc82000a2f0, 27</span></span><br><span class="line"><span class="comment">/// v: 0xc82000a298, 27</span></span><br></pre></td></tr></table></figure><p>指针类型的<code>receiver</code>必须时合法指针(包括<code>nil</code>), 或能获取实例地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *X)</span></span> test() &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;hi!&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a *X</span><br><span class="line">  a.test()  <span class="comment">///相当于test(nil)</span></span><br><span class="line">  X&#123;&#125;.test()  <span class="comment">/// 错误无法获取地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何选择方法的<code>receiver</code>类型：</p><ul><li>要修改实例状态，用<code>*T</code></li><li>无需修改状态的小对象或固定值，建议用<code>T</code></li><li>大对象建议用<code>*T</code>, 以减少复制成本。</li><li>引用类型、字符串、函数等指针包装对象，直接用T。</li><li>若包含<code>Mutex</code>等同步字段，用<code>*T</code>,避免因复制造成锁操作无效</li><li>其他无法确定的情况，都用<code>*T</code></li></ul><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>可以访问匿名字段成员那样调用其方法，有编译器负责查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line">  buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := data()</span><br><span class="line">  d.Lock()  <span class="comment">/// 编译器会处理为 sync.(*Mutex).Lock()调用</span></span><br><span class="line">  <span class="keyword">defer</span> d.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法也会有同名遮蔽问题。但利用这一特性可实现类似(<code>override</code>)操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">  user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun (user) toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m manager)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.user.toString() + <span class="string">&quot;; manager&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> m manager</span><br><span class="line">  <span class="built_in">println</span>(m.toString())</span><br><span class="line">  <span class="built_in">println</span>(m.user.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// user; manager</span></span><br><span class="line"><span class="comment">/// user</span></span><br></pre></td></tr></table></figure><p>尽可能直接访问匿名字段的成员和方法，但他们依然不属于继承关系。</p><h3 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h3><p>类型有一个与之相关的方法集，这决定了它是否实现某个接口。</p><ul><li>类型<code>T</code>方法集包含所有<code>receiver T</code>方法。</li><li>类型<code>*T</code>方法集包含所有<code>recever T</code> + <code>*T</code>方法。</li><li>匿名嵌入<code>S</code>, <code>T</code>方法集包含所有<code>receiver S</code>方法。</li><li>匿名嵌入<code>*S</code>, <code>T</code>方法集包含所有<code>receiver S</code>+<code>*S</code>方法。</li><li>匿名嵌入<code>S</code>或<code>*S</code>, <code>*T</code>方法集包含所有<code>receiver S</code>+<code>*S</code>方法。</li></ul><p>可利用反射测试这些规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">  S <span class="comment">// 匿名嵌入字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span></span> sVal() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*S)</span></span> sPtr() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> tVal() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span></span> tPtr() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodSet</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(a)</span><br><span class="line">  <span class="keyword">for</span> i, n := <span class="number">0</span>, t.NumMethod(); i &lt; n; i++ &#123;</span><br><span class="line">    m := t.Method(i)</span><br><span class="line">    fmt.Println(m.Name, m.Type)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t T</span><br><span class="line">  methodSet(t)  <span class="comment">///&lt; 显示T方法集</span></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;-------&quot;</span>)</span><br><span class="line">  methodSet(&amp;t) <span class="comment">///&lt; 显示*T方法集</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// sVal func(main.T)</span></span><br><span class="line"><span class="comment">/// tVal func(main.T)</span></span><br><span class="line"><span class="comment">/// ---------</span></span><br><span class="line"><span class="comment">/// sPtr func(*main.T)</span></span><br><span class="line"><span class="comment">/// sVal func(*main.T)</span></span><br><span class="line"><span class="comment">/// tPtr func(*main.T)</span></span><br><span class="line"><span class="comment">/// tVal func(*main.T)</span></span><br></pre></td></tr></table></figure><p>方法集影响接口实现和方法表达式转换，于通过实例或实例指针调用方法无关。实例并不使用方法集，而是直接调用(或通过隐式字段名).<br>很显然，匿名字段就是为方法准备的。否则，完全没必要为少写个字段名而大费周折。<br>面向对象的三大特征”封装”,”继承”和”多态”, Go仅仅实现了部分特征，它更倾向于”组合优于继承“这种思想。将模块分解成相互独立的更小单元，分别处理不同方面的需求，最后以匿名嵌入方式组合到一起，共同实现对外接口。而且其简短一致的调用方式，更是隐藏了内部实现细节。</p><blockquote><p>组合没有父子依赖，不会破坏封装。且整体和局部松耦合，可任意增加来实现实现扩展。各单元持有单一职责，互无关联，实现和维护更加简单。</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>方法和函数一样，除直接调用外还可以赋值给变量，或作为参数传递。依照具体引用方式不同，可分为<code>expression</code>和<code>value</code>两种状态。<br>通过类型引用<code>Method expression</code>会被还原为普通函数央视，receiver是第一参数，调用时须显示传参。至于类型，可以是<code>T</code>或<code>*T</code>, 只要目标方法集中即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %d&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %d\n&quot;</span>, &amp;n, n)</span><br><span class="line">  f1 := N.test  <span class="comment">///&lt; func(n N)</span></span><br><span class="line">  f1(n)</span><br><span class="line">  f2 := (*N).test <span class="comment">///&lt; func(n *N)</span></span><br><span class="line">  f2(&amp;n)  <span class="comment">///&lt; 按方法集中的签名传递正确类型的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc82000a140, 25</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a158, 25</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a168, 25</span></span><br></pre></td></tr></table></figure><p>当然，也可直接以表达式方式调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">  N.test(n)</span><br><span class="line">  (*N).test(&amp;n) <span class="comment">///&lt; 注意： *N 须使用括号，以免语法解析错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于实例或指针引用的<code>method value</code>, 参数签名不会改变，依旧按正常方式调用。<br>但当<code>method value</code>被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需的<code>receiver</code>对象，与其绑定，以便在稍后执行时，能隐式传入<code>receiver</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %v\n&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  n++</span><br><span class="line">  f1 := n.test  <span class="comment">//&lt; 因为test方法的reveiver是类型,所以复制n, 等于101</span></span><br><span class="line"></span><br><span class="line">  n++</span><br><span class="line">  f2 := p.test  <span class="comment">///&lt; 复制*p, 等于102</span></span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %v\n&quot;</span>, p, n)</span><br><span class="line">  f1()</span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc829976028, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc820076060, 101</span></span><br><span class="line"><span class="comment">/// test.n: 0xc820076060, 102</span></span><br></pre></td></tr></table></figure><blockquote><p>编译器会为method value生成一个包装函数，实现间接调用。至于<code>receiver</code>复制，和闭包的实现方法基本相同，打包成<code>funcval</code>, 经由<code>DX</code>寄存器传递。</p></blockquote><p>当<code>method value</code>作为参数是，会复制含<code>receiver</code>在内的整个<code>method value</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(m <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">  m()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.h: %p, %v&quot;</span>, p, n)</span><br><span class="line">  n++</span><br><span class="line">  call(n.test)</span><br><span class="line">  n++</span><br><span class="line">  call(p.test)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n 0x82000a288, 100</span></span><br><span class="line"><span class="comment">/// test.n 0x82000a2c0, 101</span></span><br><span class="line"><span class="comment">/// main.n 0x82000a2d0, 102</span></span><br></pre></td></tr></table></figure><p>当然，如果目标方法的<code>receiver</code>是指针类型，那么被复制的仅是指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %v\n&quot;</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  n++</span><br><span class="line">  f1 := n.test  <span class="comment">///&lt; 因为test方法的receiver是*N类型, 所以复制&amp;n</span></span><br><span class="line">  n++</span><br><span class="line">  f2 := p.test  <span class="comment">///&lt; 复制p指针</span></span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %v\n&quot;</span>, p, n)</span><br><span class="line">  f1()  <span class="comment">///&lt; 延迟调用，n == 103</span></span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc82000a298, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a298, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a298, 103</span></span><br></pre></td></tr></table></figure><p>只要receiver参数类型正确，使用<code>nil</code>同样可以执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span></span> value() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*N)</span></span> pointer() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p *N</span><br><span class="line">  p.pointer() <span class="comment">// method value</span></span><br><span class="line">  (*N)(<span class="literal">nil</span>).pointer() <span class="comment">// method value</span></span><br><span class="line">  (*N).pointer(<span class="literal">nil</span>) <span class="comment">// method expression</span></span><br><span class="line">  <span class="comment">/// p.value() 错误： invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 二叉树的遍历</title>
      <link href="/2020/08/26/2020-08-26-C++%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2020/08/26/2020-08-26-C++%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>前序遍历：</p><p>遍历的顺序是：根节点-左节点-右节点</p><p>递归代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">order</span>(root);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      s.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><p>遍历的顺序是：左节点-根节点-右节点</p><p>递归代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">          res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">order</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          s.<span class="built_in">push</span>(root);</span><br><span class="line">          root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><p>遍历的顺序是：左节点-右节点-根节点</p><p>递归代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">          res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">order</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      s.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          s.<span class="built_in">pop</span>();</span><br><span class="line">          res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">          s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;right) s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;left) s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 算法题解</title>
      <link href="/2020/08/26/2020-08-26-C++%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/26/2020-08-26-C++%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="排序操作次数"><a href="#排序操作次数" class="headerlink" title="排序操作次数"></a>排序操作次数</h2><p>题目描述:<br>有一种排序算法定义如下，该排序算法每次把一个元素提到序列的开头，例如2, 1, 3, 4，只需要一次操作把1提到序列起始位置就可以使得原序列从小到大有序。现在给你个乱序的1-n的排列，请你计算最少需要多少次操作才可以使得原序列从小到大有序。<br>输入描述</p><p>输入第一行包含两个正整数n，表示序列的长度。（1 &lt;&#x3D; n &lt;&#x3D; 100000）<br>接下来一行有n个正整数，表示序列中的n个元素，中间用空格隔开。（1 &lt;&#x3D; a_i &lt;&#x3D; n）</p><p>输出描述</p><p>输出仅包含一个整数，表示最少的操作次数。</p><p>样例输入<br>4<br>2 1 3 4</p><p>样例输出<br>1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_operation_count</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">sorted</span><span class="params">(vec)</span></span>;</span><br><span class="line">  std::<span class="built_in">sort</span>(sorted.<span class="built_in">begin</span>(), sorted.<span class="built_in">end</span>());</span><br><span class="line">  <span class="type">int</span> p = sorted.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> q = p;</span><br><span class="line">  <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; q &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">at</span>(p) == sorted.<span class="built_in">at</span>(q)) &#123;</span><br><span class="line">      --p;</span><br><span class="line">      --q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; vec.<span class="built_in">at</span>(p) != sorted.<span class="built_in">at</span>(q)) &#123;</span><br><span class="line">        --p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; vec.<span class="built_in">at</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">get_operation_count</span>(vec) &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(5)接口</title>
      <link href="/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口代表一种调用契约，是多个方法声明的集合。接口最常见的使用场景，是对包外提供访问，或预留扩展空间。<br><code>Go</code>接口的实现机制很简洁，只要目标类型方法集内包含接口声明的全部方法，就被视为实现了该接口，无须做显式声明。当然，目标类型可实现多个接口。<br>接口：</p><ul><li>不能有字段</li><li>不能定义自己的方法</li><li>只能声明方法，不能实现</li><li>可嵌入其他接口类型</li></ul><p>接口通常以<code>er</code>作为名称后缀，方法名是声明组成部分，但参数名可不同或省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  test()</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>() &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// var t tester = d  ///&lt; 错误</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果接口没有任何声明方法声明，那么就是一个空接口, 他的用途类似面向对象的根类型<code>Object</code>, 可被赋值为任何类型的对象。<br>接口变量默认值是<code>nil</code>。如果实现接口的类型支持，可做相等运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t1, t2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == <span class="literal">nil</span>, t1 == t2)</span><br><span class="line"></span><br><span class="line">  t1, t2 = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">  t1, t2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// panic: runtime error: comparing uncomparable type map[string]int</span></span><br></pre></td></tr></table></figure><p>可以像匿名字段一样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算实现了该接口。<br>前提是，不能有同名方法, 不能嵌入自身或循环嵌入，那会导致递归错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  stringer  <span class="comment">///&lt; 嵌入接口</span></span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超集接口变量可隐式转换为子集，反过来不行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(a stringer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(a.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  pp(t) <span class="comment">///&lt; 隐式转换为自己接口</span></span><br><span class="line">  <span class="keyword">var</span> s stringer = t  <span class="comment">///&lt; 超集转换为子集</span></span><br><span class="line">  <span class="built_in">println</span>(s.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持匿名接口类型，可直接用于变量定义，或作为结构字段类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">interface</span> &#123;  <span class="comment">///&lt; 匿名接口类型</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t <span class="keyword">interface</span> &#123; <span class="comment">///&lt; 定义匿名接口变量</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125; = data&#123;&#125;</span><br><span class="line"></span><br><span class="line">  n := node&#123;</span><br><span class="line">    data: t,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println</span>(n.data.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h3><p>接口执行一个名为<code>itab</code>的结构存储运行期所需的相关类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">  tab *itab <span class="comment">///&lt; 类型信息</span></span><br><span class="line">  data unsafe.Pointer <span class="comment">///&lt; 实际对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">  inter *interfacetype  <span class="comment">///&lt; 接口类型</span></span><br><span class="line">  _type *_type  <span class="comment">///&lt; 实际对象类型</span></span><br><span class="line">  fun [<span class="number">1</span>]<span class="type">uintptr</span>  <span class="comment">///&lt; 实际对象方法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关类型信息里保存了接口和实际对象的元数据。同时<code>itab</code>还用<code>fun</code>数组（不定长结构）保存了实际方法地址，从而实现在运行期对目标方法的动态调用。<br>除此之外，接口还有一个重要特征：将对象赋值给接口变量时，会复制该对象。我们甚至无法修改结构存储的复制品，因为它也是<code>unaddressable</code>的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := data&#123;<span class="number">100</span>&#125;</span><br><span class="line">  vat t <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  p := &amp;t.(data)  <span class="comment">///&lt; 错误</span></span><br><span class="line">  t.(data).x = <span class="number">200</span>  <span class="comment">///&lt; 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即便将其复制出来，用本地变量修改后，依然无法对<code>iface.data</code>赋值。解决方法就是将对象指针赋值给接口，那么接口内存存储的就是指针的复制品。<br>只有当接口变量内部的两个指针(<code>itab</code>, <code>data</code>)都为<code>nil</code>时, 接口才等于<code>nil</code>.</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体地接口类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> String() <span class="type">string</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;data:%d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data = <span class="number">15</span></span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> n, ok := x.(fmt.Stringer); ok &#123;  <span class="comment">///&lt; 转换为更具体地接口类型</span></span><br><span class="line">    fmt.Println(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> d2, ok := x.(data); ok &#123; <span class="comment">///&lt; 转换回原始类型</span></span><br><span class="line">    fmt.Println(d2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e := x.(<span class="type">error</span>)  <span class="comment">///&lt; 错误： main.data is not error</span></span><br><span class="line">  fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>ok-idiom</code>模式，即便转换失败也不会引发<code>panic</code>。还可用<code>switch</code>语句在多种类型间做出推断匹配，这样空接口就有更多发挥空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;d:%d&quot;</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> v := x(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">      <span class="built_in">println</span>(*v)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">string</span>:</span><br><span class="line">      <span class="built_in">println</span>(v(<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">case</span> fmt.Stringer:</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// d: 100</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： <code>type switch</code>不支持<code>fallthrought</code></p></blockquote><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>让编译器检查，确保类型实现了指定接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> x <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">///&lt; 包初始函数</span></span><br><span class="line">  <span class="keyword">var</span> _ fmt.Stringer = x(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数类型，让相同签名地函数自动实现某个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncString <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t fmt.Stringer = FuncString(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt. Println(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(4)并发</title>
      <link href="/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>并发： 逻辑上具备同时处理多个任务的能力。</li><li>并行： 物理上在同一时刻执行多个并发任务。<br>多线程或多进程时并行的基本条件，但单线程也可用协程做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，它也有自己的优势。除了将因阻塞而浪费的时间找回来以外，还免去了线程切换的开销。协程上运行的多个任务本质上是依旧串行的，加上可控自主，所以并不需要做同步处理。<br>通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源。用协程来提高处理器时间片利用率。</li></ul><p>简单将<code>goroutine</code>归纳为协程并不合适。运行时创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。这更像是多线程和协程的综合体，能最大限度提升执行效率，发挥多核处理能力。<br>只须在函数调用前添加<code>go</code>关键字即可创建并发任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(s)</span><br><span class="line">&#125; (<span class="string">&quot;hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>关键字<code>go</code>并非执行并发操作，而是创建一个并发任务单元。新建任务被放置在系统队列中，等待调度器安排合适系统线程去获取执行权。当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。</p><p>每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间。相比系统默认<code>MB</code>级别的线程栈，<code>goroutinue</code>自定义栈初始仅须<code>2 KB</code>，所以才能创建成千上万的并发任务。自定义栈采取按需分配策略，在需要时进行扩容，最大能到<code>GB</code>规模。<br>与<code>defer</code>一样，<code>gorountine</code>也会因”延迟执行”而立即计算并复制执行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">c++</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">100</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;go:&quot;</span>, x, y)</span><br><span class="line">&#125;(a, counter())</span><br><span class="line">a += <span class="number">100</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main:&quot;</span>, a, counter())</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)<span class="comment">// 等待 `goroutine` 结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main: 200 2</span></span><br><span class="line"><span class="comment">/// go: 100 1</span></span><br></pre></td></tr></table></figure><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>进程退出时不会等待并发任务结束，可用管道(<code>channel</code>)阻塞，然后发出退出信号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)<span class="comment">///&lt; 创建通道。因为仅是通知，数据并没有实际意义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;goroutine done.&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(exit)<span class="comment">///&lt; 关闭通道</span></span><br><span class="line">&#125; ()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">&lt;-exit<span class="comment">///&lt; 如通道关闭，立即解除阻塞</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><p>除关闭通道外，写入数据也可解除阻塞。<br>如要等待多个任务结束，推荐使用<code>sync.WaitGroup</code>。通过设定计数器，让每个<code>goroutine</code>在退出前递减，直至归零时接触阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)<span class="comment">///&lt; 累加计数</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()<span class="comment">///&lt; 递减计数</span></span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;goroutine&quot;</span>, id, <span class="string">&quot;done.&quot;</span>)</span><br><span class="line">&#125; (i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">wg.Wait()<span class="comment">///&lt; 阻塞，直到计数为零</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine 2 done.</span></span><br><span class="line"><span class="comment">/// goroutine 3 done.</span></span><br><span class="line"><span class="comment">/// goroutine 7 done.</span></span><br><span class="line"><span class="comment">/// goroutine 9 done.</span></span><br><span class="line"><span class="comment">/// goroutine 6 done.</span></span><br><span class="line"><span class="comment">/// goroutine 0 done.</span></span><br><span class="line"><span class="comment">/// goroutine 8 done.</span></span><br><span class="line"><span class="comment">/// goroutine 4 done.</span></span><br><span class="line"><span class="comment">/// goroutine 1 done.</span></span><br><span class="line"><span class="comment">/// goroutine 5 done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><p>尽管<code>WaitGroup.Add</code>实现了原子操作，但建议在<code>goroutine</code>外累加计数器，以免<code>Add</code>尚未执行，<code>Wait</code>已经退出。<br>可在多处使用<code>Wait</code>阻塞，他们都能接收到通知</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()<span class="comment">///&lt; 等待归零，解除阻塞</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;wait exit.&quot;</span>)</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done.&quot;</span>)</span><br><span class="line">wg.Done()<span class="comment">///&lt; 递减计数</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()<span class="comment">///&lt; 等待归零</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// done.</span></span><br><span class="line"><span class="comment">/// wait exit.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><h3 id="GOMAXPROCE"><a href="#GOMAXPROCE" class="headerlink" title="GOMAXPROCE"></a>GOMAXPROCE</h3><p>运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量默认与处理器核数相等，可用<code>runtime.GOMAXPROCS</code>函数(或环境变量)修改。</p><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h3><p>与线程不同，<code>goroutine</code>任务无法设置优先级，无法获取编号，没有局部存储(TLS), 甚至连返回值都会被抛弃。但除优先级外，其他功能都很容易实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> gs [<span class="number">5</span>]<span class="keyword">struct</span> &#123;<span class="comment">///&lt; 用于实现类似TLS功能</span></span><br><span class="line">id <span class="type">int</span><span class="comment">///&lt; 编号</span></span><br><span class="line">result <span class="type">int</span><span class="comment">///&lt; 返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gs); i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;<span class="comment">// 使用参数避免闭包延迟求值</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">gs[id].id = id</span><br><span class="line">gs[id].result = (id + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, gs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [&#123;id:0 result:100&#125; &#123;id:1 result:200&#125; &#123;id:2 result:300&#125; &#123;id:3 result:400&#125; &#123;id:4 result:500&#125;]</span></span><br></pre></td></tr></table></figure><blockquote><p>如使用<code>map</code>作为局部存储容器，建议做同步处理，因为运行时会对其做并发读写检查。</p></blockquote><h3 id="Gosched"><a href="#Gosched" class="headerlink" title="Gosched"></a>Gosched</h3><p>暂停，释放线程去执行其他任务。当前任务被放回队列，等待下次调度时恢复执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;<span class="comment">/// 让出当前线程，调度执行b</span></span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-exit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0</span></span><br><span class="line"><span class="comment">/// a: 1</span></span><br><span class="line"><span class="comment">/// b</span></span><br><span class="line"><span class="comment">/// a: 2</span></span><br><span class="line"><span class="comment">/// a: 3</span></span><br></pre></td></tr></table></figure><h3 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h3><p><code>Goexit</code>立即终止当前任务，运行时确保所有已注册延迟调用被执行。该函数不会影响其他并发任务，不会引发<code>panic</code>, 自然也就无法捕获。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(exit)<span class="comment">///&lt; 执行</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)<span class="comment">///&lt; 执行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>, <span class="built_in">recover</span>() == <span class="literal">nil</span>)<span class="comment">///&lt; 执行，recover返回nil</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">///&lt; 在多层调用中执行Goexit</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">runtime.Goexit()<span class="comment">///&lt; 立即终止整个调用堆栈</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;c done.&quot;</span>)</span><br><span class="line">&#125; ()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;b done.&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;a done.&quot;</span>)<span class="comment">///&lt; 不会执行</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-exit</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// c</span></span><br><span class="line"><span class="comment">/// b true</span></span><br><span class="line"><span class="comment">/// a</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure><p>如果在<code>main.main</code>里调用<code>Goexit</code>, 它会等待其他任务结束，然后让进程直接崩溃。<br>无论身处哪一层，<code>Goexit</code>都能立即终止整个调用堆栈，这与<code>return</code>仅退出当前函数不同。标准库函数<code>os.Exit</code>可终止进程，但不会执行延迟调用。</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p><code>Go</code>语言并未实现严格的并发安全。<br>允许全局变量、指针、引用类型这些非安全内存共享操作，就需要开发人员自行维护数据一致和完整性。<code>Go</code>鼓励使用<code>CSP</code>通道，以通信来代替内存共享，实现并发安全。</p><blockquote><p>CSP: Communicating Sequential Process</p></blockquote><p>通过消息来避免竞态的模型除了<code>CSP</code>, 还有<code>Actor</code>。但两者由较大区别<br>作为<code>CSP</code>核心，通道(channel)是显式的，要求操作双方必须知道数据类型和具体通道，并不关心另一端操作者身份和数量。可如果另一端未准备妥当，或消息未能及时处理时，会阻塞当前端。<br>相比起来，<code>Actor</code>是透明的，它不在乎数据类型及通道，只要知道接收者信箱即可。默认就是异步方式，发送方对消息是否被接收和处理并不关心。</p><p>从底层实现上来说，通道知识一个队列。同步模式下，发送和接受双方配对，然后直接赋值数据给对方。如配对失败，则置入等待队列，直到另一方出现后才被唤醒。异步模式抢夺的则是数据缓冲槽。发送方要求有空槽可供写入，而接收方则要求有缓冲数据可读。需求不符时，同样加入缓冲队列，直到有另一方写入数据或腾出空槽后被唤醒。<br>除传递消息（数据）外，通道还常被用做事件通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := &lt;-<span class="keyword">chan</span><span class="comment">///&lt; 接收消息</span></span><br><span class="line"><span class="built_in">println</span>(s)</span><br><span class="line"><span class="built_in">close</span>(done)<span class="comment">///&lt; 关闭通道，作为结束通知</span></span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="string">&quot;hi!&quot;</span> <span class="comment">///&lt; 发送消息</span></span><br><span class="line">&lt;-done<span class="comment">///&lt; 阻塞，直到有数据或管道关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步模式必须有配对操作的<code>goroutine</code>出现，否则会一直阻塞。而异步模式在缓冲区未满或数据未读完前，不会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)  <span class="comment">///&lt; 创建带3个缓冲槽的异步通道。</span></span><br><span class="line">  c &lt;- <span class="number">1</span>  <span class="comment">///&lt; 缓冲区未满，不会阻塞</span></span><br><span class="line">  c &lt;- <span class="number">2</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br></pre></td></tr></table></figure><p>多数时候，异步通道有助于提升性能，减少排队阻塞。<br>缓冲去大小仅是内部属性，不属于类型组成部分。另外通道变量本身就是指针，可用相等操作符判断是否为同一对象或<code>nil</code>。<br>内置函数<code>cap</code>和<code>len</code>返回缓冲区大小和当前已缓冲数量；而对于同步通道则都返回0；据此可判断通道时同步还是异步</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  b &lt;- <span class="number">1</span></span><br><span class="line">  b &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;b:&quot;</span>, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0 0</span></span><br><span class="line"><span class="comment">/// b: 2 3</span></span><br></pre></td></tr></table></figure><h3 id="收发"><a href="#收发" class="headerlink" title="收发"></a>收发</h3><p>除使用简单的发送和接受操作符外，还可用<code>ok-idom</code>或<code>range</code>模式处理数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)<span class="comment">///&lt; 确保发出结束通知</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">x, ok := &lt;-c</span><br><span class="line"><span class="keyword">if</span> !ok &#123;<span class="comment">///&lt; 据此判断通道是否被关闭</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line">c &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(c)<span class="comment">///&lt; 及时使用`close`函数关闭通道引发结束通知，否则可能会导致死锁。</span></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="comment">/// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>一次性事件用<code>close</code>效率更好，没有多余开销。连续或多样性事件，可传递不同数据标志实现。还可使用<code>sync.Cond</code>实现单播或广播事件。</p></blockquote><p>对于<code>closed</code>或<code>nil</code>通道，发送和接收操作都有相应规则：</p><ul><li>向已关闭通道发送数据，引发<code>panci</code></li><li>从已关闭接收数据，返回已缓冲数据或零值。</li><li>无论收发，<code>nil</code>通道都会阻塞。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  c &lt;- <span class="number">10</span></span><br><span class="line">  c &lt;- <span class="number">20</span></span><br><span class="line">  <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(c)+<span class="number">1</span>; i++ &#123;</span><br><span class="line">    x, ok := &lt;-c</span><br><span class="line">    <span class="built_in">println</span>(i, <span class="string">&quot;:&quot;</span>, ok, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复关闭或关闭<code>nil</code>通道都会引发<code>panic</code>错误。</p><h3 id="单向"><a href="#单向" class="headerlink" title="单向"></a>单向</h3><p>通道默认时双向的，并不区分发送和接收端。<br>尽管可用<code>make</code>创建单向通道，但那没有任何意义。通常使用类型装欢来获取单向通道，并分别赋予操作双方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> recv &#123;</span><br><span class="line">      <span class="built_in">println</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      send &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在单向通道上做逆向操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  &lt;-send  <span class="comment">///&lt; 无效操作</span></span><br><span class="line">  recv &lt;- <span class="number">1</span> <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，close不能用于接收端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;- <span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line">  <span class="built_in">close</span>(recv) <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无法将单向通道重新转换回去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">  a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = a</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = a</span><br><span class="line"></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(recv)  <span class="comment">/// 错误</span></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(send)  <span class="comment">/// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>如要同时处理多个通道，可选用<code>select</code>语句。它会随机选择一个可用通道做收发操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">///&lt; 接收端</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">x<span class="type">int</span></span><br><span class="line">ok <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;<span class="comment">///&lt; 随机选择可用 channel 接收数据</span></span><br><span class="line"><span class="keyword">case</span> x, ok = &lt;-a:</span><br><span class="line">name = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">case</span> x, ok = &lt;-b:</span><br><span class="line">name = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ok &#123;<span class="comment">///&lt; 如果任一通道关闭，则终止接收</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(name, x)<span class="comment">///&lt; 输出接收的数据信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">///&lt; 发送端</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(a)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(b)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> a &lt;- i:</span><br><span class="line"><span class="keyword">case</span> b &lt;- i*<span class="number">10</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a 0</span></span><br><span class="line"><span class="comment">/// b 10</span></span><br><span class="line"><span class="comment">/// a 2</span></span><br><span class="line"><span class="comment">/// a 3</span></span><br><span class="line"><span class="comment">/// a 4</span></span><br><span class="line"><span class="comment">/// a 5</span></span><br><span class="line"><span class="comment">/// b 60</span></span><br><span class="line"><span class="comment">/// a 7</span></span><br><span class="line"><span class="comment">/// a 8</span></span><br><span class="line"><span class="comment">/// a 9</span></span><br></pre></td></tr></table></figure><p>如要等全部通道消息处理结束(closed),可将已完成通道设置为<code>nil</code>。这样它就会被阻塞，不再被<code>select</code>选中。<br>即使是同一通道，也会随机选择<code>case</code>执行。</p><p>当所有通道都不可用时，<code>select</code>会执行<code>default</code>语句。如此可避开<code>select</code>阻塞，但须注意处理外层循环，以免陷入空耗。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>通常使用工厂方法将<code>goroutine</code>和通道绑定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> receiver <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.WaitGroup</span><br><span class="line">  data <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newReceiver</span><span class="params">()</span></span> * receiver &#123;</span><br><span class="line">  r := &amp;receiver&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  r.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> r.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> r.data&#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;recv:&quot;</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := newReceiver()</span><br><span class="line">  r.data &lt;- <span class="number">1</span></span><br><span class="line">  r.data &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(r.data) <span class="comment">///&lt; 关闭通道，发出结束通知</span></span><br><span class="line">  r.Wait()  <span class="comment">///&lt; 等待接收者处理结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于通道本身就是一个并发安全的队列，可用作<code>ID generator</code>、<code>Pool</code>等用途。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type pool chan []<span class="function">byte</span></span><br><span class="line"><span class="function">func <span class="keyword">new</span> <span class="title">Pool</span><span class="params">(cap <span class="type">int</span>)</span> pool </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(chan []byte, cap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">get</span>() []byte &#123;</span><br><span class="line">  var v []byte</span><br><span class="line"></span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> v = &lt;-p: <span class="comment">///&lt; 获取</span></span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 获取失败，则创建</span></span><br><span class="line">      v = <span class="built_in">make</span>([]byte, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">put</span>(b []byte) &#123;</span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> p &lt;- b:</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 放回失败，放弃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用通道实现信号量(semaphore)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>) <span class="comment">///&lt; 最多允许两个并发同时执行</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">///&lt; acquire: 获取信号</span></span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem&#125;() <span class="comment">///&lt; release: 释放信号</span></span><br><span class="line">      time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">      fmt.Println(id, time.Now())</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库<code>time</code>提供了<code>timeout</code>和<code>tick channel</code>实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second*<span class="number">5</span>):</span><br><span class="line">          fmt.Println(<span class="string">&quot;timeout ...&quot;</span>)</span><br><span class="line">          os.Exit(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">          fmt.Println(time.Now())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  &lt;-(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)  <span class="comment">// 直接用nil channel阻塞进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获<code>INT</code>、<code>TERM</code>信号，顺便实现一个简易的<code>atexit</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exits = &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.RWMutex</span><br><span class="line">  <span class="function"><span class="keyword">func</span> []<span class="title">func</span><span class="params">()</span></span></span><br><span class="line">  signals <span class="keyword">chan</span> os.Signal</span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atexit</span><span class="params">(f <span class="keyword">func</span>()</span></span>)&#123;</span><br><span class="line">  exits.Lock()</span><br><span class="line">  <span class="keyword">defer</span> exits.Unlock()</span><br><span class="line">  exits.funcs = <span class="built_in">append</span>(exits.funcs, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> exits.signals == <span class="literal">nil</span> &#123;</span><br><span class="line">    exits.signals = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(exits.signals, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">  &#125;</span><br><span class="line">  exits.RLock()</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> exits.funcs &#123;</span><br><span class="line">    <span class="keyword">defer</span> f() <span class="comment">///&lt; 即使某些函数panic,延迟调用也能确保后续函数执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  exits.RUnlock()</span><br><span class="line">  &lt;-exit.signals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit1 ...&quot;</span>)&#125;)</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit2 ...&quot;</span>)&#125;)</span><br><span class="line">  waitExit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源泄露"><a href="#资源泄露" class="headerlink" title="资源泄露"></a>资源泄露</h3><p>通道可能会引发<code>goroutine leak</code>, 确切的说，是指<code>goroutine</code>处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致他们会在等待队列里长久休眠形成资源泄露。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>标准库<code>sync</code>提供了互斥和读写锁，另有原子操作等，可基本满足日常开发需要。<code>Mutex</code>、<code>RWMutex</code>的使用并不复杂，只有几个地方需要注意。<br>将<code>Mutex</code>作为匿名字段时，相关方法必须实现为<code>pointer-receiver</code>, 否则会因赋值导致锁机制失效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> test(s <span class="type">string</span>) &#123;</span><br><span class="line">d.Lock()</span><br><span class="line"><span class="keyword">defer</span> d.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="built_in">println</span>(s, i)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d data</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">d.test(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">d.test(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁不支持递归锁。</li><li>对性能要求较高时，应避免使用<code>defer Unlock</code></li><li>读写并发时，用<code>RWMutex</code>性能会更好一些</li><li>对单个数据读写保护，可尝试用原子操作</li><li>执行严格的测试，尽可能打开数据竞争检查</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(3)工作空间</title>
      <link href="/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/"/>
      <url>/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p>依照规范，工作空间由<code>src</code>、<code>bin</code>、<code>pkg</code>三个目录组成。通常需要将空间路径添加到<code>GOPATH</code>环境变量列表中, 以便相关工具能正常工作。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- service/</span><br><span class="line">  |          |</span><br><span class="line">  |          +-- user.go</span><br><span class="line">  |</span><br><span class="line">  +-- bin/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server</span><br><span class="line">  |</span><br><span class="line">  +-- pkg/</span><br><span class="line">       |</span><br><span class="line">       +-- linux_amd64/</span><br><span class="line">            |</span><br><span class="line">            +-- service.a</span><br></pre></td></tr></table></figure><p>在工作空间里，包括子包在内的所有源码文件都保存在<code>src</code>目录下。至于<code>bin</code>、<code>pkg</code>两个目录， 其主要影响 <code>go install/get</code>命令，他们会将编译结果(可执行文件或静态库)安装到这两个目录下，以实现增量编译。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>编译器等相关工具按<code>GOPATH</code>设置的路径搜索目标。也就是说在导入目标库时，排在列表前面的路径比当前工作空间优先级更高。另外，<code>go get</code>默认将下载的第三方包保存到列表中第一个工作空间内。</p><p>环境变量<code>GOPATH</code>用于指示工具链和标准库的存放位置。在生成工具链时，相关路径就已经嵌入到可执行文件内，故无需额外设置。<br>除通过设置<code>GOROOT</code>环境变量覆盖内部路径外，还可移动目录(改名、符号链接等), 或重新编译工具链来解决。<br>至于<code>GOBIN</code>, 则是强制替代工作空间的<code>bin</code>目录，作为<code>go install</code>目标保存路径。这可避免将所有工作空间的<code>bin</code>路径添加到<code>PATH</code>环境变量当中。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>使用标准库或第三方包前，须用<code>import</code>导入，参数是工作空间中以<code>src</code>为起始的绝对路径。编译器从标准库开始搜索，然后依次搜索<code>GOPATH</code>列表中的各个工作空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span> <span class="comment">// 实际路径: /usr/local/go/src/net/http</span></span><br></pre></td></tr></table></figure><p>除使用默认包名外，还可使用别名，以解决同名冲突问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> osx <span class="string">&quot;github.com/apple/osx/lib&quot;</span></span><br><span class="line"><span class="keyword">import</span> nix <span class="string">&quot;github.com/linux/lib&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>import</code>导入参数是路径，而非包名。尽管习惯将包和目录名保持一致，但这不是强制规定。在代码中引用包成员时，使用包名而非目录名。</p></blockquote><p>有四种不同的导入方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>    <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 默认方式: test.A</span></span><br><span class="line"><span class="keyword">import</span> X  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 别名方式: X.A</span></span><br><span class="line"><span class="keyword">import</span> .  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 简便方式: A</span></span><br><span class="line"><span class="keyword">import</span> _  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 初始化方式: 无法引用，仅用来初始化目标包。</span></span><br></pre></td></tr></table></figure><blockquote><p>不能直接或间接导入自己，不支持任何形式的循环导入。</p></blockquote><p>未使用的导入(不包括初始化方式)会被编译器视为错误。</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>除工作空间和绝对路径外，部分工具还支持相对路径。可在非工作空间目录下，直接运行、编译一些测试代码。<br>但在设置了<code>GOPATH</code>的工作空间后相对路径会导致编译失败。<code>go run</code>不受影响。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>包内每个源码文件都可定义一到多个初始化函数，但编译器不保证执行次序。<br>实际上，所有这些初始化函数(包括标准库和导入的第三方包)都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且仅执行一次。</p><p>编译器首先确保完成所有全局变量初始化，然后才开始执行初始化函数。直到这些全部结束后，运行时才正式进入<code>main.main</code>入口函数。<br>可在初始化函数中创建<code>goroutine</code>，或等到它结束执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    fmt.Println(<span class="string">&quot;init:&quot;</span>, time.Now)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  &#125; ()</span><br><span class="line"></span><br><span class="line">  &lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main: &quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在多个初始化函数中引用全局变量，那么最好在变量定义处直接赋值。因无法保证执行次序，所以任何初始化函数中的赋值都有可能”延迟无效”。</p><h3 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h3><p>内部包机制相当于增加了新的访问权限控制：所有保存在<code>internal</code>目录下的包(包括自身)仅能被其父目录下的包(包含所有子目录) 访问。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- lib/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- internal/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- a/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- b/</span><br><span class="line">  |         +-- x/</span><br><span class="line">  |             |</span><br><span class="line">  |             +-- y/</span><br><span class="line">  |</span><br></pre></td></tr></table></figure><p>在<code>lib</code>目录外(比如<code>main.go</code>)导入内部包会引发编译错误。</p><blockquote><p>导入内部包必须使用完整路径， 例如： import “lib&#x2F;internal&#x2F;a”</p></blockquote><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>如何使用<code>vendor</code>，专门存放第三方包，实现将源码和依赖完整打包分发。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- vendor/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- github.com/</span><br><span class="line">  |         |              |</span><br><span class="line">  |         |              +-- mercy1101/</span><br><span class="line">                                  |</span><br><span class="line">                                  +-- test/</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/Mercy1101/test&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  test.Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>main.go</code>中导入<code>github.com/mercy1101/test</code>时，优先使用<code>vendor/github.com/mercy1101/test</code></p></blockquote><p>导入<code>vendor</code>中的第三方包，参数是以<code>vendor/</code>为起点的绝对路径。这避免了<code>vendor</code>目录位置带来的麻烦，让导入无论使用<code>vendor</code>,还是<code>GOPATH</code>都能保持一致。</p><blockquote><p>注意：<code>vendor</code>优先级比标准库高</p></blockquote><p>当多个<code>vendor</code>目录嵌套时，匹配规则如下:<br>从当前源文件所在目录开始，逐级向上构造<code>vendor</code>全路径，直到发现路径匹配的目标为止。匹配失败，则依旧搜索<code>GOPATH</code></p><p>要使用<code>vendor</code>机制，须开启<code>GO15VENDOREXPERIMENT=1</code>环境变量开关(Go 1.6默认开启),且必须设置了<code>GOPATH</code>的工作空间。</p><blockquote><p>使用<code>go get</code>下载第三方包时，依旧使用<code>GOPATH</code>第一个工作空间，而非<code>vendor</code>目录。当前工具链中并没有真正意义上的包依赖管理，好在由不少第三放工具可选。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(2)反射</title>
      <link href="/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射能让我们能在运行期探知对象的类型信息和内存结构，同时反射还是实现元编程的重要手段。<br>Go对象头部并没有类型指针，通过自身是无法在运行期获知任何类型相关信息的。反射操作所需的全部信息都源自接口变量。接口变量除自身存储自身类型外，还会保存实际对象的类型数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure><blockquote><p>这两个反射入口函数，会将任何传入的对象转换为接口类型。</p></blockquote><p>在面对类型是，需要区分<code>Type</code>和<code>Kind</code>。前者表示真实类型(静态类型), 后者表示器接触接口(底层类型)类别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X = <span class="number">100</span></span><br><span class="line">  t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">  fmt.Println(t.Name(), t.Kind())</span><br><span class="line">  <span class="comment">/// 输出：X int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := reflect.ArrayOf(<span class="number">10</span>, reflect.TypeOf(<span class="type">byte</span>(<span class="number">0</span>)))</span><br><span class="line">  b := reflect.MapOf(reflect.TypeOf(<span class="string">&quot;&quot;</span>), reflect.TypeOf(<span class="number">0</span>))</span><br><span class="line">  fmt.Println(a, m)</span><br><span class="line">  <span class="comment">/// 输出: [10]uint8 map[string]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>Elem</code>返回指针、数组、切片、字典值或通道的基类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(reflect.TypeOf(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;).Elem())</span><br><span class="line">  fmt.Println(reflect.TypeOf([]<span class="type">int32</span>&#123;&#125;).Elem())</span><br><span class="line">  <span class="comment">/// 输出： int int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在获取结构体指针的基类型后，才能遍历它的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">user</span><br><span class="line">title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m manager</span><br><span class="line">t := reflect.TypeOf(&amp;m)</span><br><span class="line"><span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">t = t.Elem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">f := t.Field(i)</span><br><span class="line">fmt.Println(f.Name, f.Type, f.Offset)</span><br><span class="line"><span class="keyword">if</span> f.Anonymous &#123;</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; f.Type.NumField(); x++ &#123;</span><br><span class="line">af := f.Type.Field(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;  &quot;</span>, af.Name, af.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// user main.user 0</span></span><br><span class="line"><span class="comment">///  name string</span></span><br><span class="line"><span class="comment">///   age int</span></span><br><span class="line"><span class="comment">/// title string 24</span></span><br></pre></td></tr></table></figure><p>对于匿名字段，可用多级索引（按定义顺序）直接访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m manager</span><br><span class="line">t := reflect.TypeOf(m)</span><br><span class="line">name, _ := t.FieldByName(<span class="string">&quot;name&quot;</span>)<span class="comment">///&lt; 按名称查找</span></span><br><span class="line">fmt.Println(name.Name, name.Type)</span><br><span class="line"></span><br><span class="line">age := t.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;)<span class="comment">///&lt; 按多级索引查找</span></span><br><span class="line">fmt.Println(age.Name, age.Type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// name string</span></span><br><span class="line"><span class="comment">/// age int</span></span><br></pre></td></tr></table></figure><blockquote><p><code>FieldByName</code>不支持多级名称，如有同名遮蔽，须通过匿名字段二次获取</p></blockquote><p>反射能探知当前包或外包的非导出结构成员</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s http.Server</span><br><span class="line">t := reflect.TypeOf(s)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">fmt.Println(t.Field(i).Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// Addr</span></span><br><span class="line"><span class="comment">/// Handler</span></span><br><span class="line"><span class="comment">/// TLSConfig</span></span><br><span class="line"><span class="comment">/// ReadTimeout</span></span><br><span class="line"><span class="comment">/// ReadHeaderTimeout</span></span><br><span class="line"><span class="comment">/// WriteTimeout</span></span><br><span class="line"><span class="comment">/// IdleTimeout</span></span><br><span class="line"><span class="comment">/// MaxHeaderBytes</span></span><br><span class="line"><span class="comment">/// TLSNextProto</span></span><br><span class="line"><span class="comment">/// ConnState</span></span><br><span class="line"><span class="comment">/// ErrorLog</span></span><br><span class="line"><span class="comment">/// BaseContext</span></span><br><span class="line"><span class="comment">/// ConnContext</span></span><br><span class="line"><span class="comment">/// inShutdown</span></span><br><span class="line"><span class="comment">/// disableKeepAlives</span></span><br><span class="line"><span class="comment">/// nextProtoOnce</span></span><br><span class="line"><span class="comment">/// nextProtoErr</span></span><br><span class="line"><span class="comment">/// mu</span></span><br><span class="line"><span class="comment">/// listeners</span></span><br><span class="line"><span class="comment">/// activeConn</span></span><br><span class="line"><span class="comment">/// doneChan</span></span><br><span class="line"><span class="comment">/// onShutdown</span></span><br></pre></td></tr></table></figure><blockquote><p>相对<code>reflect</code>而言，当前包和外包都是”外包”</p></blockquote><p>可用反射提取<code>struct tag</code>, 还能自动分解。其常用于ORM映射, 或数据格式验证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span> <span class="string">`field:&quot;name&quot; type:&quot;varchar(50)&quot;`</span></span><br><span class="line">age <span class="type">int</span><span class="string">`field:&quot;age&quot; type:&quot;int&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">f := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %s %s\n&quot;</span>, f.Name, f.Tag.Get(<span class="string">&quot;field&quot;</span>), f.Tag.Get(<span class="string">&quot;type&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: name varchar(50)</span></span><br><span class="line"><span class="comment">/// age: age int</span></span><br></pre></td></tr></table></figure><p>辅助判断方法<code>Implements</code>、<code>ConvertibleTo</code>、<code>AssignableTo</code> 都是运行期进行动态调用和赋值所必需的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a X</span><br><span class="line">t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implements 不能直接使用类型作为参数，导致这种用法特别别扭</span></span><br><span class="line">st := reflect.TypeOf((*fmt.Stringer)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">fmt.Println(t.Implements(st))</span><br><span class="line"></span><br><span class="line">it := reflect.TypeOf(<span class="number">0</span>)</span><br><span class="line">fmt.Println(t.ConvertibleTo(it))</span><br><span class="line"></span><br><span class="line">fmt.Println(t.AssignableTo(st), t.AssignableTo(it))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true false</span></span><br></pre></td></tr></table></figure><h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>和<code>Type</code>获取类型信息不同， <code>Value</code>专注于对象实例数据读写<br>接口变量会赋值对象，且时<code>unaddressable</code>的，所以要修改对象就必须使用指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">100</span></span><br><span class="line">  va, vp := reflect.ValueOf(a), reflect.ValueOf(&amp;a).Elem()</span><br><span class="line"></span><br><span class="line">  fmt.Println(va.CanAddr(), va.CanSet())</span><br><span class="line">  fmt.Println(vp.CpnAddr(), va.CanSet())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// false false</span></span><br><span class="line"><span class="comment">/// true true</span></span><br></pre></td></tr></table></figure><blockquote><p>就算传入指针，一样需要通过<code>Elem</code>获取目标对象。因为被接口存储的指针本身时不能寻址和进行设置操作的。</p></blockquote><p>注意：不能对非导出字段进行设置操作，无论是当前包还是外包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">code <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := <span class="built_in">new</span>(User)</span><br><span class="line">v := reflect.ValueOf(p).Elem()</span><br><span class="line">name := v.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">code := v.FieldByName(<span class="string">&quot;code&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;name: canaddr = %v, canset = %v\n&quot;</span>, name.CanAddr(), name.CanSet())</span><br><span class="line">fmt.Printf(<span class="string">&quot;code: canaddr = %v, canset = %v\n&quot;</span>, code.CanAddr(), code.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name.CanSet() &#123;</span><br><span class="line">name.SetString(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> code.CanAddr() &#123;</span><br><span class="line">*(*<span class="type">int</span>)(unsafe.Pointer(code.UnsafeAddr())) = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, *p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: canaddr = true, canset = true</span></span><br><span class="line"><span class="comment">/// code: canaddr = true, canset = false</span></span><br><span class="line"><span class="comment">/// &#123;Name:Tom code:100&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Value.Pointer</code>和<code>Value.Int</code>等方法类似，将<code>Value.data</code>存储的数据转换为指针，目标必须是指针类型。<br>而<code>UnsafeAddr</code>返回任何<code>CanAddr Value.data</code>地址（相当于&amp;取地址操作）,比如<code>Elem</code>后的<code>Value</code>, 以及字段成员地址。<br>以结构体里的指针类型字段为例，<code>Pointer</code>返回该字段所保存的地址，而<code>UnsafeAddr</code>返回该字段本身的地址(结构对象地址+偏移量)</p></blockquote><p>可通过<code>Interface</code>方法进行类型推断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := user&#123;</span><br><span class="line"><span class="string">&quot;q.yuhen&quot;</span>,</span><br><span class="line"><span class="number">60</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(&amp;u)</span><br><span class="line"><span class="keyword">if</span> !v.CanInterface() &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;CanInterface: fail.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p, ok := v.Interface().(*user)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Interface: fail.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.Age++</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// &#123;Name:q.yuhen Age:61&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以直接使用<code>Value.Int</code>、<code>Bool</code>等方法进行类型转换，但失败时会引发<code>panic</code>, 且不支持<code>ok-idiom</code></p></blockquote><p>复合类型对象设置示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">  v := reflect.ValueOf(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> v.TrySend(reflect.ValueOf(<span class="number">100</span>)) &#123;</span><br><span class="line">    fmt.Println(v.TryRecv())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 100 true</span></span><br></pre></td></tr></table></figure><p>接口有两种<code>nil</code>状态，这一致是个潜在麻烦。解决方法是用<code>IsNil</code>判断值是否为<code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(a == <span class="literal">nil</span>)</span><br><span class="line">  fmt.Println(b == <span class="literal">nil</span>, reflect.ValueOf(b).IsNil())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false true</span></span><br></pre></td></tr></table></figure><p>也可用<code>unsafe</code>转换后直接判断<code>iface.data</code>是否是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">  iface := (*[<span class="number">2</span>]<span class="type">uintptr</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">  fmt.Println(iface, iface[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// &amp;[712160 0] true</span></span><br></pre></td></tr></table></figure><p>让人很无奈的是, <code>Value</code>里的某些方法并未实现<code>ok-idom</code>或返回<code>error</code>, 所以得自行判断返回的是否为<code>Zero Value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  v := reflect.ValueOf(<span class="keyword">struct</span>&#123;name <span class="type">string</span>&#125;)</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;name&quot;</span>).IsValid())</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;xxx&quot;</span>).IsValid())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false</span></span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>动态调用方法，谈不上有多麻烦。只须按<code>In</code>列表准备好所需参数即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Test(x, y <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y, fmt.Errorf(<span class="string">&quot;err: %d&quot;</span>, x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X</span><br><span class="line">  v := reflect.ValueOf(&amp;a)</span><br><span class="line">  m := MethodByName(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  in := []reflect.Value &#123;</span><br><span class="line">    reflect.ValueOf(<span class="number">1</span>),</span><br><span class="line">    reflect.ValueOf(<span class="number">2</span>),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out := m.Call(in)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> out &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="comment">/// err: 3</span></span><br></pre></td></tr></table></figure><p>对于变参来书，用<code>CallSlice</code>要更方便一些</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Format(s <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(s, a...)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a X</span><br><span class="line">   v := reflect.ValueOf(&amp;a)</span><br><span class="line">   m := v.MethodByName(<span class="string">&quot;Format&quot;</span>)</span><br><span class="line">   out := m.Call([]reflect.Value&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;x&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;100&quot;</span>),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"></span><br><span class="line">   out = m.CallSlice([]reflect.ValueP&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf([]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;x&quot;</span>, <span class="number">100</span>&#125;),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br></pre></td></tr></table></figure><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>反射库提供了内置函数<code>make</code>和<code>new</code>的对应操作，其中最有意思的就是<code>MakeFunc</code>。可用它实现通用模板，使用不同数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args []reflect.Value)</span></span> (results []reflect.Value) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret reflect.Value</span><br><span class="line">  <span class="keyword">switch</span> args[<span class="number">0</span>].Kind() &#123;</span><br><span class="line">  <span class="keyword">case</span> reflect.Int:</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">      n += <span class="type">int</span>(a.Int())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = reflect.ValueOf(n)</span><br><span class="line">  <span class="keyword">case</span> reflect.String:</span><br><span class="line">    ss := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> args &#123;</span><br><span class="line">      ss = <span class="built_in">append</span>(ss, s.String())</span><br><span class="line">    &#125;</span><br><span class="line">    ret = reflect.ValueOf(strings.Join(ss, <span class="string">&quot;&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  results = <span class="built_in">append</span>(results, ret)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将函数指针参数指向通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAdd</span><span class="params">(fptr <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  fn := reflect.ValueOf(fptr).Elem()</span><br><span class="line">  v := reflect.MakeFunc(fn.Type(), add) <span class="comment">// 这是关键</span></span><br><span class="line">  fn.Set(v) <span class="comment">// 指向通用算法函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> intAdd <span class="function"><span class="keyword">func</span><span class="params">(s, y <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> strAdd <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  makeAdd(&amp;intAdd)</span><br><span class="line">  makeAdd(&amp;strAdd)</span><br><span class="line">  <span class="built_in">println</span>(intAdd(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">  <span class="built_in">println</span>(strAdd(<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot;world!&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 300</span></span><br><span class="line"><span class="comment">/// hello, world!</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言学习笔记》读书笔记(1)测试</title>
      <link href="/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="11-测试"><a href="#11-测试" class="headerlink" title="11. 测试"></a>11. 测试</h2><p>标准库自带单元测试框架</p><ul><li>测试代码须放在当前包以”_test.go”结尾的文件中</li><li>测试函数以Test为名称前缀</li><li>测试命令(go test) 忽略以”_” 或 “.” 开头的测试文件</li><li>正常编译操作(go build&#x2F;install)会忽略测试文件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">x<span class="type">int</span></span><br><span class="line">y<span class="type">int</span></span><br><span class="line">expect<span class="type">int</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">actual := add(tt.x, tt.y)</span><br><span class="line"><span class="keyword">if</span> actual != tt.expect &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;add(%d, %d): expect %d, actual %d&quot;</span>, tt.x, tt.y, tt.expect, actual)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">t.Parallel()</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">t.Parallel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>-arg</td><td>命令行参数</td><td></td></tr><tr><td>-v</td><td>输出详细信息</td><td></td></tr><tr><td>-parallel</td><td>并发执行, 默认执行GOMAXPROCS</td><td>-parallel 2</td></tr><tr><td>-run</td><td>指定测试函数，正则表达式</td><td>-run “Add”</td></tr><tr><td>-timeout</td><td>全部测试累计时间超时将引发panic, 默认值为10ms</td><td>-timeout 1m30s</td></tr><tr><td>-count</td><td>重复测试次数，默认次数为1</td><td></td></tr></tbody></table><h3 id="test-main"><a href="#test-main" class="headerlink" title="test main"></a>test main</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span>&#123;</span><br><span class="line"><span class="comment">// setup</span></span><br><span class="line">code := m.Run()<span class="comment">// 调用测试函数</span></span><br><span class="line"><span class="comment">// tear down</span></span><br><span class="line">os.Exit(code)<span class="comment">// 注意： os.Exit 不会执行defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多测试用例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span> &#123;</span><br><span class="line">match := <span class="function"><span class="keyword">func</span><span class="params">(pat, str <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;<span class="comment">// pat: 命令行参数-run 提供的过滤条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span><span class="comment">// str: InternalTest.Name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tests := []testing.InternalTest &#123;</span><br><span class="line">&#123;<span class="string">&quot;b&quot;</span>, TestB&#125;,</span><br><span class="line">&#123;<span class="string">&quot;a&quot;</span>, TestA&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">benchmarks := []testing.InternalBenchmark&#123;&#125;</span><br><span class="line">examples := []testing.InternalExample&#123;&#125;</span><br><span class="line"></span><br><span class="line">m = testing.MainStart(match, tests, benchmarks, examples)</span><br><span class="line"></span><br><span class="line">os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Println(add(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果没有output注释，该示例就不会被执行。另外，不能使用内置函数print&#x2F;printIn, 因为他们输出到stderr</p><h3 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go test -bench .</p></blockquote><p>如果希望仅执行性能测试，那么可以用<code>run=NONE</code>忽略所有测试用例。<br>性能测试默认以并发方式进行测试，但可用cpu参数设定多个并发限制来观察结果。</p><blockquote><p>go test -bench . -cpu 1,2,4</p></blockquote><p>某些耗时的目标，默认循环测试过少，取平均值不足以准确计量性能。可用<code>benchtime</code>设定最小测试时间来增加循环次数，以便返回更准确的结果。</p><blockquote><p>go test -bench . -benchtime 5s</p></blockquote><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>如果在测试函数中要执行一些额外的操作，那么应该临时i组织计时器工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">b.ResetTimer()<span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">b.StopTimer()<span class="comment">// 暂停</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">b.StartTimer()<span class="comment">// 恢复</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p>性能测试查看内存情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heap</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = heap()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go test -bench . -benchmem -gcflags “-N -l” # 禁止内联和优化， 以便观察结果</p></blockquote><p>也可将测试函数设置为总是输出内存分配信息，无论使用benchmem参数与否</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span> </span>&#123;</span><br><span class="line">b.<span class="built_in">ReportAllocs</span>()</span><br><span class="line">b.<span class="built_in">ReportTimer</span>()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = <span class="built_in">heap</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><blockquote><p>go test -cover</p></blockquote><p>为获取更详细信息，可指定covermode 和coverprofile 参数</p><ul><li>set: 是否执行</li><li>count: 执行次数</li><li>atomic: 执行次数，支持并发模式<blockquote><p>go test -cover -covermode count -coverprofile cover.out</p></blockquote></li></ul><p>还可以在浏览器中查看包括具体的执行次数等信息</p><blockquote><p>go tool cover -html&#x3D;cover.out</p></blockquote><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>引发性能问题的原因无外乎执行时间过长、内存占用过多，以及意外阻塞。通过捕获或监控相关执行状态数据，就可定位引发问题的原因，从而针对性改进算法。</p><blockquote><p>go test -run NONE -bench . -memprofile mem.out -cpuprofile cpu.out net&#x2F;http</p></blockquote><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>-cpuprofile</td><td>保存执行时间采样到指定文件</td><td>-cpuprofile cpu.out</td></tr><tr><td>-memprofile</td><td>保存内存分配采样到指定文件</td><td>-memprofile mem.out</td></tr><tr><td>-memprofilerate</td><td>内存分配采样起始值，默认为512KB</td><td>-memprofilerate 1</td></tr><tr><td>-blockprofile</td><td>保存阻塞时间采样到指定文件</td><td>-blockprofile block.out</td></tr><tr><td>-blockprofilerate</td><td>阻塞时间采样起始值，单位为：ns</td><td></td></tr></tbody></table><p>如果执行性能测试，可能需要设置<code>benchtime</code>参数，以确保有足够的采样时间</p><p>可使用交互模式查看，或用命令行直接输出单向结果。</p><blockquote><p>go tool pprof http.test mem.out<br>(pprof) top5</p></blockquote><ul><li>flat: 仅当前函数，不包括它调用的其他函数。</li><li>sum: 列表前几行所占百分比的总和。</li><li>cum: 当前函数调用堆栈累计。</li></ul><p>top命令可指定排序字段，比如<code>top5 -cum</code><br>找出需要进一步查看的目标，使用<code>peek</code>命令列出调用来源<br>也可用list命令输出源码统计样式，以便更直观的定位<br>除文字模式以外，还可输出svg图形，将其保存或用浏览器查看</p><p>在线采集数据须诸如 <code>http/pprof</code>包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用浏览器访问指定路径，就可看到不同的检测项。</p><blockquote><p>go tool pprof <a href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a></p></blockquote><p>必要时还可抓取数据，进行离线分析。</p><blockquote><p>curl <a href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a> &gt; mem.out<br>go tool pprof test mem.out</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 迭代器介绍</title>
      <link href="/2020/07/31/2020-07-31-C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/07/31/2020-07-31-C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="C-迭代器介绍"><a href="#C-迭代器介绍" class="headerlink" title="C++ 迭代器介绍"></a>C++ 迭代器介绍</h1><h2 id="迭代器概念"><a href="#迭代器概念" class="headerlink" title="迭代器概念"></a>迭代器概念</h2><p><code>Iterator</code>(迭代器)是一种”能够迭代某序列内所有元素”的对象，可通过改变自寻常pointer的一致性接口来完成工作。<code>Iterator</code>奉行一个纯抽象概念：任何东西，只要行为类似iterator，就是一种iterator。然而不同的的iterator具有不同的行进能力。</p><h2 id="迭代器种类"><a href="#迭代器种类" class="headerlink" title="迭代器种类"></a>迭代器种类</h2><table><thead><tr><th>迭代器种类</th><th>能力</th><th>提供者</th></tr></thead><tbody><tr><td>Output 迭代器</td><td>向前写入</td><td>Ostream,inserter</td></tr><tr><td>Input 迭代器</td><td>向前读取一次</td><td>Istream</td></tr><tr><td>Forward 迭代器</td><td>向前读取</td><td>Forward list、unordered containers</td></tr><tr><td>Bidirectional 迭代器</td><td>向前和向后读取</td><td>List、set、multiset、map、multimap</td></tr><tr><td>Random-access 迭代器</td><td>以随机访问方式读取</td><td>Array、vector、deque、string、C-style array</td></tr><tr><td><img src="/resource/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A7%8D%E7%B1%BB/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="迭代器种类"></td><td></td><td></td></tr></tbody></table><h3 id="Output迭代器"><a href="#Output迭代器" class="headerlink" title="Output迭代器"></a>Output迭代器</h3><p>Output迭代器允许一步一步前行并搭配write动作。因此你可以一个一个元素地赋值，不能使用output迭代器对同一区间迭代两次。事实上，甚至不保证你可以将一个value复制两次而其迭代器不累进。我们的目标是将一个value以下列形式写入一个黑洞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">  *pos = ...;</span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output 迭代器无需比较操作。你无法检验output迭代器是否有效，或写入是否成功。你唯一可做的就是写入。通常，一批写入动作是以一个”额外条件定义出”的”特定output迭代器”作为结束。<br>见下表Output迭代器操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter &#x3D; val</td><td>将val写至迭代器所指的位置</td></tr><tr><td>++iter</td><td>向前步进(step forward), 返回新位置</td></tr><tr><td>iter++</td><td>向前步进(step forward), 返回旧位置</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(copy 构造函数)</td></tr></tbody></table><p>通常，迭代器可用来读，也可用来写; 几乎所有reading迭代器都有write的额外功能，这种情况下他们被称为<code>mutable</code>(可产生变化的)迭代器。<br>一个典型的<code>pure output</code>迭代器例子是：”将元素写至标准输出设备”。 如果采用两个output迭代器写至屏幕, 第二个字将跟在第一个字后面，而不是覆盖第一个字。另一个典型的例子是inserter, 那是一种用来将他插入容器。如果随后写入第二个value, 并不会覆盖第一个value, 而是安插进去。</p><h3 id="Input迭代器"><a href="#Input迭代器" class="headerlink" title="Input迭代器"></a>Input迭代器</h3><p>Input迭代器只能一次一个以前行方向读取元素，按此顺序一个个返回元素值。<br>Input迭代器的各项操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter</td><td>读取实际元素</td></tr><tr><td>iter-&gt;member</td><td>读取实际元素的成员(如果有的话)</td></tr><tr><td>++iter</td><td>向前步进(step forward), 返回新位置</td></tr><tr><td>iter++</td><td>向前步进(step forward), 返回旧位置</td></tr><tr><td>iter1 &#x3D;&#x3D; iter2</td><td>判断两个迭代器是否相等</td></tr><tr><td>iter1 !&#x3D; iter2</td><td>判断两个迭代器是否不相等</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(copy 构造函数)</td></tr></tbody></table><p>Input迭代器只能读取元素一次。如果你复制input迭代器, 并令原input迭代器和新产生的拷贝都向前读取, 可能会遍历到不同的值。<br><strong>所有的迭代器都具备input迭代器的能力，而且往往更强。</strong><code>Pure input</code>迭代器的典型例子就是”从标准输入设备读取数据”。同一个值不会被读取两次。一旦从<code>input stream</code>读入一个字(离开input缓冲区), 下次读取时就会返回另一个字。</p><p>对于input迭代器, 操作符&#x3D;&#x3D;和!&#x3D;只用来检查”某个迭代器是否等于一个past-the-end迭代器(指指向最末元素的下一个位置)”.这有其必要, 因为处理input迭代器的操作函数通常会有以下行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputIterator pos, end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos != end) &#123;</span><br><span class="line">  ... <span class="comment">// read-only access using *pos</span></span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有任何保证说，两个迭代器如果都不是past-the-end迭代器, 且指向不同位置，他们的比较结果会不相等</strong>(这个条件是和forward迭代器搭配引入的)。</p><p>也请注意, input迭代器的后置式递增操作符(<code>++iter</code>)不一定会返回什么东西。不过通常它会返回旧位置。<br>你应该尽可能优先先选用前置式递增操作符(<code>++iter</code>)而非后置式递增操作符(<code>iter++</code>), 因为前者效能更好。因为后者会返回一个临时对象。</p><h3 id="Forward-前向-迭代器"><a href="#Forward-前向-迭代器" class="headerlink" title="Forward(前向)迭代器"></a>Forward(前向)迭代器</h3><p>Forward迭代器是一种input迭代器且在前进读取时提供额外保证。</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>*iter</td><td>访问实际元素</td></tr><tr><td>iter-&gt;member</td><td>访问实际元素的成员</td></tr><tr><td>++iter</td><td>向前步进(返回新位置)</td></tr><tr><td>iter++</td><td>向前步进(返回旧位置)</td></tr><tr><td>iter1 &#x3D;&#x3D; iter2</td><td>判断两个迭代器是否相等</td></tr><tr><td>iter1 !&#x3D; iter2</td><td>判断两个迭代器是否不等</td></tr><tr><td>TYPE()</td><td>创建迭代器(default构造函数)</td></tr><tr><td>TYPE(iter)</td><td>复制迭代器(拷贝构造函数)</td></tr><tr><td>iter1 &#x3D; iter2</td><td>对迭代器赋值(assign)</td></tr><tr><td>和input迭代器不同的是, 两个forward迭代器如果指向同一元素, <code>operator==</code>会获得<code>true</code>, 如果两者都递增, 会再次指向同一元素。</td><td></td></tr><tr><td>例如：</td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ForwardIterator pos1, pos2;</span><br><span class="line"></span><br><span class="line">pos1 = pos2 = begin; <span class="comment">/// both iterator refer to the same element</span></span><br><span class="line"><span class="keyword">if</span>(pos1 != end) &#123;</span><br><span class="line">  ++pos1; <span class="comment">/// pos1 is one element ahead</span></span><br><span class="line">  <span class="keyword">while</span>(pos1 != end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(*pos1 == *pos2) &#123;</span><br><span class="line">      ... <span class="comment">// precess adjacent duplicates</span></span><br><span class="line">      ++pos1;</span><br><span class="line">      ++pos2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Forward迭代器由以下对象和类型提供：</p><ul><li>Class<forward_list></li><li>Unordered container<br>然而标准库也允许<code>unordered</code>容器的实现提供<code>bidirectional</code>迭代器。<br>如果forward迭代器履行了output迭代器应有的条件, 那么它就是一个mutable forward迭代器, 即可用于读取，也可用于涂写。</li></ul><h3 id="Bidirectional-双向-迭代器"><a href="#Bidirectional-双向-迭代器" class="headerlink" title="Bidirectional(双向)迭代器"></a>Bidirectional(双向)迭代器</h3><p><code>Bidirectional</code>迭代器在<code>forward</code>迭代器的基础上增加回头迭代(<code>iterate backward</code>)能力。</p><p><code>Bidirectional</code> 迭代器的新增操作</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>–iter</td><td>步退(返回新位置)</td></tr><tr><td>iter–</td><td>步退(返回旧位置)</td></tr></tbody></table><p><code>Bidirectional</code>迭代器由以下的对象和类型提供：</p><ul><li>Class list&lt;&gt;.</li><li>Associative(关联式) 关联式容器提供</li></ul><p>如果<code>bidirectional</code>迭代器履行了output迭代器应有的条件, 那么他就是个<code>mutable bidirectional</code>迭代器, 即可用于读取, 也可用于涂写。</p><h3 id="Random-Access-随机访问-迭代器"><a href="#Random-Access-随机访问-迭代器" class="headerlink" title="Random-Access(随机访问)迭代器"></a>Random-Access(随机访问)迭代器</h3><p><code>Random-access</code>迭代器在<code>bidirectional</code>迭代器的基础上增加了随机访问能里。因此它必须提供<code>iterator</code>算数运算。也就是说，它能增减某个偏移量、<br>计算距离(<code>difference</code>), 并运用诸如&lt;和&gt;等管理操作符(<code>relational operator</code>)进行比较。<br>随机访问迭代器的新增操作:</p><table><thead><tr><th>表达式</th><th>效果</th></tr></thead><tbody><tr><td>iter[n]</td><td>访问索引位置为n的元素</td></tr><tr><td>iter+&#x3D;n</td><td>前进n个元素(如果n是负数, 则改为回退)</td></tr><tr><td>iter-&#x3D;n</td><td>回退n个元素(如果n是负数, 则改为前进)</td></tr><tr><td>iter+n</td><td>返回iter之后的第n个元素</td></tr><tr><td>n+iter</td><td>返回iter之后的第n个元素</td></tr><tr><td>iter-n</td><td>返回iter之前的第n个元素</td></tr><tr><td>iter1-iter2</td><td>返回iter1和iter2之间的距离</td></tr><tr><td>iter1 &lt; iter2</td><td>判断iter1是否在iter2之前</td></tr><tr><td>iter1 &gt; iter2</td><td>判断iter1是否在iter2之后</td></tr><tr><td>iter1 &lt;&#x3D; iter2</td><td>判断iter1是否不在iter2之后</td></tr><tr><td>iter1 &gt;&#x3D; iter2</td><td>判断iter1是否不在iter2之前</td></tr></tbody></table><p><code>Random-access</code>迭代器由以下对象和类型提供:</p><ul><li>可随机访问的容器(<code>array</code>、<code>vector</code>、<code>deque</code>)</li><li>String(<code>string</code>、<code>wstring</code>)</li><li>寻常的C-Style(<code>pointer</code>)</li></ul><h2 id="迭代器相关辅助函数"><a href="#迭代器相关辅助函数" class="headerlink" title="迭代器相关辅助函数"></a>迭代器相关辅助函数</h2><h3 id="std-advance"><a href="#std-advance" class="headerlink" title="std::advance()"></a>std::advance()</h3><p><code>std::advance()</code>可将迭代器的位置增加, 增加的幅度由实参决定, 也就是说它令迭代器一次前进(或后退)多个元素:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; pos, Dist n)</span></span></span><br></pre></td></tr></table></figure><ul><li>令名称为pos的input迭代器前进(或后退)n个元素</li><li>对<code>bidirectinal</code>迭代器和<code>random-access</code>迭代器而言, n可为负值, 表示后退</li><li><code>Dist</code>是个template类型。通常它必须是个整数类型, 因为会调用诸如<code>&lt;</code>、<code>++</code>、<code>--</code>等操作, 还要和0做比较。</li><li><code>std::advance()</code>并不检查迭代器是否超过序列的<code>end()</code>(因为迭代器通常不知道其所操作的容器, 因此并无检查)。所以, 调用<code>std::advance()</code>有可能导致不明确行为–因为”对序列尾端调用<code>operator++</code>“是一种未定义的行为。</li></ul><p>对于<code>random-access</code>迭代器, 此函数只是简单地调用<code>pos+=n</code>, 因此具有常量复杂度。 对于其他任何类型的迭代器, 则调用<code>++pos</code>(或<code>--pos</code>如果n为负值)n次。因此，对于其他任何类型地迭代器, 本函数具有线性复杂度。<br><strong>如果你希望你的程序可以轻松地更换容器和迭代器种类, 你应该使用<code>std::advance()</code>而不是<code>operator+=</code></strong><br><strong>另外, 请注意<code>std::advance()</code>不具有返回值, 而<code>operator+=</code>会返回新位置, 所以后者可作为更大表达式的一部分。</strong></p><p>下面是一个<code>std::advance()</code>的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 输入迭代器的情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_InIt&amp; _Where, _Diff _Off, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 检查该偏移量不能为负值</span></span><br><span class="line">  <span class="keyword">if</span> (_Off &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span> &amp;&amp; <span class="string">&quot;negative offset in advance&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 使用自增运算符来计算</span></span><br><span class="line">  <span class="keyword">for</span> (; <span class="number">0</span> &lt; _Off; --_Off) ++_Where;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 双向迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_BidIt&amp; _Where, _Diff _Off,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 使用自增运算符来计算</span></span><br><span class="line">  <span class="keyword">for</span> (; <span class="number">0</span> &lt; _Off; --_Off) ++_Where;</span><br><span class="line">  <span class="comment">/// 如果偏移量为负值则使用自减运算符</span></span><br><span class="line">  <span class="keyword">for</span> (; _Off &lt; <span class="number">0</span>; ++_Off) --_Where;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 随机访问迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_RanIt&amp; _Where, _Diff _Off,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 使用operator += ，常量复杂度</span></span><br><span class="line">  _Where += _Off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InIt&amp; _Where, _Diff _Off)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">advance_impl</span>(_Where, _Off,</span><br><span class="line">               <span class="comment">/// 在萃取迭代器的特性时去掉其const的属性来提高性能</span></span><br><span class="line">               std::iterator_traits&lt;_Iter&gt;::iterator_category&lt;</span><br><span class="line">                   std::<span class="type">remove_const_t</span>&lt;_InIt&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-next-和std-prev"><a href="#std-next-和std-prev" class="headerlink" title="std::next()和std::prev()"></a>std::next()和std::prev()</h3><p>c++ 提供了两个新增的辅助函数, 允许你前进和后退移动迭代器的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">next</span><span class="params">(ForwardIterator pos)</span></span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">next</span><span class="params">(ForwardIterator pos, Dist n)</span></span></span><br></pre></td></tr></table></figure><ul><li>导致<code>forward</code>迭代器<code>pos</code>前进或n个位置</li><li>如果处理的是<code>bidirectional</code>和<code>random-access</code>迭代器, n可为负值, 导致后退移动</li><li><code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li><li>其内部将对一个临时对象调用<code>std::advance(pos, n)</code></li><li>注意, <code>std::next()</code>并不检查是否会跨越序列的<code>end()</code>。因此调用者必须自行担保其结果有效。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">prev</span><span class="params">(BidirectionalIterator pos)</span></span></span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">prev</span><span class="params">(BidirectionalIterator pos, Dist n)</span></span></span><br></pre></td></tr></table></figure><ul><li>导致<code>bidirectional</code>迭代器<code>pos</code>后退一个或n个位置</li><li>n可为负值, 导致向前移动</li><li><code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li><li>其内部将对一个临时对象调用<code>std::advance(pos, -n)</code></li><li>注意, <code>std::prev()</code>并不检查是否会跨越序列的<code>begin()</code>。因此调用者必须自行担保其结果有效。</li></ul><p>下面写一个简单的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _InIt <span class="title">next</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _InIt _First,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::iterator_traits&lt;_InIt&gt;::iterator_category&lt;_InIt&gt; _Off = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::is_base_of&lt;</span><br><span class="line">          std::input_iterator_tag,</span><br><span class="line">          <span class="keyword">typename</span> std::iterator_traits&lt;_InIt&gt;::iterator_category&gt;::value,</span><br><span class="line">      <span class="string">&quot;next requires input iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">advance</span>(_First, _Off);</span><br><span class="line">  <span class="keyword">return</span> (_First);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidIt</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _BidIt <span class="title">prev</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _BidIt _First,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::iterator_traits&lt;_BidIt&gt;::iterator_category&lt;_BidIt&gt; _Off = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::is_base_of&lt;</span><br><span class="line">          std::bidirectional_iterator_tag,</span><br><span class="line">          <span class="keyword">typename</span> std::iterator_traits&lt;_BidIt&gt;::iterator_category&gt;::value,</span><br><span class="line">      <span class="string">&quot;prev requires bidirectional iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">advance</span>(_First, -_Off);</span><br><span class="line">  <span class="keyword">return</span> (_First);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-distance"><a href="#std-distance" class="headerlink" title="std::distance()"></a>std::distance()</h3><p><code>std::distance()</code>用来处理两个迭代器之间的距离:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dist <span class="title">distance</span><span class="params">(InputIterator pos1, InputIterator pos2)</span></span></span><br></pre></td></tr></table></figure><ul><li>返回两个<code>input</code>迭代器<code>pos1</code>和<code>pos2</code>之间的距离。</li><li>两个迭代器必须指向同一个容器</li><li>如果不是<code>random-access</code>迭代器, 则从<code>pos1</code>开始前进必须能够到达<code>pos2</code>, 亦即<code>pos2</code>的位置必须与<code>pos1</code>相同或在其后。</li><li>返回类型<code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li></ul><p>注意： 处理两个<code>non-random-access</code>迭代器之间的距离时, 必须十分小心。第一个迭代器所指的元素绝不能在第二个迭代器所指元素之后方, 否则会导致不明确的行为。<strong>如果不知道哪个迭代器在前, 你必须先算出两个迭代器分别至容器起点的距离, 在根据这两个距离来判断。</strong></p><p>一个简单的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> it&gt;</span><br><span class="line"><span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(it from, it to)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::iterator_category() ==</span></span></span><br><span class="line"><span class="params"><span class="function">                std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 随机访问迭代器</span></span><br><span class="line">    <span class="keyword">return</span> to - from;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::<span class="built_in">iterator_category</span>() ==</span><br><span class="line">                       std::input_iterator_tag) &#123;</span><br><span class="line">    <span class="comment">/// input 迭代器</span></span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::difference_type res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; from != to; ++from) &#123;</span><br><span class="line">      ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="string">&quot;unknow iterator type.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-iter-swap"><a href="#std-iter-swap" class="headerlink" title="std::iter_swap()"></a>std::iter_swap()</h3><p>这个简单的辅助函数用来交换两个迭代器所指的元素值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator1 pos1, ForwardIterator pos2)</span></span></span><br></pre></td></tr></table></figure><ul><li>交换迭代器pos1和pos2所指的值</li><li>迭代器的类型不必相同, 但其所指的两个值必须<strong>可以相互赋值</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ integer_sequence介绍</title>
      <link href="/2020/07/22/2020-07-22-C++%20integer_sequence%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/07/22/2020-07-22-C++%20integer_sequence%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="integer-sequence"><a href="#integer-sequence" class="headerlink" title="integer_sequence"></a>integer_sequence</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T... ints&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sequence</span><span class="params">(std::integer_sequence&lt;T, ints...&gt; int_seq)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; int_seq.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  ((std::cout &lt;&lt; ints &lt;&lt; <span class="string">&#x27; &#x27;</span>), ...);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 转化数组为tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Array, std::<span class="type">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">a2t_impl</span><span class="params">(<span class="type">const</span> Array&amp; a, std::index_sequence&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(a[I]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N,</span><br><span class="line">          <span class="keyword">typename</span> Indices = std::make_index_sequence&lt;N&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">a2t</span>(<span class="type">const</span> std::array&lt;T, N&gt;&amp; a) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">a2t_impl</span>(a, Indices&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 漂亮地打印 tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ch</span>, <span class="keyword">class</span> <span class="title class_">Tr</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>, std::<span class="type">size_t</span>... Is&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_tuple_impl</span><span class="params">(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, <span class="type">const</span> Tuple&amp; t,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::index_sequence&lt;Is...&gt;)</span> </span>&#123;</span><br><span class="line">  ((os &lt;&lt; (Is == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>) &lt;&lt; std::<span class="built_in">get</span>&lt;Is&gt;(t)), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ch</span>, <span class="keyword">class</span> <span class="title class_">Tr</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span>&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, <span class="type">const</span> std::tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">  <span class="built_in">print_tuple_impl</span>(os, t, std::index_sequence_for&lt;Args...&gt;&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::integer_sequence&lt;<span class="type">unsigned</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::make_integer_sequence&lt;<span class="type">int</span>, <span class="number">20</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::make_index_sequence&lt;<span class="number">10</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::index_sequence_for&lt;<span class="type">float</span>, std::iostream, <span class="type">char</span>&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  std::array&lt;<span class="type">int</span>, 4&gt; array = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> tuple = <span class="built_in">a2t</span>(array);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;<span class="keyword">decltype</span>(tuple), std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; tuple &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 设计模式之单例模式</title>
      <link href="/2020/07/15/2020-07-15-C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/15/2020-07-15-C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正确写法"><a href="#正确写法" class="headerlink" title="正确写法"></a>正确写法</h2><p>该写法在第一次调用<code>get_instance()</code>后构造该实例，线程安全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;object&gt;&amp; <span class="title">get_instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>; <span class="comment">///&lt; 构造函数写为private，防止其他调用者单独构造该对象实例。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;object&gt;&amp; <span class="title">object::get_instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;object&gt; instance;  <span class="comment">///&lt; 该对象的唯一实例</span></span><br><span class="line">  <span class="type">static</span> std::once_flag flag; <span class="comment">///&lt; 标志位, 标记只调用一次</span></span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;]()&#123;</span><br><span class="line">    instance = std::<span class="built_in">make_unique</span>&lt;object&gt;();  <span class="comment">///&lt; C++14以后版本的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    instance = std::unique_ptr&lt;object&gt;(new object()); ///&lt; C++14 到 C++11 可用的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他写法比较"><a href="#其他写法比较" class="headerlink" title="其他写法比较"></a>其他写法比较</h2><p>最简单的写法: 线程不安全<br>由于<code>new object()</code>这个构造的过程需要时间，所以可能造成两个线程同时获取到<code>instance</code>变量为空指针。从而导致实例化两次，从未导致硬件驱动加载两次，而导致崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object* <span class="title">object::get_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  object* instance = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>double check</code>写法： 看起来线程安全，其实有条件竞争。<br>在<code>#1</code>和<code>#2</code>处，可能发生一个线程正在对<code>instance</code>变量赋值(写操作), 而另一个线程在进行在进行判断<code>instance</code>变量是否为空(读操作)，从而导致条件竞争，而导致崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object* <span class="title">object::get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> std::mutex mt;</span><br><span class="line">  <span class="keyword">volatile</span> object* instance = <span class="literal">nullptr</span>;  <span class="comment">///&lt; volatile关键字为了防止编译器优化</span></span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123; <span class="comment">///&lt; #1 读操作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">object</span>();  <span class="comment">///&lt; #2 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 设计模式 单例模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 设计模式 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 信号槽的连接方式</title>
      <link href="/2020/07/15/2020-07-15-Qt%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/15/2020-07-15-Qt%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a>官网解释</h2><h3 id="Qt-ConnectionType"><a href="#Qt-ConnectionType" class="headerlink" title="Qt::ConnectionType"></a>Qt::ConnectionType</h3><p>跨线程的信号和槽<br>Qt支持这些信号槽的连接方式：</p><ol><li>Auto Connection(默认): 假如信号在一个接收者的线程中发射，则行为等同于 Direct Connect. 否则行为等同于Queued Connection.</li><li>Direct Connect: 当信号被发射，槽函数将会被立即调用。槽函数将会在发射者的线程中执行, 而不一定在接收者线程中执行。</li><li>Queued Connect: 槽函数在控制权返回到接收者线程的事件循环时被调用。槽函数在接收者线程中被执行。</li><li>Blocking Queued Connection: 槽函数除了阻塞当前线程直到槽函数返回，其他像Queued Connection一样被调用。备注：在同一线程中使用这个类型的connect会导致死锁。</li><li>Unique Connect: 这个行为等同于Auto Connection，但是这个connection是只能在现有连接不重复的情况下生效。假如相同的信号已经连接到相同的槽函数中，这个连接不会建立且<code>connect()</code>返回<code>false</code>。</li></ol><ul><li>连接的类型可以通过<code>connect()</code>额外的参数指定，注意：在发送者和接收者在不同线程中使用direct connect是不安全的。如同一个事件循环在接收者的线程中，在另一个线程中调用存活对象的任何函数是不安全的。</li><li><code>QObject::connect()</code> 它本身是线程安全的。</li></ul><p> 在使用Queue Connection的时候，参数必须是Qt 元对象系统已知的类型，因为Qt需要拷贝入参并保存在事件背后的场景。假如你使用Queue Connection并得到以下错误信息：</p><blockquote><p>QObject::connect: Cannot queue arguments of type ‘MyType’</p></blockquote><p>在connection建立之前，调用<code>qRegisterMetaType()</code>去注册数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++循环队列的简单实现</title>
      <link href="/2020/07/09/2020-07-09-C++%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/07/09/2020-07-09-C++%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">front_</span>(<span class="number">0</span>), <span class="built_in">end_</span>(<span class="number">0</span>) &#123; data_ = <span class="keyword">new</span> T[size]; &#125;</span><br><span class="line">  ~<span class="built_in">queue</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">const</span> queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">queue</span>(queue&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  queue <span class="keyword">operator</span>=(<span class="type">const</span> queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  queue <span class="keyword">operator</span>=(queue&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> front_ == end_; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_full</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> front_ = (end_ + <span class="number">1</span>) % size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data_[front_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((end_ + <span class="number">1</span>) % size_ != front_) &#123;</span><br><span class="line">      data_[end_] = val;</span><br><span class="line">      end_ = (end_ + <span class="number">1</span>) % size_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front_ != end_) &#123;</span><br><span class="line">      front_ = (front_ + <span class="number">1</span>) % size_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">size_t</span> front_;</span><br><span class="line">  <span class="type">size_t</span> end_;</span><br><span class="line">  <span class="type">size_t</span> size_;</span><br><span class="line">  T* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">is_empty</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不采用哨兵值，使用状态来实现"><a href="#不采用哨兵值，使用状态来实现" class="headerlink" title="不采用哨兵值，使用状态来实现"></a>不采用哨兵值，使用状态来实现</h2><h2 id="spdlog-循环队列实现"><a href="#spdlog-循环队列实现" class="headerlink" title="spdlog 循环队列实现"></a>spdlog 循环队列实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circular_q</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> max_items_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type head_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type tail_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> overrun_counter_ = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;T&gt; v_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// empty ctor - create a disabled queue with no elements allocated at all</span></span><br><span class="line">  <span class="built_in">circular_q</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">circular_q</span><span class="params">(<span class="type">size_t</span> max_items)</span></span></span><br><span class="line"><span class="function">      : max_items_(max_items + <span class="number">1</span>)  // one item is reserved as marker for full q</span></span><br><span class="line"><span class="function">        ,</span></span><br><span class="line"><span class="function">        v_(max_items_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">circular_q</span>(<span class="type">const</span> circular_q &amp;) = <span class="keyword">default</span>;</span><br><span class="line">  circular_q &amp;<span class="keyword">operator</span>=(<span class="type">const</span> circular_q &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move cannot be default,</span></span><br><span class="line">  <span class="comment">// since we need to reset head_, tail_, etc to zero in the moved object</span></span><br><span class="line">  <span class="built_in">circular_q</span>(circular_q &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">copy_moveable</span>(std::<span class="built_in">move</span>(other));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  circular_q &amp;<span class="keyword">operator</span>=(circular_q &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">copy_moveable</span>(std::<span class="built_in">move</span>(other));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push back, overrun (oldest) item if no room left</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_items_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      v_[tail_] = std::<span class="built_in">move</span>(item);</span><br><span class="line">      tail_ = (tail_ + <span class="number">1</span>) % max_items_;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (tail_ == head_)  <span class="comment">// overrun last item if full</span></span><br><span class="line">      &#123;</span><br><span class="line">        head_ = (head_ + <span class="number">1</span>) % max_items_;</span><br><span class="line">        ++overrun_counter_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return reference to the front item.</span></span><br><span class="line">  <span class="comment">// If there are no elements in the container, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> v_[head_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T &amp;<span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> v_[head_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return number of elements actually stored</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail_ &gt;= head_) &#123;</span><br><span class="line">      <span class="keyword">return</span> tail_ - head_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> max_items_ - (head_ - tail_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return const reference to item by index.</span></span><br><span class="line">  <span class="comment">// If index is out of range 0…size()-1, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; <span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> v_[(head_ + i) % max_items_];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pop item from front.</span></span><br><span class="line">  <span class="comment">// If there are no elements in the container, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; head_ = (head_ + <span class="number">1</span>) % max_items_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tail_ == head_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// head is ahead of the tail by 1</span></span><br><span class="line">    <span class="keyword">if</span> (max_items_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((tail_ + <span class="number">1</span>) % max_items_) == head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> overrun_counter_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// copy from other&amp;&amp; and reset it to disabled state</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy_moveable</span><span class="params">(circular_q &amp;&amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    max_items_ = other.max_items_;</span><br><span class="line">    head_ = other.head_;</span><br><span class="line">    tail_ = other.tail_;</span><br><span class="line">    overrun_counter_ = other.overrun_counter_;</span><br><span class="line">    v_ = std::<span class="built_in">move</span>(other.v_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put &amp;&amp;other in disabled, but valid state</span></span><br><span class="line">    other.max_items_ = <span class="number">0</span>;</span><br><span class="line">    other.head_ = other.tail_ = <span class="number">0</span>;</span><br><span class="line">    other.overrun_counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 继承示例</title>
      <link href="/2020/07/09/2020-07-09-C++%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B/"/>
      <url>/2020/07/09/2020-07-09-C++%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Container</span>() &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">      <span class="keyword">auto</span> it = uuid.<span class="built_in">load</span>();</span><br><span class="line">      uuid.<span class="built_in">store</span>(++it);</span><br><span class="line">      serial_number_ = it;</span><br><span class="line">      container_map.<span class="built_in">insert</span>(&#123; serial_number_, <span class="keyword">this</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_fluid_capacity</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">totalFluidCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : container_map) &#123;</span><br><span class="line">      result += it.second-&gt;<span class="built_in">get_fluid_capacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Container* <span class="title">find_container</span><span class="params">(<span class="type">size_t</span> serial_number)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(container_map.<span class="built_in">find</span>(serial_number) != container_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> container_map[serial_number];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> std::mutex mut;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> std::atomic&lt;<span class="type">size_t</span>&gt; uuid;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> std::map&lt;<span class="type">size_t</span>, Container*&gt; container_map;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">size_t</span> serial_number_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">totalFluidCapacity</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Container* <span class="title">find_container</span><span class="params">(<span class="type">size_t</span> serial_number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buckets</span> : <span class="keyword">public</span> Container &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Buckets</span>(<span class="type">int</span> height, <span class="type">int</span> radius) : <span class="built_in">height_</span>(height), <span class="built_in">radius_</span>(radius) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_fluid_capacity</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(radius_ * radius_ * height_ * pi);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> height_;</span><br><span class="line">  <span class="type">int</span> radius_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boxes</span> : <span class="keyword">public</span> Container &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">material_type</span> : <span class="type">int</span> &#123;</span><br><span class="line">    m = <span class="number">0</span>,  <span class="comment">/// for metal</span></span><br><span class="line">    c = <span class="number">1</span>,  <span class="comment">/// for cardboard</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Boxes</span>(<span class="type">const</span> <span class="type">int</span> length, <span class="type">const</span> <span class="type">int</span> width, <span class="type">const</span> <span class="type">int</span> height, material_type type)</span><br><span class="line">      : <span class="built_in">length_</span>(length), <span class="built_in">width_</span>(width), <span class="built_in">height_</span>(height), <span class="built_in">type_</span>(type) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_fluid_capacity</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type_ == material_type::c) &#123;</span><br><span class="line">      <span class="keyword">return</span> length_ * width_ * height_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> length_;</span><br><span class="line">  <span class="type">int</span> width_;</span><br><span class="line">  <span class="type">int</span> height_;</span><br><span class="line">  material_type type_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Boxes <span class="title">box_c</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, Boxes::material_type::c)</span></span>;</span><br><span class="line">  <span class="function">Boxes <span class="title">box_m</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, Boxes::material_type::m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Buckets <span class="title">bucket</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> capa = <span class="built_in">totalFluidCapacity</span>();</span><br><span class="line">  <span class="built_in">assert</span>(capa == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> p_container = <span class="built_in">find_container</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">assert</span>(p_container == &amp; box_m);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++序列化与反序列化二叉树</title>
      <link href="/2020/07/05/2020-07-05-C++%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/05/2020-07-05-C++%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="C-序列化与反序列化二叉树"><a href="#C-序列化与反序列化二叉树" class="headerlink" title="C++序列化与反序列化二叉树"></a>C++序列化与反序列化二叉树</h1><p>首先我们定义树节点的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode* left;</span><br><span class="line">  TreeNode* right;</span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="序列化函数"><a href="#序列化函数" class="headerlink" title="序列化函数"></a>序列化函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;TreeNode*&gt; queue;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; result;</span><br><span class="line">  queue.<span class="built_in">push_back</span>(root);</span><br><span class="line">  <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">    !std::<span class="built_in">all_of</span>(queue.<span class="built_in">begin</span>(), queue.<span class="built_in">end</span>(),</span><br><span class="line">      [](<span class="type">const</span> TreeNode* node) &#123; <span class="keyword">return</span> node == <span class="literal">nullptr</span>; &#125;)) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; temp;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">pow</span>(<span class="number">2</span>, height));</span><br><span class="line">    <span class="keyword">while</span> (count-- != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> front = queue.<span class="built_in">front</span>();</span><br><span class="line">      queue.<span class="built_in">erase</span>(queue.<span class="built_in">begin</span>());</span><br><span class="line">      <span class="keyword">if</span> (front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        queue.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        queue.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(std::<span class="built_in">to_string</span>(front-&gt;val));</span><br><span class="line">        queue.<span class="built_in">push_back</span>(front-&gt;left);</span><br><span class="line">        queue.<span class="built_in">push_back</span>(front-&gt;right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    ++height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string str = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="comment">/// 组装字符串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : result) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it1 : it) &#123;</span><br><span class="line">      str += it1 + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (str.<span class="built_in">back</span>() == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">    str.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(str.<span class="built_in">end</span>()));</span><br><span class="line">    str += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反序列化函数"><a href="#反序列化函数" class="headerlink" title="反序列化函数"></a>反序列化函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">const</span> std::string&amp; s, std::vector&lt;std::string&gt;&amp; tokens,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> std::string&amp; delimiters = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  std::string::size_type lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, <span class="number">0</span>);</span><br><span class="line">  std::string::size_type pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  <span class="keyword">while</span> (std::string::npos != pos || std::string::npos != lastPos) &#123;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">    lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, pos);</span><br><span class="line">    pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> TreeNode* <span class="title">deserialize</span><span class="params">(std::string data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">front</span>() != <span class="string">&#x27;[&#x27;</span> || data.<span class="built_in">back</span>() != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  data.<span class="built_in">erase</span>(data.<span class="built_in">begin</span>());</span><br><span class="line">  data.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(data.<span class="built_in">end</span>()));</span><br><span class="line">  std::vector&lt;std::string&gt; vec_str;</span><br><span class="line">  <span class="built_in">split</span>(data, vec_str, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (vec_str.<span class="built_in">empty</span>() || vec_str.<span class="built_in">front</span>() == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;TreeNode*&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : vec_str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">      result.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">stoi</span>(it)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">at</span>(i) != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt; i * <span class="number">2</span> + <span class="number">2</span>) &#123;</span><br><span class="line">      result.<span class="built_in">at</span>(i)-&gt;left = result.<span class="built_in">at</span>(i*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">      result.<span class="built_in">at</span>(i)-&gt;right = result.<span class="built_in">at</span>(i*<span class="number">2</span><span class="number">+2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> result = <span class="built_in">deserialize</span>(<span class="string">&quot;[5,null,7,null,null,6,8]&quot;</span>);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">serialize</span>(result) == <span class="string">&quot;[5,null,7,null,null,6,8]&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> string =</span><br><span class="line">      <span class="string">&quot;[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,&quot;</span></span><br><span class="line">      <span class="string">&quot;27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,&quot;</span></span><br><span class="line">      <span class="string">&quot;51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,&quot;</span></span><br><span class="line">      <span class="string">&quot;75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,&quot;</span></span><br><span class="line">      <span class="string">&quot;99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,&quot;</span></span><br><span class="line">      <span class="string">&quot;117,118,119,120,121,122,123,124,125,126]&quot;</span>;</span><br><span class="line">  <span class="keyword">auto</span> result3 = <span class="built_in">deserialize</span>(string);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">serialize</span>(result3) == string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化改进版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">  <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::string res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        res += <span class="string">&quot;null,&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res += std::<span class="built_in">to_string</span>(temp-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 去除首尾的&#x27;[]&#x27;</span></span><br><span class="line">    data.<span class="built_in">erase</span>(data.<span class="built_in">begin</span>());</span><br><span class="line">    data.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(data.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="comment">/// 把字符串解析成数组</span></span><br><span class="line">    <span class="keyword">auto</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> lastPos = data.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;,&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> pos = data.<span class="built_in">find_first_of</span>(<span class="string">&#x27;,&#x27;</span>, lastPos);</span><br><span class="line">    std::queue&lt;std::string&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (pos != std::string::npos || std::string::npos != lastPos) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(data.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">      lastPos = data.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;,&#x27;</span>, pos);</span><br><span class="line">      pos = data.<span class="built_in">find_first_of</span>(<span class="string">&#x27;,&#x27;</span>, lastPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 遍历数组建立树</span></span><br><span class="line">    <span class="keyword">auto</span> head = q.<span class="built_in">front</span>();</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q_ceng;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q_next_ceng;</span><br><span class="line">    TreeNode* r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> thead = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">atoi</span>(head.<span class="built_in">c_str</span>()));</span><br><span class="line">      q_ceng.<span class="built_in">push</span>(thead);</span><br><span class="line">      r = thead;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!q_ceng.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q_ceng.<span class="built_in">front</span>();</span><br><span class="line">        q_ceng.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">l_t</span> = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">r_t</span> = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">l_t</span> != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">          t-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">atoi</span>(<span class="type">l_t</span>.<span class="built_in">c_str</span>()));</span><br><span class="line">          q_next_ceng.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">r_t</span> != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">          t-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(std::<span class="built_in">atoi</span>(<span class="type">r_t</span>.<span class="built_in">c_str</span>()));</span><br><span class="line">          q_next_ceng.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!q_next_ceng.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        q_ceng.<span class="built_in">push</span>(q_next_ceng.<span class="built_in">front</span>());</span><br><span class="line">        q_next_ceng.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串分割与解析代码学习</title>
      <link href="/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/26328793/how-to-split-string-with-delimiter-using-c">源码链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           把字符串前后的字符串给去除</span></span><br><span class="line"><span class="comment"> * @param           s       [in]    要剪切的字符串</span></span><br><span class="line"><span class="comment"> * @param           chars   [in]    要去除什么的字符串</span></span><br><span class="line"><span class="comment"> * @return          std::string&amp; 剪切后的字符串</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::string&amp; <span class="title">strip</span><span class="params">(std::string&amp; s, <span class="type">const</span> std::string&amp; chars = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(chars.<span class="built_in">c_str</span>()));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(chars.<span class="built_in">c_str</span>()) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           以特定符号为分隔符，切分字符串并放入vector里</span></span><br><span class="line"><span class="comment"> * @param           s           [in]    原字符串</span></span><br><span class="line"><span class="comment"> * @param           tokens      [out]   剪切后的子字符串</span></span><br><span class="line"><span class="comment"> * @param           delimiters  [in]    分隔符</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">const</span> std::string&amp; s, std::vector&lt;std::string&gt;&amp; tokens,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> std::string&amp; delimiters = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  std::string::size_type lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, <span class="number">0</span>);</span><br><span class="line">  std::string::size_type pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  <span class="keyword">while</span> (std::string::npos != pos || std::string::npos != lastPos) &#123;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">    lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, pos);</span><br><span class="line">    pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">parse</span><span class="params">(std::string&amp; s, std::map&lt;std::string, std::string&gt;&amp; items)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; elements;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &#123;&quot;</span>));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;&#125; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">split</span>(s, elements, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : elements) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; kv;</span><br><span class="line">    <span class="built_in">split</span>(iter, kv, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kv.<span class="built_in">size</span>() != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    items[<span class="built_in">strip</span>(kv[<span class="number">0</span>], <span class="string">&quot; \&quot;&quot;</span>)] = <span class="built_in">strip</span>(kv[<span class="number">1</span>], <span class="string">&quot; \&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string data =</span><br><span class="line">      <span class="string">&quot;  &#123;  \&quot;key1\&quot;  :  \&quot;data1\&quot;  ,  \&quot;key2\&quot;  :  \&quot;data2\&quot;    &#125;  &quot;</span>;</span><br><span class="line">  std::map&lt;std::string, std::string&gt; items;</span><br><span class="line">  <span class="built_in">parse</span>(data, items);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iter:items)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key=&quot;</span> &lt;&lt; iter.first &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; iter.second &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读spdlog-rotating_file_sink源码</title>
      <link href="/2020/07/05/2020-07-05-%E9%98%85%E8%AF%BBspdlog-rotating_file_sink%E6%BA%90%E7%A0%81/"/>
      <url>/2020/07/05/2020-07-05-%E9%98%85%E8%AF%BBspdlog-rotating_file_sink%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="thread-pool-源码学习"><a href="#thread-pool-源码学习" class="headerlink" title="thread_pool 源码学习"></a>thread_pool 源码学习</h1><h2 id="rotating-file-sink定义"><a href="#rotating-file-sink定义" class="headerlink" title="rotating_file_sink定义"></a>rotating_file_sink定义</h2><p><a href="https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/sinks/rotating_file_sink.h">rotating_file_sink.h</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Rotating file sink based on size</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rotating_file_sink</span> <span class="keyword">final</span> : <span class="keyword">public</span> base_sink&lt;Mutex&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rotating_file_sink</span>(<span class="type">filename_t</span> base_filename, std::<span class="type">size_t</span> max_size, std::<span class="type">size_t</span> max_files, <span class="type">bool</span> rotate_on_open = <span class="literal">false</span>);</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">filename_t</span> <span class="title">calc_filename</span><span class="params">(<span class="type">const</span> <span class="type">filename_t</span> &amp;filename, std::<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">filename_t</span> <span class="title">filename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sink_it_</span><span class="params">(<span class="type">const</span> details::log_msg &amp;msg)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush_</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Rotate files:</span></span><br><span class="line">    <span class="comment">// log.txt -&gt; log.1.txt</span></span><br><span class="line">    <span class="comment">// log.1.txt -&gt; log.2.txt</span></span><br><span class="line">    <span class="comment">// log.2.txt -&gt; log.3.txt</span></span><br><span class="line">    <span class="comment">// log.3.txt -&gt; delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the target if exists, and rename the src file  to target</span></span><br><span class="line">    <span class="comment">// return true on success, false otherwise.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rename_file_</span><span class="params">(<span class="type">const</span> <span class="type">filename_t</span> &amp;src_filename, <span class="type">const</span> <span class="type">filename_t</span> &amp;target_filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">filename_t</span> base_filename_;          <span class="comment">///&lt; 基础文件名称</span></span><br><span class="line">    std::<span class="type">size_t</span> max_size_;              <span class="comment">///&lt; 最大单个文件大小</span></span><br><span class="line">    std::<span class="type">size_t</span> max_files_;             <span class="comment">///&lt; 最大日志文件数量</span></span><br><span class="line">    std::<span class="type">size_t</span> current_size_;          <span class="comment">///&lt; 当前文件的大小</span></span><br><span class="line">    details::file_helper file_helper_;  <span class="comment">///&lt; 用于辅助写文件的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// @name     rotating_file_sink</span></span><br><span class="line"><span class="comment">/// @brief    构造本对象，</span></span><br><span class="line"><span class="comment">///           1. 打开日志文件</span></span><br><span class="line"><span class="comment">///           2. 获取当前文件大小</span></span><br><span class="line"><span class="comment">///           3. 如果超出了单个文件大小，则重新创建文件并打开</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    base_filename   [in]  基础的文件名</span></span><br><span class="line"><span class="comment">/// @param    max_size        [in]  最大单个文件大小</span></span><br><span class="line"><span class="comment">/// @param    max_files       [in]  最大的文件</span></span><br><span class="line"><span class="comment">/// @param    rotate_on_open  [in]  是否在文件打开时rotate</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-04 21:51:27</span></span><br><span class="line"><span class="built_in">rotating_file_sink</span>(std::string base_filename, std::<span class="type">size_t</span> max_size,</span><br><span class="line">                   std::<span class="type">size_t</span> max_files, <span class="type">bool</span> rotate_on_open = <span class="literal">false</span>)</span><br><span class="line">    : <span class="built_in">base_filename_</span>(std::<span class="built_in">move</span>(base_filename)),</span><br><span class="line">      <span class="built_in">max_size_</span>(max_size),</span><br><span class="line">      <span class="built_in">max_files_</span>(max_files) &#123;</span><br><span class="line">  <span class="comment">/// 打开当前应该写入的文件，并由file_helper对象来持有这个文件指针</span></span><br><span class="line">  file_helper_.<span class="built_in">open</span>(<span class="built_in">calc_filename</span>(base_filename_, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// 该函数时间执行时间很长，在这里只执行一次。</span></span><br><span class="line">  current_size_ = file_helper_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">/// 假如允许rotate且当前文件大小大于零</span></span><br><span class="line">  <span class="keyword">if</span> (rotate_on_open &amp;&amp; current_size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 执行一次rotate</span></span><br><span class="line">    <span class="built_in">rotate_</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotate-函数"><a href="#rotate-函数" class="headerlink" title="rotate_()函数"></a>rotate_()函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     rotate_</span></span><br><span class="line"><span class="comment">/// @brief    执行循环日志文件的创建</span></span><br><span class="line"><span class="comment">/// @details</span></span><br><span class="line"><span class="comment">/// Rotate files:</span></span><br><span class="line"><span class="comment">/// log.txt -&gt; log.1.txt</span></span><br><span class="line"><span class="comment">/// log.1.txt -&gt; log.2.txt</span></span><br><span class="line"><span class="comment">/// log.2.txt -&gt; log.3.txt</span></span><br><span class="line"><span class="comment">/// log.3.txt -&gt; delete</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-04 21:58:24</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 首先关闭该文件</span></span><br><span class="line">  file_helper_.<span class="built_in">close</span>();</span><br><span class="line">  <span class="comment">/// 开始查找要创建的下一个日志文件名称</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = max_files_; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">/// 拼装出上一个该文件名称</span></span><br><span class="line">    std::string src = <span class="built_in">calc_filename</span>(base_filename_, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">path_exists</span>(src)) &#123;</span><br><span class="line">      <span class="comment">/// 该文件如果不存在则到下一个循环</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 这里找到要创建的日志名称了日志文件的名称</span></span><br><span class="line">    std::string target = <span class="built_in">calc_filename</span>(base_filename_, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 把上一个文件改名为当前的文件名</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">rename_file_</span>(src, target)) &#123;</span><br><span class="line">      <span class="comment">/// 如果失败则在一个短暂的延迟后再次尝试</span></span><br><span class="line">      <span class="built_in">sleep_for_millis</span>(<span class="number">100</span>);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">rename_file_</span>(src, target)) &#123;</span><br><span class="line">        <span class="comment">/// 关闭并打开这个日志文件，防止它增长超出限制</span></span><br><span class="line">        file_helper_.<span class="built_in">reopen</span>(<span class="literal">true</span>);</span><br><span class="line">        current_size_ = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/// 抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span>(<span class="string">&quot;rotating_file_sink: failed renaming &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 以追加模式(&quot;a&quot;)重新打开这个文件</span></span><br><span class="line">  file_helper_.<span class="built_in">reopen</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name   sink_it_</span></span><br><span class="line"><span class="comment">/// @brief  写文件日志的函数，如果写入日志大于最大文件大小则创建下一个文件</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param  msg [in]  写入的日志信息</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-05 09:33:12</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink_it_</span><span class="params">(<span class="type">const</span> details::log_msg &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  std::string formatted;</span><br><span class="line">  <span class="comment">/// 拼装日志信息</span></span><br><span class="line">  base_sink&lt;Mutex&gt;::formatter_-&gt;format(msg, formatted);</span><br><span class="line">  <span class="comment">/// 计算这条日志加上原本大小是否超过了最大文件大小</span></span><br><span class="line">  current_size_ += formatted.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (current_size_ &gt; max_size_) &#123;</span><br><span class="line">    <span class="comment">/// 超过了就创建下一个文件</span></span><br><span class="line">    <span class="built_in">rotate_</span>();</span><br><span class="line">    <span class="comment">/// 更新为当前文件大小为这个日志信息的大小</span></span><br><span class="line">    current_size_ = formatted.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 如果没有超过最大大小则继续写该文件</span></span><br><span class="line">  file_helper_.<span class="built_in">write</span>(formatted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @name     flush_</span></span><br><span class="line"><span class="comment">/// @brief    刷新文件</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-07-05 09:36:23</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flush_</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; file_helper_.<span class="built_in">flush</span>(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>​<strong>异常处理</strong>（<code>exception handling</code>）机制允许程序独立开发的部分能够在运行时就出现问题<strong>进行通信</strong>并作出<strong>相应的处理</strong>。异常是的我们能够将问题的检测和解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无需知道问题处理模块的所有细节，反之亦然。</p><h2 id="1-抛出异常"><a href="#1-抛出异常" class="headerlink" title="1. 抛出异常"></a>1. 抛出异常</h2><p>​在C++语言中，我们通过<strong>抛出</strong>(<code>throwing</code>)一条表达式来<strong>引发</strong>(<code>raised</code>)一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段<strong>处理代码</strong>(<code>handler</code>)将被用来处理该异常。被选中的处理代码实在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分会告知异常处理部分到底发生了什么错误。</p><p>​当执行一个<code>throw</code>时，跟在<code>throw</code>后面的语句将不再被执行。相反，程序的控制权从<code>throw</code>转移到与之匹配的<code>catch</code>模块。该<code>catch</code><strong>可能是同一函数中</strong>的局部<code>catch</code>，<strong>也可能位于直接或间接调用了发生异常的函数的另一个函数中</strong>。控制权从一处转移到另一处，这有两个重要的含义：</p><ul><li><strong>沿着调用链的函数可能会提早退出</strong>。</li><li><strong>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁</strong>。</li></ul><p>因为跟在<code>throw</code>后面的语句将不再被执行，所以<code>throw</code>语句的有类似于<code>return</code>语句：它通常作为条件语句的一部分或者作为某个函数的最后(或者唯一)一条语句。</p><h3 id="1-1-栈展开"><a href="#1-1-栈展开" class="headerlink" title="1.1 栈展开"></a>1.1 栈展开</h3><p>​<strong>当抛出一个异常后</strong>，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的<code>catch</code>子句。</p><ul><li><p>当<code>throw</code>出现在一个<strong>try语句块</strong>(<code>try block</code>)内时，检查与该<code>try</code>块关联的<code>catch</code>子句。</p></li><li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p></li><li><p>如果这一步<strong>没找到匹配</strong>的<code>catch</code><strong>且该<code>try</code>语句嵌套在其他<code>try</code>块中</strong>，则<strong>继续检查与外层<code>try</code>匹配的<code>catch</code>子句</strong>。</p></li><li><p>如果<strong>还是找不到匹配</strong>的<code>catch</code>，则<strong>退出当前函数</strong>，在调<strong>用当前函数的外层函数中</strong>继续寻找。</p></li><li><p>如果对抛出异常的函数的调用语句位于一个<code>try</code>语句块内，则检查与该<code>try</code>块关联的<code>catch</code>子句。</p></li><li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p></li><li><p>否则，如果该<code>try</code>语句嵌套在其他<code>try</code>块中，则继续检查与外层<code>try</code>匹配的<code>catch</code>子句。</p></li><li><p>如果仍然没找到匹配的<code>catch</code>，则退出当前这个主调函数，继续在调用刚刚退出的这个函数的其他函数中寻找，以此类推。</p></li></ul><p>​上述过程被称为<strong>栈展开</strong>(<code>stack unwinding</code>)过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的<code>catch</code>子句为止；或者也可能一致没找到匹配的<code>catch</code>，则退出主函数后过程中止。</p><p>​假设找到了一个匹配的<code>catch</code>子句，则程序进入该子句并执行其中代码。当执行完这个<code>catch</code>子句后，找到与<code>try</code>块关联的最后一个<code>catch</code>子句后的点，并从这里继续执行。</p><p>​<strong>如果没有找到匹配的<code>catch</code>子句，程序将退出</strong>。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的<code>catch</code>时，程序将调用标准库函数<code>terminate</code>，顾名思义，<code>terminate</code>负责中止程序的执行过程。</p><h3 id="1-2-栈展开过程中对象被自动销毁"><a href="#1-2-栈展开过程中对象被自动销毁" class="headerlink" title="1.2 栈展开过程中对象被自动销毁"></a>1.2 栈展开过程中对象被自动销毁</h3><p>​在栈展开过程中，位于调用链上的语句块可能会提前退出。如果在<strong>栈展开过程中</strong>退出了某个块，编译器将负责确保在这个块中<strong>创建的对象都能被正确的销毁</strong>。如果某个局部对象的类型是<strong>类类型</strong>，则<strong>该对象的析构函数将被自动调用</strong>。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。</p><p>​如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经开始初始化了，而另外一些成员在异常发生前也许还没有开始初始化。即使某个对象只构造了一部分，我们也要<strong>确保构造的成员能被正确的销毁</strong>（否则会发生内存泄露）。</p><p>​类似的，异常也可能发生在<strong>数组</strong>或<strong>标准库容器的元素初始化过程</strong>中。与之前类似，如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确的销毁。</p><h3 id="1-3-析构函数与异常"><a href="#1-3-析构函数与异常" class="headerlink" title="1.3 析构函数与异常"></a>1.3 析构函数与异常</h3><p>​析构函数总是会被执行的，但是函数中负责释放资源的代码却可能会被跳过。如果一个块分配了资源，并且在<strong>负责释放这些资源的代码前面发生了异常</strong>，则释放资源的代码将<strong>不会被执行</strong>。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。（<code>RAII</code>的思想，在构造函数中获取资源(i.e <code>new</code>)，在析构函数中释放资源(i.e <code>delete</code>)。）</p><p>​所以出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，<strong>如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理</strong>（如果不这样做的话，程序会马上被终止）。</p><blockquote><p> 注：所有标准库类型都能保证它们的析构函数不会引发异常。</p></blockquote><h3 id="1-4-异常对象"><a href="#1-4-异常对象" class="headerlink" title="1.4 异常对象"></a>1.4 异常对象</h3><p><strong>异常对象</strong>（<code>exception object</code>）是一种特殊的对象，编译器使用<strong>异常抛出表达式</strong>来对<strong>异常对象</strong>进行<strong>拷贝初始化</strong>。因此<code>throw</code>语句中的表达式必须拥有<strong>完整类型</strong>。而且如果该表达式是<strong>类类型</strong>的话，则相应的类必须含有一个<strong>可访问的析构函数</strong>和一个<strong>可访问的拷贝或移动构造函数</strong>。如果该表达式是<strong>数组类型</strong>或<strong>函数类型</strong>，则表达式将被<strong>转换成</strong>与之对应的<strong>指针类型</strong>。</p><p>​异常对象位于有编译器管理的空间中，编译器确保无论调用哪个<code>catch</code>子句都能访问该空间。异常处理完毕后，异常对象被销毁。</p><p>​当一个异常被抛出是，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向<strong>局部对象的指针</strong>几乎肯定是一种<strong>错误</strong>行为。如果指针所指的对象位于某个块中，而该块在<code>catch</code>语句之前就已经退出了，则意味着在执行<code>catch</code>语句之前局部对象已经被销毁了。</p><p>​当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条<code>throw</code>表达式<strong>解引用一个基类指针</strong>，而该指针<strong>实际指向的是派生类对象</strong>，则<strong>抛出的对象将被切掉一部分，只有基类部分被抛出</strong>。</p><blockquote><p>注： 抛出指针要求在任何对应处理代码存在的地方，指针所指的对象都必须存在。</p></blockquote><h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p><code>catch</code>子句（<code>catch clause</code>）中的一场声明（<code>exception declaration</code>）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果<code>catch</code>无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p><p>声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，不能是右值引用。当进入一个<code>catch</code>语句后，入参通过异常对象初始化异常声明中的参数。和函数的参数类似，如果<code>catch</code>的参数类型是非引用类型，则该参数是异常对象的一个副本，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名。</p><p>如果<code>catch</code>的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果<code>catch</code>的参数是非引用类型，则异常对象将被切掉一部分，如果<code>catch</code>的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。</p><p>最后一点需要注意的是，异常声明的静态类型将决定<code>catch</code>语句所能执行的操作。如果<code>catch</code>的参数是基类类型，则<code>catch</code>无法使用派生类特有的任何成员。</p><blockquote><p>Tips: 通常情况下，如果<code>catch</code>接收的异常与某个继承体系有关，则最好将该<code>catch</code>的参数定义成引用类型。</p></blockquote><h3 id="2-1-查找匹配的处理代码"><a href="#2-1-查找匹配的处理代码" class="headerlink" title="2.1 查找匹配的处理代码"></a>2.1 查找匹配的处理代码</h3><p>​在搜寻<code>catch</code>语句的过程中，我们最终找到的<code>catch</code>未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的<code>catch</code>语句。因此，越是专门的<code>catch</code>越应该置于整个<code>catch</code>列表的前端。</p><p>​因为<code>catch</code>语句是按照其出现的顺序逐一匹配的，所以当程序员使用具有继承关系的多个异常时必须对<code>catch</code>语句的顺序进行组织管理，是的派生类异常的处理代码出现在基类异常的处理代码异常之前。</p><p>​与实参和形参的匹配规则相比，异常和<code>catch</code>异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和<code>catch</code>声明的类型时精确匹配的：</p><ul><li>允许从非常量的类型转换，也就是说一条非常量对象的<code>throw</code>语句可以匹配一个接受常量引用的<code>catch</code>语句</li><li>允许从派生类向基类的类型转换。</li><li>数组被转换成指向数组（元素）类型的指针，函数被转化成指向该函数类型的指针。</li></ul><p>除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用。</p><blockquote><p>如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最低端的类（<code>most derived type</code>）放在前面，而将继承链最顶端的类（<code>least derived type</code>）放在后面。</p></blockquote><h3 id="2-2-重新抛出"><a href="#2-2-重新抛出" class="headerlink" title="2.2 重新抛出"></a>2.2 重新抛出</h3><p>​一个单独的<code>catch</code>语句不能完整的处理某个异常。在执行了某些校正操作之后，当前的<code>catch</code>可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出的操作将异常传递给另外一个<code>catch</code>语句。这里的重新抛出仍然是一条<code>throw</code>语句，只不过不包含任何表达式: <code>throw;</code></p><p>​空的<code>throw</code>语句只能出现在<code>catch</code>语句或<code>catch</code>语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空<code>throw</code>语句，编译器将调用<code>terminate</code>。</p><p>​一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。</p><p>​很多时候，catch语句会改变其参数内容。如果在改变了参数的内容后catch语句重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所作的改变才会被保留并继续传播。</p><h3 id="2-3-捕获所有异常的处理代码"><a href="#2-3-捕获所有异常的处理代码" class="headerlink" title="2.3 捕获所有异常的处理代码"></a>2.3 捕获所有异常的处理代码</h3><p>​为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常的处理代码，形如<code>catch(...)</code>.</p><p>​<code>catch(...)</code>通常与重新抛出语句一起使用，其中<code>catch</code>执行当前局部能完成的工作，随后重新抛出异常。</p><blockquote><p>Tips: 如果<code>catch(...)</code>与其他几个<code>catch</code>语句一起出现，则<code>catch(...)</code>必须在最后的位置。出现在捕获所有一场语句后面的<code>catch</code>语句将永远不会被匹配。</p></blockquote><h2 id="3-函数try语句块与构造函数"><a href="#3-函数try语句块与构造函数" class="headerlink" title="3. 函数try语句块与构造函数"></a>3. 函数try语句块与构造函数</h2><p>​通常情况下，程序执行的任何时刻都可能发生异常，特别是一场可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的<code>try</code>语句块还未生效，所以构造函数体内的<code>catch</code>语句无法处理构造函数初始值列表抛出的异常。</p><p>​要想处理构造函数初始值抛出的异常，我们必须将构造函数写成<strong>函数try语句块</strong>（<code>function try block</code>）的形式。函数<code>try</code>语句使得一组<code>catch</code>语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"> : <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;<span class="comment">/** ... */</span>&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">handle_out_of_memory</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-noexcept-异常说明"><a href="#4-noexcept-异常说明" class="headerlink" title="4. noexcept 异常说明"></a>4. noexcept 异常说明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span></span>;           <span class="comment">/** 可能会抛出异常 */</span></span><br></pre></td></tr></table></figure><ul><li><p>对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数应该在函数的尾置返回类型之前。</p></li><li><p>我们也可以在函数指针的声明和定义中指定<code>noexcept</code>。</p></li><li><p>在typedef或类型别名中则不能出现<code>noexcept</code>。</p></li><li><p>在成员函数中，<code>noexcept</code>说明符需要跟在<code>const</code>及引用限定符之后，而在<code>final</code>、<code>override</code>或虚函数<code>=0</code>之前。</p></li></ul><h3 id="4-1-违反异常说明"><a href="#4-1-违反异常说明" class="headerlink" title="4.1 违反异常说明"></a>4.1 违反异常说明</h3><p>​编译器并不会在编译时检查<code>noexcept</code>说明。实际上，如果一个函数说明了<code>noexcept</code>的同时又含有<code>throw</code>语句或者调用了可能抛出异常的其他函数，编译器将顺利通过，并不会因为这种违反异常说明的情况而报错。</p><p>​因此可能会出现一种情况：尽管函数说明了它不会抛出异常，但实际上还是抛出了。一旦一个<code>noexcept</code>函数抛出异常，程序就会调用<code>terminate</code>以确保遵守不在运行时抛出异常的承诺。</p><p>​上述过程是执行栈展开未作约定，因此<code>noexcept</code>可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。</p><h3 id="4-2-noexcept运算符"><a href="#4-2-noexcept运算符" class="headerlink" title="4.2 noexcept运算符"></a>4.2 noexcept运算符</h3><p>​<code>noexcept</code>说明符接受一个可选实参，该实参必须能转换为<code>bool</code>类型：如果实参是<code>true</code>，则函数不会抛出异常；如果实参是<code>false</code>，则函数可能抛出异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;<span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;<span class="comment">/** 可能抛出异常 */</span></span><br></pre></td></tr></table></figure><p>​<code>noexcept</code>说明符的实参常常与<code>noexcept</code>运算符混合使用。<code>noexcept</code>运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和<code>sizeof</code>类似，<code>noexcept</code>也不会求其运算对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">noexcept</span>(<span class="built_in">recoup</span>())<span class="comment">/** 如果recoup不跑出异常则结果为true；否则结果为false */</span></span><br><span class="line"><span class="built_in">noexcept</span>(e)<span class="comment">/** 等价于上一句 */</span></span><br></pre></td></tr></table></figure><p>我们可以使用noexcept运算符得到如下的异常说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>;<span class="comment">// f 和 g的异常说明一致</span></span><br></pre></td></tr></table></figure><p>如果函数<code>g()</code>承诺了不会抛出异常，则f也不会抛出异常；如果<code>g()</code>没有异常说明符，或者g虽然有异常说明符但是允许抛出异常，则<code>f()</code>也可能抛出异常。</p><blockquote><p><code>noexcept</code>有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为<code>noexcept</code>异常说明的<code>bool</code>实参出现时，它是一个运算符。</p></blockquote><h3 id="4-3-异常说明与指针、虚函数和拷贝控制"><a href="#4-3-异常说明与指针、虚函数和拷贝控制" class="headerlink" title="4.3 异常说明与指针、虚函数和拷贝控制"></a>4.3 异常说明与指针、虚函数和拷贝控制</h3><p>​<strong>函数指针及该指针所指的函数必须具有一致的异常说明</strong>。也就是说我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以。</p><p>​如果<strong>虚函数</strong>承诺了它<strong>不会抛出异常</strong>，则后续派生出来的<strong>虚函数</strong>也必须做出<strong>同样的承诺</strong>；与之相反如果<strong>基类的虚函数允许抛出异常</strong>，则派<strong>生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。</strong></p><p>​当编译器<strong>合成拷贝控制成员</strong>时，同时也<strong>生成一个异常说明</strong>。如果对<strong>所有成员</strong>和<strong>基类的所有操作</strong>都承诺了不会抛出异常，则合成的成员是<code>noexcept</code>的。如果合成成员调用的<strong>任意一个函数可能抛出异常</strong>，则合成的成员是<code>noexcept(false)</code>。而且如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将于假设有编译器为类合成析构函数时所得的异常说明一致。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20三路比较符</title>
      <link href="/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/"/>
      <url>/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="三路比较符（C-20）"><a href="#三路比较符（C-20）" class="headerlink" title="三路比较符（C++20）"></a>三路比较符（C++20）</h1><p><a href="https://zh.cppreference.com/w/cpp/utility/compare/compare_three_way">官网解释</a></p><p><a href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/">微软技术博客介绍</a></p><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1186r3.html">When do you actually use <code>&lt;=&gt;</code>?</a></p><p>例子1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rational_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> den; <span class="comment">// &gt; 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> std::weak_ordering <span class="built_in">operator</span>&lt;=&gt;(Rational_2 lhs, Rational_2 rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.num * rhs.den &lt;=&gt; rhs.num * lhs.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::weak_ordering value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;equal\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;less\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;greater\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rational_2 c&#123;<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Rational_2 d&#123;<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(c &lt;=&gt; d);</span><br><span class="line">    <span class="built_in">print</span>(std::compare_three_way&#123;&#125;(c,d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basics</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Basics&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">  <span class="type">int</span> ai[<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">2</span>];</span><br><span class="line">  <span class="type">float</span> af[<span class="number">3</span>];</span><br><span class="line">  <span class="type">double</span> ad[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Arrays&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bases</span> : Basics, Arrays &#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Bases&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases a = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases b = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="built_in">static_assert</span>(a == b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a != b));</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &lt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &lt;= b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &gt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &gt;= b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++严格弱序的介绍</title>
      <link href="/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="严格弱序（strict-weak-ordering）"><a href="#严格弱序（strict-weak-ordering）" class="headerlink" title="严格弱序（strict weak ordering）"></a>严格弱序（strict weak ordering）</h1><p>关联式容器（<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>）的排序准则的定义，和std::sort的排序准则定义必须遵守严格弱序，详细描述见官方解释(<a href="/resource/C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/strict_weak_ordering.pdf">strict weak ordering.pdf</a>)。</p><p><strong>严格弱序的定义</strong>：</p><p><strong>简单的来说就是a&lt;b返回true，a&#x3D;b和a&gt;b返回false。</strong></p><p>详细定义：</p><blockquote><ol><li><p>必须是<strong>非对称的</strong>（antisymmetric）。</p><p> 对<code>operator&lt; </code>而言， 如果x &lt; y为true， 则y &lt; x为false。</p><p> 对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true，则op(y, x)为false。</p></li><li><p>必须是<strong>可传递的</strong>（transitive）。</p></li></ol><p>  对<code>operator&lt; </code>而言，如果x &lt; y 为true且y &lt; z为true， 则x &lt; z 为false。</p><p>  对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true且op(y, z)为tru，则op(x, z)为true。</p><ol start="3"><li><p>必须是<strong>非自反的</strong>（irreflexive）</p><p> 对<code>operator&lt; </code>而言，x &lt; x 永远是false</p><p> 对判断式(predicate) <code>op()</code>而言，op(x, x)永远是false。</p></li><li><p>必须有<strong>等效传递性</strong>（transitivity of equivalence）</p></li></ol><p>对<code>operator&lt; </code>而言，假如 !(a&lt;b) &amp;&amp; !(b&lt;a) 为true且 !(b&lt;c) &amp;&amp; !(c&lt;b) 为 true<br>那么!(a&lt;c) &amp;&amp; !(c&lt;a) 也为true.<br>对判断式(predicate) <code>op()</code>而言， 假如 op(a,b), op(b,a), op(b,c), 和op(c,b) 都为<br>false, 那么op(a,c) and op(c,a) 也为false.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个定义std::set&lt;struct&gt;的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ORDERING_EXAMPLE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 重载遵循严格弱序的运算符&lt;</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> ORDERING_EXAMPLE&amp; OtherStruct) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;x &lt; OtherStruct.x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.x &lt; <span class="keyword">this</span>-&gt;x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x == x则比较y</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;y &lt; OtherStruct.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.y &lt; <span class="keyword">this</span>-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// y == y则比较z</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;z &lt; OtherStruct.z)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;ORDERING_EXAMPLE&gt; setOrderingExample;</span><br><span class="line"></span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample0 = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample1 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample3 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample0);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample1);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample2);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面举一个会崩溃的例子对二维数组排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">5</span>, temp);</span><br><span class="line">  std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;l, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;r) &#123;</span><br><span class="line">              <span class="keyword">if</span> (l.<span class="built_in">size</span>() == r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; l.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (l.<span class="built_in">at</span>(i) == r.<span class="built_in">at</span>(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> l.<span class="built_in">at</span>(i) &lt; r.<span class="built_in">at</span>(i);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/// 这里会崩溃，改为false则不会而不会崩溃(遵循严格弱序)</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> l.<span class="built_in">size</span>() &lt; r.<span class="built_in">size</span>();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个参数的重载符号简单示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于乘法溢出的判断</title>
      <link href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先我们对于乘法溢出的判断，先写测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715337389.png" alt="1592715337389"></p><p>由上图我们简化测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715602260.png" alt="1592715602260"></p><p>我们可以这样设计乘法溢出函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们添加测试用例</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727579022.png" alt="1592727579022"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来为特殊数值来添加判断：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727736048.png" alt="1592727736048"></p><p>添加异号情况的判断：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730284047.png" alt="1592730284047"></p><p>把函数改为模板，一并添加测试用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_multi_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot; is_multi_overflow need integral type!&quot;</span>);</span><br><span class="line">  <span class="type">int</span> num_max = std::numeric_limits&lt;T1&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> num_min = std::numeric_limits&lt;T1&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">1</span> || y == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y == num_min;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x == num_min;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; num_max / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == num_min &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / -y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 3</span></span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 4</span></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = INT_MIN;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 5</span></span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = min_num;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 6</span></span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后附上完整测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730393076.png" alt="1592730393076"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我们既然有了判断乘法溢出的函数，我们可以借此封装一个带有检查溢出的乘法函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">std::optional&lt;T1&gt; <span class="title">multiplies_s</span><span class="params">(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value, <span class="string">&quot;Multiplies_s need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;Multiplies_s need integral type!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_multi_overflow</span>(x, y)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">multiplies_s</span>(x, y).<span class="built_in">value_or</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于虚析构函数</title>
      <link href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="虚析构函数问题"><a href="#虚析构函数问题" class="headerlink" title="虚析构函数问题"></a>虚析构函数问题</h2><blockquote><p>引用标准中原文：  一条有用的方针，是任何基类的析构函数必须为公开且虚， 或受保护且非虚。</p></blockquote><p>虚析构这个概念被设计出来就是<strong>为了解决基类指针指向派生类实例的析构问题</strong>，当一个基类指针指向派生类实例然后进行delete该指针时，只会执行基类析构函数而派生类的析构函数不会被执行，这将导致派生类构造的资源不会被正确释放，造成内存泄漏。如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/// 该析构函数为错误示例，严禁这样写.</span></span><br><span class="line">     ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug.png" alt="Virtual DeConstruct Debug"></p><p>可以看到派生类没有被析构，如要解决该问题在基类析构函数处加上<strong>virtual</strong>关键字即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/** 正确写法： 加上关键字virtual， 后面函数体可写可不写，或者直接使用=default都行。 */</span></span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">/// 或者 virtual ~Derived() override &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug_Correct.png" alt="Virtual DeConstruct Debug Correct"></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PlantUML语法学习</title>
      <link href="/2020/07/02/2020-07-02-PlantUML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/02/2020-07-02-PlantUML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="PlantUML语法学习"><a href="#PlantUML语法学习" class="headerlink" title="PlantUML语法学习"></a>PlantUML语法学习</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>类之间的关系通过下面的符号定义:</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_20-38-31.png" alt="类之间的关系"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class01 &lt;|-- Class02</span><br><span class="line">Class03 *-- Class04</span><br><span class="line">Class05 o-- Class06</span><br><span class="line">Class07 .. Class08</span><br><span class="line">Class09 -- Class10</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_1.png" alt="class1"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class11 &lt;|.. Class12</span><br><span class="line">Class13 --&gt; Class14</span><br><span class="line">Class15 ..&gt; Class16</span><br><span class="line">Class17 ..|&gt; Class18</span><br><span class="line">Class19 &lt;--* Class20</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_2.png" alt="class2"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class21 #-- Class22</span><br><span class="line">Class23 x-- Class24</span><br><span class="line">Class25 &#125;-- Class26</span><br><span class="line">Class27 +-- Class28</span><br><span class="line">Class29 ^-- Class30</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_3.png" alt="class3"></p><h3 id="关系上的标识"><a href="#关系上的标识" class="headerlink" title="关系上的标识"></a>关系上的标识</h3><p>在关系之间使用标签来说明时, 使用: 后接标签文字。<br>对元素的说明，你可以在每一边使用”” 来说明.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class01 &quot;1&quot; *-- &quot;many&quot; Class02 : contains</span><br><span class="line">Class03 o-- Class04 : aggregation</span><br><span class="line">Class05 --&gt; &quot;1&quot; Class06</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_4.png" alt="class4"></p><p>在标签的开始或结束位置添加&lt; 或&gt; 以表明是哪个对象作用到哪个对象上。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Car</span><br><span class="line">Driver - Car : drives &gt;</span><br><span class="line">Car *- Wheel : have 4 &gt;</span><br><span class="line">Car -- Person : &lt; owns</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_5.png" alt="class5"></p><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>为了声明字段(对象属性）或者方法，你可以使用后接字段名或方法名。<br>系统检查是否有括号来判断是方法还是字段。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Object &lt;|-- ArrayList</span><br><span class="line">Object : equals()</span><br><span class="line">ArrayList : Object[] elementData</span><br><span class="line">ArrayList : size()</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_6.png" alt="class6"></p><p>也可以使用{} 把字段或者方法括起来<br>注意，这种语法对于类型&#x2F;名字的顺序是非常灵活的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">String data</span><br><span class="line">void methods()</span><br><span class="line">&#125;</span><br><span class="line">class Flight &#123;</span><br><span class="line">flightNumber : Integer</span><br><span class="line">departureTime : Date</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_7.png" alt="class7"></p><p>你可以（显式地）使用{field} 和{method} 修饰符来覆盖解析器的对于字段和方法的默认行为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">&#123;field&#125; A field (despite parentheses)</span><br><span class="line">&#123;method&#125; Some method</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_8.png" alt="class8"></p><h3 id="定义可访问性"><a href="#定义可访问性" class="headerlink" title="定义可访问性"></a>定义可访问性</h3><p>一旦你定义了域或者方法，你可以定义相应条目的可访问性质。<br><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_20-55-15.png" alt="定义可访问性"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">-field1</span><br><span class="line">#field2</span><br><span class="line">~method1()</span><br><span class="line">+method2()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_9.png" alt="class9"></p><p>你可以采用命令（skinparam classAttributeIconSize 0 ：)停用该特性</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam classAttributeIconSize 0</span><br><span class="line">class Dummy &#123;</span><br><span class="line">-field1</span><br><span class="line">#field2</span><br><span class="line">~method1()</span><br><span class="line">+method2()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_10.png" alt="class10"></p><h3 id="抽象与静态"><a href="#抽象与静态" class="headerlink" title="抽象与静态"></a>抽象与静态</h3><p>通过修饰符{static} 或者{abstract}，可以定义静态或者抽象的方法或者属性。<br>这些修饰符可以写在行的开始或者结束。也可以使用{classifier} 这个修饰符来代替{static}.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">&#123;static&#125; String id</span><br><span class="line">&#123;abstract&#125; void methods()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_11.png" alt="class11"></p><h3 id="高级类体"><a href="#高级类体" class="headerlink" title="高级类体"></a>高级类体</h3><p>PlantUML 默认自动将方法和属性重新分组，你可以自己定义分隔符来重排方法和属性，下面的分隔符都<br>是可用的：– .. &#x3D;&#x3D; __.<br>还可以在分隔符中添加标题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Foo1 &#123;</span><br><span class="line">You can use</span><br><span class="line">several lines</span><br><span class="line">..</span><br><span class="line">as you want</span><br><span class="line">and group</span><br><span class="line">==</span><br><span class="line">things together.</span><br><span class="line">__</span><br><span class="line">You can have as many groups</span><br><span class="line">as you want</span><br><span class="line">--</span><br><span class="line">End of class</span><br><span class="line">&#125;</span><br><span class="line">class User &#123;</span><br><span class="line">.. Simple Getter ..</span><br><span class="line">+ getName()</span><br><span class="line">+ getAddress()</span><br><span class="line">.. Some setter ..</span><br><span class="line">+ setName()</span><br><span class="line">__ private data __</span><br><span class="line">int age</span><br><span class="line">-- encrypted --</span><br><span class="line">String password</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_12.png" alt="class12"></p><h3 id="更多注释"><a href="#更多注释" class="headerlink" title="更多注释"></a>更多注释</h3><p>可以在注释中使用部分html 标签：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Foo</span><br><span class="line">note left: On last defined class</span><br><span class="line">note top of Object</span><br><span class="line">In java, &lt;size:18&gt;every&lt;/size&gt; &lt;u&gt;class&lt;/u&gt;</span><br><span class="line">&lt;b&gt;extends&lt;/b&gt;</span><br><span class="line">&lt;i&gt;this&lt;/i&gt; one.</span><br><span class="line">end note</span><br><span class="line">note as N1</span><br><span class="line">This note is &lt;u&gt;also&lt;/u&gt;</span><br><span class="line">&lt;b&gt;&lt;color:royalBlue&gt;on several&lt;/color&gt;</span><br><span class="line">&lt;s&gt;words&lt;/s&gt; lines</span><br><span class="line">And this is hosted by &lt;img:sourceforge.jpg&gt;</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_13.png" alt="class13"></p><h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>使用关键字object 定义实例。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object firstObject</span><br><span class="line">object &quot;My Second Object&quot; as o2</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_1.png" alt="object1"></p><h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><p>对象之间的关系可以用如下符号定义：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_19-56-04.png" alt="对象之间的关系"></p><p>也可以用.. 来代替– 以使用点线。<br>知道了这些规则，就可以画下面的图：<br>可以用冒号给关系添加标签，标签内容紧跟在冒号之后。<br>用双引号在关系的两边添加基数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object Object01</span><br><span class="line">object Object02</span><br><span class="line">object Object03</span><br><span class="line">object Object04</span><br><span class="line">object Object05</span><br><span class="line">object Object06</span><br><span class="line">object Object07</span><br><span class="line">object Object08</span><br><span class="line">Object01 &lt;|-- Object02</span><br><span class="line">Object03 *-- Object04</span><br><span class="line">Object05 o-- &quot;4&quot; Object06</span><br><span class="line">Object07 .. Object08 : some labels</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_2.png" alt="object2"></p><h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><p>用冒号加属性名的形式声明属性。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object user</span><br><span class="line">user : name = &quot;Dummy&quot;</span><br><span class="line">user : id = 123</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_3.png" alt="object3"></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><h3 id="简单活动"><a href="#简单活动" class="headerlink" title="简单活动"></a>简单活动</h3><p>使用(*) 作为活动图的开始点和结束点。<br>有时，你可能想用(*top) 强制开始点位于图示的顶端。<br>使用–&gt; 绘制箭头。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;First Activity&quot;</span><br><span class="line">&quot;First Activity&quot; --&gt; (*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_1.png" alt="activity1"></p><h3 id="箭头上的标签"><a href="#箭头上的标签" class="headerlink" title="箭头上的标签"></a>箭头上的标签</h3><p>默认情况下，箭头开始于最接近的活动。<br>可以用[ 和 ] 放在箭头定义的后面来添加标签。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;First Activity&quot;</span><br><span class="line">--&gt;[You can put also labels] &quot;Second Activity&quot;</span><br><span class="line">--&gt; (*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_2.png" alt="activity2"></p><h3 id="改变箭头方向"><a href="#改变箭头方向" class="headerlink" title="改变箭头方向"></a>改变箭头方向</h3><p>你可以使用-&gt; 定义水平方向箭头，还可以使用下列语法强制指定箭头的方向：</p><ul><li>-down-&gt; (default arrow)</li><li>-right-&gt; or -&gt;</li><li>-left-&gt;</li><li>-up-&gt;</li></ul><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_3.png" alt="activity3"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>你可以使用关键字if&#x2F;then&#x2F;else 创建分支。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;Initialization&quot;</span><br><span class="line">if &quot;Some Test&quot; then</span><br><span class="line">--&gt;[true] &quot;Some Activity&quot;</span><br><span class="line">--&gt; &quot;Another activity&quot;</span><br><span class="line">-right-&gt; (*)</span><br><span class="line">else</span><br><span class="line">-&gt;[false] &quot;Something else&quot;</span><br><span class="line">--&gt;[Ending process] (*)</span><br><span class="line">endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_4.png" alt="activity4"></p><p>不过，有时你可能需要重复定义同一个活动：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;check input&quot;</span><br><span class="line">If &quot;input is verbose&quot; then</span><br><span class="line">--&gt; [Yes] &quot;turn on verbosity&quot;</span><br><span class="line">--&gt; &quot;run command&quot;</span><br><span class="line">else</span><br><span class="line">--&gt; &quot;run command&quot;</span><br><span class="line">Endif</span><br><span class="line">--&gt;(*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_5.png" alt="activity5"></p><h3 id="更多分支"><a href="#更多分支" class="headerlink" title="更多分支"></a>更多分支</h3><p>默认情况下，一个分支连接上一个最新的活动，但是也可以使用if 关键字进行连接。<br>还可以嵌套定义分支。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; if &quot;Some Test&quot; then</span><br><span class="line">--&gt;[true] &quot;activity 1&quot;</span><br><span class="line">if &quot;&quot; then</span><br><span class="line">-&gt; &quot;activity 3&quot; as a3</span><br><span class="line">else</span><br><span class="line">if &quot;Other test&quot; then</span><br><span class="line">-left-&gt; &quot;activity 5&quot;</span><br><span class="line">else</span><br><span class="line">--&gt; &quot;activity 6&quot;</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">-&gt;[false] &quot;activity 2&quot;</span><br><span class="line">endif</span><br><span class="line">a3 --&gt; if &quot;last test&quot; then</span><br><span class="line">--&gt; &quot;activity 7&quot;</span><br><span class="line">else</span><br><span class="line">-&gt; &quot;activity 8&quot;</span><br><span class="line">endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_6.png" alt="activity6"></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>你可以在活动定义之后用note left, note right, note top or note bottom, 命令给活动添加注释。<br>如果想给开始点添加注释，只需把注释的定义放在活动图最开始的地方即可。<br>也可以用关键字endnote 定义多行注释。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;Some Activity&quot;</span><br><span class="line">note right: This activity has to be defined</span><br><span class="line">&quot;Some Activity&quot; --&gt; (*)</span><br><span class="line">note left</span><br><span class="line">This note is on</span><br><span class="line">several lines</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_7.png" alt="activity7"></p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>用关键字partition 定义分区，还可以设置背景色(用颜色名或者颜色值)。<br>定义活动的时候，它自动被放置到最新的分区中。<br>用} 结束分区的定义。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">partition Conductor &#123;</span><br><span class="line">(*) --&gt; &quot;Climbs on Platform&quot;</span><br><span class="line">--&gt; === S1 ===</span><br><span class="line">--&gt; Bows</span><br><span class="line">&#125;</span><br><span class="line">partition Audience #LightSkyBlue &#123;</span><br><span class="line">=== S1 === --&gt; Applauds</span><br><span class="line">&#125;</span><br><span class="line">partition Conductor &#123;</span><br><span class="line">Bows --&gt; === S2 ===</span><br><span class="line">--&gt; WavesArmes</span><br><span class="line">Applauds --&gt; === S2 ===</span><br><span class="line">&#125;</span><br><span class="line">partition Orchestra #CCCCEE &#123;</span><br><span class="line">WavesArmes --&gt; Introduction</span><br><span class="line">--&gt; &quot;Play music&quot;</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_8.png" alt="activity8"></p><h3 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title Servlet Container</span><br><span class="line">(*) --&gt; &quot;ClickServlet.handleRequest()&quot;</span><br><span class="line">--&gt; &quot;new Page&quot;</span><br><span class="line">if &quot;Page.onSecurityCheck&quot; then</span><br><span class="line">-&gt;[true] &quot;Page.onInit()&quot;</span><br><span class="line">if &quot;isForward?&quot; then</span><br><span class="line">-&gt;[no] &quot;Process controls&quot;</span><br><span class="line">if &quot;continue processing?&quot; then</span><br><span class="line">--&gt;[yes] ===RENDERING===</span><br><span class="line">else</span><br><span class="line">--&gt;[no] ===REDIRECT_CHECK===</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">--&gt;[yes] ===RENDERING===</span><br><span class="line">endif</span><br><span class="line">if &quot;is Post?&quot; then</span><br><span class="line">--&gt;[yes] &quot;Page.onPost()&quot;</span><br><span class="line">--&gt; &quot;Page.onRender()&quot; as render</span><br><span class="line">--&gt; ===REDIRECT_CHECK===</span><br><span class="line">else</span><br><span class="line">--&gt;[no] &quot;Page.onGet()&quot;</span><br><span class="line">--&gt; render</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">--&gt;[false] ===REDIRECT_CHECK===</span><br><span class="line">endif</span><br><span class="line">if &quot;Do redirect?&quot; then</span><br><span class="line">-&gt;[yes] &quot;redirect request&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">else</span><br><span class="line">if &quot;Do Forward?&quot; then</span><br><span class="line">-left-&gt;[yes] &quot;Forward request&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">else</span><br><span class="line">-right-&gt;[no] &quot;Render page template&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">--&gt; &quot;Page.onDestroy()&quot;</span><br><span class="line">--&gt;(*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_9.png" alt="activity9"></p><h3 id="界面格式相关"><a href="#界面格式相关" class="headerlink" title="界面格式相关"></a>界面格式相关</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam SequenceGroupBodyBackgroundColor #FFFFFF90</span><br><span class="line"></span><br><span class="line">box &quot;Internal Service&quot; #LightBlue</span><br><span class="line">    participant Bob</span><br><span class="line">    participant Alice</span><br><span class="line">end box</span><br><span class="line"></span><br><span class="line">box &quot;Other&quot; #LightGreen</span><br><span class="line">    participant Other</span><br><span class="line">end box</span><br><span class="line"></span><br><span class="line">group group</span><br><span class="line">    Bob -&gt; Alice : hello</span><br><span class="line">    Alice -&gt; Other : hello</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/skinparam_uml_0.png" alt="skinparam_uml_0"></p><h3 id="颜色示例"><a href="#颜色示例" class="headerlink" title="颜色示例"></a>颜色示例</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">!unquoted procedure $DrawColor($colour)</span><br><span class="line"></span><br><span class="line">    skinparam rectangle &#123;</span><br><span class="line">            backgroundColor&lt;&lt;$colour&gt;&gt; $colour</span><br><span class="line">            borderColor&lt;&lt;$colour&gt;&gt; $colour</span><br><span class="line">            shadowing&lt;&lt;$colour&gt;&gt; true</span><br><span class="line">            BorderThickness&lt;&lt;$colour&gt;&gt; 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    rectangle $colour &lt;&lt;$colour&gt;&gt; as &quot;&lt;color:$colour&gt;&lt;/color&gt;&quot;</span><br><span class="line"></span><br><span class="line">!endprocedure</span><br><span class="line"></span><br><span class="line">package HexCodes &#123;</span><br><span class="line">$DrawColor(&quot;00ff00&quot;)</span><br><span class="line">$DrawColor(&quot;ff0000&quot;)</span><br><span class="line">$DrawColor(&quot;0000ff&quot;)</span><br><span class="line">$DrawColor(&quot;123456&quot;)</span><br><span class="line">$DrawColor(&quot;654321&quot;)</span><br><span class="line">$DrawColor(&quot;165432&quot;)</span><br><span class="line">$DrawColor(&quot;ff22ff&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package Colours &#123;</span><br><span class="line">$DrawColor(&quot;APPLICATION&quot;)</span><br><span class="line">$DrawColor(&quot;AliceBlue&quot;)</span><br><span class="line">$DrawColor(&quot;AntiqueWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Aqua&quot;)</span><br><span class="line">$DrawColor(&quot;Aquamarine&quot;)</span><br><span class="line">$DrawColor(&quot;Azure&quot;)</span><br><span class="line">$DrawColor(&quot;BUSINESS&quot;)</span><br><span class="line">$DrawColor(&quot;Beige&quot;)</span><br><span class="line">$DrawColor(&quot;Bisque&quot;)</span><br><span class="line">$DrawColor(&quot;Black&quot;)</span><br><span class="line">$DrawColor(&quot;BlanchedAlmond&quot;)</span><br><span class="line">$DrawColor(&quot;Blue&quot;)</span><br><span class="line">$DrawColor(&quot;BlueViolet&quot;)</span><br><span class="line">$DrawColor(&quot;Brown&quot;)</span><br><span class="line">$DrawColor(&quot;BurlyWood&quot;)</span><br><span class="line">$DrawColor(&quot;CadetBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Chartreuse&quot;)</span><br><span class="line">$DrawColor(&quot;Chocolate&quot;)</span><br><span class="line">$DrawColor(&quot;Coral&quot;)</span><br><span class="line">$DrawColor(&quot;CornflowerBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Cornsilk&quot;)</span><br><span class="line">$DrawColor(&quot;Crimson&quot;)</span><br><span class="line">$DrawColor(&quot;Cyan&quot;)</span><br><span class="line">$DrawColor(&quot;DarkBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DarkCyan&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGray&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DarkKhaki&quot;)</span><br><span class="line">$DrawColor(&quot;DarkMagenta&quot;)</span><br><span class="line">$DrawColor(&quot;DarkOliveGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkOrchid&quot;)</span><br><span class="line">$DrawColor(&quot;DarkRed&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSalmon&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DarkTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;DarkViolet&quot;)</span><br><span class="line">$DrawColor(&quot;Darkorange&quot;)</span><br><span class="line">$DrawColor(&quot;DeepPink&quot;)</span><br><span class="line">$DrawColor(&quot;DeepSkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DimGray&quot;)</span><br><span class="line">$DrawColor(&quot;DimGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DodgerBlue&quot;)</span><br><span class="line">$DrawColor(&quot;FireBrick&quot;)</span><br><span class="line">$DrawColor(&quot;FloralWhite&quot;)</span><br><span class="line">$DrawColor(&quot;ForestGreen&quot;)</span><br><span class="line">$DrawColor(&quot;Fuchsia&quot;)</span><br><span class="line">$DrawColor(&quot;Gainsboro&quot;)</span><br><span class="line">$DrawColor(&quot;GhostWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Gold&quot;)</span><br><span class="line">$DrawColor(&quot;GoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;Gray&quot;)</span><br><span class="line">$DrawColor(&quot;Green&quot;)</span><br><span class="line">$DrawColor(&quot;GreenYellow&quot;)</span><br><span class="line">$DrawColor(&quot;Grey&quot;)</span><br><span class="line">$DrawColor(&quot;HoneyDew&quot;)</span><br><span class="line">$DrawColor(&quot;HotPink&quot;)</span><br><span class="line">$DrawColor(&quot;IMPLEMENTATION&quot;)</span><br><span class="line">$DrawColor(&quot;IndianRed&quot;)</span><br><span class="line">$DrawColor(&quot;Indigo&quot;)</span><br><span class="line">$DrawColor(&quot;Ivory&quot;)</span><br><span class="line">$DrawColor(&quot;Khaki&quot;)</span><br><span class="line">$DrawColor(&quot;Lavender&quot;)</span><br><span class="line">$DrawColor(&quot;LavenderBlush&quot;)</span><br><span class="line">$DrawColor(&quot;LawnGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LemonChiffon&quot;)</span><br><span class="line">$DrawColor(&quot;LightBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightCoral&quot;)</span><br><span class="line">$DrawColor(&quot;LightCyan&quot;)</span><br><span class="line">$DrawColor(&quot;LightGoldenRodYellow&quot;)</span><br><span class="line">$DrawColor(&quot;LightGray&quot;)</span><br><span class="line">$DrawColor(&quot;LightGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LightGrey&quot;)</span><br><span class="line">$DrawColor(&quot;LightPink&quot;)</span><br><span class="line">$DrawColor(&quot;LightSalmon&quot;)</span><br><span class="line">$DrawColor(&quot;LightSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LightSkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightSlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;LightSlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;LightSteelBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightYellow&quot;)</span><br><span class="line">$DrawColor(&quot;Lime&quot;)</span><br><span class="line">$DrawColor(&quot;LimeGreen&quot;)</span><br><span class="line">$DrawColor(&quot;Linen&quot;)</span><br><span class="line">$DrawColor(&quot;MOTIVATION&quot;)</span><br><span class="line">$DrawColor(&quot;Magenta&quot;)</span><br><span class="line">$DrawColor(&quot;Maroon&quot;)</span><br><span class="line">$DrawColor(&quot;MediumAquaMarine&quot;)</span><br><span class="line">$DrawColor(&quot;MediumBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MediumOrchid&quot;)</span><br><span class="line">$DrawColor(&quot;MediumPurple&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSpringGreen&quot;)</span><br><span class="line">$DrawColor(&quot;MediumTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;MediumVioletRed&quot;)</span><br><span class="line">$DrawColor(&quot;MidnightBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MintCream&quot;)</span><br><span class="line">$DrawColor(&quot;MistyRose&quot;)</span><br><span class="line">$DrawColor(&quot;Moccasin&quot;)</span><br><span class="line">$DrawColor(&quot;NavajoWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Navy&quot;)</span><br><span class="line">$DrawColor(&quot;OldLace&quot;)</span><br><span class="line">$DrawColor(&quot;Olive&quot;)</span><br><span class="line">$DrawColor(&quot;OliveDrab&quot;)</span><br><span class="line">$DrawColor(&quot;Orange&quot;)</span><br><span class="line">$DrawColor(&quot;OrangeRed&quot;)</span><br><span class="line">$DrawColor(&quot;Orchid&quot;)</span><br><span class="line">$DrawColor(&quot;PHYSICAL&quot;)</span><br><span class="line">$DrawColor(&quot;PaleGoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;PaleGreen&quot;)</span><br><span class="line">$DrawColor(&quot;PaleTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;PaleVioletRed&quot;)</span><br><span class="line">$DrawColor(&quot;PapayaWhip&quot;)</span><br><span class="line">$DrawColor(&quot;PeachPuff&quot;)</span><br><span class="line">$DrawColor(&quot;Peru&quot;)</span><br><span class="line">$DrawColor(&quot;Pink&quot;)</span><br><span class="line">$DrawColor(&quot;Plum&quot;)</span><br><span class="line">$DrawColor(&quot;PowderBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Purple&quot;)</span><br><span class="line">$DrawColor(&quot;Red&quot;)</span><br><span class="line">$DrawColor(&quot;RosyBrown&quot;)</span><br><span class="line">$DrawColor(&quot;RoyalBlue&quot;)</span><br><span class="line">$DrawColor(&quot;STRATEGY&quot;)</span><br><span class="line">$DrawColor(&quot;SaddleBrown&quot;)</span><br><span class="line">$DrawColor(&quot;Salmon&quot;)</span><br><span class="line">$DrawColor(&quot;SandyBrown&quot;)</span><br><span class="line">$DrawColor(&quot;SeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;SeaShell&quot;)</span><br><span class="line">$DrawColor(&quot;Sienna&quot;)</span><br><span class="line">$DrawColor(&quot;Silver&quot;)</span><br><span class="line">$DrawColor(&quot;SkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;SlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;SlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;SlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;Snow&quot;)</span><br><span class="line">$DrawColor(&quot;SpringGreen&quot;)</span><br><span class="line">$DrawColor(&quot;SteelBlue&quot;)</span><br><span class="line">$DrawColor(&quot;TECHNOLOGY&quot;)</span><br><span class="line">$DrawColor(&quot;Tan&quot;)</span><br><span class="line">$DrawColor(&quot;Teal&quot;)</span><br><span class="line">$DrawColor(&quot;Thistle&quot;)</span><br><span class="line">$DrawColor(&quot;Tomato&quot;)</span><br><span class="line">$DrawColor(&quot;Turquoise&quot;)</span><br><span class="line">$DrawColor(&quot;Violet&quot;)</span><br><span class="line">$DrawColor(&quot;Wheat&quot;)</span><br><span class="line">$DrawColor(&quot;White&quot;)</span><br><span class="line">$DrawColor(&quot;WhiteSmoke&quot;)</span><br><span class="line">$DrawColor(&quot;Yellow&quot;)</span><br><span class="line">$DrawColor(&quot;YellowGreen&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/color_uml.png" alt="color_uml"></p><h3 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h3><p><a href="https://crashedmind.github.io/PlantUMLHitchhikersGuide/about/AboutPlantUML.html">PlantUML资料</a></p>]]></content>
      
      
      <categories>
          
          <category> UML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读C++线程池源码</title>
      <link href="/2020/06/27/2020-06-27-%E9%98%85%E8%AF%BBC++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/"/>
      <url>/2020/06/27/2020-06-27-%E9%98%85%E8%AF%BBC++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="progschj-thread-pool"><a href="#progschj-thread-pool" class="headerlink" title="progschj&#x2F;thread_pool"></a>progschj&#x2F;thread_pool</h2><p>Github上这个库(<a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">progschj&#x2F;thread_pool</a>)的点赞最多，学习一下。</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>);</span><br><span class="line">  <span class="comment">/// 任务入列</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line">  ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 所有的工作线程</span></span><br><span class="line">  std::vector&lt;std::thread&gt; workers;</span><br><span class="line">  <span class="comment">/// 任务队列</span></span><br><span class="line">  std::queue&lt;std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 用于同步的互斥锁和条件变量</span></span><br><span class="line">  std::mutex queue_mutex;</span><br><span class="line">  std::condition_variable condition;</span><br><span class="line">  <span class="type">bool</span> stop;  <span class="comment">///&lt; 用于判断所有线程是否需要结束</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数和消费者实现"><a href="#构造函数和消费者实现" class="headerlink" title="构造函数和消费者实现"></a>构造函数和消费者实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     ThreadPool</span></span><br><span class="line"><span class="comment">/// @brief    用于创建若干个线程，并规定消费者函数</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    threads   [in]    要创建的线程数量</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 16:17:50</span></span><br><span class="line"><span class="comment">/// @warning  线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span> : stop(false) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i)</span><br><span class="line">    workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/// 获取同步锁</span></span><br><span class="line">          std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">          <span class="comment">/// 阻塞等待获取任务，直到任务队列不为空</span></span><br><span class="line">          <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(</span><br><span class="line">              lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">          <span class="comment">/// 如果stop标志位为true，且任务列表都执行完毕后，该线程退出</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">/// 从任务队列中拿出来一个任务</span></span><br><span class="line">          task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">          <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;  <span class="comment">///&lt; 这里释放锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 执行该任务函数</span></span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 在stop位, 置为true后通知所有线程执行一次，然后等待所有线程处理完任务后join()</span></span><br><span class="line">  condition.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers) worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者函数"><a href="#生产者函数" class="headerlink" title="生产者函数"></a>生产者函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     enqueue</span></span><br><span class="line"><span class="comment">/// @brief    用于添加任务函数到任务队列中</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    f     [in]    任务函数</span></span><br><span class="line"><span class="comment">/// @param    args  [in]    任务函数的入参列表</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   取决于任务函数的返回值</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 16:06:30</span></span><br><span class="line"><span class="comment">/// @warning  线程安全</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::invoke_result&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 这里封装一个异步的线程并执行刚刚传入的函数，这个函数通过bind改类型为void()</span></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">  <span class="comment">/// 创建一个这个函数的未来的值， 这个未来值不获取就不会进行计算</span></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 假如说没有让这个线程停止则继续，否则抛出异常阻止线程池结束后在入列</span></span><br><span class="line">    <span class="keyword">if</span> (stop) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    <span class="comment">/// 这个封装好的函数放入任务列表中</span></span><br><span class="line">    tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 通知一个阻塞中的线程，任务队列中有任务了</span></span><br><span class="line">  condition.<span class="built_in">notify_one</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 异步运算接口</title>
      <link href="/2020/06/27/2020-06-27-C++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/06/27/2020-06-27-C++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="std-async介绍"><a href="#std-async介绍" class="headerlink" title="std::async介绍"></a>std::async介绍</h2><p>下面是一个很好的并行计算的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** is_prime(700020007)这个函数调用隐藏于主线程，异步执行 */</span></span><br><span class="line">    std::future&lt;<span class="type">bool</span>&gt; fut = std::<span class="built_in">async</span>(is_prime, <span class="number">700020007</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;please wait&quot;</span>;</span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">span</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">/** 这个异步调用函数等待100ms，如果没有计算完就继续等待 */</span></span><br><span class="line">    <span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(span) != std::future_status::ready)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 计算完毕后，获取函数返回值 */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;final result: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::async中的第一个参数是启动策略，它控制std::async的异步行为，我们可以用三种不同的启动策略来创建std::async<br><strong>·std::launch::async</strong><br>保证异步行为，即传递函数将在单独的线程中执行<br><strong>·std::launch::deferred</strong><br>当其他线程调用get()来访问共享状态时，将调用非异步行为<br><strong>·std::launch::async | std::launch::deferred</strong><br>默认行为。有了这个启动策略，它可以异步运行或不运行，这取决于系统的负载，但我们无法控制它。</p><p>见下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保函数要5秒才能执行完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理创建数据库连接、获取数据等事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DB_&quot;</span> + recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromFile</span><span class="params">(std::string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保函数要5秒才能执行完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理获取文件数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;File_&quot;</span> + recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取开始时间</span></span><br><span class="line">    system_clock::time_point start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用std::launch::async，来指定其异步执行 */</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                                                    fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从文件获取数据</span></span><br><span class="line">    std::string fileData = <span class="built_in">fetchDataFromFile</span>(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从DB获取数据</span></span><br><span class="line">    <span class="comment">//数据在future&lt;std::string&gt;对象中可获取之前，将一直阻塞</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结束时间</span></span><br><span class="line">    <span class="keyword">auto</span> end = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> diff = <span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装数据</span></span><br><span class="line">    std::string data = dbData + <span class="string">&quot; :: &quot;</span> + fileData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出组装的数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-promise介绍"><a href="#std-promise介绍" class="headerlink" title="std::promise介绍"></a>std::promise介绍</h2><p>std::promise的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个某种类型的值，并将其传递给对应的future， 即使这个future不在同一个线程中也可以安全的访问到这个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::ref</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>         <span class="comment">// std::promise, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_int</span> <span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fut)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter print_int: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> x = fut.<span class="built_in">get</span>();  <span class="comment">///&lt; 在这里会等待外部std::promise变量set_value进来，否则会一致阻塞在这里</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;                      <span class="comment">// 创建一个std::promise变量</span></span><br><span class="line"></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();    <span class="comment">// 创建一个std::future变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">th1</span> <span class="params">(print_int, std::ref(fut))</span></span>;  <span class="comment">// 创建一个线程执行函数print_int</span></span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    prom.<span class="built_in">set_value</span> (<span class="number">10</span>);                         <span class="comment">// 传值进入线程th1</span></span><br><span class="line"></span><br><span class="line">    th<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-packaged-task介绍"><a href="#std-packaged-task介绍" class="headerlink" title="std::packaged_task介绍"></a>std::packaged_task介绍</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>       <span class="comment">// std::chrono::seconds</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>       <span class="comment">// std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// count down taking a second for each value:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countdown</span> <span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = from; i != to; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lift off!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> from - to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个std::packaged_task对象</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">tsk</span> <span class="params">(countdown)</span></span>;</span><br><span class="line">    <span class="comment">// 创建一个std::future对象，用于跨线程异步获取该线程返回的值</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; ret = tsk.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="comment">// 把线程对象移动进一个可运行的线程中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">th</span> <span class="params">(std::move(tsk), <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 让该线程从主线程中分离</span></span><br><span class="line">    th.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 利用std::future对象来获取已经分离开的线程运行是否结束的返回的值</span></span><br><span class="line">    <span class="type">int</span> value = ret.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The countdown lasted for &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; seconds.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="硬件支持的线程数量"><a href="#硬件支持的线程数量" class="headerlink" title="硬件支持的线程数量"></a>硬件支持的线程数量</h2><p>由于硬件支持的并行线程数量有限，如果创建线程的数量比硬件支持的数量要多，那么CPU进行的上下文切换可能会浪费大量时间，所以了解硬件支持的线程数量是高效并行编程的重点。</p><p>使用<code>std::thread::hardware_concurrency()</code>来获取硬件支持的线程数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; concurrent threads are supported.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-thread-yield介绍"><a href="#std-thread-yield介绍" class="headerlink" title="std::thread::yield介绍"></a>std::thread::yield介绍</h2><p><a href="https://stackoverflow.com/questions/11048946/stdthis-threadyield-vs-stdthis-threadsleep-for">关于std::thread::yield 和 std::sleep_for的比较</a></p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (work_queue.<span class="built_in">try_pop</span>(task)) &#123;</span><br><span class="line">            <span class="comment">/// 获取到任务就运行</span></span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 没有获取到就休息一下</span></span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读spdlog-thread_pool源码</title>
      <link href="/2020/06/26/2020-06-27-%E9%98%85%E8%AF%BBspdlog-thread_pool%E6%BA%90%E7%A0%81/"/>
      <url>/2020/06/26/2020-06-27-%E9%98%85%E8%AF%BBspdlog-thread_pool%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="thread-pool-源码学习"><a href="#thread-pool-源码学习" class="headerlink" title="thread_pool 源码学习"></a>thread_pool 源码学习</h2><h3 id="源码定义"><a href="#源码定义" class="headerlink" title="源码定义"></a>源码定义</h3><p>我们先概览一下<a href="https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/details/thread_pool.h">spdlog-thread_pool定义</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SPDLOG_API</span> thread_pool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> item_type = async_msg;</span><br><span class="line">    <span class="keyword">using</span> q_type = details::mpmc_blocking_queue&lt;item_type&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span><br><span class="line">                std::function&lt;<span class="built_in">void</span>()&gt; on_thread_start);</span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n);</span><br><span class="line">    ~<span class="built_in">thread_pool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_pool &amp;<span class="keyword">operator</span>=(thread_pool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_log</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr, <span class="type">const</span> details::log_msg &amp;msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                  async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_flush</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                    async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    q_type q_; <span class="comment">///&lt; 任务队列</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;  <span class="comment">///&lt; 线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_async_msg_</span><span class="params">(async_msg &amp;&amp;new_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                         async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_loop_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process_next_msg_</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="基本成员函数"><a href="#基本成员函数" class="headerlink" title="基本成员函数"></a>基本成员函数</h3><p>首先我们从thread_pll中最基本的五个成员函数开始看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span><br><span class="line">            std::function&lt;<span class="built_in">void</span>()&gt; on_thread_start);</span><br><span class="line"><span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// message all threads to terminate gracefully join them</span></span><br><span class="line">~<span class="built_in">thread_pool</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">thread_pool &amp;<span class="keyword">operator</span>=(thread_pool &amp;&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>可以看到该类删除了拷贝构造，移动构造，标志该类不可以被拷贝和移动。<br>其中有两个构造函数，我们来详细看看它们的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     thread_pool</span></span><br><span class="line"><span class="comment">/// @brief    构造函数，创建了一定数量的线程，并规定执行哪个函数</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    q_max_item      [in] 用于初始化任务队列最大的数量</span></span><br><span class="line"><span class="comment">/// @param    thread_n        [in] 用于初始化最大线程数量</span></span><br><span class="line"><span class="comment">/// @param    on_thread_start [in] 每个线程执行的初始化函数(只执行一次)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:32:47</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">thread_pool</span><span class="params">(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::function&lt;<span class="type">void</span>()&gt; on_thread_start)</span></span></span><br><span class="line"><span class="function">    : q_(q_max_items) ///&lt; 任务队列的最大数目</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (threads_n == <span class="number">0</span> || threads_n &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span>(</span><br><span class="line">        <span class="string">&quot;spdlog::thread_pool(): invalid threads_n param (valid &quot;</span></span><br><span class="line">        <span class="string">&quot;range is 1-1000)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads_n; i++) &#123;</span><br><span class="line">    threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, on_thread_start] &#123;</span><br><span class="line">      <span class="comment">/// 线程开始时候需要执行的初始函数</span></span><br><span class="line">      <span class="built_in">on_thread_start</span>();</span><br><span class="line">      <span class="comment">/// 主任务循环</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;thread_pool::<span class="built_in">worker_loop_</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 委托构造函数，用于输入默认入参 std::function&lt;void()&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">thread_pool::thread_pool</span><span class="params">(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n)</span></span></span><br><span class="line"><span class="function">    : thread_pool(q_max_items, threads_n, [] &#123;</span>&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure><p>接着我们来看一下析构函数执行了什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 告诉所有线程中止，并且执行join()</span></span><br><span class="line">~<span class="built_in">thread_pool</span>() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">/// 对每一个线程池发送一个中止消息</span></span><br><span class="line">      <span class="built_in">post_async_msg_</span>(<span class="built_in">async_msg</span>(async_msg_type::terminate),</span><br><span class="line">                      async_overflow_policy::block);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads_) &#123;</span><br><span class="line">      <span class="comment">/// 等待每一个线程的结束时的join</span></span><br><span class="line">      t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">/// 析构函数中不能有异常，所以在这里做一个全捕获</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者逻辑"><a href="#生产者逻辑" class="headerlink" title="生产者逻辑"></a>生产者逻辑</h3><p>接着我们来看公有的两个接口函数的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用于发送任务消息，并判断是否需要打印到命令行或写入文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_log</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr, <span class="type">const</span> log_msg &amp;msg,</span></span></span><br><span class="line"><span class="params"><span class="function">              async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="function">async_msg <span class="title">async_m</span><span class="params">(std::move(worker_ptr), async_msg_type::log, msg)</span></span>;</span><br><span class="line">  <span class="built_in">post_async_msg_</span>(std::<span class="built_in">move</span>(async_m), overflow_policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于发送任务消息，并判断是否需要马上写入文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_flush</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">post_async_msg_</span>(<span class="built_in">async_msg</span>(std::<span class="built_in">move</span>(worker_ptr), async_msg_type::flush),</span><br><span class="line">                  overflow_policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于返回任务队列溢出了多少条</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> q_.<span class="built_in">overrun_counter</span>(); &#125;</span><br></pre></td></tr></table></figure><p> <code>post_log</code> 和 <code>post_flush</code> 执行了一个差不多的任务，就是写日志，这两个函数都调用了<code>post_async_msg_()</code>来执行具体的任务们就来看看<code>post_async_msg_()</code>到底执行了什么。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     post_async_msg_</span></span><br><span class="line"><span class="comment">/// @brief    用于从队列中插入消息, 相当于生产者</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    new_msg         [in] 用于传入异步日志消息(使用右值方便移动)</span></span><br><span class="line"><span class="comment">/// @param    overflow_policy [in] 消息数量溢出的策略</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:42:18</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_async_msg_</span><span class="params">(async_msg &amp;&amp;new_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                     async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (overflow_policy == async_overflow_policy::block) &#123;</span><br><span class="line">    <span class="comment">/// 阻塞至消息队列中有空间来插入消息</span></span><br><span class="line">    q_.<span class="built_in">enqueue</span>(std::<span class="built_in">move</span>(new_msg));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 立即插入队列且队列满时丢弃老的消息</span></span><br><span class="line">    q_.<span class="built_in">enqueue_nowait</span>(std::<span class="built_in">move</span>(new_msg));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者逻辑"><a href="#消费者逻辑" class="headerlink" title="消费者逻辑"></a>消费者逻辑</h3><p> 如上面的实现，我们知道这是一个生产者，从外部插入到本对象内的任务队列，等待消费者来处理这些消息<br> 我们来看看消费者到底执行了什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     worker_loop_</span></span><br><span class="line"><span class="comment">/// @brief    用于每个线程执行的死循环，当process_next_msg_返回false时候</span></span><br><span class="line"><span class="comment">///           线程自己退出</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:51:13</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_loop_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 如果处理消息没有返回false，就一致执行该函数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">process_next_msg_</span>()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @name     process_next_msg_</span></span><br><span class="line"><span class="comment">/// @brief    处理队列中的下一个消息，相当于消费者</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   如果不是中止线程消息，则返回true, 反之返回false</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:53:45</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">process_next_msg_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  async_msg incoming_async_msg;</span><br><span class="line">  <span class="comment">/// 从任务消息队列中取消息，如果没有任务则等待获取任务,</span></span><br><span class="line">  <span class="comment">/// 如十秒后仍然没有获取到则直接返回</span></span><br><span class="line">  <span class="type">bool</span> dequeued =</span><br><span class="line">      q_.<span class="built_in">dequeue_for</span>(incoming_async_msg, std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">  <span class="comment">/// 如果获取任务消息失败则直接返回true</span></span><br><span class="line">  <span class="keyword">if</span> (!dequeued) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 获取到消息后则进行处理</span></span><br><span class="line">  <span class="keyword">switch</span> (incoming_async_msg.msg_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> async_msg_type::log: &#123;</span><br><span class="line">      <span class="comment">/// 打印消息到命令行且判断是否要马上刷新文件</span></span><br><span class="line">      incoming_async_msg.worker_ptr-&gt;<span class="built_in">backend_sink_it_</span>(incoming_async_msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> async_msg_type::flush: &#123;</span><br><span class="line">      <span class="comment">/// 刷新文件</span></span><br><span class="line">      incoming_async_msg.worker_ptr-&gt;<span class="built_in">backend_flush_</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> async_msg_type::terminate: &#123;</span><br><span class="line">      <span class="comment">/// 用于终止本线程池的信号</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑我们可以看到：首先由<code>worker_loop()</code>函数来不停的执行消费者函数。<br>而消费者函数在不停地去任务队列中获取任务最后由<code>backend_sink_it_()</code> 和 <code>backend_flush_()</code>两个函数来执行真正地任务。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>很简单的一个消费者和生产者的队列，但最核心的部分被一个任务队列<code>mpmc_blocking_queue&lt;async_msg&gt;</code>给封装了，让我们继续深入来看看这个任务队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mpmc_blocking_queue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> item_type = T;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mpmc_blocking_queue</span><span class="params">(<span class="type">size_t</span> max_items)</span> : q_(max_items) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 尝试入列，如果空间不足则阻塞</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      pop_cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;q_.<span class="built_in">full</span>(); &#125;);</span><br><span class="line">      q_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    push_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 马上入列，如果没有空间则丢弃队列中老的消息</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enqueue_nowait</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      q_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    push_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 尝试出列。如果队列中没有消息，则等待到超时然后再次尝试</span></span><br><span class="line">  <span class="comment">/// 假如出列成功则返回true, 否则返回false</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dequeue_for</span><span class="params">(T &amp;popped_item, std::chrono::milliseconds wait_duration)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (!push_cv_.<span class="built_in">wait_for</span>(lock, wait_duration,</span><br><span class="line">                             [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;q_.<span class="built_in">empty</span>(); &#125;)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      popped_item = std::<span class="built_in">move</span>(q_.<span class="built_in">front</span>());</span><br><span class="line">      q_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pop_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> q_.<span class="built_in">overrun_counter</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex queue_mutex_;           <span class="comment">///&lt; 用于控制整个对象的锁</span></span><br><span class="line">  std::condition_variable push_cv_;  <span class="comment">///&lt; 用于入列的条件变量</span></span><br><span class="line">  std::condition_variable pop_cv_;   <span class="comment">///&lt; 用于出列的条件变量</span></span><br><span class="line">  circular_q&lt;T&gt; q_;                  <span class="comment">///&lt; 用于保存信息的队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看看这个队列是怎么实现线程安全的。<br>其中<code>q_</code>这个循环队列不是线程安全的，所以加上了一个<code>queue_mutex</code> 这个互斥锁用来同步所有成员函数的顺序并配合条件变量实现等待获取的功能。</p><p><code>spdlog-thread_pool</code> 的实现逻辑很清晰，我们可以对比一下Github上另一个thread-pool: <a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">progschj&#x2F;ThreadPool</a> 的实现。<br>由于需要写入的任务很明确，就是处理异步日志，所以任务的队列直接写死了处理异步日志消息。而progschj&#x2F;ThreadPool的实现则更加灵活。我们可以看看我的另一篇博客<a href="./_site/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2020/06/27/%E9%98%85%E8%AF%BB%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81.html">阅读progschj&#x2F;thread_pool源码</a>对progschj&#x2F;ThreadPool的介绍</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于加法溢出的判断</title>
      <link href="/2020/06/26/2020-06-26-C++%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2020/06/26/2020-06-26-C++%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>首先我们知道整型是由有符号和无符号整型所组成。由于有符号整型的判断包含了无符号整型的计算，所以我们现在先讨论<strong>有符号整型</strong>。</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592040132570.png" alt="1592040132570"></p><p>有符号整型的加法包括以下几种情况：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592042113575.png" alt="1592042113575"></p><p>由上图我们可以知道我们只用考虑两个操作数拥有<strong>相同符号</strong>的情况就行了。我们显而易见的可以知道，<strong>两数相加的结果一定大于任一操作数</strong>，写出以下函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来为了测试这个函数能否正确运行，我们添加如下测试用例：case 1.</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592044663011.png" alt="1592044663011"></p><p>完整验证程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑两数都为负数，判断负溢出的情况，同样我们知道<strong>两负数相加结果一定小于任一操作数</strong>, 对函数加以补充，并添加两个测试用例：case 2.</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592044894101.png" alt="1592044894101"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算负溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">-1</span>, <span class="number">-1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_min, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的程序顺利执行完毕后我们可以继续往下看。接着我们能不能使用模板来扩展到其他类型的加法.</p><p>当然可以我们只需要把<code>int</code>换为模板参数T就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    T result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算负溢出的情况</span></span><br><span class="line">    T result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们为模板函数添加上类型限定和静态编译检查。然后同样使用测试用例:case 1 和 case 2 来测试以下这个模板函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参的类型是否一致</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参类型都为整数类型</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need integral type!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  T1 result = x + y;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">-1</span>, <span class="number">-1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(int_min, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来添加上详细的测试用例就大功告成了。</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592130012130.png" alt="1592130012130"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参的类型是否一致</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参类型都为整数类型</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need integral type!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  T1 result = x + y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result &lt; x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result &gt; x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">1</span>, <span class="number">1</span>));       <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(max_num, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">-1</span>, <span class="number">-1</span>));      <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(min_num, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 3</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(max_num, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// case 4</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(max_num, min_num));</span><br><span class="line">  <span class="comment">/// case 5</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, max_num));</span><br><span class="line">  <span class="comment">/// case 6</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// case 7</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, min_num));</span><br><span class="line">  <span class="comment">/// case 8</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(min_num, max_num));</span><br><span class="line">  <span class="comment">/// case 9</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(min_num, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个函数也<strong>可以用作检查减法是否溢出</strong>，只需要对第二个入参求相反数即可。但<strong>需要注意</strong>一个情况。</p><blockquote><p> 就是int值的负数个数(- 2^31)是比正数个数(2^31 - 1)多一个的, 所以在转化为相反数的时候可能在函数入参时出现溢出，导致计算没有溢出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">is_plus_overflow_t</span>(x, y);<span class="comment">/// 正确：等价与计算 2-1 表达式会不会溢出</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">y = INT_MIN;</span><br><span class="line"><span class="built_in">is_plus_overflow_t</span>(x, -y);<span class="comment">/// 错误：当y等于int的最小值的时候，无法求其相反数，会直接溢出</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于数值极限</title>
      <link href="/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/"/>
      <url>/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="关于数值极限"><a href="#关于数值极限" class="headerlink" title="关于数值极限"></a>关于数值极限</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type\t\t\tlowest()\t\tmin()\t\t\tmax()\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned short\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h2><blockquote><p>在64位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/1592038101047.png" alt="1592038101047"></p></blockquote><p>换为2的幂级数表示为（64位系统下）：</p><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table><h2 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h2><blockquote><p>在32位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/Snipaste_2022-10-12_15-36-58.png" alt="1592038101047"></p></blockquote><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
