<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面对对象简介与 C++ 类的基本介绍</title>
      <link href="/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-10-23-C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C-构造函数与析构函数"><a href="#C-构造函数与析构函数" class="headerlink" title="C++ 构造函数与析构函数"></a>C++ 构造函数与析构函数</h2><p>类的基本组合元素。<br>构造函数、析构函数、拷贝构造函数和拷贝复制符</p><p>构造函数在对象被创建的时候调用，如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;          <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">    A* p = <span class="keyword">new</span> A;   <span class="comment">///&lt; 调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数在对象被销毁时刻调用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        A obj;</span><br><span class="line">    &#125;   <span class="comment">///&lt; 临时变量超出作用域，调用析构函数</span></span><br><span class="line"></span><br><span class="line">    A* p = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">///&lt; 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造与析构函数的具体讲解可见 <a href="https://mercy1101.github.io/C++-%E7%B1%BB%E5%86%85%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/">类内默认成员函数</a></p><h2 id="面对对象的简介"><a href="#面对对象的简介" class="headerlink" title="面对对象的简介"></a>面对对象的简介</h2><p>对象有三个特点: 封装、继承和多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>封装方法</li><li>聚合数据</li><li>隐藏细节</li></ul><h4 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h4><p>当我们在使用对象时，自然而然可以把一系列方法放在一个类内，就比如我们想要定义一系列读取 <code>Json</code> 字符串的方法。</p><p>下面是 <code>C 语言</code>的封装方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GJSON*  <span class="title">gos_json_init</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>    <span class="title">gos_json_free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span>    <span class="title">gos_json_parse</span><span class="params">(GJSON* Json, <span class="type">char</span> *szJson)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span>*   <span class="title">gos_json_get_string</span> <span class="params">(GJSON* Json, <span class="type">char</span> *szKey)</span></span>;</span><br></pre></td></tr></table></figure><p>我们推断使用顺序是:</p><ol><li>使用 <code>gos_json_init</code> 来获取一个可用的 <code>Json</code> 解析用的结构体, 其中存储了一些信息。</li><li>使用 <code>gos_json_parse</code> 来读取一系列 <code>Json</code> 字符串中的键值。</li><li>使用 <code>gos_json_get_string</code> 来通过键来获取值。</li><li>最后使用 <code>gos_json_free</code> 来释放资源。</li></ol><p>那么调用过程如以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GJSON* pJson = <span class="built_in">gos_json_init</span>();</span><br><span class="line">    <span class="built_in">gos_json_parse</span>(pJson, <span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = <span class="built_in">gos_json_get_string</span>(pJson, <span class="string">&quot;Key&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">gos_json_free</span>(pJson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比面对对象接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span> *szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上面所示: <code>C++</code>的接口</p><p>由于类内保存了一个 <code>GJSON</code> 的指针 <code>m_Json</code>, 所以接口函数不需要 <code>GJSON*</code> 的入参.<br>由于可以被调用的函数只有两个，那我们可以推测调用方法:</p><ol><li>使用 <code>parser</code> 接口函数解析 <code>json</code> 字符串</li><li>使用 <code>get_string</code> 接口函数来获取对应键的值</li></ol><p>调用如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Json obj;</span><br><span class="line">    obj.<span class="built_in">parser</span>(<span class="string">&quot;Json string&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* szValue = obj.<span class="built_in">get_string</span>(<span class="string">&quot;Key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的调用可以看到少了调用 <code>init</code> 和 <code>free</code> 两个函数的过程，因为 <code>class</code> 可以使用构造函数中初始化自己，在析构函数中做相反动作，我们下面补充构造函数和析构函数的定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Json = <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Json</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(m_Json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span>    <span class="title">parse</span><span class="params">(<span class="type">char</span> *szJson)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>*   <span class="title">get_string</span> <span class="params">(<span class="type">char</span>*szKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GJSON* m_Json;</span><br><span class="line">    <span class="function">GJSON* <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(GJSON* Json)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h4><p><code>class</code> 带来的好处是，类内不仅可以定义函数，也可以聚合成员，定义在一起方便查看与传递。</p><p>例如我们有一堆配置项数据需要保存。</p><p>C 语言可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="type">bool</span>     g_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 给变量赋值</span></span><br><span class="line">    g_ulLogLevel = <span class="number">1</span>;</span><br><span class="line">    g_bLogToStdout = TRUE;</span><br><span class="line">    g_bLogToFile = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他 cpp 文件中访问这些配置项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> g_ulLogLevel;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToStdout;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span>     g_bLogToFile;</span><br></pre></td></tr></table></figure><p>C++ 可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LocalCfg</span>() &#123; <span class="built_in">GetLogCfg</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> m_ulLogLevel;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToStdout;</span><br><span class="line">    <span class="type">bool</span>     m_bLogToFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetLogCfg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在其他地方访问这些配置项</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogCfg obj;</span><br><span class="line"></span><br><span class="line">    obj.m_ulLogLevel;</span><br><span class="line">    obj.m_bLogToStdout;</span><br><span class="line">    obj.m_bLogToFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们经常在类中见到函数 <code>Get</code> 和 <code>Set</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; value = i; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们为什么要把一个简单的赋值操作封装成函数呢？</p><p>如果我们想要把变量的赋值与其他业务联动，见下面的例子:</p><ol><li>追踪赋值，添加打印</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;value: %d -&gt; %d&quot;</span>, value, i);</span><br><span class="line">        value = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加锁来支持多线程</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        value = i;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> value_temp = value;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> value_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    GMutex mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>业务联动绑定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = i;</span><br><span class="line">        IsSet = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (IsSet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 返回无效值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 用于记录 value 是否有效</span></span><br><span class="line">    <span class="type">bool</span> IsSet = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="隐藏细节"><a href="#隐藏细节" class="headerlink" title="隐藏细节"></a>隐藏细节</h4><p>见下面代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 把大象放进冰箱里</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PutElephantInFreezer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/// 打开冰箱门</span></span><br><span class="line">        <span class="built_in">OpenFreezerDoor</span>();</span><br><span class="line">        <span class="comment">/// 把大象放进去</span></span><br><span class="line">        <span class="built_in">LetElephantIn</span>();</span><br><span class="line">        <span class="comment">/// 关上冰箱门</span></span><br><span class="line">        <span class="built_in">CloseFreezerDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LetElephantIn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseFreezerDoor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    <span class="comment">// 调用 public 函数来把大象放进冰箱里</span></span><br><span class="line">    obj.<span class="built_in">PutElephantInFreezer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍"><a href="#相关语法介绍" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="关于-public-与-private"><a href="#关于-public-与-private" class="headerlink" title="关于 public 与 private"></a>关于 <code>public</code> 与 <code>private</code></h5><p>关于关键字 <code>public</code> 和 <code>private</code>, <code>public</code> 类型的类内成员变量和函数，可以被类的实例调用而 <code>private</code> 不能。</p><p>实例化简单来说就是，把一个就是在代码中定义该对象。(如果把类的定义比作蛋糕模子，那么类的实例就是蛋糕)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OBJECT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象实例化</span></span><br><span class="line">    OBJECT obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例访问 public 类成员</span></span><br><span class="line">    obj.i_public = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象实例无法访问 private 成员</span></span><br><span class="line">    <span class="comment">// obj.i_private = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="友元函数介绍-friend-function"><a href="#友元函数介绍-friend-function" class="headerlink" title="友元函数介绍 (friend function)"></a>友元函数介绍 (<code>friend function</code>)</h5><p>对于私有变量和私有成员函数, 友元函数可以打破访问权限限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 友元函数不属于某个类，所以定义时</span></span><br><span class="line"><span class="comment">/// 不需要这样写:</span></span><br><span class="line"><span class="comment">/// void count::Set(counter&amp; obj, int num)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obj, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 友元函数内，对象实例访问对象私有成员</span></span><br><span class="line">    obj.i_private = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>友元函数本质是普通函数，友元只是描述的是对类的友元。</p></li><li><p>友元函数不属于类，是独立的函数，所以不受作用域描述符的限制。</p></li><li><p>友元函数本身可以同时成为多个类的友元函数。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(A&amp; obja, B&amp; objb, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obja.i_private = num;</span><br><span class="line">    objb.i_private = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj_a;</span><br><span class="line">    B obj_b;</span><br><span class="line">    <span class="built_in">Set</span>(obj_a, obj_b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类内-static-与对象之间的关系"><a href="#类内-static-与对象之间的关系" class="headerlink" title="类内 static 与对象之间的关系"></a>类内 <code>static</code> 与对象之间的关系</h5><p>在对象内的 <code>static</code> 变量和函数，与对象的生命周期无关，每一个对象的所有实例都共享同一个 <code>static</code> 变量和函数。</p><p>类内 <code>static</code> 函数对类内的静态成员函数、构造函数、析构函数和静态成员变量享有访问权限。</p><h6 id="类内静态变量"><a href="#类内静态变量" class="headerlink" title="类内静态变量"></a>类内静态变量</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">///&lt; 记录对象被实例化了多少次</span></span><br><span class="line">    <span class="built_in">A</span>()&#123;count++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    std::cout &lt;&lt; A::counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="类内静态成员函数"><a href="#类内静态成员函数" class="headerlink" title="类内静态成员函数"></a>类内静态成员函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCounter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_non_static = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun_non_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj0;</span><br><span class="line">    A obj1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, A::<span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">0.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, obj<span class="number">1.</span><span class="built_in">GetCounter</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示 类内静态成员函数是可以直接访问类内静态成员变量也可以调用类内静态成员函数<br>但不能调用类内非静态成员变量和函数, 如 <code>i_non_static</code>、 <code>fun_non_static</code></p><p>静态成员函数的使用限制，不能调用非 <code>static</code> 的类内成员函数和成员变量。</p><p>类内静态函数在单例模式中的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleon* pInstance = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pInstance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pInstance = <span class="keyword">new</span> Singleon;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleon</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承用来从基类中继承来函数或成员变量, 省却重复定义。</p><p>假如我们有很多呼叫相关的业务，都需要一个唯一的业务标识号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() : <span class="built_in">strBusinessID</span>(gos::<span class="built_in">GetUUID</span>()) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string strBusinessID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 点呼从基类中继承出来了一个业务 ID</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P2PCall</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P2PCall p2p_call;   <span class="comment">///&lt; 自动生成了一个唯一的业务号</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p2p_call.strBusinessID &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关语法介绍-1"><a href="#相关语法介绍-1" class="headerlink" title="相关语法介绍"></a>相关语法介绍</h4><h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span>: <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">derive</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~derive&quot;</span> &lt;&lt; std::endl; &#125; <span class="comment">///&lt; 不定义虚析构函数会导致内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base* p = <span class="keyword">new</span> derive;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="protected-关键字"><a href="#protected-关键字" class="headerlink" title="protected 关键字"></a><code>protected</code> 关键字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_protected</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 可访问基类中的 protected 成员</span></span><br><span class="line">    <span class="keyword">return</span> i_protected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int get_private()</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   基类中的 private 成员不能被派生类访问</span></span><br><span class="line">  <span class="comment">//   return i_private;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  base obj0;</span><br><span class="line">  <span class="comment">// 在基类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj0.i_protected = 0;</span></span><br><span class="line">  derive obj;</span><br><span class="line">  <span class="comment">// 在派生类实例中表现为私有成员, 不可访问</span></span><br><span class="line">  <span class="comment">// obj.i_protected = 0;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>假设一个程序员又想拥有使用 <code>VSCode</code> 的能力 又想拥有使用 <code>source insight</code> 能力，<code>UML</code> 图如下</p><p><img src="/../resource/C++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/multiple_inheritance.png" alt="multiple_inheritance"></p><p>写成代码为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseVSCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UseSourceInsight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Programmer 拥有了 class VSCode 和</span></span><br><span class="line"><span class="comment">// class SourceInsight 中的方法函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">UseVSCode</span>();</span><br><span class="line">    lijiancong.<span class="built_in">UserSourceInsight</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个基类中拥有同名成员变量或函数，则派生类使用时应标注该成员变量或函数的作用域，避免产生编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果两个基类中拥有同名成员变量或函数，</span></span><br><span class="line">    <span class="comment">/// 派生类使用时应该标注哪个类的成员变量或函数， 否则编译错误</span></span><br><span class="line">    <span class="keyword">return</span> A::i_protected;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="使用-virtual-阻隔菱形继承"><a href="#使用-virtual-阻隔菱形继承" class="headerlink" title="使用 virtual 阻隔菱形继承"></a>使用 <code>virtual</code> 阻隔菱形继承</h5><p>我们在使用多重继承时，可能会出现如下的情况。</p><p>可能出现如下情况:</p><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5Cmultiple_inheritance2.png" alt="multiple_inheritance2"></p><p>菱形继承不仅会出现二义性成员变量名或函数名，而且在虚函数的继承中，中间类每一个类都会保存一个继承的副本，导致未知问题。使用 <code>virtual</code> 关键字避免菱形继承导致的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Tool</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Tool::i: &quot;</span> &lt;&lt; &amp;i</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VSCode</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;VSCode::i: &quot;</span> &lt;&lt; &amp;(VSCode::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SourceInsight</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SourceInsight::i: &quot;</span></span><br><span class="line">              &lt;&lt; &amp;(SourceInsight::i)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/..%5Cresource%5CC++%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%5CSnipaste_2021-10-23_14-41-51.png" alt="Snipaste_2021-10-23_14-41-51"></p><p>如上图， <code>VSCode</code> 和 <code>SourceInsight</code> 两个类都保存了一份基类 <code>Tool::i</code> 的副本, 造成了二义性。使用 <code>virtual</code> 来避免菱形继承带来的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VSCode</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  使用 `virtual` 关键字来避免菱形继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceInsight</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tool</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="keyword">public</span> VSCode, <span class="keyword">public</span> SourceInsight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">///&lt; 正常使用 Tool 类中的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Programmer lijiancong;</span><br><span class="line">    lijiancong.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述对象 <code>VSCode</code> 和 <code>SourceInsight</code> 没有使用关键字 <code>virtual</code> 来标注继承方式，那么 <code>Programmer</code> 类中正常使用 <code>Tool::i</code>。</p><h5 id="继承的方式与访问权限"><a href="#继承的方式与访问权限" class="headerlink" title="继承的方式与访问权限"></a>继承的方式与访问权限</h5><p><code>public</code>、<code>private</code>、<code>protected</code> 三种继承方式</p><p>见基类定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i_public;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> i_protected;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i_private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>public</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>public</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// public 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `public`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive obj;</span><br><span class="line">    obj.i_public = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;  不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>protected</code> 继承：</p><ul><li>基类中 <code>public</code> 成员， 在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>protected</code> 继承与 <code>public</code> 继承相比， 区别在于 基类中 <code>public</code> 成员在 <code>protected</code> 继承后的派生类中降级为 <code>protected</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">protected</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `protected`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `protected`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;</span><br><span class="line">    i_protected = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private</code> 继承：</p><ul><li>基类中 <code>public</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>protected</code> 成员，在派生类中表现为 <code>protected</code></li><li>基类中 <code>private</code> 成员，在派生类中不可访问</li></ul><p><code>private</code> 继承与 <code>public</code> 继承相比，区别在于基类中 <code>public</code> 成员和 <code>protected</code> 成员在 <code>private</code> 继承后的派生类中都降级为 <code>private</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span> : <span class="keyword">private</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    i_public = <span class="number">0</span>;       <span class="comment">///&lt; 基类中 `public` 成员， 在派生类中表现为 `private`</span></span><br><span class="line">    i_protected = <span class="number">0</span>;    <span class="comment">///&lt; 基类中 `protected` 成员，在派生类中表现为 `private`</span></span><br><span class="line">    <span class="comment">/// i_private = 0;  ///&lt; 基类中 `private` 成员，在派生类中不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive0</span> : <span class="keyword">public</span> derive</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">get0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">/// i_public = 0;</span></span><br><span class="line">    <span class="comment">/// i_protected = 0;</span></span><br><span class="line">    <span class="comment">/// i_private = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive0 obj;</span><br><span class="line">    obj.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/// obj.i_public = 0;     不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_protected = 0;  不可访问</span></span><br><span class="line">    <span class="comment">/// obj.i_private = 0;    不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，什么类型的继承，在派生类中最高的类成员访问权限就降级为什么类型。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态用于接口与多态实现的分离</p><p>下面代码示例为多态在工厂模式中的应用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">MySql_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Redis_Query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Interface* <span class="title">getInterface</span><span class="params">(<span class="type">bool</span> bIsUseMySQL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bIsUseMySQL)</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">MySqlImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">RedisImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Interface* p = factory.<span class="built_in">GetInterface</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 通过基类指针指向派生类</span></span><br><span class="line">    <span class="comment">// 调用基类中的虚函数，会通过编译器自动识别</span></span><br><span class="line">    <span class="comment">// 是使用 MySQL 的实现还是 Redis 的实现</span></span><br><span class="line">    p-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">    p-&gt;<span class="built_in">Query</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用多态进行了函数覆盖(<code>override</code>), 但是在基类和派生类中出现了同名但不同入参的函数名，则会发生函数隐藏(<code>hide</code>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">///  这里没有使用多态对基类中的 `Insert` 函数进行覆盖(override), 而是单独创建了一个新的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;RedisImpl::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Interface* pRedis = <span class="keyword">new</span> RedisImpl;</span><br><span class="line">  pRedis-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常使用多态，访问派生类的 `Insert` 函数的实现</span></span><br><span class="line"></span><br><span class="line">  Interface* pMySQL = <span class="keyword">new</span> MySqlImpl;</span><br><span class="line">  <span class="comment">/// pMySQL-&gt;Insert(&quot;Hello World!&quot;); 无法使用基类指针访问多态函数 `Insert`</span></span><br><span class="line">  pMySQL-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>);  <span class="comment">///&lt; 只能访问基类 `Insert` 函数的实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用关键字 <code>override</code> 关键字避免因输入错误而导致函数覆盖不正确的现象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Interface::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlImpl</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 由于 `override` 要求必须该函数对基类函数进行覆盖，这里由于入参不一致, 会出现编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string s)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MySQL::Insert&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>一个基类的虚函数，在不同派生类中实现，会产生多个虚函数表。</p><p>派生类的多个实例都会保存一个指针，该指针指向对应虚函数的实现（即对应的虚函数表）。</p><p>虚函数表中放入特定实现的函数指针，被调用时，通过函数指针来调用对应的汇编。</p><h4 id="类成员变量初始化顺序"><a href="#类成员变量初始化顺序" class="headerlink" title="类成员变量初始化顺序"></a>类成员变量初始化顺序</h4><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">a</span>(): <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">x</span>(y<span class="number">+1</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; obj.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出:<br>x: -858993459, y: 0</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 基本操作</title>
      <link href="/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/21/2021-11-20-MySQL%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>最简单的查询语句： 查询 <code>dcuser</code> 表中所有字段。</p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>以上语句在代码中禁止使用，因为在数据库扩展时，<code>SELECT *</code> 语句对应的结构体如果没有增加字段，则会出现未知错误。</p><h3 id="指定字段查询"><a href="#指定字段查询" class="headerlink" title="指定字段查询"></a>指定字段查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">UserID</th><th align="center">Name</th><th align="center">DCType</th><th align="center">DepotID</th></tr></thead><tbody><tr><td align="center">3000</td><td align="center">dis01</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3001</td><td align="center">dis02</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3002</td><td align="center">dis03</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">3003</td><td align="center">dis04</td><td align="center">65535</td><td align="center">1</td></tr><tr><td align="center">9999</td><td align="center">test</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><h3 id="查询添加过滤条件"><a href="#查询添加过滤条件" class="headerlink" title="查询添加过滤条件"></a>查询添加过滤条件</h3><p>查询 <code>dcuser</code> 表中具有行车调度权限(<code>DCType = 1</code>)的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 为 <code>13003</code> 或 <code>13004</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="number">13003</span>, <span class="number">13004</span>);</span><br></pre></td></tr></table></figure><h4 id="BETWEEN-AND"><a href="#BETWEEN-AND" class="headerlink" title="BETWEEN AND"></a>BETWEEN AND</h4><p>查询 <code>groupcallinfo</code> 表中 <code>DCUserID</code> 介于 <code>13003</code> 到 <code>13005</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID BETWEEN <span class="number">13003</span> AND <span class="number">13005</span>;</span><br><span class="line">SELECT DCUserID, GroupID, Time, CallType FROM groupcallinfo WHERE DCUserID &gt;= <span class="number">13003</span> AND DCUserID &lt;= <span class="number">13005</span>;</span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis</code> 开头的内容。 <code>%</code> 代替任意数量字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis%&#x27;</span></span><br></pre></td></tr></table></figure><p>查询 <code>dcuser</code> 表中所有以 <code>Name</code> 字段以 <code>dis0</code> + 任意一个字符的内容。 <code>_</code> 代替一个任意字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, Name, DCType, DepotID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;dis0_&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h3><p>按时间降序查询 <code>groupcallinfo</code> 表中的数据。</p><p>升序(<code>ASC</code>): 数值小的记录在前。<br>降序(<code>DESC</code>): 数值大的记录在前。</p><p>如果不写关键字, 则默认使用 升序<code>ASC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>也可以使用多字段排序。 按照 <code>Time</code> 字段降序， <code>ASC</code> 字段升序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SeqID, DCUserID, GroupID, <span class="type">Time</span> <span class="keyword">FROM</span> groupcallinfo <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">Time</span> <span class="keyword">DESC</span>, SeqID <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="查询总数量"><a href="#查询总数量" class="headerlink" title="查询总数量"></a>查询总数量</h3><p>查询 <code>dcuser</code> 表中有几个全功能调度员的账号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;记录数&#x27;</span> <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">65535</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">记录数</th></tr></thead><tbody><tr><td align="center">2</td></tr></tbody></table><h3 id="限制查询记录条数"><a href="#限制查询记录条数" class="headerlink" title="限制查询记录条数"></a>限制查询记录条数</h3><p>查询组呼记录，只显示100条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>查询组呼记录表中所有具有行车调度权限调度台处理的记录。</p><p>翻译为 <code>SQL</code> 语句:</p><p>查询 <code>groupcallinfo</code> 表中， <code>DCUserID</code> 等于 <code>dcuser</code> 表中 <code>DCType</code> 等于 <code>1</code> 记录的 <code>UserID</code> 字段的值</p><p>三句话等价:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> DCUserID, GroupID, <span class="type">Time</span>, CallType <span class="keyword">FROM</span> groupcallinfo <span class="keyword">WHERE</span> DCUserID <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> dcuser <span class="keyword">WHERE</span> DCType <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> A.DCUserID, A.GroupID, A.Time, A.CallType <span class="keyword">FROM</span> groupcallinfo A <span class="keyword">WHERE</span> A.DCUserID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> B.UserID <span class="keyword">FROM</span> dcuser B <span class="keyword">WHERE</span> B.DCType <span class="operator">=</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> contacts <span class="keyword">WHERE</span> (surname, firstname) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> surname, firstname <span class="keyword">FROM</span> customer);</span><br></pre></td></tr></table></figure><h3 id="ALL-与-ANY-关键字"><a href="#ALL-与-ANY-关键字" class="headerlink" title="ALL 与 ANY 关键字:"></a>ALL 与 ANY 关键字:</h3><p>找出 class1 中比 class2 所有 source 都高的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> source <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> source <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><p>找出 class1 中 second_name 与 class2 中的重名的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class1 <span class="keyword">WHERE</span> second_name <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> second_name <span class="keyword">FROM</span> class2);</span><br></pre></td></tr></table></figure><h3 id="查询最大、最小、平均值"><a href="#查询最大、最小、平均值" class="headerlink" title="查询最大、最小、平均值"></a>查询最大、最小、平均值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最大通话时长&#x27;</span>, <span class="built_in">MIN</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;最小通话时长&#x27;</span>, <span class="built_in">AVG</span>(EndTime<span class="operator">-</span>StartTime) <span class="keyword">AS</span> <span class="string">&#x27;平均通话时长&#x27;</span> <span class="keyword">FROM</span> trainposcallinfo;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">最大通话时长</th><th align="center">最小通话时长</th><th align="center">平均通话时长</th></tr></thead><tbody><tr><td align="center">48</td><td align="center">2</td><td align="center">14.667</td></tr></tbody></table><h3 id="查询数据分组"><a href="#查询数据分组" class="headerlink" title="查询数据分组"></a>查询数据分组</h3><p>统计不同的 <code>DCUserID</code> 都有多少条组呼记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr></tbody></table><h4 id="WITH-ROLLUP"><a href="#WITH-ROLLUP" class="headerlink" title="WITH ROLLUP"></a>WITH ROLLUP</h4><p><code>WITH ROLLUP</code> 用来在 <code>GROUP BY</code> 统计的基础上再加一行总数的统计行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DCUserID, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;总数&quot; <span class="keyword">FROM</span> groupcallinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> DCUserID <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCUserID</th><th align="center">总数</th></tr></thead><tbody><tr><td align="center">13001</td><td align="center">13</td></tr><tr><td align="center">13003</td><td align="center">662</td></tr><tr><td align="center">13005</td><td align="center">53</td></tr><tr><td align="center">13006</td><td align="center">131</td></tr><tr><td align="center"></td><td align="center">859</td></tr></tbody></table><h4 id="HAVING-与-WHERE-区别"><a href="#HAVING-与-WHERE-区别" class="headerlink" title="HAVING 与 WHERE 区别"></a>HAVING 与 WHERE 区别</h4><p>having子句与where都是设定条件筛选的语句，有相似之处也有区别。</p><p>having与where的区别:<br>having是在分组后对数据进行过滤<br>where是在分组前对数据进行过滤<br>having后面可以使用聚合函数<br>where后面不可以使用聚合</p><p>在查询过程中执行顺序：from&gt;where&gt;group（含聚合）&gt;having&gt;order&gt;select。</p><p>所以聚合语句(sum,min,max,avg,count)要比having子句优先执行，而where子句在查询过程中执行优先级别优先于聚合语句(sum,min,max,avg,count)。<br>where子句：<br>select sum(num) as rmb from order where id&gt;10<br>&#x2F;&#x2F;只有先查询出id大于10的记录才能进行聚合语句</p><p><a href="https://blog.csdn.net/ryan007liu/article/details/91441479">Mysql中having和where的区别</a></p><h3 id="查询过滤重复数据"><a href="#查询过滤重复数据" class="headerlink" title="查询过滤重复数据"></a>查询过滤重复数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">DCType</th></tr></thead><tbody><tr><td align="center">65535</td></tr><tr><td align="center">2</td></tr></tbody></table><p>说明: <code>DISTINCT</code> 关键词修饰的是语句整体，不能对单独字段修饰，并查询其他字段内容。<br>如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> DCType, UserID <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>如上语句意义为查询 DCType 且 UserID 同时不重复的列。</p><p>输出:</p><table><thead><tr><th align="center">DCType</th><th align="center">UserID</th></tr></thead><tbody><tr><td align="center">65535</td><td align="center">3000</td></tr><tr><td align="center">65535</td><td align="center">3001</td></tr><tr><td align="center">65535</td><td align="center">3002</td></tr><tr><td align="center">65535</td><td align="center">3003</td></tr><tr><td align="center">2</td><td align="center">9999</td></tr></tbody></table><h3 id="替换特定字段查询结果"><a href="#替换特定字段查询结果" class="headerlink" title="替换特定字段查询结果"></a>替换特定字段查询结果</h3><p>查询 <code>dcuser</code> 表中所有数据， <code>DCType</code> 字段等于 <code>65535</code> 的显示全功能调度员, 等于 <code>1</code> 的显示行车调度员, 其他取值显示原本的值, 该字段结果显示为<code>调度员类型</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> DCType <span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span> &quot;全功能调度员&quot; <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> &quot;行车调度员&quot; <span class="keyword">ELSE</span> UserID <span class="keyword">END</span> <span class="keyword">AS</span> &quot;调度员类型&quot; <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>分段看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CASE</span> DCType</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">65535</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;全功能调度员&quot;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">&quot;行车调度员&quot;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">UserID</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span> &quot;调度员类型&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dcuser;</span><br></pre></td></tr></table></figure><p>输出:</p><table><thead><tr><th align="center">调度员类型</th></tr></thead><tbody><tr><td align="center">全功能调度员</td></tr><tr><td align="center">14004</td></tr><tr><td align="center">行车调度员</td></tr></tbody></table><p>关于 <code>CASE... WHEN...</code> 更多用法见下面链接</p><p><a href="https://zhuanlan.zhihu.com/p/63333847">SQL之CASE WHEN用法详解</a><br><a href="https://www.gairuo.com/p/sql-select-case-when-then">SQL 查询：SELECT CASE 条件赋值</a><br><a href="https://blog.csdn.net/qq_31071543/article/details/79666427">关于case when复杂sql语句查询</a></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><a href="https://blog.csdn.net/lxf512666/article/details/52812146">SQL SELECT(复杂查询)之 自连接 &amp; 子查询 解析</a><br><a href="https://www.cnblogs.com/Hadley-pu/p/sql_selfconnect.html">sql中自连接的使用</a><br><a href="https://zhuanlan.zhihu.com/p/110891010">010-MySQL：自连接查询</a><br><a href="https://cloud.tencent.com/developer/article/1665642">算法工程师-SQL进阶：神奇的自连接与子查询</a></p><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>改变 dcuser 表名称到 dcuser_new</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> dcuser <span class="keyword">TO</span> dcuser_new;</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>删除整个 dcuser 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> dcuser;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p>删除表信息的方式有两种 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> dcuser;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dcuser;</span><br></pre></td></tr></table></figure><p>注 : truncate操作中的table可以省略，delete操作中的*可以省略</p><p>truncate、delete 清空表数据的区别 :<br>1&gt; truncate 是整体删除 (速度较快)，delete是逐条删除 (速度较慢)<br>2&gt; truncate 不写服务器 log，delete 写服务器 log，也就是 truncate 效率比 delete高的原因<br>3&gt; truncate 不激活trigger (触发器)，但是会重置Identity (标识列、自增字段)，相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的 ID数。而 delete 删除以后，identity 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件</p><p>参考资料:<br><a href="https://blog.csdn.net/chenshun123/article/details/79676446">MySQL 清空表(truncate)与删除表中数据(delete) 详解</a></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> runoob_tbl <span class="keyword">SET</span> runoob_title<span class="operator">=</span><span class="string">&#x27;学习 C++&#x27;</span> <span class="keyword">WHERE</span> runoob_id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="过程、函数"><a href="#过程、函数" class="headerlink" title="过程、函数"></a>过程、函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span>  Create10K<span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `Create10K`(<span class="keyword">IN</span> `for_time` <span class="type">INT</span>, <span class="keyword">IN</span> `type_int` <span class="type">INT</span>, <span class="keyword">IN</span> `info_text` <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> for_time <span class="operator">*</span> <span class="number">10000</span> DO</span><br><span class="line">    <span class="keyword">INSERT INTO</span> test_table(Type, Info) <span class="keyword">VALUES</span>(type_int, info_text);</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> Create10K(<span class="number">500</span>, <span class="number">1</span>, &quot;1&quot;);</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/sunada2005/p/3411873.html">常用SQL查询语句</a></p><h3 id="插入主键重复的数据"><a href="#插入主键重复的数据" class="headerlink" title="插入主键重复的数据"></a>插入主键重复的数据</h3><p>插入 <code>dcuser</code> 表中一条数据，如果主键重复则更新原数据的 <code>StationList</code> 字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> dcuser(UserID, Name, DCType, DepotID, StationList) <span class="keyword">VALUES</span>(<span class="number">14005</span>, <span class="string">&#x27;14005&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, &quot;1,2,3,4&quot;) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> StationList <span class="operator">=</span> &quot;1,2,3,4&quot;;</span><br></pre></td></tr></table></figure><h3 id="按天查询数量"><a href="#按天查询数量" class="headerlink" title="按天查询数量"></a>按天查询数量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP(date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d 0:0:0&#x27;</span>)), <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> sds_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> date_format(FROM_UNIXTIME(SendTime),<span class="string">&#x27;%y-%m-%d&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL 8.0 Reference Manual</a><br><a href="https://dev.mysql.com/doc/mysql-tutorial-excerpt/8.0/en/examples.html">Chapter 7 Examples of Common Queries</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html">13.2.9 REPLACE Statement</a></p><p>TODO: 合并查询、分页查询、空值判断、Contact 拼接查询结果、REPLACE INTO、多条插入、事务、存储过程、视图、批量插入、my.ini 的配置项的研究、中间表查询<br><a href="https://www.cnblogs.com/zengen/archive/2011/08/10/2133423.html">SQL中的循环、for循环、游标</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用场景</title>
      <link href="/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/07/21/2021-06-26-Git-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Git 使用场景</p><h2 id="场景：仓库中的临时文件"><a href="#场景：仓库中的临时文件" class="headerlink" title="场景：仓库中的临时文件"></a>场景：仓库中的临时文件</h2><p>我们编译出来了大量临时文件或很大的二进制文件，如 .o, .lib文件，这些文件不想上传。</p><p>提出问题： 想要在本文件夹中做版本控制，但需要忽略某些特定的文件</p><p>解决方案： 使用.gitignore文件来标记不想要进行版本控制的临时文件。</p><p>.gitignore 文件的用法:</p><p>.gitignore文件是由我们自己创建, 并默认放置在仓库的根目录。<br>Git 默认会忽略<code>.gitignore</code>中的文件名的大小写, 不过我们可以通过<code>git config core.ignorecase false</code>，来设置为不忽略大小写。</p><ol><li>文件内容格式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略.lib为后缀的文件</span></span><br><span class="line">*.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libmysql.lib 这个文件不忽略</span></span><br><span class="line">!libmysql.lib</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的bin文件夹</span></span><br><span class="line">bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略根目录下的bin文件夹</span></span><br><span class="line">/bin/</span><br></pre></td></tr></table></figure><ol start="2"><li>已经被忽略的文件如何添加到暂存区: <code>git add -f &lt;filename&gt;</code></li><li>已经添加到暂存区中的文件如何忽略: <code>git rm --cached &lt;filename&gt;</code></li></ol><h2 id="场景-不小心提交了一个临时文件"><a href="#场景-不小心提交了一个临时文件" class="headerlink" title="场景: 不小心提交了一个临时文件"></a>场景: 不小心提交了一个临时文件</h2><p>我们对<strong>这个临时文件不想做版本跟踪</strong>，但是在<code>.gitignore</code>文件中添加该文件，这个文件仍然会被追踪。</p><p>提出问题: 如何忽略一个已经被追踪的文件?</p><p>解决方案：</p><ol><li><code>git rm filename</code>直接从仓库中删除该文件，并把该改动commit后，随后在<code>.gitignore</code>中添加该文件为忽略。</li><li><code>git update-index --assume-unchanged &lt;filename&gt;</code>, 这个操作不会删除该文件，也不用提交，但命令太长</li></ol><h2 id="场景-需要标记一个特定的版本"><a href="#场景-需要标记一个特定的版本" class="headerlink" title="场景: 需要标记一个特定的版本"></a>场景: 需要标记一个特定的版本</h2><p>当我们的代码进入到比较稳定，或者开发出了一个功能，需要标记一个commit来作为稳定版本的基准。</p><p>提出问题： 如何为commit添加标记和备注信息</p><p>解决方案： 使用<code>git tag</code>为版本打标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a vx.x.x -m &quot;message&quot;</span><br><span class="line">git push origin tags    ///&lt; 推送到远端</span><br></pre></td></tr></table></figure><h2 id="场景-修改远端标签名称"><a href="#场景-修改远端标签名称" class="headerlink" title="场景: 修改远端标签名称"></a>场景: 修改远端标签名称</h2><p>修改tag名 v1.0重命名v2.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag 新tag名称 旧tag名称</span><br><span class="line">git tag -d 旧tag名称</span><br><span class="line">git push origin :refs/tags/旧tag名称</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="场景：-开发一个功能"><a href="#场景：-开发一个功能" class="headerlink" title="场景： 开发一个功能"></a>场景： 开发一个功能</h2><p>某项功能可能开发时间较久，但又想把未完成的代码上传到远端版本库，来实现多台电脑同步。</p><p>例如：在开发随车通信需求时，在<code>linux</code>上编译<code>dis</code>，而我开发的环境在<code>windows</code>上, 当我在本地<code>window</code>开发的临时代码，想要放到<code>linux</code>机器上，这时我们需要分支来对代码的同步。</p><p>提出问题： 怎样才能在不影响远端仓库的代码的情况下，在远端备份开发过程代码？</p><p>解决方法： 使用 git branch<br>brunch 介绍:<br>brunch意味着你可以从主分支中，分叉出来一个分支来提交代码而不影响主分支的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/// 创建并切换到分支</span><br><span class="line">git checkout -b &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 做相应的提交，修改</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 把本地分支上传到远端</span><br><span class="line">git push origin &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">/// 切换到另一台电脑上，拉去自己的分支</span><br><span class="line">git pull origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>合并分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop    ///&lt; 当前处于develop分支下</span><br><span class="line">git merge master   ///&lt; 把master的东西合入到当前分支，方便在自己开发的分支上处理冲突</span><br><span class="line">git checkout master    ///&lt; 切换到master分支</span><br><span class="line">git merge develop    ///&lt; 把develop合并到当前分支</span><br><span class="line">git branch -d future    ///&lt; 把合并过的分支删除</span><br></pre></td></tr></table></figure><h2 id="场景：临时切换分支"><a href="#场景：临时切换分支" class="headerlink" title="场景：临时切换分支"></a>场景：临时切换分支</h2><p>我们会遇到临时切换回主分支的情况。<br>例如： 当我在开发随车通信功能开发一半时，雷总让我在仓库中提交一个文档。如果我在自己的开发分支上上传该文档，那么在<code>master</code>分支上会没有这个文档，其他人也获取不到，所以只能切换回<code>master</code>分支上进行上传。</p><p>提出问题： 快速切换分支，做完提交，切换回开发分支时，工作区应跟切换分支前一样。</p><p>解决方案：<br>那么现在分为两种情况：</p><ol><li>我们工作区没有未被commit的文件，那么我们直接<code>git checkout &lt;branch_name&gt;</code>, 即可切换到相应的分支。</li><li>我们工作区有很多未被commit的代码，这时我们可以选择，把工作区内代码全部commit或者选择使用<code>git stash</code>来临时把未被commit的代码给存储起来， 在我们切换回开发分支时，再把临时存储的代码拿出来。</li></ol><p><code>stash</code>介绍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 把所有未commit的文件(工作区、暂存区里的文件)都放入一个临时的分支，使工作区可以切换分支</span><br><span class="line">git stash</span><br><span class="line">或</span><br><span class="line">git stash save &quot;some comment&quot;</span><br><span class="line"></span><br><span class="line">/// 切换到其他分支，并做一些提交, 并切换回自己的开发分支</span><br><span class="line">git checkout master</span><br><span class="line">git add .</span><br><span class="line">git commit -m&quot;some comment&quot;</span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line">/// 把临时存储的代码给拿出来，放入工作区(之前暂存区的文件在pop后的状态是到工作区)</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p><code>git stash --include-untracked</code>或<code>git stash -u</code> 来存储未被跟踪的文件</p><h2 id="场景：-某个commit，提交错分支了"><a href="#场景：-某个commit，提交错分支了" class="headerlink" title="场景： 某个commit，提交错分支了"></a>场景： 某个commit，提交错分支了</h2><p>开发过程中，突然出现了一个<code>BUG</code>需要立即修复，我们急着修复，把修复的代码放入了正在大改开发分支上。<br>提出问题： 我们需要怎样，把主分支上的<code>BUG</code>给修正过来<br>解决方案:</p><ol><li>切换到主分支，再次把刚才修改的文件，同样在主分支上进行修改，再次进行提交。</li><li>切换到主分支，使用<code>git cherry-pick &lt;SHA&gt;</code>把特定提交给放到主分支中。</li></ol><p>方案一存在修改的不一致，当后面需要合并分支时，需要处理冲突。<br>方案二快速提交，不用再次使用手动修改文件。</p><p><code>git cherry-pick &lt;SHA&gt;</code>用法示例：<br>该操作会把特定的commit给，放入当前所在的分支，并产生一个新的提交</p><p>之前分支的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">        \</span><br><span class="line">        e - f - g Feature</span><br></pre></td></tr></table></figure><p><code>cherry-pick</code>操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 切换到</span><br><span class="line">git checkout master</span><br><span class="line">/// 把提交f给提交到本分支</span><br><span class="line">git cherry-pick f</span><br></pre></td></tr></table></figure><p>操作后的分支情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">    \</span><br><span class="line">    e - f - g       Feature</span><br></pre></td></tr></table></figure><h2 id="场景-commit的信息输入错了"><a href="#场景-commit的信息输入错了" class="headerlink" title="场景: commit的信息输入错了"></a>场景: commit的信息输入错了</h2><p>提出问题： 怎么修改提交的commit信息</p><p>解决方案：</p><ol><li>修改最近一次提交的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">/// 进入到提交的文件里面，默认使用vim打开</span><br><span class="line">/// 修改好提交信息，保存后退出</span><br></pre></td></tr></table></figure><ol start="2"><li>如果想要修改之前的commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3    ///&lt; 回退到HEAD前面第三个commit处</span><br><span class="line"></span><br><span class="line">/// 想要修改哪一个提交就把pick换成你想要的操作,edit</span><br><span class="line">git commit --amend</span><br><span class="line">/// 然后执行</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><ol start="3"><li>如果该 commit 已经 push 到远端</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line">git push --force-with-lease origin &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h2 id="场景-开发到一半，发现修改的思路有误"><a href="#场景-开发到一半，发现修改的思路有误" class="headerlink" title="场景: 开发到一半，发现修改的思路有误"></a>场景: 开发到一半，发现修改的思路有误</h2><p>我们从远端仓库拉去最新代码，修改过程中，发现修改错误了，想再从已经提交的代码上重新开始。</p><p>提出问题： 如何回退版本</p><p>解决方案：</p><ol><li>没有commit想要回退， 只是清除工作区修改的代码, 如何让当前已经修改过的代码恢复到HEAD的最新提交代码一致, 即清除工作区修改的代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 清除所有没有被暂存的改动</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">/// 清除该文件没有被暂存的改动</span><br><span class="line">git checkout filename</span><br></pre></td></tr></table></figure><ol start="2"><li>想要撤销上一个commit</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 删除工作区改动的代码，撤销最近一次的commit，撤销git add .</span><br><span class="line">/// 注意完成这个操作后，就恢复到了上一次的commit状态。</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">/// HEAD 指向 commit_id 指向的提交</span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--hard</code>换成<code>--soft</code>, 则会保留已经暂存和修改的文件</li><li><code>HEAD^</code>换成<code>HEAD~2</code>则可以回退两个commit</li></ul><h3 id="清除工作区的修改"><a href="#清除工作区的修改" class="headerlink" title="清除工作区的修改"></a>清除工作区的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_id&gt;    /// 返回到某个节点，不保留修改，已有的改动会丢失</span><br><span class="line">git reset --soft &lt;commit_id&gt;    /// 返回到某个节点，保留修改，已有的改动会保留，在未提交中， `git status` 或 `git diff` 查看</span><br><span class="line"></span><br><span class="line">git clean -df /// 返回到某个节点(未跟踪文件的删除)</span><br><span class="line">git clean -n  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -f  /// 不实际删除，展示即将哪些文件要被删除</span><br><span class="line">git clean -i  /// 显示将要删除的文件</span><br><span class="line">git clean -d  /// 递归删除目录及文件(未跟踪的文件)</span><br><span class="line">git clean -q  /// 仅显示错误，成功删除的文件不显示</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clean -nxdf /// 查看要删除的文件及目录，确认无误后再使用下面的命令进行删除</span><br><span class="line">git checkout . &amp;&amp; git clean -xdf</span><br></pre></td></tr></table></figure><h3 id="revert-和-reset"><a href="#revert-和-reset" class="headerlink" title="revert 和 reset"></a>revert 和 reset</h3><ol><li><p>revert<br>首先肯定的是 <code>revert</code>，<code>git revert commit_id</code> 能产生一个 与 <code>commit_id</code> 完全相反的提交，即 <code>commit_id</code> 里是添加， <code>revert</code> 提交里就是删除。<br><code>revert</code> 会生成一个新的提交记录，但不适合回退多个提交。</p></li><li><p>reset<br><code>reset</code> 的原理是把 <code>HEAD</code> 的指向，并删除回退后的版本之后的提交(被删除的提交可以通过 git reflog 查看)。<code>git reset --hard &lt;commit_id&gt;</code><br>但是由于是本地回退版本，所以在推送至远端时，需要使用 <code>git push -f origin master</code> 的命令象只覆盖远端分支。由于我们的远端仓库大部分都是对 <code>master</code> 分支进行保护不允许使用 <code>-f</code> 强制覆盖。我们可以先回退 <code>develop</code> 分支, 在 <code>develop</code> 分支上在创建一次提交(该提交已经领先于远端<code>master</code>分支), 再提交至远端 <code>develop</code> 分支后 <code>merge</code>。</p></li></ol><h2 id="场景：-想要找到某个特定业务的所有提交"><a href="#场景：-想要找到某个特定业务的所有提交" class="headerlink" title="场景： 想要找到某个特定业务的所有提交"></a>场景： 想要找到某个特定业务的所有提交</h2><p>假设我们的commit的信息都是采用模板来填写的，且已经有大量的<code>commit</code>时候，需要过滤检索一些特定提交信息的<code>commit</code>。</p><p>提出问题： 如何使用关键字搜索提交信息</p><p>解决方案：<br>使用git自带的文字搜索功能<code>git log --all --grep=&#39;TrainPosCall&#39;</code>, 搜索提交信息中带有<code>TrainPosCall</code>的<code>commit</code>。</p><h2 id="场景：-想要确认代码的改动"><a href="#场景：-想要确认代码的改动" class="headerlink" title="场景： 想要确认代码的改动"></a>场景： 想要确认代码的改动</h2><p>想要分步提交修改库函数的文件和修改业务逻辑的文件，需要确认每个文件的改动。</p><p>提出问题： 怎么查看已修改的代码对比之前的版本</p><p>解决方案：</p><ol><li>查看尚未缓存的改动：<code>git diff</code></li><li>查看已缓存的改动： <code>git diff --cached</code>, <code>git diff --staged</code></li><li>查看已缓存的与未缓存的所有改动：<code>git diff HEAD</code></li><li>显示摘要而非整个 diff： <code>git diff --stat</code></li><li>版本号与版本号之间的差别: <code>git diff &lt;SHA&gt; &lt;SHA&gt;</code></li></ol><h2 id="场景误删除分支"><a href="#场景误删除分支" class="headerlink" title="场景误删除分支"></a>场景误删除分支</h2><p>在误删除分支后，可以使用 <code>git reflog</code> 来查看分支的<code>commit id</code>并使用该<code>commit id</code>来创建一个新的分支<br><code>git branch recover-branch [commit id]</code></p><h2 id="场景-git-账户修改密码"><a href="#场景-git-账户修改密码" class="headerlink" title="场景: git 账户修改密码"></a>场景: git 账户修改密码</h2><p>操作<code>git</code>时, 出现错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: HTTP Basic: Access denied</span><br></pre></td></tr></table></figure><p>管理员权限输入以下命令后在命令行中操作<code>git</code>，重新输入用户名，密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/docs">git Reference</a></p><p><a href="https://git-scm.com/book/en/v2">Pro Git</a></p><p><a href="https://juejin.cn/post/6844903965625155597">Git新手教程-添加忽略文件(十)</a></p><p><a href="https://www.freecodecamp.org/news/git-cheat-sheet/">Git Cheat Sheet – 50 Git Commands You Should Know</a></p><p><a href="https://www.runoob.com/git/git-diff.html">git diff 命令</a></p><p><a href="https://www.atlassian.com/git/tutorials/saving-changes/git-diff">Git diff</a></p><p><a href="https://www.cnblogs.com/ibingshan/p/10783552.html">git clean 删除忽略文件 和 未被跟踪文件及文件夹</a></p><p><a href="https://git-scm.com/docs/git-branch">git-branch - List, create, or delete branches</a></p><p><a href="https://stackoverflow.com/questions/7124914/how-to-search-a-git-repository-by-commit-message/7124949#7124949">How to search a Git repository by commit message?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类型大小(32bit 与 64bit)</title>
      <link href="/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/"/>
      <url>/2023/07/21/2021-09-24-C++%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F(32bit%E4%B8%8E64bit)/</url>
      
        <content type="html"><![CDATA[<p>C++ 类型大小 (32bit 与 64bit)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---标准类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int size:                &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long size:          &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size_t size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned char size:      &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;signed char size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">signed</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pointer size:            &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---自定义类型大小---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SHORT(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT(int) size:                   &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;LONG(long) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT8(unsigned char) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT16(unsigned short) size:     &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT32(unsigned int) size:       &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UINT64(unsigned long long) size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT8(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT16(short) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT32(int) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;INT64(long long) size:           &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;FLOAT(float) size:               &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DOUBLE(double) size:             &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CHAR(char) size:                 &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BOOL(int) size:                  &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BYTE(unsigned char) size:        &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;HANDLE(void*) size:              &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>VS2010 32bit</th><th>VS2010 64bit</th><th>VS2019 32bit</th><th>VS2019 64bit</th><th>Linux 32bit</th><th>Linux 64bit</th><th>备注</th></tr></thead><tbody><tr><td>short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>unsigned short</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>unsigned int</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>unsigned long</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>unsigned long long</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>size_t</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>signed char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>pointer</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr><tr><td>SHORT(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>LONG(long)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>8</td><td>不同</td></tr><tr><td>UINT8(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>UINT16(unsigned short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>UINT32(unsigned int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>UINT64(unsigned long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>INT8(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>INT16(short)</td><td>2</td><td>2</td><td>2</td><td>2</td><td></td><td>2</td><td></td></tr><tr><td>INT32(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>INT64(long long)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>FLOAT(float)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>DOUBLE(double)</td><td>8</td><td>8</td><td>8</td><td>8</td><td></td><td>8</td><td></td></tr><tr><td>CHAR(char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>BOOL(int)</td><td>4</td><td>4</td><td>4</td><td>4</td><td></td><td>4</td><td></td></tr><tr><td>BYTE(unsigned char)</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td>1</td><td></td></tr><tr><td>HANDLE(void*)</td><td>4</td><td>8</td><td>4</td><td>8</td><td></td><td>8</td><td>不同</td></tr></tbody></table><p>结论:</p><ol><li><code>size_t</code>、<code>pointer</code>、<code>long</code>、<code>unsigned long</code>、<code>HANDLE</code>这三种类型在<code>32bit</code>和<code>64bit</code>的大小有差别。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华为C++编程规范摘录</title>
      <link href="/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/"/>
      <url>/2023/07/21/2021-05-17-%E5%8D%8E%E4%B8%BAC++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bookstack.cn/read/openharmony-1.0-zh-cn/contribute-OpenHarmony-cpp-coding-style-guide.md">华为C++语言编程规范</a></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="3-7-1-if-循环语句必须使用大括号"><a href="#3-7-1-if-循环语句必须使用大括号" class="headerlink" title="3.7.1 if&#x2F;循环语句必须使用大括号"></a>3.7.1 if&#x2F;循环语句必须使用大括号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>();  <span class="comment">///&lt; Good</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-不用的代码段直接删除，不要注释掉"><a href="#4-4-3-不用的代码段直接删除，不要注释掉" class="headerlink" title="4.4.3 不用的代码段直接删除，不要注释掉"></a>4.4.3 不用的代码段直接删除，不要注释掉</h3><p>被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入容易被忽略的缺陷。正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。使用版本控制来，记录代码。</p><h3 id="5-2-3-禁止通过声明的方式引用外部函数接口、变量"><a href="#5-2-3-禁止通过声明的方式引用外部函数接口、变量" class="headerlink" title="5.2.3 禁止通过声明的方式引用外部函数接口、变量"></a>5.2.3 禁止通过声明的方式引用外部函数接口、变量</h3><p>只能通过包含头文件的方式使用其他模块或文件提供的接口。通过<code>extern</code>声明的方式使用外部函数接口、变量，容易在外部接口改变时可能导致声明和定义不一致。同时这种隐式依赖，容易导致架构腐化。</p><h3 id="5-2-4-禁止在extern-C-中包含头文件"><a href="#5-2-4-禁止在extern-C-中包含头文件" class="headerlink" title="5.2.4 禁止在extern &quot;C&quot;中包含头文件"></a>5.2.4 禁止在<code>extern &quot;C&quot;</code>中包含头文件</h3><p>在<code>extern &quot;C&quot;</code> 中包含头文件，有可能导致<code>extern &quot;C&quot;</code>嵌套，部分编译器对<code>extern &quot;C&quot;</code>嵌套层次有限制，嵌套层次太多会编译错误。</p><h3 id="7-1-1-类的成员变量必须显式初始化"><a href="#7-1-1-类的成员变量必须显式初始化" class="headerlink" title="7.1.1 类的成员变量必须显式初始化"></a>7.1.1 类的成员变量必须显式初始化</h3><p>如果类有成员变量，没有定义构造函数，有没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。<br>如果类的成员变量具有默认构造函数，那么可以不需要显式初始化</p><h3 id="7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。"><a href="#7-1-3-如果不需要拷贝构造函数、赋值操作符，请明确禁止。" class="headerlink" title="7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。"></a>7.1.3 如果不需要拷贝构造函数、赋值操作符，请明确禁止。</h3><p>可以将拷贝构造函数或者赋值操作符设置为<code>private</code>，并且不实现。<br>C++11以后可以使用关键字<code>delete</code>, 来删除该成员函数。</p><h3 id="7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"><a href="#7-1-4-拷贝构造和拷贝赋值操作符应该是成对出现或者禁止" class="headerlink" title="7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止"></a>7.1.4 拷贝构造和拷贝赋值操作符应该是成对出现或者禁止</h3><h3 id="7-1-6-禁止在构造函数和析构函数中调用虚函数"><a href="#7-1-6-禁止在构造函数和析构函数中调用虚函数" class="headerlink" title="7.1.6 禁止在构造函数和析构函数中调用虚函数"></a>7.1.6 禁止在构造函数和析构函数中调用虚函数</h3><p>在构造函数和析构函数中调用当前对象的虚函数，会导致未定义的行为。在C++中，一个基类一次只构造一个完整的对象。</p><h3 id="7-2-1-基类的析构函数应该声明为virtual"><a href="#7-2-1-基类的析构函数应该声明为virtual" class="headerlink" title="7.2.1 基类的析构函数应该声明为virtual"></a>7.2.1 基类的析构函数应该声明为<code>virtual</code></h3><p><code>虚析构函数</code></p><h3 id="7-2-2-禁止虚函数使用缺省参数值"><a href="#7-2-2-禁止虚函数使用缺省参数值" class="headerlink" title="7.2.2 禁止虚函数使用缺省参数值"></a>7.2.2 禁止虚函数使用缺省参数值</h3><p>在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着你最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。为了避免虚函数重载时，因参数声明不一致给使用者带来的困惑和由此导致的问题，规定所有虚函数均不允许声明缺省参数值。</p><h3 id="7-2-3-禁止重新定义继承而来的非虚函数"><a href="#7-2-3-禁止重新定义继承而来的非虚函数" class="headerlink" title="7.2.3 禁止重新定义继承而来的非虚函数"></a>7.2.3 禁止重新定义继承而来的非虚函数</h3><p>因为非虚函数无法实现动态绑定，只有虚函数才能实现动态绑定：只要操作基类的指针，即可获得正确的结果。</p><h3 id="8-1-1-避免函数过长，函数不超过50行-非空非注释"><a href="#8-1-1-避免函数过长，函数不超过50行-非空非注释" class="headerlink" title="8.1.1 避免函数过长，函数不超过50行(非空非注释)"></a>8.1.1 避免函数过长，函数不超过50行(非空非注释)</h3><p>函数应该可以一屏显示完(50行以内), 只做一件事情，而且把它做好。<br>过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步抽象。<br>例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。<br>即使一个长函数现在工作的很好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的BUG。建议将其拆分为更加简短并易于管理的若干函数，以便于他人阅读和修改代码。</p><h3 id="9-1-1-不允许使用宏来表示常量"><a href="#9-1-1-不允许使用宏来表示常量" class="headerlink" title="9.1.1 不允许使用宏来表示常量"></a>9.1.1 不允许使用宏来表示常量</h3><p>宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名；宏没有类型检查，不安全；宏没有作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MSI_SDN_LEN 20  <span class="comment">///&lt; Bad</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>; <span class="comment">///&lt; Good</span></span><br><span class="line"><span class="comment">/// C++11以上的版本，可以使用`constexpr`</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="9-1-2不允许使用魔鬼数字"><a href="#9-1-2不允许使用魔鬼数字" class="headerlink" title="9.1.2不允许使用魔鬼数字"></a>9.1.2不允许使用魔鬼数字</h3><p>魔鬼数字是看不懂、难以理解的数字。<br>例如<code>type = 12</code>，看不懂，但改成<code>mouthsCount = yearsCount * 12</code>, 就容易理解。<br>数字<code>0</code>有时候也难以理解。<code>status = 0</code>并不能表达是什么状态。<br>解决途径： 对于局部使用的数字，可以增加注释说明，对于多处使用的数字，必须定义<code>const</code>常量，并通过符号命名自注释。<br>禁止出现下列情况： 没有通过符号来解释数字含义，如<code>const int ZERO = 0</code>，符号命名限制了其取值，如<code>const int XXX_TIMER_INTERVAL_300MS = 300</code>，<br>直接使用<code>XX_TIMER_INTERVAL_MS</code>来表示该常量是定时器的时间间隔。</p><h3 id="9-1-3-常量应该保证单一职责"><a href="#9-1-3-常量应该保证单一职责" class="headerlink" title="9.1.3 常量应该保证单一职责"></a>9.1.3 常量应该保证单一职责</h3><p>一个常量只用来标识一个特定功能，即一个常量不能有多种用途。</p><p>好的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> A_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B_MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Namespace1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Namespace2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_MSI_SDN_LEN = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-4-禁止用memcpy-s、memset-s初始化非POD对象"><a href="#9-1-4-禁止用memcpy-s、memset-s初始化非POD对象" class="headerlink" title="9.1.4 禁止用memcpy_s、memset_s初始化非POD对象"></a>9.1.4 禁止用<code>memcpy_s</code>、<code>memset_s</code>初始化非<code>POD</code>对象</h3><p><code>POD</code>类型主要包括<code>int</code>, <code>char</code>, <code>float</code>, <code>double</code>, <code>enumeration</code>, <code>void</code>, <code>pointer</code>等原始类ing以及聚合类型，不能使用封装和面向对象特性(如用户定义的构造&#x2F;赋值&#x2F;析构函数、基类、虚函数)<br>由于非<code>POD</code>类型比如非聚合类型的<code>class</code>对象，可能存在虚函数，内存布局不确定，跟编译器有关，滥用内存拷贝可能会导致严重的问题。<br>即使对聚合类型的<code>class</code>,使用直接的内存拷贝和比较，破坏了信息隐蔽和数据保护的作用，也不提倡使用<code>memcpy_s</code>、<code>memset_s</code></p><h3 id="9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量"><a href="#9-2-1-含有变量自增或自减运算的表达式中禁止再次引用该变量" class="headerlink" title="9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量"></a>9.2.1 含有变量自增或自减运算的表达式中禁止再次引用该变量</h3><p>含有变量自增或自减的表达式中，如果再引用该变量，其结果在C++标准中未明确定义。会产生未定义的结果。<br>注意，运算次序的问题不能使用括号来解决，因为之不是优先级的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i++; <span class="comment">///&lt; Bad: b[i]运算跟i++, 先后顺序并不明确。</span></span><br></pre></td></tr></table></figure><p>正确的写法是将自增或自减运算单独放一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = b[i] + i;</span><br><span class="line">i++;    <span class="comment">///&lt; Good， 单独一行</span></span><br></pre></td></tr></table></figure><p>函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Func</span>(i++, i)    <span class="comment">///&lt; Bad</span></span><br><span class="line"></span><br><span class="line">i++;    <span class="comment">///&lt; Good， 自增运算单独放一行</span></span><br><span class="line"><span class="built_in">Func</span>(i, i)</span><br></pre></td></tr></table></figure><h3 id="9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换"><a href="#9-3-1-如果确定要使用类型转换，请使用由C-提供的类型转换，而不是C风格的类型转换" class="headerlink" title="9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换"></a>9.3.1 如果确定要使用类型转换，请使用由C++提供的类型转换，而不是C风格的类型转换</h3><p>C++提供的类型转换操作比C风格更具有针对性，更易读，也更安全，C++提供的转换有：</p><ol><li><code>dynamic_cast</code>: 主要用于继承体系下行转换，<code>dynamic_cast</code>具有类型检查的功能，请做好基类和派生类的设计，避免使用<code>dynamec_cast</code>来进行转换。</li><li><code>static_cast</code>: 和C风格相似可做值的强制转换，或上行转换(把派生类的指着或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。</li><li><code>reinterpret_cast</code>: 用于转换不相关的类型。<code>reinterpret_cast</code>强制编译器将某个类型对象的内存重新解释成另一种类型，这是一种不安全的转换，建议尽可能少用<code>reinterpret_cast</code></li><li><code>const_cast</code>: 用于移除对象的<code>const</code>属性，使对象变得可修改，这样会破坏数据的不变性，建议尽可能少用。</li></ol><h3 id="9-5-1-不要保存std-string的c-str-返回的指针"><a href="#9-5-1-不要保存std-string的c-str-返回的指针" class="headerlink" title="9.5.1 不要保存std::string的c_str()返回的指针"></a>9.5.1 不要保存<code>std::string</code>的<code>c_str()</code>返回的指针</h3><p>C++标准中并未规定<code>c_str()</code>返回的指针持久有效，所以不要保存。</p><h3 id="9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const"><a href="#9-6-1-对于指针和引用类型的形参，如果是不需要修改的，请使用const" class="headerlink" title="9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用const"></a>9.6.1 对于指针和引用类型的形参，如果是不需要修改的，请使用<code>const</code></h3><p>不变的值更易于理解&#x2F;跟踪和分析， 把<code>const</code>作为默认悬念，在编译时会对其进行检查，使代码更安全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-6-2-对于不会修改成员变量的成员函数请使用const修饰"><a href="#9-6-2-对于不会修改成员变量的成员函数请使用const修饰" class="headerlink" title="9.6.2 对于不会修改成员变量的成员函数请使用const修饰"></a>9.6.2 对于不会修改成员变量的成员函数请使用<code>const</code>修饰</h3><p>尽可能将成员函数声明为<code>const</code>。访问函数应该总是<code>const</code>。只要不修改数据成员的成员函数，都声明为<code>const</code>。对于虚函数，应当从设计意图上考虑继承链上的所有类是否需要在此虚函数中修改数据成员，而不是仅关注单个类的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">PrintValue</span><span class="params">()</span> <span class="type">const</span> <span class="comment">///&lt; 修饰成员函数, 不会修改成员变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="2-4-1-避免滥用typedef或者-define对基本类型起别名"><a href="#2-4-1-避免滥用typedef或者-define对基本类型起别名" class="headerlink" title="2.4.1 避免滥用typedef或者#define对基本类型起别名"></a>2.4.1 避免滥用<code>typedef</code>或者<code>#define</code>对基本类型起别名</h3><p>除有明确的必要性，否则不要用<code>typedef</code>、<code>#define</code>对基本数据类型进行重定义。优先使用<code>&lt;cstdint&gt;</code>头文件中的基本。</p><table><thead><tr><th>有符号类型</th><th>无符号类型</th><th>描述</th></tr></thead><tbody><tr><td>int8_t</td><td>uint8_t</td><td>宽度恰为8的有、无符号整数类型</td></tr><tr><td>int16_t</td><td>uint16_t</td><td>宽度恰为16的有、无符号整数类型</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>宽度恰为32的有、无符号整数类型</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>宽度恰为64的有、无符号整数类型</td></tr><tr><td>intptr_t</td><td>uintptr_t</td><td>足以保存指针的有、无符号整数类型</td></tr></tbody></table><h3 id="3-1-1-行宽不超过120个字符"><a href="#3-1-1-行宽不超过120个字符" class="headerlink" title="3.1.1 行宽不超过120个字符"></a>3.1.1 行宽不超过120个字符</h3><h3 id="3-9-1-表达式换行要保持换行的一致性，运算符放行末"><a href="#3-9-1-表达式换行要保持换行的一致性，运算符放行末" class="headerlink" title="3.9.1 表达式换行要保持换行的一致性，运算符放行末"></a>3.9.1 表达式换行要保持换行的一致性，运算符放行末</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">IsCorrect</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsValid</span>() &amp;&amp;</span><br><span class="line">   <span class="built_in">IsSomething</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-1-合理安排空行，保持代码紧凑"><a href="#3-14-1-合理安排空行，保持代码紧凑" class="headerlink" title="3.14.1 合理安排空行，保持代码紧凑"></a>3.14.1 合理安排空行，保持代码紧凑</h3><p>减少不必要的空行，可以显示更多的代码，方便代码阅读。</p><ul><li>根据上下内容的相关程度，合理安排空行</li><li>函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行</li><li>不适用连续三个空行，或更多</li><li>大括号内的代码块行首之前和行尾之后不要加空行，但<code>namespace</code>的大括号内不做要求</li></ul><h3 id="5-2-1-尽量避免使用前置声明"><a href="#5-2-1-尽量避免使用前置声明" class="headerlink" title="5.2.1 尽量避免使用前置声明"></a>5.2.1 尽量避免使用前置声明</h3><h3 id="6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"><a href="#6-1-1-对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰" class="headerlink" title="6.1.1 对于cpp文件中不需要导出的变量，常量或者函数，请使用匿名namespace封装或者用static修饰"></a>6.1.1 对于<code>cpp</code>文件中不需要导出的变量，常量或者函数，请使用匿名<code>namespace</code>封装或者用<code>static</code>修饰</h3><p>更加推荐使用匿名<code>namespace</code>：</p><ol><li><code>static</code>在C++中已经赋予了太多的含义，静态函数成员变量，静态成员函数， 静态全局变量，静态函数局部变量，每一种都有特殊的处理。</li><li><code>static</code>只能保证变量，常量和函数的文件作用域，但是<code>namespace</code>还可以封装类型等。</li><li>统一<code>namespace</code>来处理C++的作用域，而不需要同时使用<code>static</code>和<code>namespace</code>来管理</li><li><code>static</code>修饰的函数不能用来实例化模板，而匿名<code>namespace</code>可以</li></ol><p>注意： 不要<code>.h</code>中使用匿名<code>namespace</code>或者<code>static</code></p><h3 id="6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"><a href="#6-2-1-优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数" class="headerlink" title="6.2.1 优先使用命名空间来管理全局函数，如果和某个class有直接关系的，可以使用静态成员函数"></a>6.2.1 优先使用命名空间来管理全局函数，如果和某个<code>class</code>有直接关系的，可以使用静态成员函数</h3><p>非成员函数放在名字控件内可避免污染全局作用域，也不要用类+静态成员方法来简单管理全局函数。如果某个全局函数和某个类有紧密联系，那么可以作为类的静态成员函数。<br>如果你需要定义一些全局函数，给某个cpp文件使用，那么请使用匿名namespace来管理。</p><h3 id="6-4-1-尽量避免使用全局变量，考虑使用单例模式"><a href="#6-4-1-尽量避免使用全局变量，考虑使用单例模式" class="headerlink" title="6.4.1 尽量避免使用全局变量，考虑使用单例模式"></a>6.4.1 尽量避免使用全局变量，考虑使用单例模式</h3><p>全局变量是可以修改和读取的，那么这样会导致业务代码和这个全局变量产生数据耦合。</p><h3 id="8-3-1-函数参数使用引用代替指针"><a href="#8-3-1-函数参数使用引用代替指针" class="headerlink" title="8.3.1 函数参数使用引用代替指针"></a>8.3.1 函数参数使用引用代替指针</h3><p>引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。</p><h3 id="8-3-2-使用强类型参数，避免使用void"><a href="#8-3-2-使用强类型参数，避免使用void" class="headerlink" title="8.3.2 使用强类型参数，避免使用void*"></a>8.3.2 使用强类型参数，避免使用void*</h3><p>一般认为<code>C/C++</code>是强类型语言，既然我们使用的是强类型语言，就应该保持这样的风格。好处是尽量让编译器在编译阶段就检查出类型不匹配的问题。</p><h3 id="8-3-3-函数的参数个数不超过5个"><a href="#8-3-3-函数的参数个数不超过5个" class="headerlink" title="8.3.3 函数的参数个数不超过5个"></a>8.3.3 函数的参数个数不超过5个</h3><p>函数的参数过多，会使得该函数易于受外部变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。<br>如果超过可以考虑</p><ul><li>看能否拆分函数</li><li>看能否将相关参数合在一起，定义结构体</li></ul><h3 id="9-1-1-一组相关的整型变量应定义未枚举。"><a href="#9-1-1-一组相关的整型变量应定义未枚举。" class="headerlink" title="9.1.1 一组相关的整型变量应定义未枚举。"></a>9.1.1 一组相关的整型变量应定义未枚举。</h3><p>枚举比<code>#define</code>或<code>const int</code>更安全。编译器会检查参数值是否位于枚举取值范围内，避免错误发生。</p><h3 id="9-1-2-变量使用时才声明并初始化"><a href="#9-1-2-变量使用时才声明并初始化" class="headerlink" title="9.1.2 变量使用时才声明并初始化"></a>9.1.2 变量使用时才声明并初始化</h3><p>变量在使用前未赋初值，是常见的低级编程错误。使用前才声明变量并初始化，非常方便地避免了此类低级错误。<br>在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：</p><ul><li>程序难以理解与维护： 变量定义与使用分离</li><li>变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值（0）来初始化。如果变量在被赋予有效值以前使用，还会导致错误。</li></ul><p>遵循变量作用域最小化原则与就近声明原则，使得代码更容易阅读，方便了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string name;   <span class="comment">///&lt; Bad</span></span><br><span class="line">name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>)</span></span>;   <span class="comment">///&lt; Good</span></span><br></pre></td></tr></table></figure><h3 id="9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"><a href="#9-2-1-表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则" class="headerlink" title="9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则"></a>9.2.1 表达式的比较，应当遵循左侧倾向于变化，右侧倾向于不变的原则</h3><p>当变量与常量进行比较时，如果常量放左边， 如<code>if(MAX == v)</code>不符合阅读习惯，而<code>if(MAX &gt; v)</code>更难以理解，应当按人的正常阅读、表达习惯，将常量放右边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value &lt; MAX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有特殊情况， 如： <code>if(MIN &lt; value &amp;&amp; value &lt; MAX)</code>用来描述区间时，前半段是常量在左的。<br>不用担心将<code>==</code>误写成<code>=</code>, 因为<code>if(value = MAX)</code>会有编译告警，其他静态检查工具也会报错。让工具去解决笔误问题，代码要符合可读性第一。</p><h3 id="9-2-2-使用括号明确操作符的优先级"><a href="#9-2-2-使用括号明确操作符的优先级" class="headerlink" title="9.2.2 使用括号明确操作符的优先级"></a>9.2.2 使用括号明确操作符的优先级</h3><p>使用括号明确操作符的优先级，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b + ; <span class="comment">///&lt; 操作符相同,可以不加括号</span></span><br><span class="line">x = <span class="number">1</span> &lt;&lt; (<span class="number">2</span> + <span class="number">3</span>);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br><span class="line">x = (a == b) ? a : (a - b);   <span class="comment">///&lt; 操作符不同, 需要括号</span></span><br></pre></td></tr></table></figure><h3 id="9-3-1-避免使用dynamic-cast"><a href="#9-3-1-避免使用dynamic-cast" class="headerlink" title="9.3.1 避免使用dynamic_cast"></a>9.3.1 避免使用<code>dynamic_cast</code></h3><ol><li><code>dynamic_cast</code>依赖于C++的<code>RTTI</code>, 让程序员在运行时识别C++类对象的类型</li><li><code>dynamic_cast</code>的出现一般说明我们的基类和派生类设计出现了问题，派生类破坏了基类的七月，不得不通过</li><li><code>dynamic_cast</code>转换到子类进行特殊处理，这个时候更希望来改善类的设计，而不是通过<code>dynamic_cast</code>来解决问题</li></ol><h3 id="9-3-2-避免使用reinterpret-cast"><a href="#9-3-2-避免使用reinterpret-cast" class="headerlink" title="9.3.2 避免使用reinterpret_cast"></a>9.3.2 避免使用<code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code>用于转换不相关类型。尝试用<code>reinterpret_cast</code>将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。</p><h3 id="9-3-3-避免使用const-cast"><a href="#9-3-3-避免使用const-cast" class="headerlink" title="9.3.3 避免使用const_cast"></a>9.3.3 避免使用<code>const_cast</code></h3><p><code>cosnt_cast</code>用于移除对象的<code>const</code>和<code>volatile</code>性质。<br>使用<code>const_cast</code>转换后的指针或者引用来修改<code>const</code>对象，行为是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不好的例子</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i);</span><br><span class="line">*p = <span class="number">2048</span>;  <span class="comment">///&lt; 未定义行为</span></span><br></pre></td></tr></table></figure><h3 id="9-4-1-使用RAII特性来帮助跟踪动态分配"><a href="#9-4-1-使用RAII特性来帮助跟踪动态分配" class="headerlink" title="9.4.1 使用RAII特性来帮助跟踪动态分配"></a>9.4.1 使用<code>RAII</code>特性来帮助跟踪动态分配</h3><p><code>RAII</code>是”资源获取就是初始化”的简写(Resource Acquisition Is Initialization), 是一种利用对象生命周期来控制程序资源(如内存、文件句柄、网络连接、互斥量等等)的简单技术。<br><code>RAII</code>的一般做法是这样的： 在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内之中有效，最后在对象析构的时候释放资源，这种做法有两大好处:</p><ul><li>我们不需要显式地释放资源</li><li>对象所需的资源在其生命期内始终有效。这样，就不必检查资源有效性问题，可以简化逻辑、提高效率。</li></ul><h3 id="9-5-1-使用std-string代替char"><a href="#9-5-1-使用std-string代替char" class="headerlink" title="9.5.1 使用std::string代替char*"></a>9.5.1 使用<code>std::string</code>代替<code>char*</code></h3><p>说明: 使用<code>string</code>代替<code>char*</code>有很多优势，比如:</p><ol><li>不用考虑结尾的<code>&#39;\0&#39;</code></li><li>可以直接使用<code>+</code>, <code>=</code>, <code>==</code>等运算符以及其他字符串操作函数</li><li>不需要考虑内存分配操作，避免了显式的<code>new</code>、<code>delete</code>, 以及由此导致的错误</li></ol><p>需要注意的是</p><h3 id="9-5-2-使用新的标准头文件"><a href="#9-5-2-使用新的标准头文件" class="headerlink" title="9.5.2 使用新的标准头文件"></a>9.5.2 使用新的标准头文件</h3><p>使用C++的标准头文件时，请使用<code>&lt;cstdlib&gt;</code>这样的，而不是<code>&lt;stdlib.h&gt;</code></p><h3 id="9-6-1-初始化后不会再修改的成员变量定义为const"><a href="#9-6-1-初始化后不会再修改的成员变量定义为const" class="headerlink" title="9.6.1 初始化后不会再修改的成员变量定义为const"></a>9.6.1 初始化后不会再修改的成员变量定义为<code>const</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> length): <span class="built_in">dataLength_</span>(length)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dataLength_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现代C-since-C-11"><a href="#现代C-since-C-11" class="headerlink" title="现代C++(since C++11)"></a>现代C++(since C++11)</h2><h2 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h2><h3 id="10-1-1-在重写虚函数时请使用override或final关键字"><a href="#10-1-1-在重写虚函数时请使用override或final关键字" class="headerlink" title="10.1.1 在重写虚函数时请使用override或final关键字"></a>10.1.1 在重写虚函数时请使用<code>override</code>或<code>final</code>关键字</h3><p><code>override</code>和<code>final</code>关键字都能保证函数是虚函数，且重写了基类的虚函数。如果子类函数与基类函数圆形不一致，则产生编译错误。<code>final</code>还保证u函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>还保证虚函数不会再被子类重写。<br>使用<code>override</code>或<code>final</code>关键字后，如果修改了基类函数原型，但忘记修改子类重写的虚函数，在编译期就可以发现，也可以避免有多个子类时，重写虚函数的修改遗漏。</p><h3 id="10-1-2-使用delete关键字删除函数"><a href="#10-1-2-使用delete关键字删除函数" class="headerlink" title="10.1.2 使用delete关键字删除函数"></a>10.1.2 使用<code>delete</code>关键字删除函数</h3><p>相比于将类成员函数声明为<code>private</code>但不实现， <code>delete</code>关键字更明确，且适用范围更广。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    <span class="comment">///&lt; 只看头文件不知道拷贝构造函数是否被删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 明确删除拷贝赋值符</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，<code>delete</code>关键字还支持删除非成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> Process&lt;<span class="type">void</span>&gt; </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h3 id="10-1-3-使用nullptr-而不是NULL或0"><a href="#10-1-3-使用nullptr-而不是NULL或0" class="headerlink" title="10.1.3 使用nullptr, 而不是NULL或0"></a>10.1.3 使用<code>nullptr</code>, 而不是<code>NULL</code>或<code>0</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;   <span class="comment">///&lt; 错误: void* 不能自动转为 char*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span>(C::pmf)() = &amp;C::Func;</span><br><span class="line"><span class="keyword">if</span>(pmf == <span class="literal">NULL</span>) &#123;&#125; <span class="comment">///&lt; 错误： void* 不能自动转换为指向成员函数的指针</span></span><br></pre></td></tr></table></figure><p>如果把<code>NULL</code>定义为<code>0</code>, 或者在需要空指针的地方直接使用<code>0</code>。这样引入了另外的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 无法判断返回的是整数还是空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载也会出现重载的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用F(int)， 而不是F(int*)</span></span><br></pre></td></tr></table></figure><p>另外<code>sizeof(NULL) == sizeof(void*)</code>并不总是成立的。</p><p><code>nullptr</code>的又是不仅仅是在字面上代表了空指针，使代码清晰，而且它不再是一个整数类型。<br><code>nullptr</code>是<code>std::nullptr_t</code>类型， 而<code>std::nullptr_t</code>可以隐式的转换为所有的原始指针类型，这使得<code>nullptr</code>可以表现成指向任意类型的空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>*`)</span></span>;</span><br><span class="line"><span class="built_in">F</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 调用F(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 正确的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h2><h3 id="10-1-1-合理使用auto"><a href="#10-1-1-合理使用auto" class="headerlink" title="10.1.1 合理使用auto"></a>10.1.1 合理使用<code>auto</code></h3><ul><li><code>auto</code>可以避免编写冗长、重复的类型名，也可以保证定义变量时初始化</li><li><code>auto</code>类型推导规则复杂，需要仔细理解</li><li>如果能够使代码更清晰，继续使用明确的类型，且旨在局部变量使用<code>auto</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 避免冗长的类型名</span></span><br><span class="line">std::map&lt;std::string, std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 保证初始化</span></span><br><span class="line"><span class="type">int</span> x;  <span class="comment">///&lt; 编译正确，没有初始化</span></span><br><span class="line"><span class="keyword">auto</span> x; <span class="comment">///&lt; 编译失败，没有初始化</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于对象的复制</title>
      <link href="/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/07/21/2021-05-09-C++%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>通常我们使用对象内的拷贝构造函数和拷贝构造符来进行初始化和拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        i = other.i;</span><br><span class="line">        vec = other.vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝赋值符</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            i = other.i;</span><br><span class="line">            vec = other.vec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A foo;</span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">(foo)</span></span>; <span class="comment">///&lt; 在这里调用拷贝构造函数</span></span><br><span class="line">A bar2;</span><br><span class="line">bar2 = foo; <span class="comment">///&lt; 这里调用拷贝赋值符</span></span><br></pre></td></tr></table></figure><h2 id="关于memset"><a href="#关于memset" class="headerlink" title="关于memset"></a>关于memset</h2><p>首先说结论，不推荐使用<code>memset</code>对某个对象进行擦写内存。因为可能导致未定义行为。<br>具体可以查看<code>stackflow</code>上的这个问题 <a href="https://stackoverflow.com/questions/2481654/memset-for-initialization-in-c">memset for initialization in C++</a>和<a href="https://stackoverflow.com/questions/6421818/c-use-memset-or-a-struct-constructor-whats-the-fastest">Use memset or a struct constructor? What’s the fastest?</a></p><p>你可以使用构造函数进行初始化，也可以定义成员函数<code>clear()</code>， 或是使用<code>std::fill</code>, <code>std::fill_n</code>。<br>在使用函数<code>memset</code>时，有部分限定条件，只有目标对象为POD类型才可以使用。</p><p>简单来说就是，该对象如果没有继承，都是基础类型(如: <code>int</code>、<code>char</code>或其他<code>POD</code>类型), 没有包含如<code>std::array</code>, <code>std::vector</code>等STL容器, 该对象可以称为<code>POD</code>类型。如下面示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pod</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">12</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>POD</code>具体查看<a href="https://en.cppreference.com/w/cpp/named_req/PODType">C++ named requirements: PODType</a></p><h2 id="关于memcpy"><a href="#关于memcpy" class="headerlink" title="关于memcpy"></a>关于memcpy</h2><p>结论是，不推荐使用，同样除了你能确保该对象为<code>POD</code>类型，否则则会导致未定义现象。<br>可以使用拷贝构造函数或拷贝赋值符，或是<code>std::copy</code>或<code>std::copy_n</code>来代替<code>memcpy</code>;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《代码大全》</title>
      <link href="/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/21/2021-05-14-%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="强制类型转换的应用"><a href="#强制类型转换的应用" class="headerlink" title="强制类型转换的应用"></a>强制类型转换的应用</h2><h2 id="C语言中void-可以转换为任意指针"><a href="#C语言中void-可以转换为任意指针" class="headerlink" title="C语言中void* 可以转换为任意指针"></a>C语言中void* 可以转换为任意指针</h2><p>size_t 到 unsigned</p><p>变量初始化</p><ul><li>从未对变量赋值。它的值只是程序启动时变量所处内存区域的值</li><li>变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效</li><li>变量的一部分被赋值，而另一部分没有</li></ul><h2 id="在声明变量的时候初始化"><a href="#在声明变量的时候初始化" class="headerlink" title="在声明变量的时候初始化"></a>在声明变量的时候初始化</h2><h2 id="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"><a href="#理想情况下，在靠近第一次使用变量的位置声明和定义该变量" class="headerlink" title="理想情况下，在靠近第一次使用变量的位置声明和定义该变量"></a>理想情况下，在靠近第一次使用变量的位置声明和定义该变量</h2><ul><li>在有可能的情况下使用<code>const</code>， 定义常量，入参。</li><li>特别注意计数器和累加器，在下一次使用时忘记重置其值。</li><li>在类的构造函数中，初始化该类的数据成员</li><li>检查是否需要重新初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// do something with index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尽可能缩短变量存活时间"><a href="#尽可能缩短变量存活时间" class="headerlink" title="尽可能缩短变量存活时间"></a>尽可能缩短变量存活时间</h2><p>短的变量存活时间减少了初始化错误的可能。</p><p>变量存活时间短还会使代码具有可读性。阅读者同一时间内需要阅读的代码越少，越容易理解代码。</p><p>当需要把一个大的函数，拆分成几个小程序，短的存活时间方便拆分。</p><p>在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。</p><p>直到变量即将被使用时再为其赋值。</p><p>把相关语句放在一起。把相关语句提取成单独的子程序。</p><p>开始时采用最严格的可见性，然后根据扩展变量的作用域。比如，把一个循环内的变量挪到循环外的难度要比反过来难度低，或把一个<code>private</code>转变为<code>public</code>的难度远比反过来难度低。</p><p>避免采用硬编码，宏定义总是好于硬编码。</p><ul><li><code>TITLE_BAR_COLOR</code> 比 <code>0xFFFFFF</code> 更能反应出所代表的信息</li><li>同时，也方便修改宏定义时，同时改变所有的颜色的RGB值</li></ul><h2 id="为变量指定单一用途"><a href="#为变量指定单一用途" class="headerlink" title="为变量指定单一用途"></a>为变量指定单一用途</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + temp) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - temp) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">temp = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discriminant = <span class="built_in">Sqrt</span>(b*b - <span class="number">4</span>*a*c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + discriminant) / (<span class="number">2</span>*a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - discriminant) / (<span class="number">2</span>*a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap the roots</span></span><br><span class="line">oldRoot = root[<span class="number">0</span>];</span><br><span class="line">root[<span class="number">0</span>] = root[<span class="number">1</span>];</span><br><span class="line">root[<span class="number">1</span>] = oldRoot;</span><br></pre></td></tr></table></figure><p>避免让代码具有隐含含义，把同一变量用于多个多个用途的另外一种方式是当变量代表不同事务时让其具有不同的取值集合。</p><ul><li>变量<code>count</code>的取值可能表示某个计数，除非他等于<code>-1</code>，在这种情况下表明有错误发生</li><li>变量<code>customerId</code>可能代表某个客户账号，除非他的取值大于50000，在这种情况下，你通过减去50000来得到过期账号。</li><li>变量<code>bytesWritten</code>可能表示写入输出文件的字节数，除非它的取值为负，在这种情况下他表示的是用于输出磁盘驱动器的号码。</li></ul><h2 id="变量名的注意事项"><a href="#变量名的注意事项" class="headerlink" title="变量名的注意事项"></a>变量名的注意事项</h2><p>糟糕的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x - xx;</span><br><span class="line">xxx = fido + <span class="built_in">SalesTax</span>(fido);</span><br><span class="line">x = x + <span class="built_in">LateFee</span>(x1, x) + xxx;</span><br><span class="line">x = x + <span class="built_in">Interest</span>(x1, x);</span><br></pre></td></tr></table></figure><p>良好的变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">balance = balance - lastPayment;</span><br><span class="line">monthlyTotal = newPurchases + <span class="built_in">SalesTax</span>(newPurchases);</span><br><span class="line">balance = balance + <span class="built_in">LateFee</span>(customerID, balance) + monthlyTotal;</span><br><span class="line">balance = balance + <span class="built_in">Interest</span>(customerID, balance);</span><br></pre></td></tr></table></figure><p>为变量命名时最重要的考虑事项时，改名字要完全、准确地描述该变量所代表的事物<br>不包含晦涩的缩写，同时也没有歧义。<br>对于一个表示中国奥林匹克代表团成员数量的变量，你可能会使用<code>NumberOfPeopleOnTheChineseOlympicTeam</code><br>表示当前利率的变量最好为<code>rate</code>而不是<code>r</code>.</p><p>变量名太长: <code>numberOfPeopleOnTheChineseOlympicTeam</code>,<code>numberOfSeatsInTheStadium</code>, <code>maximumNumberOfPointsInModernOlympics</code><br>变量名太短: <code>n</code>, <code>np</code>, <code>ntm</code>, <code>ms</code>, <code>nsisd</code>, <code>m</code>, <code>max</code>, <code>min</code><br>变量名正好： <code>numTeamMembers</code>, <code>teamMemberCount</code>, <code>numSeatsInStadium</code>, <code>seatCount</code>, <code>teamPointsMax</code>, <code>pointSRecord</code></p><p>很多程序有表示计算机结果的变量：总额、平均值、最大值，等等。如果你要用类似于<code>Total</code>、<code>Sum</code>、<code>Average</code>、<code>Max</code>、<code>Min</code>、<code>Record</code>这样的限定词，那么请一定记住把限定词加到名字最后。<br>变量名中最重要的部分应该被放置在最前面，限定词在最后。<br>这样做会避免，<code>totalRevenue</code>和<code>revenueTotal</code>异议词语</p><p>为状态变量起一个比<code>flag</code>更好的名字。最好把标记<code>flag</code>看作状态变量，标记的名字中不应该含有<code>flag</code>，因为你从中丝毫看不出该标记是做什么的。<br>含义模糊的标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) ...</span><br><span class="line"><span class="keyword">if</span> (statusFlag &amp; <span class="number">0xF</span>) ...</span><br><span class="line"><span class="keyword">if</span> (printFlag == <span class="number">16</span>) ...</span><br><span class="line"><span class="keyword">if</span> (computeFlag == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure><p>更好的状态变量命名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dataReady) ...</span><br><span class="line"><span class="keyword">if</span> (characterType &amp; PRINTABLE_CHAR) ...</span><br><span class="line"><span class="keyword">if</span> (reportType == ReportType_Annual) ...</span><br><span class="line"><span class="keyword">if</span> (recalcNeeded == <span class="literal">false</span>) ...</span><br></pre></td></tr></table></figure><p>为布尔变量命名</p><ul><li><code>done</code> 用<code>done</code>表示某件事情已经发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>error</code> 用<code>error</code>表示有错误发生。在错误发生之前把变量值设为<code>false</code>, 在错误已经发生时把它设为<code>true</code></li><li><code>found</code> 用<code>found</code>来表明某个值已经找到了。在没有找到设为<code>false</code>, 找到后设为<code>true</code>.</li><li><code>success</code>和<code>ok</code>, 操作失败时设为<code>false</code>, 操作成功后设为<code>true</code></li></ul><p>给布尔变量赋予隐含“真、假”含义的名字: <code>status</code>和<code>sourceFile</code>是很糟糕的布尔变量名。<br>应该把<code>status</code>替换为类似<code>error</code>或者<code>statusOK</code>这样的名称，把<code>sourceFile</code>替换为<code>sourceFileAvailable</code>、<code>sourceFileFound</code></p><p>使用肯定的布尔变量名，否定的布尔名如<code>notFound</code>、<code>notDone</code>以及<code>notSuccessful</code>比较难阅读。使用肯定的语义避免双重否定带来的阅读难度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnsiString strTmp;</span><br><span class="line">strTmp = edtAccount-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Account = strTmp;</span><br><span class="line">&#125;</span><br><span class="line">strTmp = edtPassword-&gt;Text;</span><br><span class="line"><span class="keyword">if</span>(strTmp.<span class="built_in">IsInvalid</span>())</span><br><span class="line">&#123;</span><br><span class="line">    st.Password = strTmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩写的一般指导原则：</p><ul><li>使用标准的缩写(列在字典中的那些常见缩写)</li><li>去掉虚词<code>and</code>, <code>or</code>, <code>the</code>等</li><li>去掉无用的后缀<code>ing</code>, <code>end</code></li><li>确保不要改变变量的含义</li><li>反复使用上述技术，知道你把每个变量名的长度缩减到了8到20个字符，或者达到你所用的编程语言对变量名的限制字符数。</li></ul><h2 id="不要用每个单词中删除一个字符的方式来缩写"><a href="#不要用每个单词中删除一个字符的方式来缩写" class="headerlink" title="不要用每个单词中删除一个字符的方式来缩写"></a>不要用每个单词中删除一个字符的方式来缩写</h2><p>键入一个字符算不上是什么额外工作，而节省一个字符带来的便利却很难抵消由此而造成的可读性的损失。</p><h2 id="缩写要一致"><a href="#缩写要一致" class="headerlink" title="缩写要一致"></a>缩写要一致</h2><p>应该一直使用相同的缩写。要么全用<code>Num</code>，要么全用<code>No</code>，也不要有些地方使用全写<code>Number</code>, 同时在其他地方使用缩写<code>Num</code></p><h2 id="创建你能读出来的名字"><a href="#创建你能读出来的名字" class="headerlink" title="创建你能读出来的名字"></a>创建你能读出来的名字</h2><p>使用<code>xPos</code>而不是<code>xPstn</code>, 用<code>needsCompu</code>而不用<code>ndsCmptg</code>。这里可以使用电话沟通，如果你无法向他人读出你的代码，就请重新给变量起一个更清晰的名字。</p><h2 id="名字对于代码的读者的意义要比对作者更重要"><a href="#名字对于代码的读者的意义要比对作者更重要" class="headerlink" title="名字对于代码的读者的意义要比对作者更重要"></a>名字对于代码的读者的意义要比对作者更重要</h2><h2 id="避免使用令人误解的名字或缩写"><a href="#避免使用令人误解的名字或缩写" class="headerlink" title="避免使用令人误解的名字或缩写"></a>避免使用令人误解的名字或缩写</h2><p>要确保名字的含义是明确的</p><h2 id="避免使用具有相似含义的名字"><a href="#避免使用具有相似含义的名字" class="headerlink" title="避免使用具有相似含义的名字"></a>避免使用具有相似含义的名字</h2><p>如果你能够交换两个变量的名字而不会妨碍对程序的理解，那么你就需要为这两个变量重新命名了。</p><h2 id="避免在名字中使用数字"><a href="#避免在名字中使用数字" class="headerlink" title="避免在名字中使用数字"></a>避免在名字中使用数字</h2><p>如果名字中的数字真的非常重要，就请使用数组来代替一组单个的变量。如果数组不合适，那么数字就更不合适。</p><h2 id="避免在名字中拼错单词"><a href="#避免在名字中拼错单词" class="headerlink" title="避免在名字中拼错单词"></a>避免在名字中拼错单词</h2><h2 id="避免在名字中使用容易混淆的字符"><a href="#避免在名字中使用容易混淆的字符" class="headerlink" title="避免在名字中使用容易混淆的字符"></a>避免在名字中使用容易混淆的字符</h2><ul><li>数字<code>1</code>和小写的<code>l</code></li><li>数字<code>1</code>和大写的<code>L</code></li><li>数字<code>0</code>和大写的<code>O</code></li><li>数字<code>2</code>和小写的<code>z</code></li><li>数字<code>6</code>和大写的<code>G</code></li></ul><h2 id="避免浮点数的数量级相差巨大的数字之间的四则运算"><a href="#避免浮点数的数量级相差巨大的数字之间的四则运算" class="headerlink" title="避免浮点数的数量级相差巨大的数字之间的四则运算"></a>避免浮点数的数量级相差巨大的数字之间的四则运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">100000000.0</span> + <span class="number">0.1</span>;</span><br><span class="line">    std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免浮点数的等量比较"><a href="#避免浮点数的等量比较" class="headerlink" title="避免浮点数的等量比较"></a>避免浮点数的等量比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp += <span class="number">0.1</span>;</span><br><span class="line">        std::cout &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncreaseB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">IncreaseA</span>() || !<span class="built_in">IncreaseB</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为空语句创建一个DoNothing-预处理宏或者内联函数"><a href="#为空语句创建一个DoNothing-预处理宏或者内联函数" class="headerlink" title="为空语句创建一个DoNothing()预处理宏或者内联函数"></a>为空语句创建一个DoNothing()预处理宏或者内联函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(recordArray.<span class="built_in">Read</span>(index++) != recordArray.<span class="built_in">EmptyRecord</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DoNothing()</span></span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoNothing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UML语法简介</title>
      <link href="/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/21/2021-04-26-UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example.png" alt="generalize_example"></p><p>eg：猫是一种动物；猫与动物之间为泛化关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/generalize_example(2).png" alt="generalize_example(2)"></p><h2 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h2><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”猫”和”鸟”运动方式不同，它们的运动方式一个为走一个为飞，必须要在派生类”动物”中提供具体实现，那么”猫”和”鸟”对于基类动物来说为实现关系。</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/realize_example.png" alt="realize_example"></p><h2 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h2><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/aggregation_example.png" alt="aggregation_example"></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，<strong>整体和部分不是强依赖的</strong>，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h2 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h2><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/composition_example.png" alt="composition_example"></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种<strong>强依赖的特殊聚合关系</strong>，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h2 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h2><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/association_example.png" alt="association_example"></p><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h2 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h2><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="/../resource/UML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/dependency_example.png" alt="dependency_example"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ POD的介绍</title>
      <link href="/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/21/2021-04-28-C++POD%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="POD-plain-old-data-介绍"><a href="#POD-plain-old-data-介绍" class="headerlink" title="POD(plain old data)介绍"></a><code>POD</code>(<code>plain old data</code>)介绍</h2><h3 id="简旧类型-plain-old-data"><a href="#简旧类型-plain-old-data" class="headerlink" title="简旧类型(plain old data)"></a>简旧类型(<code>plain old data</code>)</h3><ul><li>一个标量类型(<code>scalar type</code>)</li><li>简旧类型(POD)数组</li><li>一个符合以下要求的<code>class</code>类型(<code>class</code> or <code>struct</code> or <code>union</code>)<ul><li>C++11以前:<ul><li>是一个聚合类型(<code>aggregate type</code>)</li><li>所有非静态成员都是简旧类型(<code>POD</code>)</li><li>没有成员是引用类型</li><li>没有用户定义的拷贝构造函数</li><li>没有用户定义的析构函数</li></ul></li><li>C++11以后<ul><li>是一个平凡类型(<code>trivial type</code>)</li><li>是一个标准布局类型</li><li>所有非静态成员是简旧类型(<code>POD</code>)</li></ul></li></ul></li></ul><h3 id="POD类型特别在哪里？"><a href="#POD类型特别在哪里？" class="headerlink" title="POD类型特别在哪里？"></a>POD类型特别在哪里？</h3><p><a href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special">What are Aggregates and PODs and how&#x2F;why are they special?</a></p><p>像<code>POD-classes</code>，<code>PD-unions</code>, <code>scalar type</code>和<code>数组</code>这样的类型被统一的叫做<code>POD-types</code>， <code>PODs</code>在很多地方都非常特别。下面一些例子。</p><ul><li><code>POD-classes</code>最接近C语言形式的结构体。不同的是，<code>PODs</code>可以有成员函数和任意静态成员，但他们两者都不能改变对象的内存排布。所以假如你想要写一个或多或少可移植型的可以被C语言甚至<code>.NET</code>使用的动态库，你应该尝试你所有导出的函数和返回值都是<code>POD-types</code>.</li><li>一个<code>non-POD</code>类类型对象的生存周期开始于当构造函数结束，结束于当析构函数结束。对于<code>POD</code>类型类，生命周期开始于内存空间被对象占用，结束于内存空间被释放或者被重用后。</li><li>对于<code>POD</code>类型的对象， 标准保证它当你使用<code>memcpy</code>对你对象中内容转化为<code>char</code>或<code>unsigned</code>数组时，然后<code>memcpy</code>这个内容回到你的对象内，这个对象将持有原始的值。请注意：对于<code>non-POD</code>类型对象没有这样的保证。下面的例子假设类型<code>T</code>是<code>POD</code>类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N sizeof(T)</span></span><br><span class="line"><span class="type">char</span> buf[N];</span><br><span class="line">T obj;  <span class="comment">///&lt; obj initialized to its original value</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;obj, N);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;obj, buf, N);</span><br><span class="line"><span class="comment">/// 保持它的原始值</span></span><br></pre></td></tr></table></figure><ul><li><code>goto</code>语句. 你可能知道，通过goto从一个一些变量还没有在这个作用域中定义的点跳转到一个已经定义的点是非法的（编译器会报错）。这个限制应用在只有当这个变量是一个<code>non-POD</code>类型。看下面例子中<code>f()</code>是语义错误, <code>g()</code>则符合语义。注意，微软编译器在这条规则上特别松散，它在这两个情况下只是抛出一个警告。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">NonPOD</span> &#123;<span class="built_in">NonPOD</span>()&#123;&#125;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  NonPOD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">POD</span>&#123;<span class="type">int</span> i; <span class="type">char</span> c;&#125;;</span><br><span class="line">  <span class="keyword">goto</span> label;</span><br><span class="line">  POD x;</span><br><span class="line">label:</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它保证了在<code>POD</code>对象的开始处没有内存填充位。其他情况下，假如一个<code>POD-class： A</code>使一个类型<code>T</code>的第一个成员，你可以安全的使用<code>reinterpret_cast</code>从<code>A*</code>到<code>T*</code>然后获取指向第一个成员的指针，反之亦然。</li></ul><h3 id="补充定义"><a href="#补充定义" class="headerlink" title="补充定义"></a>补充定义</h3><h4 id="标量类型-scalar-type"><a href="#标量类型-scalar-type" class="headerlink" title="标量类型(scalar type)"></a>标量类型(<code>scalar type</code>)</h4><p><code>scalar type</code>是一个不是数组类型或<code>class</code>类型的(可能<code>const</code>或<code>volatile</code>限定的[^2])<code>object</code>类型.<br>英文原文[^1]</p><blockquote><p>scalar types are (possibly cv-qualified) object types that are not array types or class types</p></blockquote><h4 id="聚合类型-aggregate-type"><a href="#聚合类型-aggregate-type" class="headerlink" title="聚合类型(aggregate type)"></a>聚合类型(<code>aggregate type</code>)</h4><p>首先介绍一下<code>聚合类型</code>:<br>聚合类型是以下类型的其中一种[^3]:</p><ul><li>数组类型</li><li><code>class</code>类型(典型的例子, <code>struct</code>, <code>union</code>):<ul><li>没有<code>private</code>和<code>protected</code>非静态数据成员(到C++11)</li><li>没有用户定义的构造函数(显式的默认或删除的构造函数) (C++11起, 到C++17)</li><li>没有用户提供的继承的或显式的构造函数(显式的默认或删除的构造函数)(C++17起，到C++20)</li><li>没有用户定义的或继承的构造函数(C++20起)</li><li>没有基类(C++17之前)， 没有<code>virtual</code>,<code>private</code>,<code>protected</code>基类(C++17起)</li><li>没有虚成员函数</li><li>没有默认成员的初始化器(从C++11到C++14)</li></ul></li></ul><h4 id="平凡类型-TrivialType"><a href="#平凡类型-TrivialType" class="headerlink" title="平凡类型 (TrivialType)"></a>平凡类型 (<code>TrivialType</code>)</h4><p>要求[^4]:</p><ul><li>可平凡复制(<code>TrivialCopyable</code>)</li><li>若该类型是类类型或其数组，则该类拥有一个或多个合格的默认构造函数，均为平凡的</li></ul><h4 id="可平凡可复制-Trivially-Copyable"><a href="#可平凡可复制-Trivially-Copyable" class="headerlink" title="可平凡可复制(Trivially Copyable)"></a>可平凡可复制(<code>Trivially Copyable</code>)</h4><p>下面列举的类型称作平凡可复制类型[^5]:</p><ul><li>标量类型</li><li>平凡可复制的类<ul><li>至少有一个拷贝构造函数，移动构造函数，拷贝赋值符是符合要求的</li><li>每个合格的拷贝构造函数(假如有的话)是平凡的</li><li>每个合格的移动构造函数(假如有的话)是平凡的</li><li>每个合格的拷贝赋值符(假如有的话)是平凡的</li><li>每个合格的移动赋值符(假如有的话)是平凡的</li><li>有一个平凡的没有被删除的析构函数</li></ul></li><li>可平凡复制的数组类型<br>这意味着一个平凡可拷贝的<code>class</code>没有虚函数和虚基类函数。</li></ul><h3 id="参考文献和扩展阅读"><a href="#参考文献和扩展阅读" class="headerlink" title="参考文献和扩展阅读"></a>参考文献和扩展阅读</h3><p>[^1]:<a href="https://stackoverflow.com/questions/14821936/what-is-a-scalar-object-in-c">What is a scalar Object in C++?</a></p><p>[^2]:<a href="https://stackoverflow.com/questions/15413037/what-does-cv-unqualified-mean-in-c">What does “cv-unqualified” mean in C++?</a>, <a href="https://en.cppreference.com/w/cpp/language/cv">cv (const and volatile) type qualifiers</a></p><p>[^3]:<a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">C++ standard: aggregate type</a></p><p>[^4]:<a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">C++ standard: C++ named requirements: TrivialType</a></p><p>[^5]: <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">C++ standard: C++ named requirements: TriviallyCopyable</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 观察者设计模式</title>
      <link href="/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/21/2020-12-16-C++%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subscriber</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;subscriber&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">subscriber</span>(<span class="type">const</span> std::string&amp; user_name) : <span class="built_in">user_name_</span>(user_name) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; user_name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string user_name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">boardcast</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">      <span class="keyword">auto</span> sp = it-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sp) &#123;</span><br><span class="line">        sp-&gt;<span class="built_in">callback</span>(message);</span><br><span class="line">        it++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">regist</span><span class="params">(std::weak_ptr&lt;subscriber&gt; wp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(wp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::weak_ptr&lt;subscriber&gt;&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ob = std::<span class="built_in">make_shared</span>&lt;observer&gt;();</span><br><span class="line">  <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber1&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp1-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  <span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber2&quot;</span>);</span><br><span class="line">  ob-&gt;<span class="built_in">regist</span>(sp2-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> sp3 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber3&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp3-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    <span class="keyword">auto</span> sp4 = std::<span class="built_in">make_shared</span>&lt;subscriber&gt; (<span class="string">&quot;subscriber4&quot;</span>);</span><br><span class="line">    ob-&gt;<span class="built_in">regist</span>(sp4-&gt;<span class="built_in">weak_from_this</span>());</span><br><span class="line">    ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;start boardcast!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ob-&gt;<span class="built_in">boardcast</span>(<span class="string">&quot;boardcast again!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 指针与引用</title>
      <link href="/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
      <url>/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-指针与引用"><a href="#C-指针与引用" class="headerlink" title="C++指针与引用"></a>C++指针与引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>可以为空（万恶之首）</li><li>可以做指针的偏移操作</li><li>可以用做修改一个变量</li><li>可以用来用来快速传递一个对象，没有复制的成本(只有指针复制的成本)<br>见下面代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* i)</span> </span>&#123;</span><br><span class="line">  *i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">f1</span>(&amp;num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num为2</span></span><br><span class="line">  <span class="built_in">f2</span>(num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num仍为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>引用同指针一样可以直接修改对象本身，减少传递对象的复制成本</li><li>引用不可为空，即创建必须初始化</li><li>引用不能同指针一样，进行四则运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> &amp;r = i;</span><br><span class="line">  r = <span class="number">1</span>;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为1</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为1</span></span><br><span class="line">  <span class="built_in">f1</span>(r);</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为100</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可见<a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(2)</title>
      <link href="/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
      <url>/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="《Effective-Modern-C-》读书笔记-2"><a href="#《Effective-Modern-C-》读书笔记-2" class="headerlink" title="《Effective Modern C++》读书笔记(2)"></a>《Effective Modern C++》读书笔记(2)</h1><ol><li><p>裸指针在声明中并没有指出，裸指针指涉到的是单个对象还是一个数组。</p></li><li><p>裸指针在声明中也没有提示在使用完指涉到的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象。</p></li><li><p>即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用<code>delete</code>运算符，还是有其他用途。</p></li><li><p>即使知道了使用<code>delete</code>运算符，还是会发生到底应该用的那个对象形式（<code>delete</code>）还是数组形式（<code>delete[]</code>）。</p></li><li><p>即启用够确信，指针拥有其指涉对象，并且也确知应该如何析构，要保证析构在所有代码路径上都仅执行一次（包括那些异常导致的路径）仍然困难重重。只要少在一条路径上执行，就会导致资源泄露。而如果析构在一条路径上执行了多次，则会导致未定义行为。</p></li><li><p>没有什么正规的方式能检测出指针是否空悬，也就是说，它指涉的内存是否已经不再持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然指涉到它，就会产生空悬指针。</p></li></ol><p>在创建对象时注意区分<code>()</code>和<code>&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;  <span class="comment">///&lt; 调用默认构造函数</span></span><br><span class="line">Widget w2 = w1; <span class="comment">///&lt; 调用复制构造函数</span></span><br><span class="line">w1 = w2;  <span class="comment">///&lt; 赋值运算符</span></span><br></pre></td></tr></table></figure><p>大括号可以用来为非静态成员指定默认初始化值，却不能使用小括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 不可行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不可复制的对象可以采用大括号和小括号来进行初始化，却不能使用<code>=</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">///&lt; 不可行</span></span><br></pre></td></tr></table></figure><p>大括号适用所有场合。<br>大括号初始化有一项新特性，就是它禁止内建型别之间进行隐式窄化型别转换。而采用小括号和<code>=</code>的初始化则不会进行窄化型别转换检查，因为如果那样的化就会破坏太多的遗留代码了。</p><p>大括号初始化的另一项值得一提的特征是，它对于C++最令人苦恼之解析语法免疫。C++规定：任何能够解析为声明的都要解析为声明。本来想要以默认方式构造一个对象，结果却一不小心声明了一个函数。这个错误的根本原因构造函数调用语法。<br>当你想要以传参的方式调用构造函数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">///&lt; 调用Widget的构造函数，传入形参10</span></span><br></pre></td></tr></table></figure><p>但你如果试图用相同的语法构造一个没有形参的Widget的话，结果却变成了声明了一个函数而非对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;  <span class="comment">///&lt; 最令人苦恼之解析语法现身</span></span><br></pre></td></tr></table></figure><p>由于函数声明不能使用大括号来指定形参列表，所以使用大括号来完成对象的默认构造上面这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;  <span class="comment">///&lt; 调用没有形参的Widget构造函数</span></span><br></pre></td></tr></table></figure><p>大括号初始化的缺陷在于伴随它有时会出现的意外行为。这种行为源于大括号初始化物、<code>std::initializer_list</code>以及构造函数重载决议之间的纠结。</p><p>如果一个或多个构造函数声明了任何一个具备<code>std::initializer_list</code>型别的形参那么采用了大括号初始化语法的调用语句会强烈地优先选用带有<code>std::initializer_list</code>型别形参的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;  <span class="comment">///&lt; 调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;  <span class="comment">///&lt; 使用最后一个构造函数, 10, true 被强制转化为long double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你的确想要调用一个带有<code>std::initializer_list</code>型别形参的构造函数，并传入一个空的<code>std::initializer_list</code>的话，你可以通过把空大括号对作为构造函数实参的方式实现这个目的，即把一对空大括号放入一对小括号或大括号的方式来清楚地表明你传递地是什么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;  <span class="comment">///&lt; 带有std::initializer_list型别形参地构造函数</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;  <span class="comment">///&lt; 同上</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有十个元素，每个元素值都为20的vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有两个元素，值分别为10、20 的vector</span></span><br></pre></td></tr></table></figure><p><code>std::make_unique</code>和<code>std::make_shared</code>在函数内部使用的小括号，作为其接口的一部分。</p><ul><li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫</li><li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有<code>std::initializer_list</code>型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个<code>std::vector&lt;数值型别&gt;</code>对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li></ul><h2 id="理解特种成员函数的生成机制"><a href="#理解特种成员函数的生成机制" class="headerlink" title="理解特种成员函数的生成机制"></a>理解特种成员函数的生成机制</h2><p>两种复制操作是彼此独立的：声明了其中一个，并不会阻止编译器生成另外一个。如果你生成了一个复制构造函数，同时未声明复制赋值运算符，并撰写了要求复制赋值的代码，则编译器会为你生成复制赋值运算符。反过来一样。</p><p>两种移动操作并不彼此独立：声明了其中一个就会阻止编译器生成另外一个。假设你声明了一个移动构造函数，你实际上表明了移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。综上声明一个移动构造函数会阻止编译器去生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器去生成移动构造函数。</p><p>一旦显式声明了赋值操作，这个类也就不再会生成移动操作了。依据在于，声明复制操作的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。从而判定既然按成员复制不适用于赋值操作，则按成员移动极有可能也不适用于移动操作。<br>一旦声明了移动操作，编译器就会删除复制操作。</p><p>三大律：如果你声明了复制构造函数、复制复制运算符，或析构函数中的任何一个，你就得同时声明所有这三个。<br>如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：1. 在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行。 2. 该类的析构函数也会参与到该资源的管理之中。</p><p>大三律的一个推论是，如果存在用户声明的析构函数，则平凡的按成员赋值也不适用于该类。如果声明了析构函数，则复制操作就不该被自动生成，因为他们呢的行为不可能正确。所以在C++11中：只要用户声明了析构函数，就不会生成移动操作。</p><p>移动操作的生成条件（如果需要生成）仅当以下三者同时成立：</p><ul><li>该类未声明任何复制操作</li><li>该类未声明任何移动操作</li><li>该类未声明任何析构操作</li></ul><p>总而言之， C++11中， 支配特种成员函数的机制如下：</p><ul><li>默认构造函数： 仅当类中不包含用户声明的构造函数时才生成</li><li>析构函数：与C++98中基本相同，唯一的区别在于析构函数默认为<code>noexcept</code>.仅当基类的析构函数为虚的，派生类析构函数才是虚的。</li><li>复制构造函数： 按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。</li><li>移动构造函数和移动赋值运算符<br>都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</li></ul><p>成员函数模板的存在会阻止编译器生成任何特种成员函数。</p><ul><li><p>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成</p></li><li><p>复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数时才生成，复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</p></li><li><p>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</p></li><li><p>auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别少打一些字</p></li><li><p>在模板推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</p></li><li><p>对万能引用形参进行推导时，左值实参会进行特殊处理。</p></li><li><p>对按值传递的形参进行推导时，若实参型别中带有<code>const</code>或<code>volatile</code>饰词，则它们还是会被当作不带<code>const</code>或<code>volatile</code>饰词的型别来处理。</p></li><li><p>在模板型别推导过程中， 数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</p></li><li><p>在一般情况下，auto型别推导和模板型推导是一模一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>, 但模板型别推导却不会。</p></li><li><p>在函数返回值或lambda式的形参中使用auto， 意思是使用模板型别推导而非auto型推导。</p></li><li><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的型别而不做任何修改</p></li><li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，<code>decltype</code>总是得出型别<code>T&amp;</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ nullptr与NULL</title>
      <link href="/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/"/>
      <url>/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/</url>
      
        <content type="html"><![CDATA[<h1 id="NULL与nullptr的区别"><a href="#NULL与nullptr的区别" class="headerlink" title="NULL与nullptr的区别"></a>NULL与nullptr的区别</h1><p>NULL为宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure><p>NULL的类型不明显，而一下情况会出现函数重载不明确的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用函数不确定，编译器警告或报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>nullptr</code>是一个特殊类型(<code>nullptr_t</code>)专门用来指代空指针。见下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;  <span class="comment">///&lt; #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125; <span class="comment">///&lt; #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 明确调用#2函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记(1)</title>
      <link href="/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/"/>
      <url>/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/</url>
      
        <content type="html"><![CDATA[<h1 id="《Effective-Modern-C-》读书笔记-1"><a href="#《Effective-Modern-C-》读书笔记-1" class="headerlink" title="《Effective Modern C++》读书笔记(1)"></a>《Effective Modern C++》读书笔记(1)</h1><p>在运行期， <code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>(); <span class="comment">///&lt; 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; 非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span>  <span class="comment">///&lt; 右值引用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span> <span class="comment">///&lt; 非右值引用</span></span></span><br></pre></td></tr></table></figure><p><code>T&amp;&amp;</code>有两种不同的含义</p><ol><li>右值引用</li><li>表示既可以是右值引用也可以是左值引用</li></ol><p>万能引用会在两个地方现身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">///&lt; param是个万能引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; var2是个万能引用</span></span><br></pre></td></tr></table></figure><p>而不涉及型别推导<code>&amp;&amp;</code>就是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 不涉及型别推导</span></span><br></pre></td></tr></table></figure><p><code>const</code>关键字也可以确定<code>const T&amp;&amp;</code>是右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>在一个模板中的<code>T&amp;&amp;</code>也不一定是万能引用， 见下面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为<code>push_back</code>是<code>vector</code>的成员函数， 如果<code>vector</code>实例存在的话就一定有确定的类型，所以并不存在型别推导。</p><p>另外，声明<code>auto&amp;&amp;</code>都是万能引用。</p><p>针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></p><p>当转发右值引用给其他函数是，应当对其实施向右值的无条件强制型别转换(通过<code>std::move</code>)，因为它们一定绑定到右值，而当转发万能引用时，应当对其实施向右值的有条件强制型别转换(通过<code>std::forward</code>), 因为它们不一定绑定到右值。<br>应当避免针对右值引用实施<code>std::forward</code>。而另一方面，针对万能引用使用<code>std::move</code>的想法更为糟糕，因为那样做的后果是某些左值会遭到意外改动(例如某些临时变量)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(newName);  <span class="comment">///&lt; 可以编译但糟糕透顶</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;  <span class="comment">///&lt; 工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>(); <span class="comment">///&lt; n是个局部变量</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">setName</span>(n); <span class="comment">///&lt; 将n移入了w</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">///&lt; n的值变得未知了</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ... <span class="comment">///&lt; 对w进行操作</span></span><br><span class="line">  <span class="keyword">return</span> w; <span class="comment">///&lt; 没有任何东西被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(w);  <span class="comment">///&lt; 将w移入返回值, 千万不要这么做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RVO</code>(return value optimization): 编译器若要在一个按值返回的函数里省略对局部对象的复制（或者移动）, 则需要满足两个前提条件： 1. 局部对象型别和函数返回值型别相同. 2. 返回的就是局部对象本身。即使实施<code>RVO</code>的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。当<code>RVO</code>的前提条件允许时，要么发生复制省略，要么<code>std::move</code>隐式地被实施于返回的局部对象。</p><ul><li>针对右值引用的最后一次使用实施<code>std::move</code>, 针对万能引用的最后一次使用实施<code>std::forward</code>。</li><li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行动。</li><li>若局部对象可能适用于返回值优化，则请勿针对其实施<code>std::move</code>或<code>std::forward</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::<span class="built_in">is_integral</span>&lt;T&gt;());  <span class="comment">///&lt; std::is_integral不够正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::is_integral&lt;&gt;</code>不够正确是因为如果传给万能引用<code>name</code>实参是个左值，那么<code>T</code>就会被推导为左值引用。因为<code>int&amp;</code>不是<code>int</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美转发的含义是我们不仅转发对象，还转发其显著特征：型别、左值还是右值，以及是否带有<code>const</code>和<code>volation</code>饰词等等。</p><p>大括号初始化物<br>假设<code>f</code>的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std:vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure><p>在此情况下，以大括号初始化物调用<code>f</code>可以通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>但如果把同一大括号初始化物的运用，就是一种完美转发失败的情形。编译器采用推导的手法来取得传递给<code>fwd</code>实参的型别结果，而后它会比较推导型别结果和<code>f</code>声明的形参型别。完美转发会在下面两个条件中的任何一个成立时失败：</p><ul><li>编译器无法为一个或多个<code>fwd</code>的形参推导出型别结果。编译器无法编译通过。</li><li>编译器为一个或多个<code>fwd</code>的形参推导出了”错误的”型别结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(Widget::MinVals); <span class="comment">///&lt; 没问题, 当f(28)处理</span></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals); <span class="comment">///&lt; 错误，无法链接</span></span><br></pre></td></tr></table></figure><p>无法链接的原因是，完美转发，转发的是入参(<code>Widget::MinVals</code>)的引用，而引用在编译器底层是指针实现的。由于<code>static</code>变量并没有被分配实际的地址，所以产生了链接错误。</p><p>完美转发的失败情形还包括：重载的函数名字和模板名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">///&lt; 一个接受函数指针入参的函数f</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 然后调用</span></span><br><span class="line"><span class="built_in">f</span>(processVal);</span><br></pre></td></tr></table></figure><p>上面在调用函数<code>f</code>的时候，其中<code>processVal</code>仅仅只是函数的名字，但编译器知道匹配的是单入参版本的函数。</p><p>而使用完美转发时，编译器是无法知道使用的是什么版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(processVal);  <span class="comment">///&lt; 编译不过</span></span><br></pre></td></tr></table></figure><p>最后一种完美转发失败的情形是位域被用作函数实参的时候。<br>标准中：非<code>const</code>引用不得绑定到位域。既然没有办法创建指涉到任意比特的指针(C++标准规定，可以指涉的最小实体是单个char)，那自然没有办法把引用绑定到任意比特上了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPV4Header</span> &#123;</span><br><span class="line">  std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">  IHL:<span class="number">4</span>,</span><br><span class="line">  DSCP:<span class="number">6</span>,</span><br><span class="line">  ECN:<span class="number">2</span>,</span><br><span class="line">  totalLength:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength); <span class="comment">///&lt; 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(h.totalLength); <span class="comment">///&lt; 错误！</span></span><br></pre></td></tr></table></figure><p>把位域传递给完美转发函数的关键，就是利用转发目的函数接收的总是位域值的副本这一事实。可以自己复制一份，并以该副本调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"><span class="built_in">fwd</span>(length);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串分割与解析代码学习</title>
      <link href="/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/26328793/how-to-split-string-with-delimiter-using-c">源码链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           把字符串前后的字符串给去除</span></span><br><span class="line"><span class="comment"> * @param           s       [in]    要剪切的字符串</span></span><br><span class="line"><span class="comment"> * @param           chars   [in]    要去除什么的字符串</span></span><br><span class="line"><span class="comment"> * @return          std::string&amp; 剪切后的字符串</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::string&amp; <span class="title">strip</span><span class="params">(std::string&amp; s, <span class="type">const</span> std::string&amp; chars = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(chars.<span class="built_in">c_str</span>()));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(chars.<span class="built_in">c_str</span>()) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           以特定符号为分隔符，切分字符串并放入vector里</span></span><br><span class="line"><span class="comment"> * @param           s           [in]    原字符串</span></span><br><span class="line"><span class="comment"> * @param           tokens      [out]   剪切后的子字符串</span></span><br><span class="line"><span class="comment"> * @param           delimiters  [in]    分隔符</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">const</span> std::string&amp; s, std::vector&lt;std::string&gt;&amp; tokens,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> std::string&amp; delimiters = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  std::string::size_type lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, <span class="number">0</span>);</span><br><span class="line">  std::string::size_type pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  <span class="keyword">while</span> (std::string::npos != pos || std::string::npos != lastPos) &#123;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">    lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, pos);</span><br><span class="line">    pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">parse</span><span class="params">(std::string&amp; s, std::map&lt;std::string, std::string&gt;&amp; items)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; elements;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &#123;&quot;</span>));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;&#125; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">split</span>(s, elements, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : elements) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; kv;</span><br><span class="line">    <span class="built_in">split</span>(iter, kv, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kv.<span class="built_in">size</span>() != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    items[<span class="built_in">strip</span>(kv[<span class="number">0</span>], <span class="string">&quot; \&quot;&quot;</span>)] = <span class="built_in">strip</span>(kv[<span class="number">1</span>], <span class="string">&quot; \&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string data =</span><br><span class="line">      <span class="string">&quot;  &#123;  \&quot;key1\&quot;  :  \&quot;data1\&quot;  ,  \&quot;key2\&quot;  :  \&quot;data2\&quot;    &#125;  &quot;</span>;</span><br><span class="line">  std::map&lt;std::string, std::string&gt; items;</span><br><span class="line">  <span class="built_in">parse</span>(data, items);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iter:items)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key=&quot;</span> &lt;&lt; iter.first &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; iter.second &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>​<strong>异常处理</strong>（<code>exception handling</code>）机制允许程序独立开发的部分能够在运行时就出现问题<strong>进行通信</strong>并作出<strong>相应的处理</strong>。异常是的我们能够将问题的检测和解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无需知道问题处理模块的所有细节，反之亦然。</p><h2 id="1-抛出异常"><a href="#1-抛出异常" class="headerlink" title="1. 抛出异常"></a>1. 抛出异常</h2><p>​在C++语言中，我们通过<strong>抛出</strong>(<code>throwing</code>)一条表达式来<strong>引发</strong>(<code>raised</code>)一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段<strong>处理代码</strong>(<code>handler</code>)将被用来处理该异常。被选中的处理代码实在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分会告知异常处理部分到底发生了什么错误。</p><p>​当执行一个<code>throw</code>时，跟在<code>throw</code>后面的语句将不再被执行。相反，程序的控制权从<code>throw</code>转移到与之匹配的<code>catch</code>模块。该<code>catch</code><strong>可能是同一函数中</strong>的局部<code>catch</code>，<strong>也可能位于直接或间接调用了发生异常的函数的另一个函数中</strong>。控制权从一处转移到另一处，这有两个重要的含义：</p><ul><li><strong>沿着调用链的函数可能会提早退出</strong>。</li><li><strong>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁</strong>。</li></ul><p>因为跟在<code>throw</code>后面的语句将不再被执行，所以<code>throw</code>语句的有类似于<code>return</code>语句：它通常作为条件语句的一部分或者作为某个函数的最后(或者唯一)一条语句。</p><h3 id="1-1-栈展开"><a href="#1-1-栈展开" class="headerlink" title="1.1 栈展开"></a>1.1 栈展开</h3><p>​<strong>当抛出一个异常后</strong>，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的<code>catch</code>子句。</p><ul><li><p>当<code>throw</code>出现在一个<strong>try语句块</strong>(<code>try block</code>)内时，检查与该<code>try</code>块关联的<code>catch</code>子句。</p></li><li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p></li><li><p>如果这一步<strong>没找到匹配</strong>的<code>catch</code><strong>且该<code>try</code>语句嵌套在其他<code>try</code>块中</strong>，则<strong>继续检查与外层<code>try</code>匹配的<code>catch</code>子句</strong>。</p></li><li><p>如果<strong>还是找不到匹配</strong>的<code>catch</code>，则<strong>退出当前函数</strong>，在调<strong>用当前函数的外层函数中</strong>继续寻找。</p></li><li><p>如果对抛出异常的函数的调用语句位于一个<code>try</code>语句块内，则检查与该<code>try</code>块关联的<code>catch</code>子句。</p></li><li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p></li><li><p>否则，如果该<code>try</code>语句嵌套在其他<code>try</code>块中，则继续检查与外层<code>try</code>匹配的<code>catch</code>子句。</p></li><li><p>如果仍然没找到匹配的<code>catch</code>，则退出当前这个主调函数，继续在调用刚刚退出的这个函数的其他函数中寻找，以此类推。</p></li></ul><p>​上述过程被称为<strong>栈展开</strong>(<code>stack unwinding</code>)过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的<code>catch</code>子句为止；或者也可能一致没找到匹配的<code>catch</code>，则退出主函数后过程中止。</p><p>​假设找到了一个匹配的<code>catch</code>子句，则程序进入该子句并执行其中代码。当执行完这个<code>catch</code>子句后，找到与<code>try</code>块关联的最后一个<code>catch</code>子句后的点，并从这里继续执行。</p><p>​<strong>如果没有找到匹配的<code>catch</code>子句，程序将退出</strong>。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的<code>catch</code>时，程序将调用标准库函数<code>terminate</code>，顾名思义，<code>terminate</code>负责中止程序的执行过程。</p><h3 id="1-2-栈展开过程中对象被自动销毁"><a href="#1-2-栈展开过程中对象被自动销毁" class="headerlink" title="1.2 栈展开过程中对象被自动销毁"></a>1.2 栈展开过程中对象被自动销毁</h3><p>​在栈展开过程中，位于调用链上的语句块可能会提前退出。如果在<strong>栈展开过程中</strong>退出了某个块，编译器将负责确保在这个块中<strong>创建的对象都能被正确的销毁</strong>。如果某个局部对象的类型是<strong>类类型</strong>，则<strong>该对象的析构函数将被自动调用</strong>。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。</p><p>​如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经开始初始化了，而另外一些成员在异常发生前也许还没有开始初始化。即使某个对象只构造了一部分，我们也要<strong>确保构造的成员能被正确的销毁</strong>（否则会发生内存泄露）。</p><p>​类似的，异常也可能发生在<strong>数组</strong>或<strong>标准库容器的元素初始化过程</strong>中。与之前类似，如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确的销毁。</p><h3 id="1-3-析构函数与异常"><a href="#1-3-析构函数与异常" class="headerlink" title="1.3 析构函数与异常"></a>1.3 析构函数与异常</h3><p>​析构函数总是会被执行的，但是函数中负责释放资源的代码却可能会被跳过。如果一个块分配了资源，并且在<strong>负责释放这些资源的代码前面发生了异常</strong>，则释放资源的代码将<strong>不会被执行</strong>。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。（<code>RAII</code>的思想，在构造函数中获取资源(i.e <code>new</code>)，在析构函数中释放资源(i.e <code>delete</code>)。）</p><p>​所以出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，<strong>如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理</strong>（如果不这样做的话，程序会马上被终止）。</p><blockquote><p> 注：所有标准库类型都能保证它们的析构函数不会引发异常。</p></blockquote><h3 id="1-4-异常对象"><a href="#1-4-异常对象" class="headerlink" title="1.4 异常对象"></a>1.4 异常对象</h3><p><strong>异常对象</strong>（<code>exception object</code>）是一种特殊的对象，编译器使用<strong>异常抛出表达式</strong>来对<strong>异常对象</strong>进行<strong>拷贝初始化</strong>。因此<code>throw</code>语句中的表达式必须拥有<strong>完整类型</strong>。而且如果该表达式是<strong>类类型</strong>的话，则相应的类必须含有一个<strong>可访问的析构函数</strong>和一个<strong>可访问的拷贝或移动构造函数</strong>。如果该表达式是<strong>数组类型</strong>或<strong>函数类型</strong>，则表达式将被<strong>转换成</strong>与之对应的<strong>指针类型</strong>。</p><p>​异常对象位于有编译器管理的空间中，编译器确保无论调用哪个<code>catch</code>子句都能访问该空间。异常处理完毕后，异常对象被销毁。</p><p>​当一个异常被抛出是，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向<strong>局部对象的指针</strong>几乎肯定是一种<strong>错误</strong>行为。如果指针所指的对象位于某个块中，而该块在<code>catch</code>语句之前就已经退出了，则意味着在执行<code>catch</code>语句之前局部对象已经被销毁了。</p><p>​当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条<code>throw</code>表达式<strong>解引用一个基类指针</strong>，而该指针<strong>实际指向的是派生类对象</strong>，则<strong>抛出的对象将被切掉一部分，只有基类部分被抛出</strong>。</p><blockquote><p>注： 抛出指针要求在任何对应处理代码存在的地方，指针所指的对象都必须存在。</p></blockquote><h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p><code>catch</code>子句（<code>catch clause</code>）中的一场声明（<code>exception declaration</code>）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果<code>catch</code>无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p><p>声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，不能是右值引用。当进入一个<code>catch</code>语句后，入参通过异常对象初始化异常声明中的参数。和函数的参数类似，如果<code>catch</code>的参数类型是非引用类型，则该参数是异常对象的一个副本，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名。</p><p>如果<code>catch</code>的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果<code>catch</code>的参数是非引用类型，则异常对象将被切掉一部分，如果<code>catch</code>的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。</p><p>最后一点需要注意的是，异常声明的静态类型将决定<code>catch</code>语句所能执行的操作。如果<code>catch</code>的参数是基类类型，则<code>catch</code>无法使用派生类特有的任何成员。</p><blockquote><p>Tips: 通常情况下，如果<code>catch</code>接收的异常与某个继承体系有关，则最好将该<code>catch</code>的参数定义成引用类型。</p></blockquote><h3 id="2-1-查找匹配的处理代码"><a href="#2-1-查找匹配的处理代码" class="headerlink" title="2.1 查找匹配的处理代码"></a>2.1 查找匹配的处理代码</h3><p>​在搜寻<code>catch</code>语句的过程中，我们最终找到的<code>catch</code>未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的<code>catch</code>语句。因此，越是专门的<code>catch</code>越应该置于整个<code>catch</code>列表的前端。</p><p>​因为<code>catch</code>语句是按照其出现的顺序逐一匹配的，所以当程序员使用具有继承关系的多个异常时必须对<code>catch</code>语句的顺序进行组织管理，是的派生类异常的处理代码出现在基类异常的处理代码异常之前。</p><p>​与实参和形参的匹配规则相比，异常和<code>catch</code>异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和<code>catch</code>声明的类型时精确匹配的：</p><ul><li>允许从非常量的类型转换，也就是说一条非常量对象的<code>throw</code>语句可以匹配一个接受常量引用的<code>catch</code>语句</li><li>允许从派生类向基类的类型转换。</li><li>数组被转换成指向数组（元素）类型的指针，函数被转化成指向该函数类型的指针。</li></ul><p>除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用。</p><blockquote><p>如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最低端的类（<code>most derived type</code>）放在前面，而将继承链最顶端的类（<code>least derived type</code>）放在后面。</p></blockquote><h3 id="2-2-重新抛出"><a href="#2-2-重新抛出" class="headerlink" title="2.2 重新抛出"></a>2.2 重新抛出</h3><p>​一个单独的<code>catch</code>语句不能完整的处理某个异常。在执行了某些校正操作之后，当前的<code>catch</code>可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出的操作将异常传递给另外一个<code>catch</code>语句。这里的重新抛出仍然是一条<code>throw</code>语句，只不过不包含任何表达式: <code>throw;</code></p><p>​空的<code>throw</code>语句只能出现在<code>catch</code>语句或<code>catch</code>语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空<code>throw</code>语句，编译器将调用<code>terminate</code>。</p><p>​一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。</p><p>​很多时候，catch语句会改变其参数内容。如果在改变了参数的内容后catch语句重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所作的改变才会被保留并继续传播。</p><h3 id="2-3-捕获所有异常的处理代码"><a href="#2-3-捕获所有异常的处理代码" class="headerlink" title="2.3 捕获所有异常的处理代码"></a>2.3 捕获所有异常的处理代码</h3><p>​为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常的处理代码，形如<code>catch(...)</code>.</p><p>​<code>catch(...)</code>通常与重新抛出语句一起使用，其中<code>catch</code>执行当前局部能完成的工作，随后重新抛出异常。</p><blockquote><p>Tips: 如果<code>catch(...)</code>与其他几个<code>catch</code>语句一起出现，则<code>catch(...)</code>必须在最后的位置。出现在捕获所有一场语句后面的<code>catch</code>语句将永远不会被匹配。</p></blockquote><h2 id="3-函数try语句块与构造函数"><a href="#3-函数try语句块与构造函数" class="headerlink" title="3. 函数try语句块与构造函数"></a>3. 函数try语句块与构造函数</h2><p>​通常情况下，程序执行的任何时刻都可能发生异常，特别是一场可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的<code>try</code>语句块还未生效，所以构造函数体内的<code>catch</code>语句无法处理构造函数初始值列表抛出的异常。</p><p>​要想处理构造函数初始值抛出的异常，我们必须将构造函数写成<strong>函数try语句块</strong>（<code>function try block</code>）的形式。函数<code>try</code>语句使得一组<code>catch</code>语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"> : <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;<span class="comment">/** ... */</span>&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">handle_out_of_memory</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-noexcept-异常说明"><a href="#4-noexcept-异常说明" class="headerlink" title="4. noexcept 异常说明"></a>4. noexcept 异常说明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span></span>;           <span class="comment">/** 可能会抛出异常 */</span></span><br></pre></td></tr></table></figure><ul><li><p>对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数应该在函数的尾置返回类型之前。</p></li><li><p>我们也可以在函数指针的声明和定义中指定<code>noexcept</code>。</p></li><li><p>在typedef或类型别名中则不能出现<code>noexcept</code>。</p></li><li><p>在成员函数中，<code>noexcept</code>说明符需要跟在<code>const</code>及引用限定符之后，而在<code>final</code>、<code>override</code>或虚函数<code>=0</code>之前。</p></li></ul><h3 id="4-1-违反异常说明"><a href="#4-1-违反异常说明" class="headerlink" title="4.1 违反异常说明"></a>4.1 违反异常说明</h3><p>​编译器并不会在编译时检查<code>noexcept</code>说明。实际上，如果一个函数说明了<code>noexcept</code>的同时又含有<code>throw</code>语句或者调用了可能抛出异常的其他函数，编译器将顺利通过，并不会因为这种违反异常说明的情况而报错。</p><p>​因此可能会出现一种情况：尽管函数说明了它不会抛出异常，但实际上还是抛出了。一旦一个<code>noexcept</code>函数抛出异常，程序就会调用<code>terminate</code>以确保遵守不在运行时抛出异常的承诺。</p><p>​上述过程是执行栈展开未作约定，因此<code>noexcept</code>可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。</p><h3 id="4-2-noexcept运算符"><a href="#4-2-noexcept运算符" class="headerlink" title="4.2 noexcept运算符"></a>4.2 noexcept运算符</h3><p>​<code>noexcept</code>说明符接受一个可选实参，该实参必须能转换为<code>bool</code>类型：如果实参是<code>true</code>，则函数不会抛出异常；如果实参是<code>false</code>，则函数可能抛出异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;<span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;<span class="comment">/** 可能抛出异常 */</span></span><br></pre></td></tr></table></figure><p>​<code>noexcept</code>说明符的实参常常与<code>noexcept</code>运算符混合使用。<code>noexcept</code>运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和<code>sizeof</code>类似，<code>noexcept</code>也不会求其运算对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">noexcept</span>(<span class="built_in">recoup</span>())<span class="comment">/** 如果recoup不跑出异常则结果为true；否则结果为false */</span></span><br><span class="line"><span class="built_in">noexcept</span>(e)<span class="comment">/** 等价于上一句 */</span></span><br></pre></td></tr></table></figure><p>我们可以使用noexcept运算符得到如下的异常说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>;<span class="comment">// f 和 g的异常说明一致</span></span><br></pre></td></tr></table></figure><p>如果函数<code>g()</code>承诺了不会抛出异常，则f也不会抛出异常；如果<code>g()</code>没有异常说明符，或者g虽然有异常说明符但是允许抛出异常，则<code>f()</code>也可能抛出异常。</p><blockquote><p><code>noexcept</code>有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为<code>noexcept</code>异常说明的<code>bool</code>实参出现时，它是一个运算符。</p></blockquote><h3 id="4-3-异常说明与指针、虚函数和拷贝控制"><a href="#4-3-异常说明与指针、虚函数和拷贝控制" class="headerlink" title="4.3 异常说明与指针、虚函数和拷贝控制"></a>4.3 异常说明与指针、虚函数和拷贝控制</h3><p>​<strong>函数指针及该指针所指的函数必须具有一致的异常说明</strong>。也就是说我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以。</p><p>​如果<strong>虚函数</strong>承诺了它<strong>不会抛出异常</strong>，则后续派生出来的<strong>虚函数</strong>也必须做出<strong>同样的承诺</strong>；与之相反如果<strong>基类的虚函数允许抛出异常</strong>，则派<strong>生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。</strong></p><p>​当编译器<strong>合成拷贝控制成员</strong>时，同时也<strong>生成一个异常说明</strong>。如果对<strong>所有成员</strong>和<strong>基类的所有操作</strong>都承诺了不会抛出异常，则合成的成员是<code>noexcept</code>的。如果合成成员调用的<strong>任意一个函数可能抛出异常</strong>，则合成的成员是<code>noexcept(false)</code>。而且如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将于假设有编译器为类合成析构函数时所得的异常说明一致。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20三路比较符</title>
      <link href="/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/"/>
      <url>/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="三路比较符（C-20）"><a href="#三路比较符（C-20）" class="headerlink" title="三路比较符（C++20）"></a>三路比较符（C++20）</h1><p><a href="https://zh.cppreference.com/w/cpp/utility/compare/compare_three_way">官网解释</a></p><p><a href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/">微软技术博客介绍</a></p><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1186r3.html">When do you actually use <code>&lt;=&gt;</code>?</a></p><p>例子1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rational_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> den; <span class="comment">// &gt; 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> std::weak_ordering <span class="built_in">operator</span>&lt;=&gt;(Rational_2 lhs, Rational_2 rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.num * rhs.den &lt;=&gt; rhs.num * lhs.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::weak_ordering value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;equal\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;less\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;greater\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rational_2 c&#123;<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Rational_2 d&#123;<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(c &lt;=&gt; d);</span><br><span class="line">    <span class="built_in">print</span>(std::compare_three_way&#123;&#125;(c,d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basics</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Basics&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">  <span class="type">int</span> ai[<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">2</span>];</span><br><span class="line">  <span class="type">float</span> af[<span class="number">3</span>];</span><br><span class="line">  <span class="type">double</span> ad[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Arrays&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bases</span> : Basics, Arrays &#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Bases&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases a = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases b = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="built_in">static_assert</span>(a == b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a != b));</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &lt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &lt;= b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &gt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &gt;= b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++严格弱序的介绍</title>
      <link href="/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="严格弱序（strict-weak-ordering）"><a href="#严格弱序（strict-weak-ordering）" class="headerlink" title="严格弱序（strict weak ordering）"></a>严格弱序（strict weak ordering）</h1><p>关联式容器（<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>）的排序准则的定义，和std::sort的排序准则定义必须遵守严格弱序，详细描述见官方解释(<a href="/resource/C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/strict_weak_ordering.pdf">strict weak ordering.pdf</a>)。</p><p><strong>严格弱序的定义</strong>：</p><p><strong>简单的来说就是a&lt;b返回true，a&#x3D;b和a&gt;b返回false。</strong></p><p>详细定义：</p><blockquote><ol><li><p>必须是<strong>非对称的</strong>（antisymmetric）。</p><p> 对<code>operator&lt; </code>而言， 如果x &lt; y为true， 则y &lt; x为false。</p><p> 对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true，则op(y, x)为false。</p></li><li><p>必须是<strong>可传递的</strong>（transitive）。</p></li></ol><p>  对<code>operator&lt; </code>而言，如果x &lt; y 为true且y &lt; z为true， 则x &lt; z 为false。</p><p>  对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true且op(y, z)为tru，则op(x, z)为true。</p><ol start="3"><li><p>必须是<strong>非自反的</strong>（irreflexive）</p><p> 对<code>operator&lt; </code>而言，x &lt; x 永远是false</p><p> 对判断式(predicate) <code>op()</code>而言，op(x, x)永远是false。</p></li><li><p>必须有<strong>等效传递性</strong>（transitivity of equivalence）</p></li></ol><p>对<code>operator&lt; </code>而言，假如 !(a&lt;b) &amp;&amp; !(b&lt;a) 为true且 !(b&lt;c) &amp;&amp; !(c&lt;b) 为 true<br>那么!(a&lt;c) &amp;&amp; !(c&lt;a) 也为true.<br>对判断式(predicate) <code>op()</code>而言， 假如 op(a,b), op(b,a), op(b,c), 和op(c,b) 都为<br>false, 那么op(a,c) and op(c,a) 也为false.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个定义std::set&lt;struct&gt;的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ORDERING_EXAMPLE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 重载遵循严格弱序的运算符&lt;</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> ORDERING_EXAMPLE&amp; OtherStruct) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;x &lt; OtherStruct.x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.x &lt; <span class="keyword">this</span>-&gt;x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x == x则比较y</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;y &lt; OtherStruct.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.y &lt; <span class="keyword">this</span>-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// y == y则比较z</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;z &lt; OtherStruct.z)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;ORDERING_EXAMPLE&gt; setOrderingExample;</span><br><span class="line"></span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample0 = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample1 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample3 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample0);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample1);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample2);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面举一个会崩溃的例子对二维数组排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">5</span>, temp);</span><br><span class="line">  std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;l, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;r) &#123;</span><br><span class="line">              <span class="keyword">if</span> (l.<span class="built_in">size</span>() == r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; l.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (l.<span class="built_in">at</span>(i) == r.<span class="built_in">at</span>(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> l.<span class="built_in">at</span>(i) &lt; r.<span class="built_in">at</span>(i);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/// 这里会崩溃，改为false则不会而不会崩溃(遵循严格弱序)</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> l.<span class="built_in">size</span>() &lt; r.<span class="built_in">size</span>();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个参数的重载符号简单示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于乘法溢出的判断</title>
      <link href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先我们对于乘法溢出的判断，先写测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715337389.png" alt="1592715337389"></p><p>由上图我们简化测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715602260.png" alt="1592715602260"></p><p>我们可以这样设计乘法溢出函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们添加测试用例</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727579022.png" alt="1592727579022"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来为特殊数值来添加判断：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727736048.png" alt="1592727736048"></p><p>添加异号情况的判断：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730284047.png" alt="1592730284047"></p><p>把函数改为模板，一并添加测试用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_multi_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot; is_multi_overflow need integral type!&quot;</span>);</span><br><span class="line">  <span class="type">int</span> num_max = std::numeric_limits&lt;T1&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> num_min = std::numeric_limits&lt;T1&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">1</span> || y == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y == num_min;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x == num_min;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; num_max / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == num_min &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / -y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 3</span></span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 4</span></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = INT_MIN;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 5</span></span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = min_num;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 6</span></span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后附上完整测试用例：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730393076.png" alt="1592730393076"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我们既然有了判断乘法溢出的函数，我们可以借此封装一个带有检查溢出的乘法函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">std::optional&lt;T1&gt; <span class="title">multiplies_s</span><span class="params">(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value, <span class="string">&quot;Multiplies_s need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;Multiplies_s need integral type!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_multi_overflow</span>(x, y)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">multiplies_s</span>(x, y).<span class="built_in">value_or</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于虚析构函数</title>
      <link href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="虚析构函数问题"><a href="#虚析构函数问题" class="headerlink" title="虚析构函数问题"></a>虚析构函数问题</h2><blockquote><p>引用标准中原文：  一条有用的方针，是任何基类的析构函数必须为公开且虚， 或受保护且非虚。</p></blockquote><p>虚析构这个概念被设计出来就是<strong>为了解决基类指针指向派生类实例的析构问题</strong>，当一个基类指针指向派生类实例然后进行delete该指针时，只会执行基类析构函数而派生类的析构函数不会被执行，这将导致派生类构造的资源不会被正确释放，造成内存泄漏。如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/// 该析构函数为错误示例，严禁这样写.</span></span><br><span class="line">     ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug.png" alt="Virtual DeConstruct Debug"></p><p>可以看到派生类没有被析构，如要解决该问题在基类析构函数处加上<strong>virtual</strong>关键字即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/** 正确写法： 加上关键字virtual， 后面函数体可写可不写，或者直接使用=default都行。 */</span></span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">/// 或者 virtual ~Derived() override &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug_Correct.png" alt="Virtual DeConstruct Debug Correct"></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PlantUML语法学习</title>
      <link href="/2020/07/02/2020-07-02-PlantUML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/02/2020-07-02-PlantUML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="PlantUML语法学习"><a href="#PlantUML语法学习" class="headerlink" title="PlantUML语法学习"></a>PlantUML语法学习</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>类之间的关系通过下面的符号定义:</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_20-38-31.png" alt="类之间的关系"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class01 &lt;|-- Class02</span><br><span class="line">Class03 *-- Class04</span><br><span class="line">Class05 o-- Class06</span><br><span class="line">Class07 .. Class08</span><br><span class="line">Class09 -- Class10</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_1.png" alt="class1"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class11 &lt;|.. Class12</span><br><span class="line">Class13 --&gt; Class14</span><br><span class="line">Class15 ..&gt; Class16</span><br><span class="line">Class17 ..|&gt; Class18</span><br><span class="line">Class19 &lt;--* Class20</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_2.png" alt="class2"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class21 #-- Class22</span><br><span class="line">Class23 x-- Class24</span><br><span class="line">Class25 &#125;-- Class26</span><br><span class="line">Class27 +-- Class28</span><br><span class="line">Class29 ^-- Class30</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_3.png" alt="class3"></p><h3 id="关系上的标识"><a href="#关系上的标识" class="headerlink" title="关系上的标识"></a>关系上的标识</h3><p>在关系之间使用标签来说明时, 使用: 后接标签文字。<br>对元素的说明，你可以在每一边使用”” 来说明.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Class01 &quot;1&quot; *-- &quot;many&quot; Class02 : contains</span><br><span class="line">Class03 o-- Class04 : aggregation</span><br><span class="line">Class05 --&gt; &quot;1&quot; Class06</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_4.png" alt="class4"></p><p>在标签的开始或结束位置添加&lt; 或&gt; 以表明是哪个对象作用到哪个对象上。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Car</span><br><span class="line">Driver - Car : drives &gt;</span><br><span class="line">Car *- Wheel : have 4 &gt;</span><br><span class="line">Car -- Person : &lt; owns</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_5.png" alt="class5"></p><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>为了声明字段(对象属性）或者方法，你可以使用后接字段名或方法名。<br>系统检查是否有括号来判断是方法还是字段。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Object &lt;|-- ArrayList</span><br><span class="line">Object : equals()</span><br><span class="line">ArrayList : Object[] elementData</span><br><span class="line">ArrayList : size()</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_6.png" alt="class6"></p><p>也可以使用{} 把字段或者方法括起来<br>注意，这种语法对于类型&#x2F;名字的顺序是非常灵活的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">String data</span><br><span class="line">void methods()</span><br><span class="line">&#125;</span><br><span class="line">class Flight &#123;</span><br><span class="line">flightNumber : Integer</span><br><span class="line">departureTime : Date</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_7.png" alt="class7"></p><p>你可以（显式地）使用{field} 和{method} 修饰符来覆盖解析器的对于字段和方法的默认行为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">&#123;field&#125; A field (despite parentheses)</span><br><span class="line">&#123;method&#125; Some method</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_8.png" alt="class8"></p><h3 id="定义可访问性"><a href="#定义可访问性" class="headerlink" title="定义可访问性"></a>定义可访问性</h3><p>一旦你定义了域或者方法，你可以定义相应条目的可访问性质。<br><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_20-55-15.png" alt="定义可访问性"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">-field1</span><br><span class="line">#field2</span><br><span class="line">~method1()</span><br><span class="line">+method2()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_9.png" alt="class9"></p><p>你可以采用命令（skinparam classAttributeIconSize 0 ：)停用该特性</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam classAttributeIconSize 0</span><br><span class="line">class Dummy &#123;</span><br><span class="line">-field1</span><br><span class="line">#field2</span><br><span class="line">~method1()</span><br><span class="line">+method2()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_10.png" alt="class10"></p><h3 id="抽象与静态"><a href="#抽象与静态" class="headerlink" title="抽象与静态"></a>抽象与静态</h3><p>通过修饰符{static} 或者{abstract}，可以定义静态或者抽象的方法或者属性。<br>这些修饰符可以写在行的开始或者结束。也可以使用{classifier} 这个修饰符来代替{static}.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Dummy &#123;</span><br><span class="line">&#123;static&#125; String id</span><br><span class="line">&#123;abstract&#125; void methods()</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_11.png" alt="class11"></p><h3 id="高级类体"><a href="#高级类体" class="headerlink" title="高级类体"></a>高级类体</h3><p>PlantUML 默认自动将方法和属性重新分组，你可以自己定义分隔符来重排方法和属性，下面的分隔符都<br>是可用的：– .. &#x3D;&#x3D; __.<br>还可以在分隔符中添加标题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Foo1 &#123;</span><br><span class="line">You can use</span><br><span class="line">several lines</span><br><span class="line">..</span><br><span class="line">as you want</span><br><span class="line">and group</span><br><span class="line">==</span><br><span class="line">things together.</span><br><span class="line">__</span><br><span class="line">You can have as many groups</span><br><span class="line">as you want</span><br><span class="line">--</span><br><span class="line">End of class</span><br><span class="line">&#125;</span><br><span class="line">class User &#123;</span><br><span class="line">.. Simple Getter ..</span><br><span class="line">+ getName()</span><br><span class="line">+ getAddress()</span><br><span class="line">.. Some setter ..</span><br><span class="line">+ setName()</span><br><span class="line">__ private data __</span><br><span class="line">int age</span><br><span class="line">-- encrypted --</span><br><span class="line">String password</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_12.png" alt="class12"></p><h3 id="更多注释"><a href="#更多注释" class="headerlink" title="更多注释"></a>更多注释</h3><p>可以在注释中使用部分html 标签：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Foo</span><br><span class="line">note left: On last defined class</span><br><span class="line">note top of Object</span><br><span class="line">In java, &lt;size:18&gt;every&lt;/size&gt; &lt;u&gt;class&lt;/u&gt;</span><br><span class="line">&lt;b&gt;extends&lt;/b&gt;</span><br><span class="line">&lt;i&gt;this&lt;/i&gt; one.</span><br><span class="line">end note</span><br><span class="line">note as N1</span><br><span class="line">This note is &lt;u&gt;also&lt;/u&gt;</span><br><span class="line">&lt;b&gt;&lt;color:royalBlue&gt;on several&lt;/color&gt;</span><br><span class="line">&lt;s&gt;words&lt;/s&gt; lines</span><br><span class="line">And this is hosted by &lt;img:sourceforge.jpg&gt;</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/class_uml_13.png" alt="class13"></p><h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>使用关键字object 定义实例。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object firstObject</span><br><span class="line">object &quot;My Second Object&quot; as o2</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_1.png" alt="object1"></p><h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><p>对象之间的关系可以用如下符号定义：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Snipaste_2020-06-27_19-56-04.png" alt="对象之间的关系"></p><p>也可以用.. 来代替– 以使用点线。<br>知道了这些规则，就可以画下面的图：<br>可以用冒号给关系添加标签，标签内容紧跟在冒号之后。<br>用双引号在关系的两边添加基数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object Object01</span><br><span class="line">object Object02</span><br><span class="line">object Object03</span><br><span class="line">object Object04</span><br><span class="line">object Object05</span><br><span class="line">object Object06</span><br><span class="line">object Object07</span><br><span class="line">object Object08</span><br><span class="line">Object01 &lt;|-- Object02</span><br><span class="line">Object03 *-- Object04</span><br><span class="line">Object05 o-- &quot;4&quot; Object06</span><br><span class="line">Object07 .. Object08 : some labels</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_2.png" alt="object2"></p><h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><p>用冒号加属性名的形式声明属性。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">object user</span><br><span class="line">user : name = &quot;Dummy&quot;</span><br><span class="line">user : id = 123</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>如下图生成：</p><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/object_uml_3.png" alt="object3"></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><h3 id="简单活动"><a href="#简单活动" class="headerlink" title="简单活动"></a>简单活动</h3><p>使用(*) 作为活动图的开始点和结束点。<br>有时，你可能想用(*top) 强制开始点位于图示的顶端。<br>使用–&gt; 绘制箭头。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;First Activity&quot;</span><br><span class="line">&quot;First Activity&quot; --&gt; (*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_1.png" alt="activity1"></p><h3 id="箭头上的标签"><a href="#箭头上的标签" class="headerlink" title="箭头上的标签"></a>箭头上的标签</h3><p>默认情况下，箭头开始于最接近的活动。<br>可以用[ 和 ] 放在箭头定义的后面来添加标签。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;First Activity&quot;</span><br><span class="line">--&gt;[You can put also labels] &quot;Second Activity&quot;</span><br><span class="line">--&gt; (*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_2.png" alt="activity2"></p><h3 id="改变箭头方向"><a href="#改变箭头方向" class="headerlink" title="改变箭头方向"></a>改变箭头方向</h3><p>你可以使用-&gt; 定义水平方向箭头，还可以使用下列语法强制指定箭头的方向：</p><ul><li>-down-&gt; (default arrow)</li><li>-right-&gt; or -&gt;</li><li>-left-&gt;</li><li>-up-&gt;</li></ul><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_3.png" alt="activity3"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>你可以使用关键字if&#x2F;then&#x2F;else 创建分支。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;Initialization&quot;</span><br><span class="line">if &quot;Some Test&quot; then</span><br><span class="line">--&gt;[true] &quot;Some Activity&quot;</span><br><span class="line">--&gt; &quot;Another activity&quot;</span><br><span class="line">-right-&gt; (*)</span><br><span class="line">else</span><br><span class="line">-&gt;[false] &quot;Something else&quot;</span><br><span class="line">--&gt;[Ending process] (*)</span><br><span class="line">endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_4.png" alt="activity4"></p><p>不过，有时你可能需要重复定义同一个活动：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;check input&quot;</span><br><span class="line">If &quot;input is verbose&quot; then</span><br><span class="line">--&gt; [Yes] &quot;turn on verbosity&quot;</span><br><span class="line">--&gt; &quot;run command&quot;</span><br><span class="line">else</span><br><span class="line">--&gt; &quot;run command&quot;</span><br><span class="line">Endif</span><br><span class="line">--&gt;(*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_5.png" alt="activity5"></p><h3 id="更多分支"><a href="#更多分支" class="headerlink" title="更多分支"></a>更多分支</h3><p>默认情况下，一个分支连接上一个最新的活动，但是也可以使用if 关键字进行连接。<br>还可以嵌套定义分支。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; if &quot;Some Test&quot; then</span><br><span class="line">--&gt;[true] &quot;activity 1&quot;</span><br><span class="line">if &quot;&quot; then</span><br><span class="line">-&gt; &quot;activity 3&quot; as a3</span><br><span class="line">else</span><br><span class="line">if &quot;Other test&quot; then</span><br><span class="line">-left-&gt; &quot;activity 5&quot;</span><br><span class="line">else</span><br><span class="line">--&gt; &quot;activity 6&quot;</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">-&gt;[false] &quot;activity 2&quot;</span><br><span class="line">endif</span><br><span class="line">a3 --&gt; if &quot;last test&quot; then</span><br><span class="line">--&gt; &quot;activity 7&quot;</span><br><span class="line">else</span><br><span class="line">-&gt; &quot;activity 8&quot;</span><br><span class="line">endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_6.png" alt="activity6"></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>你可以在活动定义之后用note left, note right, note top or note bottom, 命令给活动添加注释。<br>如果想给开始点添加注释，只需把注释的定义放在活动图最开始的地方即可。<br>也可以用关键字endnote 定义多行注释。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">(*) --&gt; &quot;Some Activity&quot;</span><br><span class="line">note right: This activity has to be defined</span><br><span class="line">&quot;Some Activity&quot; --&gt; (*)</span><br><span class="line">note left</span><br><span class="line">This note is on</span><br><span class="line">several lines</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_7.png" alt="activity7"></p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>用关键字partition 定义分区，还可以设置背景色(用颜色名或者颜色值)。<br>定义活动的时候，它自动被放置到最新的分区中。<br>用} 结束分区的定义。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">partition Conductor &#123;</span><br><span class="line">(*) --&gt; &quot;Climbs on Platform&quot;</span><br><span class="line">--&gt; === S1 ===</span><br><span class="line">--&gt; Bows</span><br><span class="line">&#125;</span><br><span class="line">partition Audience #LightSkyBlue &#123;</span><br><span class="line">=== S1 === --&gt; Applauds</span><br><span class="line">&#125;</span><br><span class="line">partition Conductor &#123;</span><br><span class="line">Bows --&gt; === S2 ===</span><br><span class="line">--&gt; WavesArmes</span><br><span class="line">Applauds --&gt; === S2 ===</span><br><span class="line">&#125;</span><br><span class="line">partition Orchestra #CCCCEE &#123;</span><br><span class="line">WavesArmes --&gt; Introduction</span><br><span class="line">--&gt; &quot;Play music&quot;</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_8.png" alt="activity8"></p><h3 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title Servlet Container</span><br><span class="line">(*) --&gt; &quot;ClickServlet.handleRequest()&quot;</span><br><span class="line">--&gt; &quot;new Page&quot;</span><br><span class="line">if &quot;Page.onSecurityCheck&quot; then</span><br><span class="line">-&gt;[true] &quot;Page.onInit()&quot;</span><br><span class="line">if &quot;isForward?&quot; then</span><br><span class="line">-&gt;[no] &quot;Process controls&quot;</span><br><span class="line">if &quot;continue processing?&quot; then</span><br><span class="line">--&gt;[yes] ===RENDERING===</span><br><span class="line">else</span><br><span class="line">--&gt;[no] ===REDIRECT_CHECK===</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">--&gt;[yes] ===RENDERING===</span><br><span class="line">endif</span><br><span class="line">if &quot;is Post?&quot; then</span><br><span class="line">--&gt;[yes] &quot;Page.onPost()&quot;</span><br><span class="line">--&gt; &quot;Page.onRender()&quot; as render</span><br><span class="line">--&gt; ===REDIRECT_CHECK===</span><br><span class="line">else</span><br><span class="line">--&gt;[no] &quot;Page.onGet()&quot;</span><br><span class="line">--&gt; render</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">--&gt;[false] ===REDIRECT_CHECK===</span><br><span class="line">endif</span><br><span class="line">if &quot;Do redirect?&quot; then</span><br><span class="line">-&gt;[yes] &quot;redirect request&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">else</span><br><span class="line">if &quot;Do Forward?&quot; then</span><br><span class="line">-left-&gt;[yes] &quot;Forward request&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">else</span><br><span class="line">-right-&gt;[no] &quot;Render page template&quot;</span><br><span class="line">--&gt; ==BEFORE_DESTROY===</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">--&gt; &quot;Page.onDestroy()&quot;</span><br><span class="line">--&gt;(*)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/activity_uml_9.png" alt="activity9"></p><h3 id="界面格式相关"><a href="#界面格式相关" class="headerlink" title="界面格式相关"></a>界面格式相关</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam SequenceGroupBodyBackgroundColor #FFFFFF90</span><br><span class="line"></span><br><span class="line">box &quot;Internal Service&quot; #LightBlue</span><br><span class="line">    participant Bob</span><br><span class="line">    participant Alice</span><br><span class="line">end box</span><br><span class="line"></span><br><span class="line">box &quot;Other&quot; #LightGreen</span><br><span class="line">    participant Other</span><br><span class="line">end box</span><br><span class="line"></span><br><span class="line">group group</span><br><span class="line">    Bob -&gt; Alice : hello</span><br><span class="line">    Alice -&gt; Other : hello</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/skinparam_uml_0.png" alt="skinparam_uml_0"></p><h3 id="颜色示例"><a href="#颜色示例" class="headerlink" title="颜色示例"></a>颜色示例</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">!unquoted procedure $DrawColor($colour)</span><br><span class="line"></span><br><span class="line">    skinparam rectangle &#123;</span><br><span class="line">            backgroundColor&lt;&lt;$colour&gt;&gt; $colour</span><br><span class="line">            borderColor&lt;&lt;$colour&gt;&gt; $colour</span><br><span class="line">            shadowing&lt;&lt;$colour&gt;&gt; true</span><br><span class="line">            BorderThickness&lt;&lt;$colour&gt;&gt; 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    rectangle $colour &lt;&lt;$colour&gt;&gt; as &quot;&lt;color:$colour&gt;&lt;/color&gt;&quot;</span><br><span class="line"></span><br><span class="line">!endprocedure</span><br><span class="line"></span><br><span class="line">package HexCodes &#123;</span><br><span class="line">$DrawColor(&quot;00ff00&quot;)</span><br><span class="line">$DrawColor(&quot;ff0000&quot;)</span><br><span class="line">$DrawColor(&quot;0000ff&quot;)</span><br><span class="line">$DrawColor(&quot;123456&quot;)</span><br><span class="line">$DrawColor(&quot;654321&quot;)</span><br><span class="line">$DrawColor(&quot;165432&quot;)</span><br><span class="line">$DrawColor(&quot;ff22ff&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package Colours &#123;</span><br><span class="line">$DrawColor(&quot;APPLICATION&quot;)</span><br><span class="line">$DrawColor(&quot;AliceBlue&quot;)</span><br><span class="line">$DrawColor(&quot;AntiqueWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Aqua&quot;)</span><br><span class="line">$DrawColor(&quot;Aquamarine&quot;)</span><br><span class="line">$DrawColor(&quot;Azure&quot;)</span><br><span class="line">$DrawColor(&quot;BUSINESS&quot;)</span><br><span class="line">$DrawColor(&quot;Beige&quot;)</span><br><span class="line">$DrawColor(&quot;Bisque&quot;)</span><br><span class="line">$DrawColor(&quot;Black&quot;)</span><br><span class="line">$DrawColor(&quot;BlanchedAlmond&quot;)</span><br><span class="line">$DrawColor(&quot;Blue&quot;)</span><br><span class="line">$DrawColor(&quot;BlueViolet&quot;)</span><br><span class="line">$DrawColor(&quot;Brown&quot;)</span><br><span class="line">$DrawColor(&quot;BurlyWood&quot;)</span><br><span class="line">$DrawColor(&quot;CadetBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Chartreuse&quot;)</span><br><span class="line">$DrawColor(&quot;Chocolate&quot;)</span><br><span class="line">$DrawColor(&quot;Coral&quot;)</span><br><span class="line">$DrawColor(&quot;CornflowerBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Cornsilk&quot;)</span><br><span class="line">$DrawColor(&quot;Crimson&quot;)</span><br><span class="line">$DrawColor(&quot;Cyan&quot;)</span><br><span class="line">$DrawColor(&quot;DarkBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DarkCyan&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGray&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DarkKhaki&quot;)</span><br><span class="line">$DrawColor(&quot;DarkMagenta&quot;)</span><br><span class="line">$DrawColor(&quot;DarkOliveGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkOrchid&quot;)</span><br><span class="line">$DrawColor(&quot;DarkRed&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSalmon&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;DarkSlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DarkTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;DarkViolet&quot;)</span><br><span class="line">$DrawColor(&quot;Darkorange&quot;)</span><br><span class="line">$DrawColor(&quot;DeepPink&quot;)</span><br><span class="line">$DrawColor(&quot;DeepSkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;DimGray&quot;)</span><br><span class="line">$DrawColor(&quot;DimGrey&quot;)</span><br><span class="line">$DrawColor(&quot;DodgerBlue&quot;)</span><br><span class="line">$DrawColor(&quot;FireBrick&quot;)</span><br><span class="line">$DrawColor(&quot;FloralWhite&quot;)</span><br><span class="line">$DrawColor(&quot;ForestGreen&quot;)</span><br><span class="line">$DrawColor(&quot;Fuchsia&quot;)</span><br><span class="line">$DrawColor(&quot;Gainsboro&quot;)</span><br><span class="line">$DrawColor(&quot;GhostWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Gold&quot;)</span><br><span class="line">$DrawColor(&quot;GoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;Gray&quot;)</span><br><span class="line">$DrawColor(&quot;Green&quot;)</span><br><span class="line">$DrawColor(&quot;GreenYellow&quot;)</span><br><span class="line">$DrawColor(&quot;Grey&quot;)</span><br><span class="line">$DrawColor(&quot;HoneyDew&quot;)</span><br><span class="line">$DrawColor(&quot;HotPink&quot;)</span><br><span class="line">$DrawColor(&quot;IMPLEMENTATION&quot;)</span><br><span class="line">$DrawColor(&quot;IndianRed&quot;)</span><br><span class="line">$DrawColor(&quot;Indigo&quot;)</span><br><span class="line">$DrawColor(&quot;Ivory&quot;)</span><br><span class="line">$DrawColor(&quot;Khaki&quot;)</span><br><span class="line">$DrawColor(&quot;Lavender&quot;)</span><br><span class="line">$DrawColor(&quot;LavenderBlush&quot;)</span><br><span class="line">$DrawColor(&quot;LawnGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LemonChiffon&quot;)</span><br><span class="line">$DrawColor(&quot;LightBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightCoral&quot;)</span><br><span class="line">$DrawColor(&quot;LightCyan&quot;)</span><br><span class="line">$DrawColor(&quot;LightGoldenRodYellow&quot;)</span><br><span class="line">$DrawColor(&quot;LightGray&quot;)</span><br><span class="line">$DrawColor(&quot;LightGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LightGrey&quot;)</span><br><span class="line">$DrawColor(&quot;LightPink&quot;)</span><br><span class="line">$DrawColor(&quot;LightSalmon&quot;)</span><br><span class="line">$DrawColor(&quot;LightSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;LightSkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightSlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;LightSlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;LightSteelBlue&quot;)</span><br><span class="line">$DrawColor(&quot;LightYellow&quot;)</span><br><span class="line">$DrawColor(&quot;Lime&quot;)</span><br><span class="line">$DrawColor(&quot;LimeGreen&quot;)</span><br><span class="line">$DrawColor(&quot;Linen&quot;)</span><br><span class="line">$DrawColor(&quot;MOTIVATION&quot;)</span><br><span class="line">$DrawColor(&quot;Magenta&quot;)</span><br><span class="line">$DrawColor(&quot;Maroon&quot;)</span><br><span class="line">$DrawColor(&quot;MediumAquaMarine&quot;)</span><br><span class="line">$DrawColor(&quot;MediumBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MediumOrchid&quot;)</span><br><span class="line">$DrawColor(&quot;MediumPurple&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MediumSpringGreen&quot;)</span><br><span class="line">$DrawColor(&quot;MediumTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;MediumVioletRed&quot;)</span><br><span class="line">$DrawColor(&quot;MidnightBlue&quot;)</span><br><span class="line">$DrawColor(&quot;MintCream&quot;)</span><br><span class="line">$DrawColor(&quot;MistyRose&quot;)</span><br><span class="line">$DrawColor(&quot;Moccasin&quot;)</span><br><span class="line">$DrawColor(&quot;NavajoWhite&quot;)</span><br><span class="line">$DrawColor(&quot;Navy&quot;)</span><br><span class="line">$DrawColor(&quot;OldLace&quot;)</span><br><span class="line">$DrawColor(&quot;Olive&quot;)</span><br><span class="line">$DrawColor(&quot;OliveDrab&quot;)</span><br><span class="line">$DrawColor(&quot;Orange&quot;)</span><br><span class="line">$DrawColor(&quot;OrangeRed&quot;)</span><br><span class="line">$DrawColor(&quot;Orchid&quot;)</span><br><span class="line">$DrawColor(&quot;PHYSICAL&quot;)</span><br><span class="line">$DrawColor(&quot;PaleGoldenRod&quot;)</span><br><span class="line">$DrawColor(&quot;PaleGreen&quot;)</span><br><span class="line">$DrawColor(&quot;PaleTurquoise&quot;)</span><br><span class="line">$DrawColor(&quot;PaleVioletRed&quot;)</span><br><span class="line">$DrawColor(&quot;PapayaWhip&quot;)</span><br><span class="line">$DrawColor(&quot;PeachPuff&quot;)</span><br><span class="line">$DrawColor(&quot;Peru&quot;)</span><br><span class="line">$DrawColor(&quot;Pink&quot;)</span><br><span class="line">$DrawColor(&quot;Plum&quot;)</span><br><span class="line">$DrawColor(&quot;PowderBlue&quot;)</span><br><span class="line">$DrawColor(&quot;Purple&quot;)</span><br><span class="line">$DrawColor(&quot;Red&quot;)</span><br><span class="line">$DrawColor(&quot;RosyBrown&quot;)</span><br><span class="line">$DrawColor(&quot;RoyalBlue&quot;)</span><br><span class="line">$DrawColor(&quot;STRATEGY&quot;)</span><br><span class="line">$DrawColor(&quot;SaddleBrown&quot;)</span><br><span class="line">$DrawColor(&quot;Salmon&quot;)</span><br><span class="line">$DrawColor(&quot;SandyBrown&quot;)</span><br><span class="line">$DrawColor(&quot;SeaGreen&quot;)</span><br><span class="line">$DrawColor(&quot;SeaShell&quot;)</span><br><span class="line">$DrawColor(&quot;Sienna&quot;)</span><br><span class="line">$DrawColor(&quot;Silver&quot;)</span><br><span class="line">$DrawColor(&quot;SkyBlue&quot;)</span><br><span class="line">$DrawColor(&quot;SlateBlue&quot;)</span><br><span class="line">$DrawColor(&quot;SlateGray&quot;)</span><br><span class="line">$DrawColor(&quot;SlateGrey&quot;)</span><br><span class="line">$DrawColor(&quot;Snow&quot;)</span><br><span class="line">$DrawColor(&quot;SpringGreen&quot;)</span><br><span class="line">$DrawColor(&quot;SteelBlue&quot;)</span><br><span class="line">$DrawColor(&quot;TECHNOLOGY&quot;)</span><br><span class="line">$DrawColor(&quot;Tan&quot;)</span><br><span class="line">$DrawColor(&quot;Teal&quot;)</span><br><span class="line">$DrawColor(&quot;Thistle&quot;)</span><br><span class="line">$DrawColor(&quot;Tomato&quot;)</span><br><span class="line">$DrawColor(&quot;Turquoise&quot;)</span><br><span class="line">$DrawColor(&quot;Violet&quot;)</span><br><span class="line">$DrawColor(&quot;Wheat&quot;)</span><br><span class="line">$DrawColor(&quot;White&quot;)</span><br><span class="line">$DrawColor(&quot;WhiteSmoke&quot;)</span><br><span class="line">$DrawColor(&quot;Yellow&quot;)</span><br><span class="line">$DrawColor(&quot;YellowGreen&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/resource/UML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/color_uml.png" alt="color_uml"></p><h3 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h3><p><a href="https://crashedmind.github.io/PlantUMLHitchhikersGuide/about/AboutPlantUML.html">PlantUML资料</a></p>]]></content>
      
      
      <categories>
          
          <category> UML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读C++线程池源码</title>
      <link href="/2020/06/27/2020-06-27-%E9%98%85%E8%AF%BBC++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/"/>
      <url>/2020/06/27/2020-06-27-%E9%98%85%E8%AF%BBC++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="progschj-thread-pool"><a href="#progschj-thread-pool" class="headerlink" title="progschj&#x2F;thread_pool"></a>progschj&#x2F;thread_pool</h2><p>Github上这个库(<a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">progschj&#x2F;thread_pool</a>)的点赞最多，学习一下。</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>);</span><br><span class="line">  <span class="comment">/// 任务入列</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br><span class="line">  ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 所有的工作线程</span></span><br><span class="line">  std::vector&lt;std::thread&gt; workers;</span><br><span class="line">  <span class="comment">/// 任务队列</span></span><br><span class="line">  std::queue&lt;std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 用于同步的互斥锁和条件变量</span></span><br><span class="line">  std::mutex queue_mutex;</span><br><span class="line">  std::condition_variable condition;</span><br><span class="line">  <span class="type">bool</span> stop;  <span class="comment">///&lt; 用于判断所有线程是否需要结束</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数和消费者实现"><a href="#构造函数和消费者实现" class="headerlink" title="构造函数和消费者实现"></a>构造函数和消费者实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     ThreadPool</span></span><br><span class="line"><span class="comment">/// @brief    用于创建若干个线程，并规定消费者函数</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    threads   [in]    要创建的线程数量</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 16:17:50</span></span><br><span class="line"><span class="comment">/// @warning  线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threads)</span> : stop(false) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i)</span><br><span class="line">    workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/// 获取同步锁</span></span><br><span class="line">          std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">          <span class="comment">/// 阻塞等待获取任务，直到任务队列不为空</span></span><br><span class="line">          <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(</span><br><span class="line">              lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">          <span class="comment">/// 如果stop标志位为true，且任务列表都执行完毕后，该线程退出</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">/// 从任务队列中拿出来一个任务</span></span><br><span class="line">          task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">          <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;  <span class="comment">///&lt; 这里释放锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 执行该任务函数</span></span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 在stop位, 置为true后通知所有线程执行一次，然后等待所有线程处理完任务后join()</span></span><br><span class="line">  condition.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">for</span> (std::thread&amp; worker : workers) worker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者函数"><a href="#生产者函数" class="headerlink" title="生产者函数"></a>生产者函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     enqueue</span></span><br><span class="line"><span class="comment">/// @brief    用于添加任务函数到任务队列中</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    f     [in]    任务函数</span></span><br><span class="line"><span class="comment">/// @param    args  [in]    任务函数的入参列表</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   取决于任务函数的返回值</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 16:06:30</span></span><br><span class="line"><span class="comment">/// @warning  线程安全</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::invoke_result&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::invoke_result&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 这里封装一个异步的线程并执行刚刚传入的函数，这个函数通过bind改类型为void()</span></span><br><span class="line">  <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; &gt;(</span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">  <span class="comment">/// 创建一个这个函数的未来的值， 这个未来值不获取就不会进行计算</span></span><br><span class="line">  std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 假如说没有让这个线程停止则继续，否则抛出异常阻止线程池结束后在入列</span></span><br><span class="line">    <span class="keyword">if</span> (stop) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    <span class="comment">/// 这个封装好的函数放入任务列表中</span></span><br><span class="line">    tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 通知一个阻塞中的线程，任务队列中有任务了</span></span><br><span class="line">  condition.<span class="built_in">notify_one</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 异步运算接口</title>
      <link href="/2020/06/27/2020-06-27-C++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/06/27/2020-06-27-C++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="std-async介绍"><a href="#std-async介绍" class="headerlink" title="std::async介绍"></a>std::async介绍</h2><p>下面是一个很好的并行计算的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** is_prime(700020007)这个函数调用隐藏于主线程，异步执行 */</span></span><br><span class="line">    std::future&lt;<span class="type">bool</span>&gt; fut = std::<span class="built_in">async</span>(is_prime, <span class="number">700020007</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;please wait&quot;</span>;</span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">span</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">/** 这个异步调用函数等待100ms，如果没有计算完就继续等待 */</span></span><br><span class="line">    <span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(span) != std::future_status::ready)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 计算完毕后，获取函数返回值 */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;final result: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::async中的第一个参数是启动策略，它控制std::async的异步行为，我们可以用三种不同的启动策略来创建std::async<br><strong>·std::launch::async</strong><br>保证异步行为，即传递函数将在单独的线程中执行<br><strong>·std::launch::deferred</strong><br>当其他线程调用get()来访问共享状态时，将调用非异步行为<br><strong>·std::launch::async | std::launch::deferred</strong><br>默认行为。有了这个启动策略，它可以异步运行或不运行，这取决于系统的负载，但我们无法控制它。</p><p>见下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保函数要5秒才能执行完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理创建数据库连接、获取数据等事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DB_&quot;</span> + recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromFile</span><span class="params">(std::string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保函数要5秒才能执行完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理获取文件数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;File_&quot;</span> + recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取开始时间</span></span><br><span class="line">    system_clock::time_point start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用std::launch::async，来指定其异步执行 */</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                                                    fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从文件获取数据</span></span><br><span class="line">    std::string fileData = <span class="built_in">fetchDataFromFile</span>(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从DB获取数据</span></span><br><span class="line">    <span class="comment">//数据在future&lt;std::string&gt;对象中可获取之前，将一直阻塞</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结束时间</span></span><br><span class="line">    <span class="keyword">auto</span> end = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> diff = <span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装数据</span></span><br><span class="line">    std::string data = dbData + <span class="string">&quot; :: &quot;</span> + fileData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出组装的数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-promise介绍"><a href="#std-promise介绍" class="headerlink" title="std::promise介绍"></a>std::promise介绍</h2><p>std::promise的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个某种类型的值，并将其传递给对应的future， 即使这个future不在同一个线程中也可以安全的访问到这个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::ref</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>         <span class="comment">// std::promise, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_int</span> <span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fut)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter print_int: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> x = fut.<span class="built_in">get</span>();  <span class="comment">///&lt; 在这里会等待外部std::promise变量set_value进来，否则会一致阻塞在这里</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;                      <span class="comment">// 创建一个std::promise变量</span></span><br><span class="line"></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();    <span class="comment">// 创建一个std::future变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">th1</span> <span class="params">(print_int, std::ref(fut))</span></span>;  <span class="comment">// 创建一个线程执行函数print_int</span></span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    prom.<span class="built_in">set_value</span> (<span class="number">10</span>);                         <span class="comment">// 传值进入线程th1</span></span><br><span class="line"></span><br><span class="line">    th<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-packaged-task介绍"><a href="#std-packaged-task介绍" class="headerlink" title="std::packaged_task介绍"></a>std::packaged_task介绍</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>       <span class="comment">// std::chrono::seconds</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>       <span class="comment">// std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// count down taking a second for each value:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countdown</span> <span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = from; i != to; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lift off!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> from - to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个std::packaged_task对象</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">tsk</span> <span class="params">(countdown)</span></span>;</span><br><span class="line">    <span class="comment">// 创建一个std::future对象，用于跨线程异步获取该线程返回的值</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; ret = tsk.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="comment">// 把线程对象移动进一个可运行的线程中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">th</span> <span class="params">(std::move(tsk), <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 让该线程从主线程中分离</span></span><br><span class="line">    th.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 利用std::future对象来获取已经分离开的线程运行是否结束的返回的值</span></span><br><span class="line">    <span class="type">int</span> value = ret.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The countdown lasted for &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; seconds.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="硬件支持的线程数量"><a href="#硬件支持的线程数量" class="headerlink" title="硬件支持的线程数量"></a>硬件支持的线程数量</h2><p>由于硬件支持的并行线程数量有限，如果创建线程的数量比硬件支持的数量要多，那么CPU进行的上下文切换可能会浪费大量时间，所以了解硬件支持的线程数量是高效并行编程的重点。</p><p>使用<code>std::thread::hardware_concurrency()</code>来获取硬件支持的线程数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; concurrent threads are supported.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-thread-yield介绍"><a href="#std-thread-yield介绍" class="headerlink" title="std::thread::yield介绍"></a>std::thread::yield介绍</h2><p><a href="https://stackoverflow.com/questions/11048946/stdthis-threadyield-vs-stdthis-threadsleep-for">关于std::thread::yield 和 std::sleep_for的比较</a></p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">if</span> (work_queue.<span class="built_in">try_pop</span>(task)) &#123;</span><br><span class="line">            <span class="comment">/// 获取到任务就运行</span></span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 没有获取到就休息一下</span></span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读spdlog-thread_pool源码</title>
      <link href="/2020/06/26/2020-06-27-%E9%98%85%E8%AF%BBspdlog-thread_pool%E6%BA%90%E7%A0%81/"/>
      <url>/2020/06/26/2020-06-27-%E9%98%85%E8%AF%BBspdlog-thread_pool%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="thread-pool-源码学习"><a href="#thread-pool-源码学习" class="headerlink" title="thread_pool 源码学习"></a>thread_pool 源码学习</h2><h3 id="源码定义"><a href="#源码定义" class="headerlink" title="源码定义"></a>源码定义</h3><p>我们先概览一下<a href="https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/details/thread_pool.h">spdlog-thread_pool定义</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SPDLOG_API</span> thread_pool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> item_type = async_msg;</span><br><span class="line">    <span class="keyword">using</span> q_type = details::mpmc_blocking_queue&lt;item_type&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span><br><span class="line">                std::function&lt;<span class="built_in">void</span>()&gt; on_thread_start);</span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n);</span><br><span class="line">    ~<span class="built_in">thread_pool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_pool &amp;<span class="keyword">operator</span>=(thread_pool &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_log</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr, <span class="type">const</span> details::log_msg &amp;msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                  async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_flush</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                    async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    q_type q_; <span class="comment">///&lt; 任务队列</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;  <span class="comment">///&lt; 线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post_async_msg_</span><span class="params">(async_msg &amp;&amp;new_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                         async_overflow_policy overflow_policy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_loop_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process_next_msg_</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="基本成员函数"><a href="#基本成员函数" class="headerlink" title="基本成员函数"></a>基本成员函数</h3><p>首先我们从thread_pll中最基本的五个成员函数开始看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span><br><span class="line">            std::function&lt;<span class="built_in">void</span>()&gt; on_thread_start);</span><br><span class="line"><span class="built_in">thread_pool</span>(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// message all threads to terminate gracefully join them</span></span><br><span class="line">~<span class="built_in">thread_pool</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">thread_pool &amp;<span class="keyword">operator</span>=(thread_pool &amp;&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>可以看到该类删除了拷贝构造，移动构造，标志该类不可以被拷贝和移动。<br>其中有两个构造函数，我们来详细看看它们的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     thread_pool</span></span><br><span class="line"><span class="comment">/// @brief    构造函数，创建了一定数量的线程，并规定执行哪个函数</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    q_max_item      [in] 用于初始化任务队列最大的数量</span></span><br><span class="line"><span class="comment">/// @param    thread_n        [in] 用于初始化最大线程数量</span></span><br><span class="line"><span class="comment">/// @param    on_thread_start [in] 每个线程执行的初始化函数(只执行一次)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:32:47</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">thread_pool</span><span class="params">(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::function&lt;<span class="type">void</span>()&gt; on_thread_start)</span></span></span><br><span class="line"><span class="function">    : q_(q_max_items) ///&lt; 任务队列的最大数目</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (threads_n == <span class="number">0</span> || threads_n &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span>(</span><br><span class="line">        <span class="string">&quot;spdlog::thread_pool(): invalid threads_n param (valid &quot;</span></span><br><span class="line">        <span class="string">&quot;range is 1-1000)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads_n; i++) &#123;</span><br><span class="line">    threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, on_thread_start] &#123;</span><br><span class="line">      <span class="comment">/// 线程开始时候需要执行的初始函数</span></span><br><span class="line">      <span class="built_in">on_thread_start</span>();</span><br><span class="line">      <span class="comment">/// 主任务循环</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;thread_pool::<span class="built_in">worker_loop_</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 委托构造函数，用于输入默认入参 std::function&lt;void()&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">thread_pool::thread_pool</span><span class="params">(<span class="type">size_t</span> q_max_items, <span class="type">size_t</span> threads_n)</span></span></span><br><span class="line"><span class="function">    : thread_pool(q_max_items, threads_n, [] &#123;</span>&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure><p>接着我们来看一下析构函数执行了什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 告诉所有线程中止，并且执行join()</span></span><br><span class="line">~<span class="built_in">thread_pool</span>() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threads_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">/// 对每一个线程池发送一个中止消息</span></span><br><span class="line">      <span class="built_in">post_async_msg_</span>(<span class="built_in">async_msg</span>(async_msg_type::terminate),</span><br><span class="line">                      async_overflow_policy::block);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads_) &#123;</span><br><span class="line">      <span class="comment">/// 等待每一个线程的结束时的join</span></span><br><span class="line">      t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">/// 析构函数中不能有异常，所以在这里做一个全捕获</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者逻辑"><a href="#生产者逻辑" class="headerlink" title="生产者逻辑"></a>生产者逻辑</h3><p>接着我们来看公有的两个接口函数的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用于发送任务消息，并判断是否需要打印到命令行或写入文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_log</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr, <span class="type">const</span> log_msg &amp;msg,</span></span></span><br><span class="line"><span class="params"><span class="function">              async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="function">async_msg <span class="title">async_m</span><span class="params">(std::move(worker_ptr), async_msg_type::log, msg)</span></span>;</span><br><span class="line">  <span class="built_in">post_async_msg_</span>(std::<span class="built_in">move</span>(async_m), overflow_policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于发送任务消息，并判断是否需要马上写入文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_flush</span><span class="params">(async_logger_ptr &amp;&amp;worker_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">post_async_msg_</span>(<span class="built_in">async_msg</span>(std::<span class="built_in">move</span>(worker_ptr), async_msg_type::flush),</span><br><span class="line">                  overflow_policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于返回任务队列溢出了多少条</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> q_.<span class="built_in">overrun_counter</span>(); &#125;</span><br></pre></td></tr></table></figure><p> <code>post_log</code> 和 <code>post_flush</code> 执行了一个差不多的任务，就是写日志，这两个函数都调用了<code>post_async_msg_()</code>来执行具体的任务们就来看看<code>post_async_msg_()</code>到底执行了什么。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     post_async_msg_</span></span><br><span class="line"><span class="comment">/// @brief    用于从队列中插入消息, 相当于生产者</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    new_msg         [in] 用于传入异步日志消息(使用右值方便移动)</span></span><br><span class="line"><span class="comment">/// @param    overflow_policy [in] 消息数量溢出的策略</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:42:18</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_async_msg_</span><span class="params">(async_msg &amp;&amp;new_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                     async_overflow_policy overflow_policy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (overflow_policy == async_overflow_policy::block) &#123;</span><br><span class="line">    <span class="comment">/// 阻塞至消息队列中有空间来插入消息</span></span><br><span class="line">    q_.<span class="built_in">enqueue</span>(std::<span class="built_in">move</span>(new_msg));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 立即插入队列且队列满时丢弃老的消息</span></span><br><span class="line">    q_.<span class="built_in">enqueue_nowait</span>(std::<span class="built_in">move</span>(new_msg));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者逻辑"><a href="#消费者逻辑" class="headerlink" title="消费者逻辑"></a>消费者逻辑</h3><p> 如上面的实现，我们知道这是一个生产者，从外部插入到本对象内的任务队列，等待消费者来处理这些消息<br> 我们来看看消费者到底执行了什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @name     worker_loop_</span></span><br><span class="line"><span class="comment">/// @brief    用于每个线程执行的死循环，当process_next_msg_返回false时候</span></span><br><span class="line"><span class="comment">///           线程自己退出</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:51:13</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_loop_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 如果处理消息没有返回false，就一致执行该函数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">process_next_msg_</span>()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @name     process_next_msg_</span></span><br><span class="line"><span class="comment">/// @brief    处理队列中的下一个消息，相当于消费者</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @param    NONE</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @return   如果不是中止线程消息，则返回true, 反之返回false</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// @date     2020-06-27 13:53:45</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">process_next_msg_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  async_msg incoming_async_msg;</span><br><span class="line">  <span class="comment">/// 从任务消息队列中取消息，如果没有任务则等待获取任务,</span></span><br><span class="line">  <span class="comment">/// 如十秒后仍然没有获取到则直接返回</span></span><br><span class="line">  <span class="type">bool</span> dequeued =</span><br><span class="line">      q_.<span class="built_in">dequeue_for</span>(incoming_async_msg, std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">  <span class="comment">/// 如果获取任务消息失败则直接返回true</span></span><br><span class="line">  <span class="keyword">if</span> (!dequeued) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 获取到消息后则进行处理</span></span><br><span class="line">  <span class="keyword">switch</span> (incoming_async_msg.msg_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> async_msg_type::log: &#123;</span><br><span class="line">      <span class="comment">/// 打印消息到命令行且判断是否要马上刷新文件</span></span><br><span class="line">      incoming_async_msg.worker_ptr-&gt;<span class="built_in">backend_sink_it_</span>(incoming_async_msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> async_msg_type::flush: &#123;</span><br><span class="line">      <span class="comment">/// 刷新文件</span></span><br><span class="line">      incoming_async_msg.worker_ptr-&gt;<span class="built_in">backend_flush_</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> async_msg_type::terminate: &#123;</span><br><span class="line">      <span class="comment">/// 用于终止本线程池的信号</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑我们可以看到：首先由<code>worker_loop()</code>函数来不停的执行消费者函数。<br>而消费者函数在不停地去任务队列中获取任务最后由<code>backend_sink_it_()</code> 和 <code>backend_flush_()</code>两个函数来执行真正地任务。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>很简单的一个消费者和生产者的队列，但最核心的部分被一个任务队列<code>mpmc_blocking_queue&lt;async_msg&gt;</code>给封装了，让我们继续深入来看看这个任务队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mpmc_blocking_queue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> item_type = T;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mpmc_blocking_queue</span><span class="params">(<span class="type">size_t</span> max_items)</span> : q_(max_items) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 尝试入列，如果空间不足则阻塞</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      pop_cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;q_.<span class="built_in">full</span>(); &#125;);</span><br><span class="line">      q_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    push_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 马上入列，如果没有空间则丢弃队列中老的消息</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enqueue_nowait</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      q_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">    push_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 尝试出列。如果队列中没有消息，则等待到超时然后再次尝试</span></span><br><span class="line">  <span class="comment">/// 假如出列成功则返回true, 否则返回false</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dequeue_for</span><span class="params">(T &amp;popped_item, std::chrono::milliseconds wait_duration)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (!push_cv_.<span class="built_in">wait_for</span>(lock, wait_duration,</span><br><span class="line">                             [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;q_.<span class="built_in">empty</span>(); &#125;)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      popped_item = std::<span class="built_in">move</span>(q_.<span class="built_in">front</span>());</span><br><span class="line">      q_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pop_cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> q_.<span class="built_in">overrun_counter</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex queue_mutex_;           <span class="comment">///&lt; 用于控制整个对象的锁</span></span><br><span class="line">  std::condition_variable push_cv_;  <span class="comment">///&lt; 用于入列的条件变量</span></span><br><span class="line">  std::condition_variable pop_cv_;   <span class="comment">///&lt; 用于出列的条件变量</span></span><br><span class="line">  circular_q&lt;T&gt; q_;                  <span class="comment">///&lt; 用于保存信息的队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看看这个队列是怎么实现线程安全的。<br>其中<code>q_</code>这个循环队列不是线程安全的，所以加上了一个<code>queue_mutex</code> 这个互斥锁用来同步所有成员函数的顺序并配合条件变量实现等待获取的功能。</p><p><code>spdlog-thread_pool</code> 的实现逻辑很清晰，我们可以对比一下Github上另一个thread-pool: <a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">progschj&#x2F;ThreadPool</a> 的实现。<br>由于需要写入的任务很明确，就是处理异步日志，所以任务的队列直接写死了处理异步日志消息。而progschj&#x2F;ThreadPool的实现则更加灵活。我们可以看看我的另一篇博客<a href="./_site/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2020/06/27/%E9%98%85%E8%AF%BB%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81.html">阅读progschj&#x2F;thread_pool源码</a>对progschj&#x2F;ThreadPool的介绍</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于加法溢出的判断</title>
      <link href="/2020/06/26/2020-06-26-C++%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2020/06/26/2020-06-26-C++%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>首先我们知道整型是由有符号和无符号整型所组成。由于有符号整型的判断包含了无符号整型的计算，所以我们现在先讨论<strong>有符号整型</strong>。</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592040132570.png" alt="1592040132570"></p><p>有符号整型的加法包括以下几种情况：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592042113575.png" alt="1592042113575"></p><p>由上图我们可以知道我们只用考虑两个操作数拥有<strong>相同符号</strong>的情况就行了。我们显而易见的可以知道，<strong>两数相加的结果一定大于任一操作数</strong>，写出以下函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来为了测试这个函数能否正确运行，我们添加如下测试用例：case 1.</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592044663011.png" alt="1592044663011"></p><p>完整验证程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑两数都为负数，判断负溢出的情况，同样我们知道<strong>两负数相加结果一定小于任一操作数</strong>, 对函数加以补充，并添加两个测试用例：case 2.</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592044894101.png" alt="1592044894101"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 溢出了返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算负溢出的情况</span></span><br><span class="line">    <span class="type">int</span> result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow</span>(<span class="number">-1</span>, <span class="number">-1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow</span>(int_min, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的程序顺利执行完毕后我们可以继续往下看。接着我们能不能使用模板来扩展到其他类型的加法.</p><p>当然可以我们只需要把<code>int</code>换为模板参数T就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算正溢出的情况</span></span><br><span class="line">    T result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 计算负溢出的情况</span></span><br><span class="line">    T result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们为模板函数添加上类型限定和静态编译检查。然后同样使用测试用例:case 1 和 case 2 来测试以下这个模板函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参的类型是否一致</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参类型都为整数类型</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need integral type!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  T1 result = x + y;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result &lt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result &gt; x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> int_min = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> int_max = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(int_max, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">-1</span>, <span class="number">-1</span>));  <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(int_min, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来添加上详细的测试用例就大功告成了。</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592130012130.png" alt="1592130012130"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_overflow_t</span><span class="params">(<span class="type">const</span> T1&amp; x, <span class="type">const</span> T2&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参的类型是否一致</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="comment">/// 编译时判断两个入参类型都为整数类型</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_plus_overflow need integral type!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  T1 result = x + y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result &lt; x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result &gt; x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 获取int类型的最大值和最小值</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">1</span>, <span class="number">1</span>));       <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(max_num, <span class="number">1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">-1</span>, <span class="number">-1</span>));      <span class="comment">///&lt; 没有溢出</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_plus_overflow_t</span>(min_num, <span class="number">-1</span>));  <span class="comment">///&lt; 溢出了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 3</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(max_num, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// case 4</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(max_num, min_num));</span><br><span class="line">  <span class="comment">/// case 5</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, max_num));</span><br><span class="line">  <span class="comment">/// case 6</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/// case 7</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(<span class="number">0</span>, min_num));</span><br><span class="line">  <span class="comment">/// case 8</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(min_num, max_num));</span><br><span class="line">  <span class="comment">/// case 9</span></span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_plus_overflow_t</span>(min_num, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个函数也<strong>可以用作检查减法是否溢出</strong>，只需要对第二个入参求相反数即可。但<strong>需要注意</strong>一个情况。</p><blockquote><p> 就是int值的负数个数(- 2^31)是比正数个数(2^31 - 1)多一个的, 所以在转化为相反数的时候可能在函数入参时出现溢出，导致计算没有溢出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">is_plus_overflow_t</span>(x, y);<span class="comment">/// 正确：等价与计算 2-1 表达式会不会溢出</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">y = INT_MIN;</span><br><span class="line"><span class="built_in">is_plus_overflow_t</span>(x, -y);<span class="comment">/// 错误：当y等于int的最小值的时候，无法求其相反数，会直接溢出</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 关于数值极限</title>
      <link href="/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/"/>
      <url>/2020/06/25/2020-06-25-C++%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="关于数值极限"><a href="#关于数值极限" class="headerlink" title="关于数值极限"></a>关于数值极限</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type\t\t\tlowest()\t\tmin()\t\t\tmax()\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;short\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned short\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned int\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unsigned long long\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">lowest</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>() &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span></span><br><span class="line">              &lt;&lt; std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h2><blockquote><p>在64位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/1592038101047.png" alt="1592038101047"></p></blockquote><p>换为2的幂级数表示为（64位系统下）：</p><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table><h2 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h2><blockquote><p>在32位系统上Visual Studio 输出结果：</p><p><img src="/resource/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%80%BC%E6%9E%81%E9%99%90/Snipaste_2022-10-12_15-36-58.png" alt="1592038101047"></p></blockquote><table><thead><tr><th align="center">type</th><th align="center">lowest()</th><th align="center">min()</th><th align="center">max()</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">-32768</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">int</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long</td><td align="center">-2147483648</td><td align="center">-2147483648</td><td align="center">2147483647</td></tr><tr><td align="center">long long</td><td align="center">-9223372036854775808</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned short</td><td align="center">0</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">unsigned int</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long</td><td align="center">0</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">unsigned long long</td><td align="center">0</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
