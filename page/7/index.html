<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mercy1101.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
<meta property="og:type" content="website">
<meta property="og:title" content="李建聪的博客">
<meta property="og:url" content="https://mercy1101.github.io/page/7/index.html">
<meta property="og:site_name" content="李建聪的博客">
<meta property="og:description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
<meta property="og:locale">
<meta property="article:author" content="李建聪">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mercy1101.github.io/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>李建聪的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李建聪的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(5)接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-24 19:40:47" itemprop="dateCreated datePublished" datetime="2020-08-24T19:40:47+08:00">2020-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="接口">接口</h2>
<p>接口代表一种调用契约，是多个方法声明的集合。接口最常见的使用场景，是对包外提供访问，或预留扩展空间。<br>
<code>Go</code>接口的实现机制很简洁，只要目标类型方法集内包含接口声明的全部方法，就被视为实现了该接口，无须做显式声明。当然，目标类型可实现多个接口。<br>
接口：</p>
<ul>
<li>不能有字段</li>
<li>不能定义自己的方法</li>
<li>只能声明方法，不能实现</li>
<li>可嵌入其他接口类型</li>
</ul>
<p>接口通常以<code>er</code>作为名称后缀，方法名是声明组成部分，但参数名可不同或省略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  test()</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>() &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// var t tester = d  ///&lt; 错误</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果接口没有任何声明方法声明，那么就是一个空接口, 他的用途类似面向对象的根类型<code>Object</code>, 可被赋值为任何类型的对象。<br>
接口变量默认值是<code>nil</code>。如果实现接口的类型支持，可做相等运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t1, t2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == <span class="literal">nil</span>, t1 == t2)</span><br><span class="line"></span><br><span class="line">  t1, t2 = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">  t1, t2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// panic: runtime error: comparing uncomparable type map[string]int</span></span><br></pre></td></tr></table></figure>
<p>可以像匿名字段一样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算实现了该接口。<br>
前提是，不能有同名方法, 不能嵌入自身或循环嵌入，那会导致递归错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  stringer  <span class="comment">///&lt; 嵌入接口</span></span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超集接口变量可隐式转换为子集，反过来不行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(a stringer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(a.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  pp(t) <span class="comment">///&lt; 隐式转换为自己接口</span></span><br><span class="line">  <span class="keyword">var</span> s stringer = t  <span class="comment">///&lt; 超集转换为子集</span></span><br><span class="line">  <span class="built_in">println</span>(s.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持匿名接口类型，可直接用于变量定义，或作为结构字段类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">interface</span> &#123;  <span class="comment">///&lt; 匿名接口类型</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t <span class="keyword">interface</span> &#123; <span class="comment">///&lt; 定义匿名接口变量</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125; = data&#123;&#125;</span><br><span class="line"></span><br><span class="line">  n := node&#123;</span><br><span class="line">    data: t,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println</span>(n.data.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行机制">执行机制</h3>
<p>接口执行一个名为<code>itab</code>的结构存储运行期所需的相关类型信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">  tab *itab <span class="comment">///&lt; 类型信息</span></span><br><span class="line">  data unsafe.Pointer <span class="comment">///&lt; 实际对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">  inter *interfacetype  <span class="comment">///&lt; 接口类型</span></span><br><span class="line">  _type *_type  <span class="comment">///&lt; 实际对象类型</span></span><br><span class="line">  fun [<span class="number">1</span>]<span class="type">uintptr</span>  <span class="comment">///&lt; 实际对象方法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关类型信息里保存了接口和实际对象的元数据。同时<code>itab</code>还用<code>fun</code>数组（不定长结构）保存了实际方法地址，从而实现在运行期对目标方法的动态调用。<br>
除此之外，接口还有一个重要特征：将对象赋值给接口变量时，会复制该对象。我们甚至无法修改结构存储的复制品，因为它也是<code>unaddressable</code>的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := data&#123;<span class="number">100</span>&#125;</span><br><span class="line">  vat t <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  p := &amp;t.(data)  <span class="comment">///&lt; 错误</span></span><br><span class="line">  t.(data).x = <span class="number">200</span>  <span class="comment">///&lt; 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便将其复制出来，用本地变量修改后，依然无法对<code>iface.data</code>赋值。解决方法就是将对象指针赋值给接口，那么接口内存存储的就是指针的复制品。<br>
只有当接口变量内部的两个指针(<code>itab</code>, <code>data</code>)都为<code>nil</code>时, 接口才等于<code>nil</code>.</p>
<h3 id="类型转换">类型转换</h3>
<p>类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体地接口类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> String() <span class="type">string</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;data:%d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data = <span class="number">15</span></span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> n, ok := x.(fmt.Stringer); ok &#123;  <span class="comment">///&lt; 转换为更具体地接口类型</span></span><br><span class="line">    fmt.Println(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> d2, ok := x.(data); ok &#123; <span class="comment">///&lt; 转换回原始类型</span></span><br><span class="line">    fmt.Println(d2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e := x.(<span class="type">error</span>)  <span class="comment">///&lt; 错误： main.data is not error</span></span><br><span class="line">  fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>ok-idiom</code>模式，即便转换失败也不会引发<code>panic</code>。还可用<code>switch</code>语句在多种类型间做出推断匹配，这样空接口就有更多发挥空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;d:%d&quot;</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> v := x(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">      <span class="built_in">println</span>(*v)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">string</span>:</span><br><span class="line">      <span class="built_in">println</span>(v(<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">case</span> fmt.Stringer:</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// d: 100</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示： <code>type switch</code>不支持<code>fallthrought</code></p>
</blockquote>
<h3 id="技巧">技巧</h3>
<p>让编译器检查，确保类型实现了指定接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> x <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">///&lt; 包初始函数</span></span><br><span class="line">  <span class="keyword">var</span> _ fmt.Stringer = x(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义函数类型，让相同签名地函数自动实现某个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncString <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t fmt.Stringer = FuncString(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt. Println(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(4)并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-23 11:17:47" itemprop="dateCreated datePublished" datetime="2020-08-23T11:17:47+08:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发">并发</h2>
<ul>
<li>并发： 逻辑上具备同时处理多个任务的能力。</li>
<li>并行： 物理上在同一时刻执行多个并发任务。<br>
多线程或多进程时并行的基本条件，但单线程也可用协程做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，它也有自己的优势。除了将因阻塞而浪费的时间找回来以外，还免去了线程切换的开销。协程上运行的多个任务本质上是依旧串行的，加上可控自主，所以并不需要做同步处理。<br>
通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源。用协程来提高处理器时间片利用率。</li>
</ul>
<p>简单将<code>goroutine</code>归纳为协程并不合适。运行时创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。这更像是多线程和协程的综合体，能最大限度提升执行效率，发挥多核处理能力。<br>
只须在函数调用前添加<code>go</code>关键字即可创建并发任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(s)</span><br><span class="line">&#125; (<span class="string">&quot;hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>关键字<code>go</code>并非执行并发操作，而是创建一个并发任务单元。新建任务被放置在系统队列中，等待调度器安排合适系统线程去获取执行权。当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。</p>
<p>每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间。相比系统默认<code>MB</code>级别的线程栈，<code>goroutinue</code>自定义栈初始仅须<code>2 KB</code>，所以才能创建成千上万的并发任务。自定义栈采取按需分配策略，在需要时进行扩容，最大能到<code>GB</code>规模。<br>
与<code>defer</code>一样，<code>gorountine</code>也会因&quot;延迟执行&quot;而立即计算并复制执行参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	c++</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">100</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;go:&quot;</span>, x, y)</span><br><span class="line">	&#125;(a, counter())</span><br><span class="line">	a += <span class="number">100</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main:&quot;</span>, a, counter())</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)	<span class="comment">// 等待 `goroutine` 结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main: 200 2</span></span><br><span class="line"><span class="comment">/// go: 100 1</span></span><br></pre></td></tr></table></figure>
<h3 id="Wait">Wait</h3>
<p>进程退出时不会等待并发任务结束，可用管道(<code>channel</code>)阻塞，然后发出退出信号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)	<span class="comment">///&lt; 创建通道。因为仅是通知，数据并没有实际意义</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;goroutine done.&quot;</span>)</span><br><span class="line">		<span class="built_in">close</span>(exit)	<span class="comment">///&lt; 关闭通道</span></span><br><span class="line">	&#125; ()</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">	&lt;-exit	<span class="comment">///&lt; 如通道关闭，立即解除阻塞</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<p>除关闭通道外，写入数据也可解除阻塞。<br>
如要等待多个任务结束，推荐使用<code>sync.WaitGroup</code>。通过设定计数器，让每个<code>goroutine</code>在退出前递减，直至归零时接触阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)	<span class="comment">///&lt; 累加计数</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()	<span class="comment">///&lt; 递减计数</span></span><br><span class="line"></span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;goroutine&quot;</span>, id, <span class="string">&quot;done.&quot;</span>)</span><br><span class="line">		&#125; (i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">	wg.Wait()	<span class="comment">///&lt; 阻塞，直到计数为零</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine 2 done.</span></span><br><span class="line"><span class="comment">/// goroutine 3 done.</span></span><br><span class="line"><span class="comment">/// goroutine 7 done.</span></span><br><span class="line"><span class="comment">/// goroutine 9 done.</span></span><br><span class="line"><span class="comment">/// goroutine 6 done.</span></span><br><span class="line"><span class="comment">/// goroutine 0 done.</span></span><br><span class="line"><span class="comment">/// goroutine 8 done.</span></span><br><span class="line"><span class="comment">/// goroutine 4 done.</span></span><br><span class="line"><span class="comment">/// goroutine 1 done.</span></span><br><span class="line"><span class="comment">/// goroutine 5 done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>WaitGroup.Add</code>实现了原子操作，但建议在<code>goroutine</code>外累加计数器，以免<code>Add</code>尚未执行，<code>Wait</code>已经退出。<br>
可在多处使用<code>Wait</code>阻塞，他们都能接收到通知</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()	<span class="comment">///&lt; 等待归零，解除阻塞</span></span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;wait exit.&quot;</span>)</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;done.&quot;</span>)</span><br><span class="line">		wg.Done()	<span class="comment">///&lt; 递减计数</span></span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()	<span class="comment">///&lt; 等待归零</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// done.</span></span><br><span class="line"><span class="comment">/// wait exit.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<h3 id="GOMAXPROCE">GOMAXPROCE</h3>
<p>运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量默认与处理器核数相等，可用<code>runtime.GOMAXPROCS</code>函数(或环境变量)修改。</p>
<h3 id="Local-Storage">Local Storage</h3>
<p>与线程不同，<code>goroutine</code>任务无法设置优先级，无法获取编号，没有局部存储(TLS), 甚至连返回值都会被抛弃。但除优先级外，其他功能都很容易实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> gs [<span class="number">5</span>]<span class="keyword">struct</span> &#123;	<span class="comment">///&lt; 用于实现类似TLS功能</span></span><br><span class="line">		id <span class="type">int</span>	<span class="comment">///&lt; 编号</span></span><br><span class="line">		result <span class="type">int</span>	<span class="comment">///&lt; 返回值</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gs); i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;	<span class="comment">// 使用参数避免闭包延迟求值</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			gs[id].id = id</span><br><span class="line">			gs[id].result = (id + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">		&#125;	(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, gs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [&#123;id:0 result:100&#125; &#123;id:1 result:200&#125; &#123;id:2 result:300&#125; &#123;id:3 result:400&#125; &#123;id:4 result:500&#125;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如使用<code>map</code>作为局部存储容器，建议做同步处理，因为运行时会对其做并发读写检查。</p>
</blockquote>
<h3 id="Gosched">Gosched</h3>
<p>暂停，释放线程去执行其他任务。当前任务被放回队列，等待下次调度时恢复执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;	<span class="comment">/// 让出当前线程，调度执行b</span></span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-exit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0</span></span><br><span class="line"><span class="comment">/// a: 1</span></span><br><span class="line"><span class="comment">/// b</span></span><br><span class="line"><span class="comment">/// a: 2</span></span><br><span class="line"><span class="comment">/// a: 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Goexit">Goexit</h3>
<p><code>Goexit</code>立即终止当前任务，运行时确保所有已注册延迟调用被执行。该函数不会影响其他并发任务，不会引发<code>panic</code>, 自然也就无法捕获。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(exit)	<span class="comment">///&lt; 执行</span></span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)	<span class="comment">///&lt; 执行</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>, <span class="built_in">recover</span>() == <span class="literal">nil</span>)	<span class="comment">///&lt; 执行，recover返回nil</span></span><br><span class="line">			&#125;()</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">///&lt; 在多层调用中执行Goexit</span></span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">			runtime.Goexit()	<span class="comment">///&lt; 立即终止整个调用堆栈</span></span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;c done.&quot;</span>)</span><br><span class="line">		&#125; ()</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;b done.&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;a done.&quot;</span>)	<span class="comment">///&lt; 不会执行</span></span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-exit</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// c</span></span><br><span class="line"><span class="comment">/// b true</span></span><br><span class="line"><span class="comment">/// a</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<p>如果在<code>main.main</code>里调用<code>Goexit</code>, 它会等待其他任务结束，然后让进程直接崩溃。<br>
无论身处哪一层，<code>Goexit</code>都能立即终止整个调用堆栈，这与<code>return</code>仅退出当前函数不同。标准库函数<code>os.Exit</code>可终止进程，但不会执行延迟调用。</p>
<h3 id="通道">通道</h3>
<p><code>Go</code>语言并未实现严格的并发安全。<br>
允许全局变量、指针、引用类型这些非安全内存共享操作，就需要开发人员自行维护数据一致和完整性。<code>Go</code>鼓励使用<code>CSP</code>通道，以通信来代替内存共享，实现并发安全。</p>
<blockquote>
<p>CSP: Communicating Sequential Process</p>
</blockquote>
<p>通过消息来避免竞态的模型除了<code>CSP</code>, 还有<code>Actor</code>。但两者由较大区别<br>
作为<code>CSP</code>核心，通道(channel)是显式的，要求操作双方必须知道数据类型和具体通道，并不关心另一端操作者身份和数量。可如果另一端未准备妥当，或消息未能及时处理时，会阻塞当前端。<br>
相比起来，<code>Actor</code>是透明的，它不在乎数据类型及通道，只要知道接收者信箱即可。默认就是异步方式，发送方对消息是否被接收和处理并不关心。</p>
<p>从底层实现上来说，通道知识一个队列。同步模式下，发送和接受双方配对，然后直接赋值数据给对方。如配对失败，则置入等待队列，直到另一方出现后才被唤醒。异步模式抢夺的则是数据缓冲槽。发送方要求有空槽可供写入，而接收方则要求有缓冲数据可读。需求不符时，同样加入缓冲队列，直到有另一方写入数据或腾出空槽后被唤醒。<br>
除传递消息（数据）外，通道还常被用做事件通知。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		s := &lt;-<span class="keyword">chan</span>	<span class="comment">///&lt; 接收消息</span></span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">		<span class="built_in">close</span>(done)	<span class="comment">///&lt; 关闭通道，作为结束通知</span></span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	c &lt;- <span class="string">&quot;hi!&quot;</span> 	<span class="comment">///&lt; 发送消息</span></span><br><span class="line">	&lt;-done			<span class="comment">///&lt; 阻塞，直到有数据或管道关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步模式必须有配对操作的<code>goroutine</code>出现，否则会一直阻塞。而异步模式在缓冲区未满或数据未读完前，不会阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)  <span class="comment">///&lt; 创建带3个缓冲槽的异步通道。</span></span><br><span class="line">  c &lt;- <span class="number">1</span>  <span class="comment">///&lt; 缓冲区未满，不会阻塞</span></span><br><span class="line">  c &lt;- <span class="number">2</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br></pre></td></tr></table></figure>
<p>多数时候，异步通道有助于提升性能，减少排队阻塞。<br>
缓冲去大小仅是内部属性，不属于类型组成部分。另外通道变量本身就是指针，可用相等操作符判断是否为同一对象或<code>nil</code>。<br>
内置函数<code>cap</code>和<code>len</code>返回缓冲区大小和当前已缓冲数量；而对于同步通道则都返回0；据此可判断通道时同步还是异步</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  b &lt;- <span class="number">1</span></span><br><span class="line">  b &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;b:&quot;</span>, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0 0</span></span><br><span class="line"><span class="comment">/// b: 2 3</span></span><br></pre></td></tr></table></figure>
<h3 id="收发">收发</h3>
<p>除使用简单的发送和接受操作符外，还可用<code>ok-idom</code>或<code>range</code>模式处理数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(done)		<span class="comment">///&lt; 确保发出结束通知</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			x, ok := &lt;-c</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;	<span class="comment">///&lt; 据此判断通道是否被关闭</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">println</span>(x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	c &lt;- <span class="number">2</span></span><br><span class="line">	c &lt;- <span class="number">3</span></span><br><span class="line">	<span class="built_in">close</span>(c)	<span class="comment">///&lt; 及时使用`close`函数关闭通道引发结束通知，否则可能会导致死锁。</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="comment">/// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一次性事件用<code>close</code>效率更好，没有多余开销。连续或多样性事件，可传递不同数据标志实现。还可使用<code>sync.Cond</code>实现单播或广播事件。</p>
</blockquote>
<p>对于<code>closed</code>或<code>nil</code>通道，发送和接收操作都有相应规则：</p>
<ul>
<li>向已关闭通道发送数据，引发<code>panci</code></li>
<li>从已关闭接收数据，返回已缓冲数据或零值。</li>
<li>无论收发，<code>nil</code>通道都会阻塞。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  c &lt;- <span class="number">10</span></span><br><span class="line">  c &lt;- <span class="number">20</span></span><br><span class="line">  <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(c)+<span class="number">1</span>; i++ &#123;</span><br><span class="line">    x, ok := &lt;-c</span><br><span class="line">    <span class="built_in">println</span>(i, <span class="string">&quot;:&quot;</span>, ok, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重复关闭或关闭<code>nil</code>通道都会引发<code>panic</code>错误。</p>
<h3 id="单向">单向</h3>
<p>通道默认时双向的，并不区分发送和接收端。<br>
尽管可用<code>make</code>创建单向通道，但那没有任何意义。通常使用类型装欢来获取单向通道，并分别赋予操作双方。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> recv &#123;</span><br><span class="line">      <span class="built_in">println</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      send &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能在单向通道上做逆向操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  &lt;-send  <span class="comment">///&lt; 无效操作</span></span><br><span class="line">  recv &lt;- <span class="number">1</span> <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，close不能用于接收端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;- <span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line">  <span class="built_in">close</span>(recv) <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法将单向通道重新转换回去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">  a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = a</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = a</span><br><span class="line"></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(recv)  <span class="comment">/// 错误</span></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(send)  <span class="comment">/// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择">选择</h3>
<p>如要同时处理多个通道，可选用<code>select</code>语句。它会随机选择一个可用通道做收发操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">///&lt; 接收端</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> (</span><br><span class="line">				name <span class="type">string</span></span><br><span class="line">				x	<span class="type">int</span></span><br><span class="line">				ok <span class="type">bool</span></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;	<span class="comment">///&lt; 随机选择可用 channel 接收数据</span></span><br><span class="line">			<span class="keyword">case</span> x, ok = &lt;-a:</span><br><span class="line">				name = <span class="string">&quot;a&quot;</span></span><br><span class="line">			<span class="keyword">case</span> x, ok = &lt;-b:</span><br><span class="line">				name = <span class="string">&quot;b&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;	<span class="comment">///&lt; 如果任一通道关闭，则终止接收</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">println</span>(name, x)	<span class="comment">///&lt; 输出接收的数据信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">///&lt; 发送端</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(a)</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(b)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> a &lt;- i:</span><br><span class="line">			<span class="keyword">case</span> b &lt;- i*<span class="number">10</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a 0</span></span><br><span class="line"><span class="comment">/// b 10</span></span><br><span class="line"><span class="comment">/// a 2</span></span><br><span class="line"><span class="comment">/// a 3</span></span><br><span class="line"><span class="comment">/// a 4</span></span><br><span class="line"><span class="comment">/// a 5</span></span><br><span class="line"><span class="comment">/// b 60</span></span><br><span class="line"><span class="comment">/// a 7</span></span><br><span class="line"><span class="comment">/// a 8</span></span><br><span class="line"><span class="comment">/// a 9</span></span><br></pre></td></tr></table></figure>
<p>如要等全部通道消息处理结束(closed),可将已完成通道设置为<code>nil</code>。这样它就会被阻塞，不再被<code>select</code>选中。<br>
即使是同一通道，也会随机选择<code>case</code>执行。</p>
<p>当所有通道都不可用时，<code>select</code>会执行<code>default</code>语句。如此可避开<code>select</code>阻塞，但须注意处理外层循环，以免陷入空耗。</p>
<h3 id="模式">模式</h3>
<p>通常使用工厂方法将<code>goroutine</code>和通道绑定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> receiver <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.WaitGroup</span><br><span class="line">  data <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newReceiver</span><span class="params">()</span></span> * receiver &#123;</span><br><span class="line">  r := &amp;receiver&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  r.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> r.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> r.data&#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;recv:&quot;</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := newReceiver()</span><br><span class="line">  r.data &lt;- <span class="number">1</span></span><br><span class="line">  r.data &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(r.data) <span class="comment">///&lt; 关闭通道，发出结束通知</span></span><br><span class="line">  r.Wait()  <span class="comment">///&lt; 等待接收者处理结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于通道本身就是一个并发安全的队列，可用作<code>ID generator</code>、<code>Pool</code>等用途。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type pool chan []<span class="function">byte</span></span><br><span class="line"><span class="function">func <span class="keyword">new</span> <span class="title">Pool</span><span class="params">(cap <span class="type">int</span>)</span> pool </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(chan []byte, cap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">get</span>() []byte &#123;</span><br><span class="line">  var v []byte</span><br><span class="line"></span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> v = &lt;-p: <span class="comment">///&lt; 获取</span></span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 获取失败，则创建</span></span><br><span class="line">      v = <span class="built_in">make</span>([]byte, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">put</span>(b []byte) &#123;</span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> p &lt;- b:</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 放回失败，放弃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用通道实现信号量(semaphore)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>) <span class="comment">///&lt; 最多允许两个并发同时执行</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">///&lt; acquire: 获取信号</span></span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem&#125;() <span class="comment">///&lt; release: 释放信号</span></span><br><span class="line">      time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">      fmt.Println(id, time.Now())</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库<code>time</code>提供了<code>timeout</code>和<code>tick channel</code>实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second*<span class="number">5</span>):</span><br><span class="line">          fmt.Println(<span class="string">&quot;timeout ...&quot;</span>)</span><br><span class="line">          os.Exit(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">          fmt.Println(time.Now())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  &lt;-(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)  <span class="comment">// 直接用nil channel阻塞进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获<code>INT</code>、<code>TERM</code>信号，顺便实现一个简易的<code>atexit</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exits = &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.RWMutex</span><br><span class="line">  <span class="function"><span class="keyword">func</span> []<span class="title">func</span><span class="params">()</span></span></span><br><span class="line">  signals <span class="keyword">chan</span> os.Signal</span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atexit</span><span class="params">(f <span class="keyword">func</span>()</span></span>)&#123;</span><br><span class="line">  exits.Lock()</span><br><span class="line">  <span class="keyword">defer</span> exits.Unlock()</span><br><span class="line">  exits.funcs = <span class="built_in">append</span>(exits.funcs, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> exits.signals == <span class="literal">nil</span> &#123;</span><br><span class="line">    exits.signals = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(exits.signals, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">  &#125;</span><br><span class="line">  exits.RLock()</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> exits.funcs &#123;</span><br><span class="line">    <span class="keyword">defer</span> f() <span class="comment">///&lt; 即使某些函数panic,延迟调用也能确保后续函数执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  exits.RUnlock()</span><br><span class="line">  &lt;-exit.signals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit1 ...&quot;</span>)&#125;)</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit2 ...&quot;</span>)&#125;)</span><br><span class="line">  waitExit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="资源泄露">资源泄露</h3>
<p>通道可能会引发<code>goroutine leak</code>, 确切的说，是指<code>goroutine</code>处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致他们会在等待队列里长久休眠形成资源泄露。</p>
<h3 id="同步">同步</h3>
<p>标准库<code>sync</code>提供了互斥和读写锁，另有原子操作等，可基本满足日常开发需要。<code>Mutex</code>、<code>RWMutex</code>的使用并不复杂，只有几个地方需要注意。<br>
将<code>Mutex</code>作为匿名字段时，相关方法必须实现为<code>pointer-receiver</code>, 否则会因赋值导致锁机制失效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> test(s <span class="type">string</span>) &#123;</span><br><span class="line">	d.Lock()</span><br><span class="line">	<span class="keyword">defer</span> d.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="built_in">println</span>(s, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d data</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		d.test(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">	&#125;	()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		d.test(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>锁不支持递归锁。</li>
<li>对性能要求较高时，应避免使用<code>defer Unlock</code></li>
<li>读写并发时，用<code>RWMutex</code>性能会更好一些</li>
<li>对单个数据读写保护，可尝试用原子操作</li>
<li>执行严格的测试，尽可能打开数据竞争检查</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(3)工作空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-22 19:34:47" itemprop="dateCreated datePublished" datetime="2020-08-22T19:34:47+08:00">2020-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工作空间">工作空间</h2>
<p>依照规范，工作空间由<code>src</code>、<code>bin</code>、<code>pkg</code>三个目录组成。通常需要将空间路径添加到<code>GOPATH</code>环境变量列表中, 以便相关工具能正常工作。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- service/</span><br><span class="line">  |          |</span><br><span class="line">  |          +-- user.go</span><br><span class="line">  |</span><br><span class="line">  +-- bin/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server</span><br><span class="line">  |</span><br><span class="line">  +-- pkg/</span><br><span class="line">       |</span><br><span class="line">       +-- linux_amd64/</span><br><span class="line">            |</span><br><span class="line">            +-- service.a</span><br></pre></td></tr></table></figure>
<p>在工作空间里，包括子包在内的所有源码文件都保存在<code>src</code>目录下。至于<code>bin</code>、<code>pkg</code>两个目录， 其主要影响 <code>go install/get</code>命令，他们会将编译结果(可执行文件或静态库)安装到这两个目录下，以实现增量编译。</p>
<h3 id="环境变量">环境变量</h3>
<p>编译器等相关工具按<code>GOPATH</code>设置的路径搜索目标。也就是说在导入目标库时，排在列表前面的路径比当前工作空间优先级更高。另外，<code>go get</code>默认将下载的第三方包保存到列表中第一个工作空间内。</p>
<p>环境变量<code>GOPATH</code>用于指示工具链和标准库的存放位置。在生成工具链时，相关路径就已经嵌入到可执行文件内，故无需额外设置。<br>
除通过设置<code>GOROOT</code>环境变量覆盖内部路径外，还可移动目录(改名、符号链接等), 或重新编译工具链来解决。<br>
至于<code>GOBIN</code>, 则是强制替代工作空间的<code>bin</code>目录，作为<code>go install</code>目标保存路径。这可避免将所有工作空间的<code>bin</code>路径添加到<code>PATH</code>环境变量当中。</p>
<h3 id="导入包">导入包</h3>
<p>使用标准库或第三方包前，须用<code>import</code>导入，参数是工作空间中以<code>src</code>为起始的绝对路径。编译器从标准库开始搜索，然后依次搜索<code>GOPATH</code>列表中的各个工作空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span> <span class="comment">// 实际路径: /usr/local/go/src/net/http</span></span><br></pre></td></tr></table></figure>
<p>除使用默认包名外，还可使用别名，以解决同名冲突问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> osx <span class="string">&quot;github.com/apple/osx/lib&quot;</span></span><br><span class="line"><span class="keyword">import</span> nix <span class="string">&quot;github.com/linux/lib&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: <code>import</code>导入参数是路径，而非包名。尽管习惯将包和目录名保持一致，但这不是强制规定。在代码中引用包成员时，使用包名而非目录名。</p>
</blockquote>
<p>有四种不同的导入方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>    <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 默认方式: test.A</span></span><br><span class="line"><span class="keyword">import</span> X  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 别名方式: X.A</span></span><br><span class="line"><span class="keyword">import</span> .  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 简便方式: A</span></span><br><span class="line"><span class="keyword">import</span> _  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 初始化方式: 无法引用，仅用来初始化目标包。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不能直接或间接导入自己，不支持任何形式的循环导入。</p>
</blockquote>
<p>未使用的导入(不包括初始化方式)会被编译器视为错误。</p>
<h3 id="相对路径">相对路径</h3>
<p>除工作空间和绝对路径外，部分工具还支持相对路径。可在非工作空间目录下，直接运行、编译一些测试代码。<br>
但在设置了<code>GOPATH</code>的工作空间后相对路径会导致编译失败。<code>go run</code>不受影响。</p>
<h3 id="初始化">初始化</h3>
<p>包内每个源码文件都可定义一到多个初始化函数，但编译器不保证执行次序。<br>
实际上，所有这些初始化函数(包括标准库和导入的第三方包)都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且仅执行一次。</p>
<p>编译器首先确保完成所有全局变量初始化，然后才开始执行初始化函数。直到这些全部结束后，运行时才正式进入<code>main.main</code>入口函数。<br>
可在初始化函数中创建<code>goroutine</code>，或等到它结束执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    fmt.Println(<span class="string">&quot;init:&quot;</span>, time.Now)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  &#125; ()</span><br><span class="line"></span><br><span class="line">  &lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main: &quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在多个初始化函数中引用全局变量，那么最好在变量定义处直接赋值。因无法保证执行次序，所以任何初始化函数中的赋值都有可能&quot;延迟无效&quot;。</p>
<h3 id="内部包">内部包</h3>
<p>内部包机制相当于增加了新的访问权限控制：所有保存在<code>internal</code>目录下的包(包括自身)仅能被其父目录下的包(包含所有子目录) 访问。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- lib/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- internal/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- a/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- b/</span><br><span class="line">  |         +-- x/</span><br><span class="line">  |             |</span><br><span class="line">  |             +-- y/</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>
<p>在<code>lib</code>目录外(比如<code>main.go</code>)导入内部包会引发编译错误。</p>
<blockquote>
<p>导入内部包必须使用完整路径， 例如： import “lib/internal/a”</p>
</blockquote>
<h3 id="依赖管理">依赖管理</h3>
<p>如何使用<code>vendor</code>，专门存放第三方包，实现将源码和依赖完整打包分发。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- vendor/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- github.com/</span><br><span class="line">  |         |              |</span><br><span class="line">  |         |              +-- mercy1101/</span><br><span class="line">                                  |</span><br><span class="line">                                  +-- test/</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/Mercy1101/test&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  test.Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>main.go</code>中导入<code>github.com/mercy1101/test</code>时，优先使用<code>vendor/github.com/mercy1101/test</code></p>
</blockquote>
<p>导入<code>vendor</code>中的第三方包，参数是以<code>vendor/</code>为起点的绝对路径。这避免了<code>vendor</code>目录位置带来的麻烦，让导入无论使用<code>vendor</code>,还是<code>GOPATH</code>都能保持一致。</p>
<blockquote>
<p>注意：<code>vendor</code>优先级比标准库高</p>
</blockquote>
<p>当多个<code>vendor</code>目录嵌套时，匹配规则如下:<br>
从当前源文件所在目录开始，逐级向上构造<code>vendor</code>全路径，直到发现路径匹配的目标为止。匹配失败，则依旧搜索<code>GOPATH</code></p>
<p>要使用<code>vendor</code>机制，须开启<code>GO15VENDOREXPERIMENT=1</code>环境变量开关(Go 1.6默认开启),且必须设置了<code>GOPATH</code>的工作空间。</p>
<blockquote>
<p>使用<code>go get</code>下载第三方包时，依旧使用<code>GOPATH</code>第一个工作空间，而非<code>vendor</code>目录。当前工具链中并没有真正意义上的包依赖管理，好在由不少第三放工具可选。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(2)反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-20 20:13:47" itemprop="dateCreated datePublished" datetime="2020-08-20T20:13:47+08:00">2020-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="反射">反射</h2>
<p>反射能让我们能在运行期探知对象的类型信息和内存结构，同时反射还是实现元编程的重要手段。<br>
Go对象头部并没有类型指针，通过自身是无法在运行期获知任何类型相关信息的。反射操作所需的全部信息都源自接口变量。接口变量除自身存储自身类型外，还会保存实际对象的类型数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个反射入口函数，会将任何传入的对象转换为接口类型。</p>
</blockquote>
<p>在面对类型是，需要区分<code>Type</code>和<code>Kind</code>。前者表示真实类型(静态类型), 后者表示器接触接口(底层类型)类别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X = <span class="number">100</span></span><br><span class="line">  t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">  fmt.Println(t.Name(), t.Kind())</span><br><span class="line">  <span class="comment">/// 输出：X int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := reflect.ArrayOf(<span class="number">10</span>, reflect.TypeOf(<span class="type">byte</span>(<span class="number">0</span>)))</span><br><span class="line">  b := reflect.MapOf(reflect.TypeOf(<span class="string">&quot;&quot;</span>), reflect.TypeOf(<span class="number">0</span>))</span><br><span class="line">  fmt.Println(a, m)</span><br><span class="line">  <span class="comment">/// 输出: [10]uint8 map[string]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法<code>Elem</code>返回指针、数组、切片、字典值或通道的基类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(reflect.TypeOf(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;).Elem())</span><br><span class="line">  fmt.Println(reflect.TypeOf([]<span class="type">int32</span>&#123;&#125;).Elem())</span><br><span class="line">  <span class="comment">/// 输出： int int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有在获取结构体指针的基类型后，才能遍历它的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	user</span><br><span class="line">	title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m manager</span><br><span class="line">	t := reflect.TypeOf(&amp;m)</span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">		t = t.Elem()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Println(f.Name, f.Type, f.Offset)</span><br><span class="line">		<span class="keyword">if</span> f.Anonymous &#123;</span><br><span class="line">			<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; f.Type.NumField(); x++ &#123;</span><br><span class="line">				af := f.Type.Field(x)</span><br><span class="line">				fmt.Println(<span class="string">&quot;  &quot;</span>, af.Name, af.Type)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// user main.user 0</span></span><br><span class="line"><span class="comment">///  name string</span></span><br><span class="line"><span class="comment">///   age int</span></span><br><span class="line"><span class="comment">/// title string 24</span></span><br></pre></td></tr></table></figure>
<p>对于匿名字段，可用多级索引（按定义顺序）直接访问</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m manager</span><br><span class="line">	t := reflect.TypeOf(m)</span><br><span class="line">	name, _ := t.FieldByName(<span class="string">&quot;name&quot;</span>)	<span class="comment">///&lt; 按名称查找</span></span><br><span class="line">	fmt.Println(name.Name, name.Type)</span><br><span class="line"></span><br><span class="line">	age := t.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;)	<span class="comment">///&lt; 按多级索引查找</span></span><br><span class="line">	fmt.Println(age.Name, age.Type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// name string</span></span><br><span class="line"><span class="comment">/// age int</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>FieldByName</code>不支持多级名称，如有同名遮蔽，须通过匿名字段二次获取</p>
</blockquote>
<p>反射能探知当前包或外包的非导出结构成员</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s http.Server</span><br><span class="line">	t := reflect.TypeOf(s)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		fmt.Println(t.Field(i).Name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// Addr</span></span><br><span class="line"><span class="comment">/// Handler</span></span><br><span class="line"><span class="comment">/// TLSConfig</span></span><br><span class="line"><span class="comment">/// ReadTimeout</span></span><br><span class="line"><span class="comment">/// ReadHeaderTimeout</span></span><br><span class="line"><span class="comment">/// WriteTimeout</span></span><br><span class="line"><span class="comment">/// IdleTimeout</span></span><br><span class="line"><span class="comment">/// MaxHeaderBytes</span></span><br><span class="line"><span class="comment">/// TLSNextProto</span></span><br><span class="line"><span class="comment">/// ConnState</span></span><br><span class="line"><span class="comment">/// ErrorLog</span></span><br><span class="line"><span class="comment">/// BaseContext</span></span><br><span class="line"><span class="comment">/// ConnContext</span></span><br><span class="line"><span class="comment">/// inShutdown</span></span><br><span class="line"><span class="comment">/// disableKeepAlives</span></span><br><span class="line"><span class="comment">/// nextProtoOnce</span></span><br><span class="line"><span class="comment">/// nextProtoErr</span></span><br><span class="line"><span class="comment">/// mu</span></span><br><span class="line"><span class="comment">/// listeners</span></span><br><span class="line"><span class="comment">/// activeConn</span></span><br><span class="line"><span class="comment">/// doneChan</span></span><br><span class="line"><span class="comment">/// onShutdown</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>相对<code>reflect</code>而言，当前包和外包都是&quot;外包&quot;</p>
</blockquote>
<p>可用反射提取<code>struct tag</code>, 还能自动分解。其常用于ORM映射, 或数据格式验证。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span> <span class="string">`field:&quot;name&quot; type:&quot;varchar(50)&quot;`</span></span><br><span class="line">	age <span class="type">int</span>	<span class="string">`field:&quot;age&quot; type:&quot;int&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> u user</span><br><span class="line">	t := reflect.TypeOf(u)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %s %s\n&quot;</span>, f.Name, f.Tag.Get(<span class="string">&quot;field&quot;</span>), f.Tag.Get(<span class="string">&quot;type&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: name varchar(50)</span></span><br><span class="line"><span class="comment">/// age: age int</span></span><br></pre></td></tr></table></figure>
<p>辅助判断方法<code>Implements</code>、<code>ConvertibleTo</code>、<code>AssignableTo</code> 都是运行期进行动态调用和赋值所必需的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a X</span><br><span class="line">	t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implements 不能直接使用类型作为参数，导致这种用法特别别扭</span></span><br><span class="line">	st := reflect.TypeOf((*fmt.Stringer)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">	fmt.Println(t.Implements(st))</span><br><span class="line"></span><br><span class="line">	it := reflect.TypeOf(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(t.ConvertibleTo(it))</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.AssignableTo(st), t.AssignableTo(it))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true false</span></span><br></pre></td></tr></table></figure>
<h3 id="值">值</h3>
<p>和<code>Type</code>获取类型信息不同， <code>Value</code>专注于对象实例数据读写<br>
接口变量会赋值对象，且时<code>unaddressable</code>的，所以要修改对象就必须使用指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">100</span></span><br><span class="line">  va, vp := reflect.ValueOf(a), reflect.ValueOf(&amp;a).Elem()</span><br><span class="line"></span><br><span class="line">  fmt.Println(va.CanAddr(), va.CanSet())</span><br><span class="line">  fmt.Println(vp.CpnAddr(), va.CanSet())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// false false</span></span><br><span class="line"><span class="comment">/// true true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>就算传入指针，一样需要通过<code>Elem</code>获取目标对象。因为被接口存储的指针本身时不能寻址和进行设置操作的。</p>
</blockquote>
<p>注意：不能对非导出字段进行设置操作，无论是当前包还是外包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	code <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := <span class="built_in">new</span>(User)</span><br><span class="line">	v := reflect.ValueOf(p).Elem()</span><br><span class="line">	name := v.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">	code := v.FieldByName(<span class="string">&quot;code&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;name: canaddr = %v, canset = %v\n&quot;</span>, name.CanAddr(), name.CanSet())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;code: canaddr = %v, canset = %v\n&quot;</span>, code.CanAddr(), code.CanSet())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name.CanSet() &#123;</span><br><span class="line">		name.SetString(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> code.CanAddr() &#123;</span><br><span class="line">		*(*<span class="type">int</span>)(unsafe.Pointer(code.UnsafeAddr())) = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, *p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: canaddr = true, canset = true</span></span><br><span class="line"><span class="comment">/// code: canaddr = true, canset = false</span></span><br><span class="line"><span class="comment">/// &#123;Name:Tom code:100&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Value.Pointer</code>和<code>Value.Int</code>等方法类似，将<code>Value.data</code>存储的数据转换为指针，目标必须是指针类型。<br>
而<code>UnsafeAddr</code>返回任何<code>CanAddr Value.data</code>地址（相当于&amp;取地址操作）,比如<code>Elem</code>后的<code>Value</code>, 以及字段成员地址。<br>
以结构体里的指针类型字段为例，<code>Pointer</code>返回该字段所保存的地址，而<code>UnsafeAddr</code>返回该字段本身的地址(结构对象地址+偏移量)</p>
</blockquote>
<p>可通过<code>Interface</code>方法进行类型推断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="type">string</span></span><br><span class="line">		Age <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u := user&#123;</span><br><span class="line">		<span class="string">&quot;q.yuhen&quot;</span>,</span><br><span class="line">		<span class="number">60</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(&amp;u)</span><br><span class="line">	<span class="keyword">if</span> !v.CanInterface() &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;CanInterface: fail.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p, ok := v.Interface().(*user)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;Interface: fail.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.Age++</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// &#123;Name:q.yuhen Age:61&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以直接使用<code>Value.Int</code>、<code>Bool</code>等方法进行类型转换，但失败时会引发<code>panic</code>, 且不支持<code>ok-idiom</code></p>
</blockquote>
<p>复合类型对象设置示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">  v := reflect.ValueOf(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> v.TrySend(reflect.ValueOf(<span class="number">100</span>)) &#123;</span><br><span class="line">    fmt.Println(v.TryRecv())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 100 true</span></span><br></pre></td></tr></table></figure>
<p>接口有两种<code>nil</code>状态，这一致是个潜在麻烦。解决方法是用<code>IsNil</code>判断值是否为<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(a == <span class="literal">nil</span>)</span><br><span class="line">  fmt.Println(b == <span class="literal">nil</span>, reflect.ValueOf(b).IsNil())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false true</span></span><br></pre></td></tr></table></figure>
<p>也可用<code>unsafe</code>转换后直接判断<code>iface.data</code>是否是零值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">  iface := (*[<span class="number">2</span>]<span class="type">uintptr</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">  fmt.Println(iface, iface[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// &amp;[712160 0] true</span></span><br></pre></td></tr></table></figure>
<p>让人很无奈的是, <code>Value</code>里的某些方法并未实现<code>ok-idom</code>或返回<code>error</code>, 所以得自行判断返回的是否为<code>Zero Value</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  v := reflect.ValueOf(<span class="keyword">struct</span>&#123;name <span class="type">string</span>&#125;)</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;name&quot;</span>).IsValid())</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;xxx&quot;</span>).IsValid())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false</span></span><br></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<p>动态调用方法，谈不上有多麻烦。只须按<code>In</code>列表准备好所需参数即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Test(x, y <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y, fmt.Errorf(<span class="string">&quot;err: %d&quot;</span>, x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X</span><br><span class="line">  v := reflect.ValueOf(&amp;a)</span><br><span class="line">  m := MethodByName(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  in := []reflect.Value &#123;</span><br><span class="line">    reflect.ValueOf(<span class="number">1</span>),</span><br><span class="line">    reflect.ValueOf(<span class="number">2</span>),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out := m.Call(in)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> out &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="comment">/// err: 3</span></span><br></pre></td></tr></table></figure>
<p>对于变参来书，用<code>CallSlice</code>要更方便一些</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Format(s <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(s, a...)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a X</span><br><span class="line">   v := reflect.ValueOf(&amp;a)</span><br><span class="line">   m := v.MethodByName(<span class="string">&quot;Format&quot;</span>)</span><br><span class="line">   out := m.Call([]reflect.Value&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;x&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;100&quot;</span>),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"></span><br><span class="line">   out = m.CallSlice([]reflect.ValueP&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf([]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;x&quot;</span>, <span class="number">100</span>&#125;),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br></pre></td></tr></table></figure>
<h3 id="构建">构建</h3>
<p>反射库提供了内置函数<code>make</code>和<code>new</code>的对应操作，其中最有意思的就是<code>MakeFunc</code>。可用它实现通用模板，使用不同数据类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args []reflect.Value)</span></span> (results []reflect.Value) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret reflect.Value</span><br><span class="line">  <span class="keyword">switch</span> args[<span class="number">0</span>].Kind() &#123;</span><br><span class="line">  <span class="keyword">case</span> reflect.Int:</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">      n += <span class="type">int</span>(a.Int())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = reflect.ValueOf(n)</span><br><span class="line">  <span class="keyword">case</span> reflect.String:</span><br><span class="line">    ss := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> args &#123;</span><br><span class="line">      ss = <span class="built_in">append</span>(ss, s.String())</span><br><span class="line">    &#125;</span><br><span class="line">    ret = reflect.ValueOf(strings.Join(ss, <span class="string">&quot;&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  results = <span class="built_in">append</span>(results, ret)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将函数指针参数指向通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAdd</span><span class="params">(fptr <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  fn := reflect.ValueOf(fptr).Elem()</span><br><span class="line">  v := reflect.MakeFunc(fn.Type(), add) <span class="comment">// 这是关键</span></span><br><span class="line">  fn.Set(v) <span class="comment">// 指向通用算法函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> intAdd <span class="function"><span class="keyword">func</span><span class="params">(s, y <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> strAdd <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  makeAdd(&amp;intAdd)</span><br><span class="line">  makeAdd(&amp;strAdd)</span><br><span class="line">  <span class="built_in">println</span>(intAdd(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">  <span class="built_in">println</span>(strAdd(<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot;world!&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 300</span></span><br><span class="line"><span class="comment">/// hello, world!</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(1)测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-19 20:24:47" itemprop="dateCreated datePublished" datetime="2020-08-19T20:24:47+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="11-测试">11. 测试</h2>
<p>标准库自带单元测试框架</p>
<ul>
<li>测试代码须放在当前包以&quot;_test.go&quot;结尾的文件中</li>
<li>测试函数以Test为名称前缀</li>
<li>测试命令(go test) 忽略以&quot;_&quot; 或 “.” 开头的测试文件</li>
<li>正常编译操作(go build/install)会忽略测试文件</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">		x	<span class="type">int</span></span><br><span class="line">		y	<span class="type">int</span></span><br><span class="line">		expect	<span class="type">int</span></span><br><span class="line">	&#125; &#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		actual := add(tt.x, tt.y)</span><br><span class="line">		<span class="keyword">if</span> actual != tt.expect &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;add(%d, %d): expect %d, actual %d&quot;</span>, tt.x, tt.y, tt.expect, actual)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-arg</td>
<td>命令行参数</td>
<td></td>
</tr>
<tr>
<td>-v</td>
<td>输出详细信息</td>
<td></td>
</tr>
<tr>
<td>-parallel</td>
<td>并发执行, 默认执行GOMAXPROCS</td>
<td>-parallel 2</td>
</tr>
<tr>
<td>-run</td>
<td>指定测试函数，正则表达式</td>
<td>-run “Add”</td>
</tr>
<tr>
<td>-timeout</td>
<td>全部测试累计时间超时将引发panic, 默认值为10ms</td>
<td>-timeout 1m30s</td>
</tr>
<tr>
<td>-count</td>
<td>重复测试次数，默认次数为1</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="test-main">test main</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span>&#123;</span><br><span class="line">	<span class="comment">// setup</span></span><br><span class="line">	code := m.Run()	<span class="comment">// 调用测试函数</span></span><br><span class="line">	<span class="comment">// tear down</span></span><br><span class="line">	os.Exit(code)	<span class="comment">// 注意： os.Exit 不会执行defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多测试用例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span> &#123;</span><br><span class="line">	match := <span class="function"><span class="keyword">func</span><span class="params">(pat, str <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;	<span class="comment">// pat: 命令行参数-run 提供的过滤条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span>	<span class="comment">// str: InternalTest.Name</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tests := []testing.InternalTest &#123;</span><br><span class="line">		&#123;<span class="string">&quot;b&quot;</span>, TestB&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;a&quot;</span>, TestA&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	benchmarks := []testing.InternalBenchmark&#123;&#125;</span><br><span class="line">	examples := []testing.InternalExample&#123;&#125;</span><br><span class="line"></span><br><span class="line">	m = testing.MainStart(match, tests, benchmarks, examples)</span><br><span class="line"></span><br><span class="line">	os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="example">example</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	fmt.Println(add(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// 3</span></span><br><span class="line">	<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果没有output注释，该示例就不会被执行。另外，不能使用内置函数print/printIn, 因为他们输出到stderr</p>
<h3 id="benchmark">benchmark</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go test -bench .</p>
</blockquote>
<p>如果希望仅执行性能测试，那么可以用<code>run=NONE</code>忽略所有测试用例。<br>
性能测试默认以并发方式进行测试，但可用cpu参数设定多个并发限制来观察结果。</p>
<blockquote>
<p>go test -bench . -cpu 1,2,4</p>
</blockquote>
<p>某些耗时的目标，默认循环测试过少，取平均值不足以准确计量性能。可用<code>benchtime</code>设定最小测试时间来增加循环次数，以便返回更准确的结果。</p>
<blockquote>
<p>go test -bench . -benchtime 5s</p>
</blockquote>
<h3 id="timer">timer</h3>
<p>如果在测试函数中要执行一些额外的操作，那么应该临时i组织计时器工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	b.ResetTimer()	<span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">			b.StopTimer()	<span class="comment">// 暂停</span></span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			b.StartTimer()	<span class="comment">// 恢复</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memory">memory</h3>
<p>性能测试查看内存情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heap</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = heap()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go test -bench . -benchmem -gcflags “-N -l” # 禁止内联和优化， 以便观察结果</p>
</blockquote>
<p>也可将测试函数设置为总是输出内存分配信息，无论使用benchmem参数与否</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span> </span>&#123;</span><br><span class="line">	b.<span class="built_in">ReportAllocs</span>()</span><br><span class="line">	b.<span class="built_in">ReportTimer</span>()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = <span class="built_in">heap</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码覆盖率">代码覆盖率</h3>
<blockquote>
<p>go test -cover</p>
</blockquote>
<p>为获取更详细信息，可指定covermode 和coverprofile 参数</p>
<ul>
<li>set: 是否执行</li>
<li>count: 执行次数</li>
<li>atomic: 执行次数，支持并发模式</li>
</ul>
<blockquote>
<p>go test -cover -covermode count -coverprofile cover.out</p>
</blockquote>
<p>还可以在浏览器中查看包括具体的执行次数等信息</p>
<blockquote>
<p>go tool cover -html=cover.out</p>
</blockquote>
<h3 id="性能监控">性能监控</h3>
<p>引发性能问题的原因无外乎执行时间过长、内存占用过多，以及意外阻塞。通过捕获或监控相关执行状态数据，就可定位引发问题的原因，从而针对性改进算法。</p>
<blockquote>
<p>go test -run NONE -bench . -memprofile mem.out -cpuprofile cpu.out net/http</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-cpuprofile</td>
<td>保存执行时间采样到指定文件</td>
<td>-cpuprofile cpu.out</td>
</tr>
<tr>
<td>-memprofile</td>
<td>保存内存分配采样到指定文件</td>
<td>-memprofile mem.out</td>
</tr>
<tr>
<td>-memprofilerate</td>
<td>内存分配采样起始值，默认为512KB</td>
<td>-memprofilerate 1</td>
</tr>
<tr>
<td>-blockprofile</td>
<td>保存阻塞时间采样到指定文件</td>
<td>-blockprofile block.out</td>
</tr>
<tr>
<td>-blockprofilerate</td>
<td>阻塞时间采样起始值，单位为：ns</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果执行性能测试，可能需要设置<code>benchtime</code>参数，以确保有足够的采样时间</p>
<p>可使用交互模式查看，或用命令行直接输出单向结果。</p>
<blockquote>
<p>go tool pprof http.test mem.out<br>
(pprof) top5</p>
</blockquote>
<ul>
<li>flat: 仅当前函数，不包括它调用的其他函数。</li>
<li>sum: 列表前几行所占百分比的总和。</li>
<li>cum: 当前函数调用堆栈累计。</li>
</ul>
<p>top命令可指定排序字段，比如<code>top5 -cum</code><br>
找出需要进一步查看的目标，使用<code>peek</code>命令列出调用来源<br>
也可用list命令输出源码统计样式，以便更直观的定位<br>
除文字模式以外，还可输出svg图形，将其保存或用浏览器查看</p>
<p>在线采集数据须诸如 <code>http/pprof</code>包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用浏览器访问指定路径，就可看到不同的检测项。</p>
<blockquote>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a></p>
</blockquote>
<p>必要时还可抓取数据，进行离线分析。</p>
<blockquote>
<p>curl <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a> &gt; mem.out<br>
go tool pprof test mem.out</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/31/2020-07-31-C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/31/2020-07-31-C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">C++ 迭代器介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-31 22:56:03" itemprop="dateCreated datePublished" datetime="2020-07-31T22:56:03+08:00">2020-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>C++ 迭代器介绍</h1>
<h2 id="迭代器概念">迭代器概念</h2>
<p><code>Iterator</code>(迭代器)是一种&quot;能够迭代某序列内所有元素&quot;的对象，可通过改变自寻常pointer的一致性接口来完成工作。<code>Iterator</code>奉行一个纯抽象概念：任何东西，只要行为类似iterator，就是一种iterator。然而不同的的iterator具有不同的行进能力。</p>
<h2 id="迭代器种类">迭代器种类</h2>
<table>
<thead>
<tr>
<th>迭代器种类</th>
<th>能力</th>
<th>提供者</th>
</tr>
</thead>
<tbody>
<tr>
<td>Output 迭代器</td>
<td>向前写入</td>
<td>Ostream,inserter</td>
</tr>
<tr>
<td>Input 迭代器</td>
<td>向前读取一次</td>
<td>Istream</td>
</tr>
<tr>
<td>Forward 迭代器</td>
<td>向前读取</td>
<td>Forward list、unordered containers</td>
</tr>
<tr>
<td>Bidirectional 迭代器</td>
<td>向前和向后读取</td>
<td>List、set、multiset、map、multimap</td>
</tr>
<tr>
<td>Random-access 迭代器</td>
<td>以随机访问方式读取</td>
<td>Array、vector、deque、string、C-style array</td>
</tr>
<tr>
<td><img src="/resource/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A7%8D%E7%B1%BB/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="迭代器种类"></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="Output迭代器">Output迭代器</h3>
<p>Output迭代器允许一步一步前行并搭配write动作。因此你可以一个一个元素地赋值，不能使用output迭代器对同一区间迭代两次。事实上，甚至不保证你可以将一个value复制两次而其迭代器不累进。我们的目标是将一个value以下列形式写入一个黑洞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">  *pos = ...;</span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output 迭代器无需比较操作。你无法检验output迭代器是否有效，或写入是否成功。你唯一可做的就是写入。通常，一批写入动作是以一个&quot;额外条件定义出&quot;的&quot;特定output迭代器&quot;作为结束。<br>
见下表Output迭代器操作</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter = val</td>
<td>将val写至迭代器所指的位置</td>
</tr>
<tr>
<td>++iter</td>
<td>向前步进(step forward), 返回新位置</td>
</tr>
<tr>
<td>iter++</td>
<td>向前步进(step forward), 返回旧位置</td>
</tr>
<tr>
<td>TYPE(iter)</td>
<td>复制迭代器(copy 构造函数)</td>
</tr>
</tbody>
</table>
<p>通常，迭代器可用来读，也可用来写; 几乎所有reading迭代器都有write的额外功能，这种情况下他们被称为<code>mutable</code>(可产生变化的)迭代器。<br>
一个典型的<code>pure output</code>迭代器例子是：“将元素写至标准输出设备”。 如果采用两个output迭代器写至屏幕, 第二个字将跟在第一个字后面，而不是覆盖第一个字。另一个典型的例子是inserter, 那是一种用来将他插入容器。如果随后写入第二个value, 并不会覆盖第一个value, 而是安插进去。</p>
<h3 id="Input迭代器">Input迭代器</h3>
<p>Input迭代器只能一次一个以前行方向读取元素，按此顺序一个个返回元素值。<br>
Input迭代器的各项操作</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>读取实际元素</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>读取实际元素的成员(如果有的话)</td>
</tr>
<tr>
<td>++iter</td>
<td>向前步进(step forward), 返回新位置</td>
</tr>
<tr>
<td>iter++</td>
<td>向前步进(step forward), 返回旧位置</td>
</tr>
<tr>
<td>iter1 == iter2</td>
<td>判断两个迭代器是否相等</td>
</tr>
<tr>
<td>iter1 != iter2</td>
<td>判断两个迭代器是否不相等</td>
</tr>
<tr>
<td>TYPE(iter)</td>
<td>复制迭代器(copy 构造函数)</td>
</tr>
</tbody>
</table>
<p>Input迭代器只能读取元素一次。如果你复制input迭代器, 并令原input迭代器和新产生的拷贝都向前读取, 可能会遍历到不同的值。<br>
<strong>所有的迭代器都具备input迭代器的能力，而且往往更强。</strong><code>Pure input</code>迭代器的典型例子就是&quot;从标准输入设备读取数据&quot;。同一个值不会被读取两次。一旦从<code>input stream</code>读入一个字(离开input缓冲区), 下次读取时就会返回另一个字。</p>
<p>对于input迭代器, 操作符==和!=只用来检查&quot;某个迭代器是否等于一个past-the-end迭代器(指指向最末元素的下一个位置)&quot;.这有其必要, 因为处理input迭代器的操作函数通常会有以下行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputIterator pos, end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos != end) &#123;</span><br><span class="line">  ... <span class="comment">// read-only access using *pos</span></span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>没有任何保证说，两个迭代器如果都不是past-the-end迭代器, 且指向不同位置，他们的比较结果会不相等</strong>(这个条件是和forward迭代器搭配引入的)。</p>
<p>也请注意, input迭代器的后置式递增操作符(<code>++iter</code>)不一定会返回什么东西。不过通常它会返回旧位置。<br>
你应该尽可能优先先选用前置式递增操作符(<code>++iter</code>)而非后置式递增操作符(<code>iter++</code>), 因为前者效能更好。因为后者会返回一个临时对象。</p>
<h3 id="Forward-前向-迭代器">Forward(前向)迭代器</h3>
<p>Forward迭代器是一种input迭代器且在前进读取时提供额外保证。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>访问实际元素</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>访问实际元素的成员</td>
</tr>
<tr>
<td>++iter</td>
<td>向前步进(返回新位置)</td>
</tr>
<tr>
<td>iter++</td>
<td>向前步进(返回旧位置)</td>
</tr>
<tr>
<td>iter1 == iter2</td>
<td>判断两个迭代器是否相等</td>
</tr>
<tr>
<td>iter1 != iter2</td>
<td>判断两个迭代器是否不等</td>
</tr>
<tr>
<td>TYPE()</td>
<td>创建迭代器(default构造函数)</td>
</tr>
<tr>
<td>TYPE(iter)</td>
<td>复制迭代器(拷贝构造函数)</td>
</tr>
<tr>
<td>iter1 = iter2</td>
<td>对迭代器赋值(assign)</td>
</tr>
<tr>
<td>和input迭代器不同的是, 两个forward迭代器如果指向同一元素, <code>operator==</code>会获得<code>true</code>, 如果两者都递增, 会再次指向同一元素。</td>
<td></td>
</tr>
<tr>
<td>例如：</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ForwardIterator pos1, pos2;</span><br><span class="line"></span><br><span class="line">pos1 = pos2 = begin; <span class="comment">/// both iterator refer to the same element</span></span><br><span class="line"><span class="keyword">if</span>(pos1 != end) &#123;</span><br><span class="line">  ++pos1; <span class="comment">/// pos1 is one element ahead</span></span><br><span class="line">  <span class="keyword">while</span>(pos1 != end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(*pos1 == *pos2) &#123;</span><br><span class="line">      ... <span class="comment">// precess adjacent duplicates</span></span><br><span class="line">      ++pos1;</span><br><span class="line">      ++pos2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Forward迭代器由以下对象和类型提供：</p>
<ul>
<li>Class&lt;forward_list&gt;</li>
<li>Unordered container<br>
然而标准库也允许<code>unordered</code>容器的实现提供<code>bidirectional</code>迭代器。<br>
如果forward迭代器履行了output迭代器应有的条件, 那么它就是一个mutable forward迭代器, 即可用于读取，也可用于涂写。</li>
</ul>
<h3 id="Bidirectional-双向-迭代器">Bidirectional(双向)迭代器</h3>
<p><code>Bidirectional</code>迭代器在<code>forward</code>迭代器的基础上增加回头迭代(<code>iterate backward</code>)能力。</p>
<p><code>Bidirectional</code> 迭代器的新增操作</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>–iter</td>
<td>步退(返回新位置)</td>
</tr>
<tr>
<td>iter–</td>
<td>步退(返回旧位置)</td>
</tr>
</tbody>
</table>
<p><code>Bidirectional</code>迭代器由以下的对象和类型提供：</p>
<ul>
<li>Class list&lt;&gt;.</li>
<li>Associative(关联式) 关联式容器提供</li>
</ul>
<p>如果<code>bidirectional</code>迭代器履行了output迭代器应有的条件, 那么他就是个<code>mutable bidirectional</code>迭代器, 即可用于读取, 也可用于涂写。</p>
<h3 id="Random-Access-随机访问-迭代器">Random-Access(随机访问)迭代器</h3>
<p><code>Random-access</code>迭代器在<code>bidirectional</code>迭代器的基础上增加了随机访问能里。因此它必须提供<code>iterator</code>算数运算。也就是说，它能增减某个偏移量、<br>
计算距离(<code>difference</code>), 并运用诸如&lt;和&gt;等管理操作符(<code>relational operator</code>)进行比较。<br>
随机访问迭代器的新增操作:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter[n]</td>
<td>访问索引位置为n的元素</td>
</tr>
<tr>
<td>iter+=n</td>
<td>前进n个元素(如果n是负数, 则改为回退)</td>
</tr>
<tr>
<td>iter-=n</td>
<td>回退n个元素(如果n是负数, 则改为前进)</td>
</tr>
<tr>
<td>iter+n</td>
<td>返回iter之后的第n个元素</td>
</tr>
<tr>
<td>n+iter</td>
<td>返回iter之后的第n个元素</td>
</tr>
<tr>
<td>iter-n</td>
<td>返回iter之前的第n个元素</td>
</tr>
<tr>
<td>iter1-iter2</td>
<td>返回iter1和iter2之间的距离</td>
</tr>
<tr>
<td>iter1 &lt; iter2</td>
<td>判断iter1是否在iter2之前</td>
</tr>
<tr>
<td>iter1 &gt; iter2</td>
<td>判断iter1是否在iter2之后</td>
</tr>
<tr>
<td>iter1 &lt;= iter2</td>
<td>判断iter1是否不在iter2之后</td>
</tr>
<tr>
<td>iter1 &gt;= iter2</td>
<td>判断iter1是否不在iter2之前</td>
</tr>
</tbody>
</table>
<p><code>Random-access</code>迭代器由以下对象和类型提供:</p>
<ul>
<li>可随机访问的容器(<code>array</code>、<code>vector</code>、<code>deque</code>)</li>
<li>String(<code>string</code>、<code>wstring</code>)</li>
<li>寻常的C-Style(<code>pointer</code>)</li>
</ul>
<h2 id="迭代器相关辅助函数">迭代器相关辅助函数</h2>
<h3 id="std-advance">std::advance()</h3>
<p><code>std::advance()</code>可将迭代器的位置增加, 增加的幅度由实参决定, 也就是说它令迭代器一次前进(或后退)多个元素:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; pos, Dist n)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>令名称为pos的input迭代器前进(或后退)n个元素</li>
<li>对<code>bidirectinal</code>迭代器和<code>random-access</code>迭代器而言, n可为负值, 表示后退</li>
<li><code>Dist</code>是个template类型。通常它必须是个整数类型, 因为会调用诸如<code>&lt;</code>、<code>++</code>、<code>--</code>等操作, 还要和0做比较。</li>
<li><code>std::advance()</code>并不检查迭代器是否超过序列的<code>end()</code>(因为迭代器通常不知道其所操作的容器, 因此并无检查)。所以, 调用<code>std::advance()</code>有可能导致不明确行为–因为&quot;对序列尾端调用<code>operator++</code>&quot;是一种未定义的行为。</li>
</ul>
<p>对于<code>random-access</code>迭代器, 此函数只是简单地调用<code>pos+=n</code>, 因此具有常量复杂度。 对于其他任何类型的迭代器, 则调用<code>++pos</code>(或<code>--pos</code>如果n为负值)n次。因此，对于其他任何类型地迭代器, 本函数具有线性复杂度。<br>
<strong>如果你希望你的程序可以轻松地更换容器和迭代器种类, 你应该使用<code>std::advance()</code>而不是<code>operator+=</code></strong><br>
<strong>另外, 请注意<code>std::advance()</code>不具有返回值, 而<code>operator+=</code>会返回新位置, 所以后者可作为更大表达式的一部分。</strong></p>
<p>下面是一个<code>std::advance()</code>的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 输入迭代器的情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_InIt&amp; _Where, _Diff _Off, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 检查该偏移量不能为负值</span></span><br><span class="line">  <span class="keyword">if</span> (_Off &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span> &amp;&amp; <span class="string">&quot;negative offset in advance&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 使用自增运算符来计算</span></span><br><span class="line">  <span class="keyword">for</span> (; <span class="number">0</span> &lt; _Off; --_Off) ++_Where;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 双向迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_BidIt&amp; _Where, _Diff _Off,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 使用自增运算符来计算</span></span><br><span class="line">  <span class="keyword">for</span> (; <span class="number">0</span> &lt; _Off; --_Off) ++_Where;</span><br><span class="line">  <span class="comment">/// 如果偏移量为负值则使用自减运算符</span></span><br><span class="line">  <span class="keyword">for</span> (; _Off &lt; <span class="number">0</span>; ++_Off) --_Where;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 随机访问迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RanIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_impl</span><span class="params">(_RanIt&amp; _Where, _Diff _Off,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 使用operator += ，常量复杂度</span></span><br><span class="line">  _Where += _Off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InIt&amp; _Where, _Diff _Off)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">advance_impl</span>(_Where, _Off,</span><br><span class="line">               <span class="comment">/// 在萃取迭代器的特性时去掉其const的属性来提高性能</span></span><br><span class="line">               std::iterator_traits&lt;_Iter&gt;::iterator_category&lt;</span><br><span class="line">                   std::<span class="type">remove_const_t</span>&lt;_InIt&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-next-和std-prev">std::next()和std::prev()</h3>
<p>c++ 提供了两个新增的辅助函数, 允许你前进和后退移动迭代器的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">next</span><span class="params">(ForwardIterator pos)</span></span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">next</span><span class="params">(ForwardIterator pos, Dist n)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>导致<code>forward</code>迭代器<code>pos</code>前进或n个位置</li>
<li>如果处理的是<code>bidirectional</code>和<code>random-access</code>迭代器, n可为负值, 导致后退移动</li>
<li><code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li>
<li>其内部将对一个临时对象调用<code>std::advance(pos, n)</code></li>
<li>注意, <code>std::next()</code>并不检查是否会跨越序列的<code>end()</code>。因此调用者必须自行担保其结果有效。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">prev</span><span class="params">(BidirectionalIterator pos)</span></span></span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">prev</span><span class="params">(BidirectionalIterator pos, Dist n)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>导致<code>bidirectional</code>迭代器<code>pos</code>后退一个或n个位置</li>
<li>n可为负值, 导致向前移动</li>
<li><code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li>
<li>其内部将对一个临时对象调用<code>std::advance(pos, -n)</code></li>
<li>注意, <code>std::prev()</code>并不检查是否会跨越序列的<code>begin()</code>。因此调用者必须自行担保其结果有效。</li>
</ul>
<p>下面写一个简单的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _InIt <span class="title">next</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _InIt _First,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::iterator_traits&lt;_InIt&gt;::iterator_category&lt;_InIt&gt; _Off = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::is_base_of&lt;</span><br><span class="line">          std::input_iterator_tag,</span><br><span class="line">          <span class="keyword">typename</span> std::iterator_traits&lt;_InIt&gt;::iterator_category&gt;::value,</span><br><span class="line">      <span class="string">&quot;next requires input iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">advance</span>(_First, _Off);</span><br><span class="line">  <span class="keyword">return</span> (_First);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidIt</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _BidIt <span class="title">prev</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _BidIt _First,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::iterator_traits&lt;_BidIt&gt;::iterator_category&lt;_BidIt&gt; _Off = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::is_base_of&lt;</span><br><span class="line">          std::bidirectional_iterator_tag,</span><br><span class="line">          <span class="keyword">typename</span> std::iterator_traits&lt;_BidIt&gt;::iterator_category&gt;::value,</span><br><span class="line">      <span class="string">&quot;prev requires bidirectional iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">advance</span>(_First, -_Off);</span><br><span class="line">  <span class="keyword">return</span> (_First);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-distance">std::distance()</h3>
<p><code>std::distance()</code>用来处理两个迭代器之间的距离:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dist <span class="title">distance</span><span class="params">(InputIterator pos1, InputIterator pos2)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回两个<code>input</code>迭代器<code>pos1</code>和<code>pos2</code>之间的距离。</li>
<li>两个迭代器必须指向同一个容器</li>
<li>如果不是<code>random-access</code>迭代器, 则从<code>pos1</code>开始前进必须能够到达<code>pos2</code>, 亦即<code>pos2</code>的位置必须与<code>pos1</code>相同或在其后。</li>
<li>返回类型<code>Dist</code>是类型<code>std::iterator_traits&lt;ForwardIterator&gt;::difference_type</code></li>
</ul>
<p>注意： 处理两个<code>non-random-access</code>迭代器之间的距离时, 必须十分小心。第一个迭代器所指的元素绝不能在第二个迭代器所指元素之后方, 否则会导致不明确的行为。<strong>如果不知道哪个迭代器在前, 你必须先算出两个迭代器分别至容器起点的距离, 在根据这两个距离来判断。</strong></p>
<p>一个简单的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> it&gt;</span><br><span class="line"><span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(it from, it to)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::iterator_category() ==</span></span></span><br><span class="line"><span class="params"><span class="function">                std::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 随机访问迭代器</span></span><br><span class="line">    <span class="keyword">return</span> to - from;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::<span class="built_in">iterator_category</span>() ==</span><br><span class="line">                       std::input_iterator_tag) &#123;</span><br><span class="line">    <span class="comment">/// input 迭代器</span></span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;it&gt;::difference_type res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; from != to; ++from) &#123;</span><br><span class="line">      ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="string">&quot;unknow iterator type.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-iter-swap">std::iter_swap()</h3>
<p>这个简单的辅助函数用来交换两个迭代器所指的元素值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator1 pos1, ForwardIterator pos2)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>交换迭代器pos1和pos2所指的值</li>
<li>迭代器的类型不必相同, 但其所指的两个值必须<strong>可以相互赋值</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/22/2020-07-22-C++%20integer_sequence%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/22/2020-07-22-C++%20integer_sequence%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">C++ integer_sequence介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-22 19:30:09" itemprop="dateCreated datePublished" datetime="2020-07-22T19:30:09+08:00">2020-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="integer-sequence">integer_sequence</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T... ints&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sequence</span><span class="params">(std::integer_sequence&lt;T, ints...&gt; int_seq)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; int_seq.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  ((std::cout &lt;&lt; ints &lt;&lt; <span class="string">&#x27; &#x27;</span>), ...);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 转化数组为tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Array, std::<span class="type">size_t</span>... I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">a2t_impl</span><span class="params">(<span class="type">const</span> Array&amp; a, std::index_sequence&lt;I...&gt;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(a[I]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N,</span><br><span class="line">          <span class="keyword">typename</span> Indices = std::make_index_sequence&lt;N&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">a2t</span>(<span class="type">const</span> std::array&lt;T, N&gt;&amp; a) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">a2t_impl</span>(a, Indices&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 漂亮地打印 tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ch</span>, <span class="keyword">class</span> <span class="title class_">Tr</span>, <span class="keyword">class</span> <span class="title class_">Tuple</span>, std::<span class="type">size_t</span>... Is&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_tuple_impl</span><span class="params">(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, <span class="type">const</span> Tuple&amp; t,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::index_sequence&lt;Is...&gt;)</span> </span>&#123;</span><br><span class="line">  ((os &lt;&lt; (Is == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>) &lt;&lt; std::<span class="built_in">get</span>&lt;Is&gt;(t)), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ch</span>, <span class="keyword">class</span> <span class="title class_">Tr</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span>&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os, <span class="type">const</span> std::tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">  <span class="built_in">print_tuple_impl</span>(os, t, std::index_sequence_for&lt;Args...&gt;&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::integer_sequence&lt;<span class="type">unsigned</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::make_integer_sequence&lt;<span class="type">int</span>, <span class="number">20</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::make_index_sequence&lt;<span class="number">10</span>&gt;&#123;&#125;);</span><br><span class="line">  <span class="built_in">print_sequence</span>(std::index_sequence_for&lt;<span class="type">float</span>, std::iostream, <span class="type">char</span>&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  std::array&lt;<span class="type">int</span>, 4&gt; array = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> tuple = <span class="built_in">a2t</span>(array);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;<span class="keyword">decltype</span>(tuple), std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; tuple &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/15/2020-07-15-C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/15/2020-07-15-C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">C++ 设计模式之单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-15 19:39:47" itemprop="dateCreated datePublished" datetime="2020-07-15T19:39:47+08:00">2020-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">c++ 设计模式 单例模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="正确写法">正确写法</h2>
<p>该写法在第一次调用<code>get_instance()</code>后构造该实例，线程安全。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">object</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;object&gt;&amp; <span class="title">get_instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">object</span>() = <span class="keyword">default</span>; <span class="comment">///&lt; 构造函数写为private，防止其他调用者单独构造该对象实例。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;object&gt;&amp; <span class="title">object::get_instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;object&gt; instance;  <span class="comment">///&lt; 该对象的唯一实例</span></span><br><span class="line">  <span class="type">static</span> std::once_flag flag; <span class="comment">///&lt; 标志位, 标记只调用一次</span></span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;]()&#123;</span><br><span class="line">    instance = std::<span class="built_in">make_unique</span>&lt;object&gt;();  <span class="comment">///&lt; C++14以后版本的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    instance = std::unique_ptr&lt;object&gt;(new object()); ///&lt; C++14 到 C++11 可用的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他写法比较">其他写法比较</h2>
<p>最简单的写法: 线程不安全<br>
由于<code>new object()</code>这个构造的过程需要时间，所以可能造成两个线程同时获取到<code>instance</code>变量为空指针。从而导致实例化两次，从未导致硬件驱动加载两次，而导致崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object* <span class="title">object::get_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  object* instance = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>double check</code>写法： 看起来线程安全，其实有条件竞争。<br>
在<code>#1</code>和<code>#2</code>处，可能发生一个线程正在对<code>instance</code>变量赋值(写操作), 而另一个线程在进行在进行判断<code>instance</code>变量是否为空(读操作)，从而导致条件竞争，而导致崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object* <span class="title">object::get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> std::mutex mt;</span><br><span class="line">  <span class="keyword">volatile</span> object* instance = <span class="literal">nullptr</span>;  <span class="comment">///&lt; volatile关键字为了防止编译器优化</span></span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123; <span class="comment">///&lt; #1 读操作</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">object</span>();  <span class="comment">///&lt; #2 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/15/2020-07-15-Qt%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/15/2020-07-15-Qt%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">Qt 信号槽的连接方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-15 19:35:47" itemprop="dateCreated datePublished" datetime="2020-07-15T19:35:47+08:00">2020-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="官网解释">官网解释</h2>
<h3 id="Qt-ConnectionType">Qt::ConnectionType</h3>
<p>跨线程的信号和槽<br>
Qt支持这些信号槽的连接方式：</p>
<ol>
<li>Auto Connection(默认): 假如信号在一个接收者的线程中发射，则行为等同于 Direct Connect. 否则行为等同于Queued Connection.</li>
<li>Direct Connect: 当信号被发射，槽函数将会被立即调用。槽函数将会在发射者的线程中执行, 而不一定在接收者线程中执行。</li>
<li>Queued Connect: 槽函数在控制权返回到接收者线程的事件循环时被调用。槽函数在接收者线程中被执行。</li>
<li>Blocking Queued Connection: 槽函数除了阻塞当前线程直到槽函数返回，其他像Queued Connection一样被调用。备注：在同一线程中使用这个类型的connect会导致死锁。</li>
<li>Unique Connect: 这个行为等同于Auto Connection，但是这个connection是只能在现有连接不重复的情况下生效。假如相同的信号已经连接到相同的槽函数中，这个连接不会建立且<code>connect()</code>返回<code>false</code>。</li>
</ol>
<ul>
<li>连接的类型可以通过<code>connect()</code>额外的参数指定，注意：在发送者和接收者在不同线程中使用direct connect是不安全的。如同一个事件循环在接收者的线程中，在另一个线程中调用存活对象的任何函数是不安全的。</li>
<li><code>QObject::connect()</code> 它本身是线程安全的。</li>
</ul>
<p>在使用Queue Connection的时候，参数必须是Qt 元对象系统已知的类型，因为Qt需要拷贝入参并保存在事件背后的场景。假如你使用Queue Connection并得到以下错误信息：</p>
<blockquote>
<p>QObject::connect: Cannot queue arguments of type ‘MyType’</p>
</blockquote>
<p>在connection建立之前，调用<code>qRegisterMetaType()</code>去注册数据类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/09/2020-07-09-C++%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/09/2020-07-09-C++%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">C++循环队列的简单实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-09 20:34:47" itemprop="dateCreated datePublished" datetime="2020-07-09T20:34:47+08:00">2020-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">front_</span>(<span class="number">0</span>), <span class="built_in">end_</span>(<span class="number">0</span>) &#123; data_ = <span class="keyword">new</span> T[size]; &#125;</span><br><span class="line">  ~<span class="built_in">queue</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">const</span> queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">queue</span>(queue&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  queue <span class="keyword">operator</span>=(<span class="type">const</span> queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  queue <span class="keyword">operator</span>=(queue&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> front_ == end_; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_full</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> front_ = (end_ + <span class="number">1</span>) % size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data_[front_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((end_ + <span class="number">1</span>) % size_ != front_) &#123;</span><br><span class="line">      data_[end_] = val;</span><br><span class="line">      end_ = (end_ + <span class="number">1</span>) % size_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front_ != end_) &#123;</span><br><span class="line">      front_ = (front_ + <span class="number">1</span>) % size_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">size_t</span> front_;</span><br><span class="line">  <span class="type">size_t</span> end_;</span><br><span class="line">  <span class="type">size_t</span> size_;</span><br><span class="line">  T* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">is_empty</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不采用哨兵值，使用状态来实现">不采用哨兵值，使用状态来实现</h2>
<h2 id="spdlog-循环队列实现">spdlog 循环队列实现</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circular_q</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> max_items_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type head_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type tail_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> overrun_counter_ = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;T&gt; v_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// empty ctor - create a disabled queue with no elements allocated at all</span></span><br><span class="line">  <span class="built_in">circular_q</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">circular_q</span><span class="params">(<span class="type">size_t</span> max_items)</span></span></span><br><span class="line"><span class="function">      : max_items_(max_items + <span class="number">1</span>)  // one item is reserved as marker for full q</span></span><br><span class="line"><span class="function">        ,</span></span><br><span class="line"><span class="function">        v_(max_items_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">circular_q</span>(<span class="type">const</span> circular_q &amp;) = <span class="keyword">default</span>;</span><br><span class="line">  circular_q &amp;<span class="keyword">operator</span>=(<span class="type">const</span> circular_q &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move cannot be default,</span></span><br><span class="line">  <span class="comment">// since we need to reset head_, tail_, etc to zero in the moved object</span></span><br><span class="line">  <span class="built_in">circular_q</span>(circular_q &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">copy_moveable</span>(std::<span class="built_in">move</span>(other));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  circular_q &amp;<span class="keyword">operator</span>=(circular_q &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">copy_moveable</span>(std::<span class="built_in">move</span>(other));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push back, overrun (oldest) item if no room left</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_items_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      v_[tail_] = std::<span class="built_in">move</span>(item);</span><br><span class="line">      tail_ = (tail_ + <span class="number">1</span>) % max_items_;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (tail_ == head_)  <span class="comment">// overrun last item if full</span></span><br><span class="line">      &#123;</span><br><span class="line">        head_ = (head_ + <span class="number">1</span>) % max_items_;</span><br><span class="line">        ++overrun_counter_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return reference to the front item.</span></span><br><span class="line">  <span class="comment">// If there are no elements in the container, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> v_[head_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T &amp;<span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> v_[head_]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return number of elements actually stored</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail_ &gt;= head_) &#123;</span><br><span class="line">      <span class="keyword">return</span> tail_ - head_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> max_items_ - (head_ - tail_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return const reference to item by index.</span></span><br><span class="line">  <span class="comment">// If index is out of range 0…size()-1, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; <span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> v_[(head_ + i) % max_items_];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pop item from front.</span></span><br><span class="line">  <span class="comment">// If there are no elements in the container, the behavior is undefined.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; head_ = (head_ + <span class="number">1</span>) % max_items_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tail_ == head_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// head is ahead of the tail by 1</span></span><br><span class="line">    <span class="keyword">if</span> (max_items_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((tail_ + <span class="number">1</span>) % max_items_) == head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">overrun_counter</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> overrun_counter_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// copy from other&amp;&amp; and reset it to disabled state</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy_moveable</span><span class="params">(circular_q &amp;&amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    max_items_ = other.max_items_;</span><br><span class="line">    head_ = other.head_;</span><br><span class="line">    tail_ = other.tail_;</span><br><span class="line">    overrun_counter_ = other.overrun_counter_;</span><br><span class="line">    v_ = std::<span class="built_in">move</span>(other.v_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put &amp;&amp;other in disabled, but valid state</span></span><br><span class="line">    other.max_items_ = <span class="number">0</span>;</span><br><span class="line">    other.head_ = other.tail_ = <span class="number">0</span>;</span><br><span class="line">    other.overrun_counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李建聪</p>
  <div class="site-description" itemprop="description">在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiancong Li</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
