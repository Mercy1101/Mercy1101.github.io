<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mercy1101.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
<meta property="og:type" content="website">
<meta property="og:title" content="李建聪的博客">
<meta property="og:url" content="https://mercy1101.github.io/page/7/index.html">
<meta property="og:site_name" content="李建聪的博客">
<meta property="og:description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
<meta property="og:locale">
<meta property="article:author" content="李建聪">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mercy1101.github.io/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>李建聪的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李建聪的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/09/19/2020-09-19-C++%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/19/2020-09-19-C++%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B/" class="post-title-link" itemprop="url">C++ 回调函数示例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-19 15:58:09" itemprop="dateCreated datePublished" datetime="2020-09-19T15:58:09+08:00">2020-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-回调函数示例">C++ 回调函数示例</h2>
<p>简单示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">callback</span>(print);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：</p>
<p>Enter: callback()</p>
<p>print()</p>
<p>Leave: callback()</p>
</blockquote>
<p>接下来我们把这两个函数放入类中实现，在调用的时候绑定函数名和其对应实例就可以按以上例子方法调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller control;</span><br><span class="line">  operation op;</span><br><span class="line">  <span class="comment">/// 绑定实例和对应的操作函数</span></span><br><span class="line">  <span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(&amp;operation::print, &amp;op);</span><br><span class="line">  control.<span class="built_in">callback</span>(f);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们把绑定函数对象的过程封装起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_print_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">bind</span>(&amp;operation::print, <span class="keyword">this</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;print()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Leave: callback()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller control;</span><br><span class="line">  operation op;</span><br><span class="line">  control.<span class="built_in">callback</span>(op.<span class="built_in">get_print_function</span>());</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/31/2020-08-31-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/2020-08-31-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(7)数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-31 20:38:47" itemprop="dateCreated datePublished" datetime="2020-08-31T20:38:47+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据结构">数据结构</h2>
<h3 id="字符串">字符串</h3>
<p>字符串是不可变字节(<code>byte</code>)序列，其本身是一个符合结构.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  str unsafe.Pointer</span><br><span class="line">  <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头部指针指向字节数组，但没有<code>NULL</code>结尾。默认以<code>UTF-8</code>编码存储<code>Unicode</code>字符，字面量里允许使用十六进制、八进制和<code>UTF</code>编码格式。</p>
<blockquote>
<p>内置函数<code>len</code>返回字节数组长度，<code>cap</code>不接受字符串类型参数。</p>
</blockquote>
<p>字符串默认值不是<code>nil</code>, 而是<code>&quot;&quot;</code>.</p>
<p>使用<code>for</code>遍历字符串是，分<code>byte</code>和<code>rune</code>两种方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;	<span class="comment">// byte</span></span><br><span class="line">	s:=<span class="string">&quot;李建聪&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, s[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;	<span class="comment">// rune: 返回数组索引号，以及Unicode字符</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///0: [æ]</span></span><br><span class="line"><span class="comment">///1: [</span></span><br><span class="line"><span class="comment">///2: []</span></span><br><span class="line"><span class="comment">///3: [å]</span></span><br><span class="line"><span class="comment">///4: [»]</span></span><br><span class="line"><span class="comment">///5: [º]</span></span><br><span class="line"><span class="comment">///6: [è]</span></span><br><span class="line"><span class="comment">///7: []</span></span><br><span class="line"><span class="comment">///8: [ª]</span></span><br><span class="line"><span class="comment">///0: [李]</span></span><br><span class="line"><span class="comment">///3: [建]</span></span><br><span class="line"><span class="comment">///6: [聪]</span></span><br></pre></td></tr></table></figure>
<p>要修改字符串，须将其转换为可变类型(<code>[]rune</code>或<code>[]byte</code>), 待完成后再转换回来。但不管怎么转换，都须重新分配内存，并复制数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(format <span class="type">string</span>, ptr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p := reflect.ValueOf(ptr).Pointer()</span><br><span class="line">	h := (*<span class="type">uintptr</span>)(unsafe.Pointer(p))</span><br><span class="line">	fmt.Printf(format, *h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;	<span class="comment">// byte</span></span><br><span class="line">	s:=<span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">	pp(<span class="string">&quot;s: %x\n&quot;</span>, &amp;s)</span><br><span class="line"></span><br><span class="line">	bs := []<span class="type">byte</span>(s)</span><br><span class="line">	s2 := <span class="type">string</span>(bs)</span><br><span class="line"></span><br><span class="line">	pp(<span class="string">&quot;string to []byte, bs:%x\n&quot;</span>, &amp;bs)</span><br><span class="line">	pp(<span class="string">&quot;[]byte to string, s2:%x\n&quot;</span>, &amp;s2)</span><br><span class="line"></span><br><span class="line">	rs := []<span class="type">rune</span>(s)</span><br><span class="line">	s3 := <span class="type">string</span>(rs)</span><br><span class="line"></span><br><span class="line">	pp(<span class="string">&quot;string to []byte, rs:%x\n&quot;</span>, &amp;rs)</span><br><span class="line">	pp(<span class="string">&quot;[]byte to string, s3:%x\n&quot;</span>, &amp;s3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// s: 2bcc91</span></span><br><span class="line"><span class="comment">/// string to []byte, bs:c0000a20a0</span></span><br><span class="line"><span class="comment">/// []byte to string, s2:c0000a20b0</span></span><br><span class="line"><span class="comment">/// string to []byte, rs:c0000b80c0</span></span><br><span class="line"><span class="comment">/// []byte to string, s3:c0000a20d0</span></span><br></pre></td></tr></table></figure>
<p>编译器会为了某些场合进行专门优化，避免额外分配和复制操作：</p>
<ul>
<li>将<code>[]byte</code>转换为<code>string key</code>, 去<code>map[string]</code>查询的时候。</li>
<li>将<code>string</code>转换为<code>[]byte</code>, 进行<code>for range</code>迭代时，直接取字节赋值给局部变量。</li>
</ul>
<p>除了类型转换外，动态构建字符串也容易造成性能问题。<br>
用加法操作符拼接字符串时，每次都须重新分配内存。如此，在构建超大字符串时，性能就显得极差。<br>
改进思路时预分配i足够大的空间。常用方法是用<code>string.Join</code>函数，他会统计所有参数长度，并一次性完成内存分配操作。<br>
另外<br>
utf8.ValidString(s) 返回s是不是一个有效的字符串<br>
utf8.RuneCountInString(s) 替代<code>len</code>返回<code>unicode</code>的字符数量</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/27/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(6)方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-27 21:24:47" itemprop="dateCreated datePublished" datetime="2020-08-27T21:24:47+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="方法">方法</h2>
<p>方法是与对象实例绑定的特殊函数。<br>
方法是面向对象编程的基本概念，用于维护和展示对象的自身状态。对象是内敛的，每个实例都有各自不同的独立特征，以属性和方法来暴露对外通信接口。普通函数则专注于算法流程，通过接收参数来完成特定逻辑运算，并返回最终结果。换句话说，方法是有关联的而函数通常没有。<br>
方法和函数定义语法区别，在于前者有前置实例接收参数，编译器以此确定方法所数类型。<br>
可以为当前包，以及除接口和指针以外的任何类型定义方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%#x&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  <span class="built_in">println</span>(a.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// 0x19</span></span><br></pre></td></tr></table></figure>
<p>方法同样不支持重载(<code>overload</code>)。<code>receiver</code>参数名没有限制，按惯例会选用简短有意义的名称。如方法内部并不引用实例，可省略参数名，仅保留类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span></span> test() &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;hi~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法可看作特殊的函数，那么<code>receiver</code>的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> value() &#123;</span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;v: %p, %v\n&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span></span> pointer() &#123;</span><br><span class="line">  (*n)++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;p: %p, %v\n&quot;</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  a.value()</span><br><span class="line">  a.pointer()</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;a: %p, %v\n&quot;</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// v: 0xc8200741c8, 26 /// receiver 被复制</span></span><br><span class="line"><span class="comment">/// p: 0xc8200741c0, 26</span></span><br><span class="line"><span class="comment">/// a: 0xc8200741c0, 26</span></span><br></pre></td></tr></table></figure>
<p>可使用实例值或指针调用方法，编译器会根据方法<code>receiver</code>类型自动在基础类型和指针类型间转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">  p := &amp;a</span><br><span class="line">  a.value()</span><br><span class="line">  a.pointer()</span><br><span class="line">  p.value()</span><br><span class="line">  p.pointer()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// p2 := &amp;p   错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// v: 0xc82999a2c0, 26</span></span><br><span class="line"><span class="comment">/// p: 0xc82999a298, 26</span></span><br><span class="line"><span class="comment">/// v: 0xc82000a2f0, 27</span></span><br><span class="line"><span class="comment">/// v: 0xc82000a298, 27</span></span><br></pre></td></tr></table></figure>
<p>指针类型的<code>receiver</code>必须时合法指针(包括<code>nil</code>), 或能获取实例地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *X)</span></span> test() &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;hi!&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a *X</span><br><span class="line">  a.test()  <span class="comment">///相当于test(nil)</span></span><br><span class="line">  X&#123;&#125;.test()  <span class="comment">/// 错误无法获取地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何选择方法的<code>receiver</code>类型：</p>
<ul>
<li>要修改实例状态，用<code>*T</code></li>
<li>无需修改状态的小对象或固定值，建议用<code>T</code></li>
<li>大对象建议用<code>*T</code>, 以减少复制成本。</li>
<li>引用类型、字符串、函数等指针包装对象，直接用T。</li>
<li>若包含<code>Mutex</code>等同步字段，用<code>*T</code>,避免因复制造成锁操作无效</li>
<li>其他无法确定的情况，都用<code>*T</code></li>
</ul>
<h3 id="匿名字段">匿名字段</h3>
<p>可以访问匿名字段成员那样调用其方法，有编译器负责查找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line">  buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := data()</span><br><span class="line">  d.Lock()  <span class="comment">/// 编译器会处理为 sync.(*Mutex).Lock()调用</span></span><br><span class="line">  <span class="keyword">defer</span> d.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法也会有同名遮蔽问题。但利用这一特性可实现类似(<code>override</code>)操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">  user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun (user) toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m manager)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.user.toString() + <span class="string">&quot;; manager&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> m manager</span><br><span class="line">  <span class="built_in">println</span>(m.toString())</span><br><span class="line">  <span class="built_in">println</span>(m.user.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// user; manager</span></span><br><span class="line"><span class="comment">/// user</span></span><br></pre></td></tr></table></figure>
<p>尽可能直接访问匿名字段的成员和方法，但他们依然不属于继承关系。</p>
<h3 id="方法集">方法集</h3>
<p>类型有一个与之相关的方法集，这决定了它是否实现某个接口。</p>
<ul>
<li>类型<code>T</code>方法集包含所有<code>receiver T</code>方法。</li>
<li>类型<code>*T</code>方法集包含所有<code>recever T</code> + <code>*T</code>方法。</li>
<li>匿名嵌入<code>S</code>, <code>T</code>方法集包含所有<code>receiver S</code>方法。</li>
<li>匿名嵌入<code>*S</code>, <code>T</code>方法集包含所有<code>receiver S</code>+<code>*S</code>方法。</li>
<li>匿名嵌入<code>S</code>或<code>*S</code>, <code>*T</code>方法集包含所有<code>receiver S</code>+<code>*S</code>方法。</li>
</ul>
<p>可利用反射测试这些规则。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">  S <span class="comment">// 匿名嵌入字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span></span> sVal() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*S)</span></span> sPtr() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> tVal() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span></span> tPtr() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodSet</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(a)</span><br><span class="line">  <span class="keyword">for</span> i, n := <span class="number">0</span>, t.NumMethod(); i &lt; n; i++ &#123;</span><br><span class="line">    m := t.Method(i)</span><br><span class="line">    fmt.Println(m.Name, m.Type)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t T</span><br><span class="line">  methodSet(t)  <span class="comment">///&lt; 显示T方法集</span></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;-------&quot;</span>)</span><br><span class="line">  methodSet(&amp;t) <span class="comment">///&lt; 显示*T方法集</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// sVal func(main.T)</span></span><br><span class="line"><span class="comment">/// tVal func(main.T)</span></span><br><span class="line"><span class="comment">/// ---------</span></span><br><span class="line"><span class="comment">/// sPtr func(*main.T)</span></span><br><span class="line"><span class="comment">/// sVal func(*main.T)</span></span><br><span class="line"><span class="comment">/// tPtr func(*main.T)</span></span><br><span class="line"><span class="comment">/// tVal func(*main.T)</span></span><br></pre></td></tr></table></figure>
<p>方法集影响接口实现和方法表达式转换，于通过实例或实例指针调用方法无关。实例并不使用方法集，而是直接调用(或通过隐式字段名).<br>
很显然，匿名字段就是为方法准备的。否则，完全没必要为少写个字段名而大费周折。<br>
面向对象的三大特征&quot;封装&quot;,“继承&quot;和&quot;多态”, Go仅仅实现了部分特征，它更倾向于”组合优于继承“这种思想。将模块分解成相互独立的更小单元，分别处理不同方面的需求，最后以匿名嵌入方式组合到一起，共同实现对外接口。而且其简短一致的调用方式，更是隐藏了内部实现细节。</p>
<blockquote>
<p>组合没有父子依赖，不会破坏封装。且整体和局部松耦合，可任意增加来实现实现扩展。各单元持有单一职责，互无关联，实现和维护更加简单。</p>
</blockquote>
<h3 id="表达式">表达式</h3>
<p>方法和函数一样，除直接调用外还可以赋值给变量，或作为参数传递。依照具体引用方式不同，可分为<code>expression</code>和<code>value</code>两种状态。<br>
通过类型引用<code>Method expression</code>会被还原为普通函数央视，receiver是第一参数，调用时须显示传参。至于类型，可以是<code>T</code>或<code>*T</code>, 只要目标方法集中即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %d&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %d\n&quot;</span>, &amp;n, n)</span><br><span class="line">  f1 := N.test  <span class="comment">///&lt; func(n N)</span></span><br><span class="line">  f1(n)</span><br><span class="line">  f2 := (*N).test <span class="comment">///&lt; func(n *N)</span></span><br><span class="line">  f2(&amp;n)  <span class="comment">///&lt; 按方法集中的签名传递正确类型的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc82000a140, 25</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a158, 25</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a168, 25</span></span><br></pre></td></tr></table></figure>
<p>当然，也可直接以表达式方式调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">  N.test(n)</span><br><span class="line">  (*N).test(&amp;n) <span class="comment">///&lt; 注意： *N 须使用括号，以免语法解析错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于实例或指针引用的<code>method value</code>, 参数签名不会改变，依旧按正常方式调用。<br>
但当<code>method value</code>被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需的<code>receiver</code>对象，与其绑定，以便在稍后执行时，能隐式传入<code>receiver</code>参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %v\n&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  n++</span><br><span class="line">  f1 := n.test  <span class="comment">//&lt; 因为test方法的reveiver是类型,所以复制n, 等于101</span></span><br><span class="line"></span><br><span class="line">  n++</span><br><span class="line">  f2 := p.test  <span class="comment">///&lt; 复制*p, 等于102</span></span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %v\n&quot;</span>, p, n)</span><br><span class="line">  f1()</span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc829976028, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc820076060, 101</span></span><br><span class="line"><span class="comment">/// test.n: 0xc820076060, 102</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器会为method value生成一个包装函数，实现间接调用。至于<code>receiver</code>复制，和闭包的实现方法基本相同，打包成<code>funcval</code>, 经由<code>DX</code>寄存器传递。</p>
</blockquote>
<p>当<code>method value</code>作为参数是，会复制含<code>receiver</code>在内的整个<code>method value</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(m <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">  m()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.h: %p, %v&quot;</span>, p, n)</span><br><span class="line">  n++</span><br><span class="line">  call(n.test)</span><br><span class="line">  n++</span><br><span class="line">  call(p.test)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n 0x82000a288, 100</span></span><br><span class="line"><span class="comment">/// test.n 0x82000a2c0, 101</span></span><br><span class="line"><span class="comment">/// main.n 0x82000a2d0, 102</span></span><br></pre></td></tr></table></figure>
<p>当然，如果目标方法的<code>receiver</code>是指针类型，那么被复制的仅是指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span></span> test() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;test.n: %p, %v\n&quot;</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  p := &amp;n</span><br><span class="line">  n++</span><br><span class="line">  f1 := n.test  <span class="comment">///&lt; 因为test方法的receiver是*N类型, 所以复制&amp;n</span></span><br><span class="line">  n++</span><br><span class="line">  f2 := p.test  <span class="comment">///&lt; 复制p指针</span></span><br><span class="line">  n++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;main.n: %p, %v\n&quot;</span>, p, n)</span><br><span class="line">  f1()  <span class="comment">///&lt; 延迟调用，n == 103</span></span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main.n: 0xc82000a298, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a298, 103</span></span><br><span class="line"><span class="comment">/// test.n: 0xc82000a298, 103</span></span><br></pre></td></tr></table></figure>
<p>只要receiver参数类型正确，使用<code>nil</code>同样可以执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span></span> value() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*N)</span></span> pointer() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p *N</span><br><span class="line">  p.pointer() <span class="comment">// method value</span></span><br><span class="line">  (*N)(<span class="literal">nil</span>).pointer() <span class="comment">// method value</span></span><br><span class="line">  (*N).pointer(<span class="literal">nil</span>) <span class="comment">// method expression</span></span><br><span class="line">  <span class="comment">/// p.value() 错误： invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/26/2020-08-26-C++%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/2020-08-26-C++%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">C++ 二叉树的遍历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-26 21:52:09" itemprop="dateCreated datePublished" datetime="2020-08-26T21:52:09+08:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">c++ 数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前序遍历：</p>
<p>遍历的顺序是：根节点-左节点-右节点</p>
<p>递归代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">order</span>(root);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      s.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<p>遍历的顺序是：左节点-根节点-右节点</p>
<p>递归代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">          res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">order</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          s.<span class="built_in">push</span>(root);</span><br><span class="line">          root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后序遍历：</p>
<p>遍历的顺序是：左节点-右节点-根节点</p>
<p>递归代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(TreeNode*)&gt; order = [&amp;](TreeNode* node)&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;left);</span><br><span class="line">          <span class="built_in">order</span>(node-&gt;right);</span><br><span class="line">          res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">order</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">      std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">      s.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          s.<span class="built_in">pop</span>();</span><br><span class="line">          res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">          s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;right) s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;left) s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/26/2020-08-26-C++%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/2020-08-26-C++%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">C++ 算法题解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-26 21:48:47" itemprop="dateCreated datePublished" datetime="2020-08-26T21:48:47+08:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-leetcode/" itemprop="url" rel="index"><span itemprop="name">c++ leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="排序操作次数">排序操作次数</h2>
<p>题目描述:<br>
有一种排序算法定义如下，该排序算法每次把一个元素提到序列的开头，例如2, 1, 3, 4，只需要一次操作把1提到序列起始位置就可以使得原序列从小到大有序。现在给你个乱序的1-n的排列，请你计算最少需要多少次操作才可以使得原序列从小到大有序。<br>
输入描述</p>
<p>输入第一行包含两个正整数n，表示序列的长度。（1 &lt;= n &lt;= 100000）<br>
接下来一行有n个正整数，表示序列中的n个元素，中间用空格隔开。（1 &lt;= a_i &lt;= n）</p>
<p>输出描述</p>
<p>输出仅包含一个整数，表示最少的操作次数。</p>
<p>样例输入<br>
4<br>
2 1 3 4</p>
<p>样例输出<br>
1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_operation_count</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">sorted</span><span class="params">(vec)</span></span>;</span><br><span class="line">  std::<span class="built_in">sort</span>(sorted.<span class="built_in">begin</span>(), sorted.<span class="built_in">end</span>());</span><br><span class="line">  <span class="type">int</span> p = sorted.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> q = p;</span><br><span class="line">  <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; q &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">at</span>(p) == sorted.<span class="built_in">at</span>(q)) &#123;</span><br><span class="line">      --p;</span><br><span class="line">      --q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; vec.<span class="built_in">at</span>(p) != sorted.<span class="built_in">at</span>(q)) &#123;</span><br><span class="line">        --p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; vec.<span class="built_in">at</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">get_operation_count</span>(vec) &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/2020-08-24-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(5)接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-24 19:40:47" itemprop="dateCreated datePublished" datetime="2020-08-24T19:40:47+08:00">2020-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="接口">接口</h2>
<p>接口代表一种调用契约，是多个方法声明的集合。接口最常见的使用场景，是对包外提供访问，或预留扩展空间。<br>
<code>Go</code>接口的实现机制很简洁，只要目标类型方法集内包含接口声明的全部方法，就被视为实现了该接口，无须做显式声明。当然，目标类型可实现多个接口。<br>
接口：</p>
<ul>
<li>不能有字段</li>
<li>不能定义自己的方法</li>
<li>只能声明方法，不能实现</li>
<li>可嵌入其他接口类型</li>
</ul>
<p>接口通常以<code>er</code>作为名称后缀，方法名是声明组成部分，但参数名可不同或省略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  test()</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>() &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// var t tester = d  ///&lt; 错误</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果接口没有任何声明方法声明，那么就是一个空接口, 他的用途类似面向对象的根类型<code>Object</code>, 可被赋值为任何类型的对象。<br>
接口变量默认值是<code>nil</code>。如果实现接口的类型支持，可做相等运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t1, t2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == <span class="literal">nil</span>, t1 == t2)</span><br><span class="line"></span><br><span class="line">  t1, t2 = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">  t1, t2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// panic: runtime error: comparing uncomparable type map[string]int</span></span><br></pre></td></tr></table></figure>
<p>可以像匿名字段一样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算实现了该接口。<br>
前提是，不能有同名方法, 不能嵌入自身或循环嵌入，那会导致递归错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">  stringer  <span class="comment">///&lt; 嵌入接口</span></span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  t.test()</span><br><span class="line">  <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超集接口变量可隐式转换为子集，反过来不行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(a stringer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(a.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data</span><br><span class="line">  <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">  pp(t) <span class="comment">///&lt; 隐式转换为自己接口</span></span><br><span class="line">  <span class="keyword">var</span> s stringer = t  <span class="comment">///&lt; 超集转换为子集</span></span><br><span class="line">  <span class="built_in">println</span>(s.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持匿名接口类型，可直接用于变量定义，或作为结构字段类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">interface</span> &#123;  <span class="comment">///&lt; 匿名接口类型</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t <span class="keyword">interface</span> &#123; <span class="comment">///&lt; 定义匿名接口变量</span></span><br><span class="line">    <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">  &#125; = data&#123;&#125;</span><br><span class="line"></span><br><span class="line">  n := node&#123;</span><br><span class="line">    data: t,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println</span>(n.data.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行机制">执行机制</h3>
<p>接口执行一个名为<code>itab</code>的结构存储运行期所需的相关类型信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">  tab *itab <span class="comment">///&lt; 类型信息</span></span><br><span class="line">  data unsafe.Pointer <span class="comment">///&lt; 实际对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">  inter *interfacetype  <span class="comment">///&lt; 接口类型</span></span><br><span class="line">  _type *_type  <span class="comment">///&lt; 实际对象类型</span></span><br><span class="line">  fun [<span class="number">1</span>]<span class="type">uintptr</span>  <span class="comment">///&lt; 实际对象方法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关类型信息里保存了接口和实际对象的元数据。同时<code>itab</code>还用<code>fun</code>数组（不定长结构）保存了实际方法地址，从而实现在运行期对目标方法的动态调用。<br>
除此之外，接口还有一个重要特征：将对象赋值给接口变量时，会复制该对象。我们甚至无法修改结构存储的复制品，因为它也是<code>unaddressable</code>的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := data&#123;<span class="number">100</span>&#125;</span><br><span class="line">  vat t <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  p := &amp;t.(data)  <span class="comment">///&lt; 错误</span></span><br><span class="line">  t.(data).x = <span class="number">200</span>  <span class="comment">///&lt; 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便将其复制出来，用本地变量修改后，依然无法对<code>iface.data</code>赋值。解决方法就是将对象指针赋值给接口，那么接口内存存储的就是指针的复制品。<br>
只有当接口变量内部的两个指针(<code>itab</code>, <code>data</code>)都为<code>nil</code>时, 接口才等于<code>nil</code>.</p>
<h3 id="类型转换">类型转换</h3>
<p>类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体地接口类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> String() <span class="type">string</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;data:%d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d data = <span class="number">15</span></span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> n, ok := x.(fmt.Stringer); ok &#123;  <span class="comment">///&lt; 转换为更具体地接口类型</span></span><br><span class="line">    fmt.Println(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> d2, ok := x.(data); ok &#123; <span class="comment">///&lt; 转换回原始类型</span></span><br><span class="line">    fmt.Println(d2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e := x.(<span class="type">error</span>)  <span class="comment">///&lt; 错误： main.data is not error</span></span><br><span class="line">  fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>ok-idiom</code>模式，即便转换失败也不会引发<code>panic</code>。还可用<code>switch</code>语句在多种类型间做出推断匹配，这样空接口就有更多发挥空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;d:%d&quot;</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> v := x(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">      <span class="built_in">println</span>(*v)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">string</span>:</span><br><span class="line">      <span class="built_in">println</span>(v(<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">case</span> fmt.Stringer:</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// d: 100</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示： <code>type switch</code>不支持<code>fallthrought</code></p>
</blockquote>
<h3 id="技巧">技巧</h3>
<p>让编译器检查，确保类型实现了指定接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> x <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">///&lt; 包初始函数</span></span><br><span class="line">  <span class="keyword">var</span> _ fmt.Stringer = x(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义函数类型，让相同签名地函数自动实现某个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncString <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t fmt.Stringer = FuncString(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt. Println(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/2020-08-23-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(4)并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-23 11:17:47" itemprop="dateCreated datePublished" datetime="2020-08-23T11:17:47+08:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发">并发</h2>
<ul>
<li>并发： 逻辑上具备同时处理多个任务的能力。</li>
<li>并行： 物理上在同一时刻执行多个并发任务。<br>
多线程或多进程时并行的基本条件，但单线程也可用协程做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，它也有自己的优势。除了将因阻塞而浪费的时间找回来以外，还免去了线程切换的开销。协程上运行的多个任务本质上是依旧串行的，加上可控自主，所以并不需要做同步处理。<br>
通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源。用协程来提高处理器时间片利用率。</li>
</ul>
<p>简单将<code>goroutine</code>归纳为协程并不合适。运行时创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。这更像是多线程和协程的综合体，能最大限度提升执行效率，发挥多核处理能力。<br>
只须在函数调用前添加<code>go</code>关键字即可创建并发任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(s)</span><br><span class="line">&#125; (<span class="string">&quot;hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>关键字<code>go</code>并非执行并发操作，而是创建一个并发任务单元。新建任务被放置在系统队列中，等待调度器安排合适系统线程去获取执行权。当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。</p>
<p>每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间。相比系统默认<code>MB</code>级别的线程栈，<code>goroutinue</code>自定义栈初始仅须<code>2 KB</code>，所以才能创建成千上万的并发任务。自定义栈采取按需分配策略，在需要时进行扩容，最大能到<code>GB</code>规模。<br>
与<code>defer</code>一样，<code>gorountine</code>也会因&quot;延迟执行&quot;而立即计算并复制执行参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	c++</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">100</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;go:&quot;</span>, x, y)</span><br><span class="line">	&#125;(a, counter())</span><br><span class="line">	a += <span class="number">100</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main:&quot;</span>, a, counter())</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)	<span class="comment">// 等待 `goroutine` 结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main: 200 2</span></span><br><span class="line"><span class="comment">/// go: 100 1</span></span><br></pre></td></tr></table></figure>
<h3 id="Wait">Wait</h3>
<p>进程退出时不会等待并发任务结束，可用管道(<code>channel</code>)阻塞，然后发出退出信号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)	<span class="comment">///&lt; 创建通道。因为仅是通知，数据并没有实际意义</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;goroutine done.&quot;</span>)</span><br><span class="line">		<span class="built_in">close</span>(exit)	<span class="comment">///&lt; 关闭通道</span></span><br><span class="line">	&#125; ()</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">	&lt;-exit	<span class="comment">///&lt; 如通道关闭，立即解除阻塞</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<p>除关闭通道外，写入数据也可解除阻塞。<br>
如要等待多个任务结束，推荐使用<code>sync.WaitGroup</code>。通过设定计数器，让每个<code>goroutine</code>在退出前递减，直至归零时接触阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)	<span class="comment">///&lt; 累加计数</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()	<span class="comment">///&lt; 递减计数</span></span><br><span class="line"></span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;goroutine&quot;</span>, id, <span class="string">&quot;done.&quot;</span>)</span><br><span class="line">		&#125; (i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">	wg.Wait()	<span class="comment">///&lt; 阻塞，直到计数为零</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// main...</span></span><br><span class="line"><span class="comment">/// goroutine 2 done.</span></span><br><span class="line"><span class="comment">/// goroutine 3 done.</span></span><br><span class="line"><span class="comment">/// goroutine 7 done.</span></span><br><span class="line"><span class="comment">/// goroutine 9 done.</span></span><br><span class="line"><span class="comment">/// goroutine 6 done.</span></span><br><span class="line"><span class="comment">/// goroutine 0 done.</span></span><br><span class="line"><span class="comment">/// goroutine 8 done.</span></span><br><span class="line"><span class="comment">/// goroutine 4 done.</span></span><br><span class="line"><span class="comment">/// goroutine 1 done.</span></span><br><span class="line"><span class="comment">/// goroutine 5 done.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>WaitGroup.Add</code>实现了原子操作，但建议在<code>goroutine</code>外累加计数器，以免<code>Add</code>尚未执行，<code>Wait</code>已经退出。<br>
可在多处使用<code>Wait</code>阻塞，他们都能接收到通知</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()	<span class="comment">///&lt; 等待归零，解除阻塞</span></span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;wait exit.&quot;</span>)</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;done.&quot;</span>)</span><br><span class="line">		wg.Done()	<span class="comment">///&lt; 递减计数</span></span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()	<span class="comment">///&lt; 等待归零</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// done.</span></span><br><span class="line"><span class="comment">/// wait exit.</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<h3 id="GOMAXPROCE">GOMAXPROCE</h3>
<p>运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量默认与处理器核数相等，可用<code>runtime.GOMAXPROCS</code>函数(或环境变量)修改。</p>
<h3 id="Local-Storage">Local Storage</h3>
<p>与线程不同，<code>goroutine</code>任务无法设置优先级，无法获取编号，没有局部存储(TLS), 甚至连返回值都会被抛弃。但除优先级外，其他功能都很容易实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> gs [<span class="number">5</span>]<span class="keyword">struct</span> &#123;	<span class="comment">///&lt; 用于实现类似TLS功能</span></span><br><span class="line">		id <span class="type">int</span>	<span class="comment">///&lt; 编号</span></span><br><span class="line">		result <span class="type">int</span>	<span class="comment">///&lt; 返回值</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gs); i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;	<span class="comment">// 使用参数避免闭包延迟求值</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			gs[id].id = id</span><br><span class="line">			gs[id].result = (id + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">		&#125;	(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, gs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [&#123;id:0 result:100&#125; &#123;id:1 result:200&#125; &#123;id:2 result:300&#125; &#123;id:3 result:400&#125; &#123;id:4 result:500&#125;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如使用<code>map</code>作为局部存储容器，建议做同步处理，因为运行时会对其做并发读写检查。</p>
</blockquote>
<h3 id="Gosched">Gosched</h3>
<p>暂停，释放线程去执行其他任务。当前任务被放回队列，等待下次调度时恢复执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;	<span class="comment">/// 让出当前线程，调度执行b</span></span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-exit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0</span></span><br><span class="line"><span class="comment">/// a: 1</span></span><br><span class="line"><span class="comment">/// b</span></span><br><span class="line"><span class="comment">/// a: 2</span></span><br><span class="line"><span class="comment">/// a: 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Goexit">Goexit</h3>
<p><code>Goexit</code>立即终止当前任务，运行时确保所有已注册延迟调用被执行。该函数不会影响其他并发任务，不会引发<code>panic</code>, 自然也就无法捕获。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(exit)	<span class="comment">///&lt; 执行</span></span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)	<span class="comment">///&lt; 执行</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>, <span class="built_in">recover</span>() == <span class="literal">nil</span>)	<span class="comment">///&lt; 执行，recover返回nil</span></span><br><span class="line">			&#125;()</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">///&lt; 在多层调用中执行Goexit</span></span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">			runtime.Goexit()	<span class="comment">///&lt; 立即终止整个调用堆栈</span></span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;c done.&quot;</span>)</span><br><span class="line">		&#125; ()</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;b done.&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;a done.&quot;</span>)	<span class="comment">///&lt; 不会执行</span></span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-exit</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// c</span></span><br><span class="line"><span class="comment">/// b true</span></span><br><span class="line"><span class="comment">/// a</span></span><br><span class="line"><span class="comment">/// main exit.</span></span><br></pre></td></tr></table></figure>
<p>如果在<code>main.main</code>里调用<code>Goexit</code>, 它会等待其他任务结束，然后让进程直接崩溃。<br>
无论身处哪一层，<code>Goexit</code>都能立即终止整个调用堆栈，这与<code>return</code>仅退出当前函数不同。标准库函数<code>os.Exit</code>可终止进程，但不会执行延迟调用。</p>
<h3 id="通道">通道</h3>
<p><code>Go</code>语言并未实现严格的并发安全。<br>
允许全局变量、指针、引用类型这些非安全内存共享操作，就需要开发人员自行维护数据一致和完整性。<code>Go</code>鼓励使用<code>CSP</code>通道，以通信来代替内存共享，实现并发安全。</p>
<blockquote>
<p>CSP: Communicating Sequential Process</p>
</blockquote>
<p>通过消息来避免竞态的模型除了<code>CSP</code>, 还有<code>Actor</code>。但两者由较大区别<br>
作为<code>CSP</code>核心，通道(channel)是显式的，要求操作双方必须知道数据类型和具体通道，并不关心另一端操作者身份和数量。可如果另一端未准备妥当，或消息未能及时处理时，会阻塞当前端。<br>
相比起来，<code>Actor</code>是透明的，它不在乎数据类型及通道，只要知道接收者信箱即可。默认就是异步方式，发送方对消息是否被接收和处理并不关心。</p>
<p>从底层实现上来说，通道知识一个队列。同步模式下，发送和接受双方配对，然后直接赋值数据给对方。如配对失败，则置入等待队列，直到另一方出现后才被唤醒。异步模式抢夺的则是数据缓冲槽。发送方要求有空槽可供写入，而接收方则要求有缓冲数据可读。需求不符时，同样加入缓冲队列，直到有另一方写入数据或腾出空槽后被唤醒。<br>
除传递消息（数据）外，通道还常被用做事件通知。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		s := &lt;-<span class="keyword">chan</span>	<span class="comment">///&lt; 接收消息</span></span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">		<span class="built_in">close</span>(done)	<span class="comment">///&lt; 关闭通道，作为结束通知</span></span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	c &lt;- <span class="string">&quot;hi!&quot;</span> 	<span class="comment">///&lt; 发送消息</span></span><br><span class="line">	&lt;-done			<span class="comment">///&lt; 阻塞，直到有数据或管道关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步模式必须有配对操作的<code>goroutine</code>出现，否则会一直阻塞。而异步模式在缓冲区未满或数据未读完前，不会阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)  <span class="comment">///&lt; 创建带3个缓冲槽的异步通道。</span></span><br><span class="line">  c &lt;- <span class="number">1</span>  <span class="comment">///&lt; 缓冲区未满，不会阻塞</span></span><br><span class="line">  c &lt;- <span class="number">2</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">  <span class="built_in">println</span>(&lt;-c)  <span class="comment">///&lt; 缓冲区不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br></pre></td></tr></table></figure>
<p>多数时候，异步通道有助于提升性能，减少排队阻塞。<br>
缓冲去大小仅是内部属性，不属于类型组成部分。另外通道变量本身就是指针，可用相等操作符判断是否为同一对象或<code>nil</code>。<br>
内置函数<code>cap</code>和<code>len</code>返回缓冲区大小和当前已缓冲数量；而对于同步通道则都返回0；据此可判断通道时同步还是异步</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  b &lt;- <span class="number">1</span></span><br><span class="line">  b &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;a:&quot;</span>, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;b:&quot;</span>, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a: 0 0</span></span><br><span class="line"><span class="comment">/// b: 2 3</span></span><br></pre></td></tr></table></figure>
<h3 id="收发">收发</h3>
<p>除使用简单的发送和接受操作符外，还可用<code>ok-idom</code>或<code>range</code>模式处理数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(done)		<span class="comment">///&lt; 确保发出结束通知</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			x, ok := &lt;-c</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;	<span class="comment">///&lt; 据此判断通道是否被关闭</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">println</span>(x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	c &lt;- <span class="number">2</span></span><br><span class="line">	c &lt;- <span class="number">3</span></span><br><span class="line">	<span class="built_in">close</span>(c)	<span class="comment">///&lt; 及时使用`close`函数关闭通道引发结束通知，否则可能会导致死锁。</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="comment">/// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一次性事件用<code>close</code>效率更好，没有多余开销。连续或多样性事件，可传递不同数据标志实现。还可使用<code>sync.Cond</code>实现单播或广播事件。</p>
</blockquote>
<p>对于<code>closed</code>或<code>nil</code>通道，发送和接收操作都有相应规则：</p>
<ul>
<li>向已关闭通道发送数据，引发<code>panci</code></li>
<li>从已关闭接收数据，返回已缓冲数据或零值。</li>
<li>无论收发，<code>nil</code>通道都会阻塞。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  c &lt;- <span class="number">10</span></span><br><span class="line">  c &lt;- <span class="number">20</span></span><br><span class="line">  <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(c)+<span class="number">1</span>; i++ &#123;</span><br><span class="line">    x, ok := &lt;-c</span><br><span class="line">    <span class="built_in">println</span>(i, <span class="string">&quot;:&quot;</span>, ok, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重复关闭或关闭<code>nil</code>通道都会引发<code>panic</code>错误。</p>
<h3 id="单向">单向</h3>
<p>通道默认时双向的，并不区分发送和接收端。<br>
尽管可用<code>make</code>创建单向通道，但那没有任何意义。通常使用类型装欢来获取单向通道，并分别赋予操作双方。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> recv &#123;</span><br><span class="line">      <span class="built_in">println</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">      send &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能在单向通道上做逆向操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line"></span><br><span class="line">  &lt;-send  <span class="comment">///&lt; 无效操作</span></span><br><span class="line">  recv &lt;- <span class="number">1</span> <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，close不能用于接收端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;- <span class="keyword">chan</span> <span class="type">int</span> = c</span><br><span class="line">  <span class="built_in">close</span>(recv) <span class="comment">///&lt; 无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法将单向通道重新转换回去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">  a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = a</span><br><span class="line">  <span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = a</span><br><span class="line"></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(recv)  <span class="comment">/// 错误</span></span><br><span class="line">  b = (<span class="keyword">chan</span> <span class="type">int</span>)(send)  <span class="comment">/// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择">选择</h3>
<p>如要同时处理多个通道，可选用<code>select</code>语句。它会随机选择一个可用通道做收发操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">///&lt; 接收端</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> (</span><br><span class="line">				name <span class="type">string</span></span><br><span class="line">				x	<span class="type">int</span></span><br><span class="line">				ok <span class="type">bool</span></span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;	<span class="comment">///&lt; 随机选择可用 channel 接收数据</span></span><br><span class="line">			<span class="keyword">case</span> x, ok = &lt;-a:</span><br><span class="line">				name = <span class="string">&quot;a&quot;</span></span><br><span class="line">			<span class="keyword">case</span> x, ok = &lt;-b:</span><br><span class="line">				name = <span class="string">&quot;b&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;	<span class="comment">///&lt; 如果任一通道关闭，则终止接收</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">println</span>(name, x)	<span class="comment">///&lt; 输出接收的数据信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">///&lt; 发送端</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(a)</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(b)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> a &lt;- i:</span><br><span class="line">			<span class="keyword">case</span> b &lt;- i*<span class="number">10</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// a 0</span></span><br><span class="line"><span class="comment">/// b 10</span></span><br><span class="line"><span class="comment">/// a 2</span></span><br><span class="line"><span class="comment">/// a 3</span></span><br><span class="line"><span class="comment">/// a 4</span></span><br><span class="line"><span class="comment">/// a 5</span></span><br><span class="line"><span class="comment">/// b 60</span></span><br><span class="line"><span class="comment">/// a 7</span></span><br><span class="line"><span class="comment">/// a 8</span></span><br><span class="line"><span class="comment">/// a 9</span></span><br></pre></td></tr></table></figure>
<p>如要等全部通道消息处理结束(closed),可将已完成通道设置为<code>nil</code>。这样它就会被阻塞，不再被<code>select</code>选中。<br>
即使是同一通道，也会随机选择<code>case</code>执行。</p>
<p>当所有通道都不可用时，<code>select</code>会执行<code>default</code>语句。如此可避开<code>select</code>阻塞，但须注意处理外层循环，以免陷入空耗。</p>
<h3 id="模式">模式</h3>
<p>通常使用工厂方法将<code>goroutine</code>和通道绑定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> receiver <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.WaitGroup</span><br><span class="line">  data <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newReceiver</span><span class="params">()</span></span> * receiver &#123;</span><br><span class="line">  r := &amp;receiver&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  r.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> r.Done()</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> r.data&#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;recv:&quot;</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := newReceiver()</span><br><span class="line">  r.data &lt;- <span class="number">1</span></span><br><span class="line">  r.data &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(r.data) <span class="comment">///&lt; 关闭通道，发出结束通知</span></span><br><span class="line">  r.Wait()  <span class="comment">///&lt; 等待接收者处理结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于通道本身就是一个并发安全的队列，可用作<code>ID generator</code>、<code>Pool</code>等用途。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type pool chan []<span class="function">byte</span></span><br><span class="line"><span class="function">func <span class="keyword">new</span> <span class="title">Pool</span><span class="params">(cap <span class="type">int</span>)</span> pool </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(chan []byte, cap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">get</span>() []byte &#123;</span><br><span class="line">  var v []byte</span><br><span class="line"></span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> v = &lt;-p: <span class="comment">///&lt; 获取</span></span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 获取失败，则创建</span></span><br><span class="line">      v = <span class="built_in">make</span>([]byte, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span> (p pool) <span class="built_in">put</span>(b []byte) &#123;</span><br><span class="line">  select &#123;</span><br><span class="line">    <span class="keyword">case</span> p &lt;- b:</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">///&lt; 放回失败，放弃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用通道实现信号量(semaphore)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>) <span class="comment">///&lt; 最多允许两个并发同时执行</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">///&lt; acquire: 获取信号</span></span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem&#125;() <span class="comment">///&lt; release: 释放信号</span></span><br><span class="line">      time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">      fmt.Println(id, time.Now())</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库<code>time</code>提供了<code>timeout</code>和<code>tick channel</code>实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second*<span class="number">5</span>):</span><br><span class="line">          fmt.Println(<span class="string">&quot;timeout ...&quot;</span>)</span><br><span class="line">          os.Exit(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">          fmt.Println(time.Now())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  &lt;-(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)  <span class="comment">// 直接用nil channel阻塞进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获<code>INT</code>、<code>TERM</code>信号，顺便实现一个简易的<code>atexit</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exits = &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.RWMutex</span><br><span class="line">  <span class="function"><span class="keyword">func</span> []<span class="title">func</span><span class="params">()</span></span></span><br><span class="line">  signals <span class="keyword">chan</span> os.Signal</span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atexit</span><span class="params">(f <span class="keyword">func</span>()</span></span>)&#123;</span><br><span class="line">  exits.Lock()</span><br><span class="line">  <span class="keyword">defer</span> exits.Unlock()</span><br><span class="line">  exits.funcs = <span class="built_in">append</span>(exits.funcs, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> exits.signals == <span class="literal">nil</span> &#123;</span><br><span class="line">    exits.signals = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(exits.signals, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">  &#125;</span><br><span class="line">  exits.RLock()</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> exits.funcs &#123;</span><br><span class="line">    <span class="keyword">defer</span> f() <span class="comment">///&lt; 即使某些函数panic,延迟调用也能确保后续函数执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  exits.RUnlock()</span><br><span class="line">  &lt;-exit.signals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit1 ...&quot;</span>)&#125;)</span><br><span class="line">  atexit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;exit2 ...&quot;</span>)&#125;)</span><br><span class="line">  waitExit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="资源泄露">资源泄露</h3>
<p>通道可能会引发<code>goroutine leak</code>, 确切的说，是指<code>goroutine</code>处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致他们会在等待队列里长久休眠形成资源泄露。</p>
<h3 id="同步">同步</h3>
<p>标准库<code>sync</code>提供了互斥和读写锁，另有原子操作等，可基本满足日常开发需要。<code>Mutex</code>、<code>RWMutex</code>的使用并不复杂，只有几个地方需要注意。<br>
将<code>Mutex</code>作为匿名字段时，相关方法必须实现为<code>pointer-receiver</code>, 否则会因赋值导致锁机制失效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span></span> test(s <span class="type">string</span>) &#123;</span><br><span class="line">	d.Lock()</span><br><span class="line">	<span class="keyword">defer</span> d.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="built_in">println</span>(s, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d data</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		d.test(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">	&#125;	()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		d.test(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>锁不支持递归锁。</li>
<li>对性能要求较高时，应避免使用<code>defer Unlock</code></li>
<li>读写并发时，用<code>RWMutex</code>性能会更好一些</li>
<li>对单个数据读写保护，可尝试用原子操作</li>
<li>执行严格的测试，尽可能打开数据竞争检查</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/22/2020-08-21-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(3)工作空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-22 19:34:47" itemprop="dateCreated datePublished" datetime="2020-08-22T19:34:47+08:00">2020-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工作空间">工作空间</h2>
<p>依照规范，工作空间由<code>src</code>、<code>bin</code>、<code>pkg</code>三个目录组成。通常需要将空间路径添加到<code>GOPATH</code>环境变量列表中, 以便相关工具能正常工作。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- service/</span><br><span class="line">  |          |</span><br><span class="line">  |          +-- user.go</span><br><span class="line">  |</span><br><span class="line">  +-- bin/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server</span><br><span class="line">  |</span><br><span class="line">  +-- pkg/</span><br><span class="line">       |</span><br><span class="line">       +-- linux_amd64/</span><br><span class="line">            |</span><br><span class="line">            +-- service.a</span><br></pre></td></tr></table></figure>
<p>在工作空间里，包括子包在内的所有源码文件都保存在<code>src</code>目录下。至于<code>bin</code>、<code>pkg</code>两个目录， 其主要影响 <code>go install/get</code>命令，他们会将编译结果(可执行文件或静态库)安装到这两个目录下，以实现增量编译。</p>
<h3 id="环境变量">环境变量</h3>
<p>编译器等相关工具按<code>GOPATH</code>设置的路径搜索目标。也就是说在导入目标库时，排在列表前面的路径比当前工作空间优先级更高。另外，<code>go get</code>默认将下载的第三方包保存到列表中第一个工作空间内。</p>
<p>环境变量<code>GOPATH</code>用于指示工具链和标准库的存放位置。在生成工具链时，相关路径就已经嵌入到可执行文件内，故无需额外设置。<br>
除通过设置<code>GOROOT</code>环境变量覆盖内部路径外，还可移动目录(改名、符号链接等), 或重新编译工具链来解决。<br>
至于<code>GOBIN</code>, 则是强制替代工作空间的<code>bin</code>目录，作为<code>go install</code>目标保存路径。这可避免将所有工作空间的<code>bin</code>路径添加到<code>PATH</code>环境变量当中。</p>
<h3 id="导入包">导入包</h3>
<p>使用标准库或第三方包前，须用<code>import</code>导入，参数是工作空间中以<code>src</code>为起始的绝对路径。编译器从标准库开始搜索，然后依次搜索<code>GOPATH</code>列表中的各个工作空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span> <span class="comment">// 实际路径: /usr/local/go/src/net/http</span></span><br></pre></td></tr></table></figure>
<p>除使用默认包名外，还可使用别名，以解决同名冲突问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> osx <span class="string">&quot;github.com/apple/osx/lib&quot;</span></span><br><span class="line"><span class="keyword">import</span> nix <span class="string">&quot;github.com/linux/lib&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: <code>import</code>导入参数是路径，而非包名。尽管习惯将包和目录名保持一致，但这不是强制规定。在代码中引用包成员时，使用包名而非目录名。</p>
</blockquote>
<p>有四种不同的导入方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>    <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 默认方式: test.A</span></span><br><span class="line"><span class="keyword">import</span> X  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 别名方式: X.A</span></span><br><span class="line"><span class="keyword">import</span> .  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 简便方式: A</span></span><br><span class="line"><span class="keyword">import</span> _  <span class="string">&quot;github.com/Mercy1101/test&quot;</span> <span class="comment">// 初始化方式: 无法引用，仅用来初始化目标包。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不能直接或间接导入自己，不支持任何形式的循环导入。</p>
</blockquote>
<p>未使用的导入(不包括初始化方式)会被编译器视为错误。</p>
<h3 id="相对路径">相对路径</h3>
<p>除工作空间和绝对路径外，部分工具还支持相对路径。可在非工作空间目录下，直接运行、编译一些测试代码。<br>
但在设置了<code>GOPATH</code>的工作空间后相对路径会导致编译失败。<code>go run</code>不受影响。</p>
<h3 id="初始化">初始化</h3>
<p>包内每个源码文件都可定义一到多个初始化函数，但编译器不保证执行次序。<br>
实际上，所有这些初始化函数(包括标准库和导入的第三方包)都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且仅执行一次。</p>
<p>编译器首先确保完成所有全局变量初始化，然后才开始执行初始化函数。直到这些全部结束后，运行时才正式进入<code>main.main</code>入口函数。<br>
可在初始化函数中创建<code>goroutine</code>，或等到它结束执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    fmt.Println(<span class="string">&quot;init:&quot;</span>, time.Now)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  &#125; ()</span><br><span class="line"></span><br><span class="line">  &lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main: &quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在多个初始化函数中引用全局变量，那么最好在变量定义处直接赋值。因无法保证执行次序，所以任何初始化函数中的赋值都有可能&quot;延迟无效&quot;。</p>
<h3 id="内部包">内部包</h3>
<p>内部包机制相当于增加了新的访问权限控制：所有保存在<code>internal</code>目录下的包(包括自身)仅能被其父目录下的包(包含所有子目录) 访问。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- lib/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- internal/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- a/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- b/</span><br><span class="line">  |         +-- x/</span><br><span class="line">  |             |</span><br><span class="line">  |             +-- y/</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>
<p>在<code>lib</code>目录外(比如<code>main.go</code>)导入内部包会引发编译错误。</p>
<blockquote>
<p>导入内部包必须使用完整路径， 例如： import “lib/internal/a”</p>
</blockquote>
<h3 id="依赖管理">依赖管理</h3>
<p>如何使用<code>vendor</code>，专门存放第三方包，实现将源码和依赖完整打包分发。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">  |</span><br><span class="line">  +-- src/</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- main.go</span><br><span class="line">  |    |</span><br><span class="line">  |    +-- server/</span><br><span class="line">  |         |</span><br><span class="line">  |         +-- vendor/</span><br><span class="line">  |         |       |</span><br><span class="line">  |         |       +-- github.com/</span><br><span class="line">  |         |              |</span><br><span class="line">  |         |              +-- mercy1101/</span><br><span class="line">                                  |</span><br><span class="line">                                  +-- test/</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/Mercy1101/test&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  test.Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>main.go</code>中导入<code>github.com/mercy1101/test</code>时，优先使用<code>vendor/github.com/mercy1101/test</code></p>
</blockquote>
<p>导入<code>vendor</code>中的第三方包，参数是以<code>vendor/</code>为起点的绝对路径。这避免了<code>vendor</code>目录位置带来的麻烦，让导入无论使用<code>vendor</code>,还是<code>GOPATH</code>都能保持一致。</p>
<blockquote>
<p>注意：<code>vendor</code>优先级比标准库高</p>
</blockquote>
<p>当多个<code>vendor</code>目录嵌套时，匹配规则如下:<br>
从当前源文件所在目录开始，逐级向上构造<code>vendor</code>全路径，直到发现路径匹配的目标为止。匹配失败，则依旧搜索<code>GOPATH</code></p>
<p>要使用<code>vendor</code>机制，须开启<code>GO15VENDOREXPERIMENT=1</code>环境变量开关(Go 1.6默认开启),且必须设置了<code>GOPATH</code>的工作空间。</p>
<blockquote>
<p>使用<code>go get</code>下载第三方包时，依旧使用<code>GOPATH</code>第一个工作空间，而非<code>vendor</code>目录。当前工具链中并没有真正意义上的包依赖管理，好在由不少第三放工具可选。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/20/2020-08-20-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(2)反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-20 20:13:47" itemprop="dateCreated datePublished" datetime="2020-08-20T20:13:47+08:00">2020-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="反射">反射</h2>
<p>反射能让我们能在运行期探知对象的类型信息和内存结构，同时反射还是实现元编程的重要手段。<br>
Go对象头部并没有类型指针，通过自身是无法在运行期获知任何类型相关信息的。反射操作所需的全部信息都源自接口变量。接口变量除自身存储自身类型外，还会保存实际对象的类型数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个反射入口函数，会将任何传入的对象转换为接口类型。</p>
</blockquote>
<p>在面对类型是，需要区分<code>Type</code>和<code>Kind</code>。前者表示真实类型(静态类型), 后者表示器接触接口(底层类型)类别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X = <span class="number">100</span></span><br><span class="line">  t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">  fmt.Println(t.Name(), t.Kind())</span><br><span class="line">  <span class="comment">/// 输出：X int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := reflect.ArrayOf(<span class="number">10</span>, reflect.TypeOf(<span class="type">byte</span>(<span class="number">0</span>)))</span><br><span class="line">  b := reflect.MapOf(reflect.TypeOf(<span class="string">&quot;&quot;</span>), reflect.TypeOf(<span class="number">0</span>))</span><br><span class="line">  fmt.Println(a, m)</span><br><span class="line">  <span class="comment">/// 输出: [10]uint8 map[string]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法<code>Elem</code>返回指针、数组、切片、字典值或通道的基类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(reflect.TypeOf(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;).Elem())</span><br><span class="line">  fmt.Println(reflect.TypeOf([]<span class="type">int32</span>&#123;&#125;).Elem())</span><br><span class="line">  <span class="comment">/// 输出： int int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有在获取结构体指针的基类型后，才能遍历它的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	user</span><br><span class="line">	title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m manager</span><br><span class="line">	t := reflect.TypeOf(&amp;m)</span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">		t = t.Elem()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Println(f.Name, f.Type, f.Offset)</span><br><span class="line">		<span class="keyword">if</span> f.Anonymous &#123;</span><br><span class="line">			<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; f.Type.NumField(); x++ &#123;</span><br><span class="line">				af := f.Type.Field(x)</span><br><span class="line">				fmt.Println(<span class="string">&quot;  &quot;</span>, af.Name, af.Type)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// user main.user 0</span></span><br><span class="line"><span class="comment">///  name string</span></span><br><span class="line"><span class="comment">///   age int</span></span><br><span class="line"><span class="comment">/// title string 24</span></span><br></pre></td></tr></table></figure>
<p>对于匿名字段，可用多级索引（按定义顺序）直接访问</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m manager</span><br><span class="line">	t := reflect.TypeOf(m)</span><br><span class="line">	name, _ := t.FieldByName(<span class="string">&quot;name&quot;</span>)	<span class="comment">///&lt; 按名称查找</span></span><br><span class="line">	fmt.Println(name.Name, name.Type)</span><br><span class="line"></span><br><span class="line">	age := t.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;)	<span class="comment">///&lt; 按多级索引查找</span></span><br><span class="line">	fmt.Println(age.Name, age.Type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// name string</span></span><br><span class="line"><span class="comment">/// age int</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>FieldByName</code>不支持多级名称，如有同名遮蔽，须通过匿名字段二次获取</p>
</blockquote>
<p>反射能探知当前包或外包的非导出结构成员</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s http.Server</span><br><span class="line">	t := reflect.TypeOf(s)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		fmt.Println(t.Field(i).Name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// Addr</span></span><br><span class="line"><span class="comment">/// Handler</span></span><br><span class="line"><span class="comment">/// TLSConfig</span></span><br><span class="line"><span class="comment">/// ReadTimeout</span></span><br><span class="line"><span class="comment">/// ReadHeaderTimeout</span></span><br><span class="line"><span class="comment">/// WriteTimeout</span></span><br><span class="line"><span class="comment">/// IdleTimeout</span></span><br><span class="line"><span class="comment">/// MaxHeaderBytes</span></span><br><span class="line"><span class="comment">/// TLSNextProto</span></span><br><span class="line"><span class="comment">/// ConnState</span></span><br><span class="line"><span class="comment">/// ErrorLog</span></span><br><span class="line"><span class="comment">/// BaseContext</span></span><br><span class="line"><span class="comment">/// ConnContext</span></span><br><span class="line"><span class="comment">/// inShutdown</span></span><br><span class="line"><span class="comment">/// disableKeepAlives</span></span><br><span class="line"><span class="comment">/// nextProtoOnce</span></span><br><span class="line"><span class="comment">/// nextProtoErr</span></span><br><span class="line"><span class="comment">/// mu</span></span><br><span class="line"><span class="comment">/// listeners</span></span><br><span class="line"><span class="comment">/// activeConn</span></span><br><span class="line"><span class="comment">/// doneChan</span></span><br><span class="line"><span class="comment">/// onShutdown</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>相对<code>reflect</code>而言，当前包和外包都是&quot;外包&quot;</p>
</blockquote>
<p>可用反射提取<code>struct tag</code>, 还能自动分解。其常用于ORM映射, 或数据格式验证。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span> <span class="string">`field:&quot;name&quot; type:&quot;varchar(50)&quot;`</span></span><br><span class="line">	age <span class="type">int</span>	<span class="string">`field:&quot;age&quot; type:&quot;int&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> u user</span><br><span class="line">	t := reflect.TypeOf(u)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %s %s\n&quot;</span>, f.Name, f.Tag.Get(<span class="string">&quot;field&quot;</span>), f.Tag.Get(<span class="string">&quot;type&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: name varchar(50)</span></span><br><span class="line"><span class="comment">/// age: age int</span></span><br></pre></td></tr></table></figure>
<p>辅助判断方法<code>Implements</code>、<code>ConvertibleTo</code>、<code>AssignableTo</code> 都是运行期进行动态调用和赋值所必需的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a X</span><br><span class="line">	t := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implements 不能直接使用类型作为参数，导致这种用法特别别扭</span></span><br><span class="line">	st := reflect.TypeOf((*fmt.Stringer)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">	fmt.Println(t.Implements(st))</span><br><span class="line"></span><br><span class="line">	it := reflect.TypeOf(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(t.ConvertibleTo(it))</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.AssignableTo(st), t.AssignableTo(it))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// true false</span></span><br></pre></td></tr></table></figure>
<h3 id="值">值</h3>
<p>和<code>Type</code>获取类型信息不同， <code>Value</code>专注于对象实例数据读写<br>
接口变量会赋值对象，且时<code>unaddressable</code>的，所以要修改对象就必须使用指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">100</span></span><br><span class="line">  va, vp := reflect.ValueOf(a), reflect.ValueOf(&amp;a).Elem()</span><br><span class="line"></span><br><span class="line">  fmt.Println(va.CanAddr(), va.CanSet())</span><br><span class="line">  fmt.Println(vp.CpnAddr(), va.CanSet())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// false false</span></span><br><span class="line"><span class="comment">/// true true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>就算传入指针，一样需要通过<code>Elem</code>获取目标对象。因为被接口存储的指针本身时不能寻址和进行设置操作的。</p>
</blockquote>
<p>注意：不能对非导出字段进行设置操作，无论是当前包还是外包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	code <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := <span class="built_in">new</span>(User)</span><br><span class="line">	v := reflect.ValueOf(p).Elem()</span><br><span class="line">	name := v.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">	code := v.FieldByName(<span class="string">&quot;code&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;name: canaddr = %v, canset = %v\n&quot;</span>, name.CanAddr(), name.CanSet())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;code: canaddr = %v, canset = %v\n&quot;</span>, code.CanAddr(), code.CanSet())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name.CanSet() &#123;</span><br><span class="line">		name.SetString(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> code.CanAddr() &#123;</span><br><span class="line">		*(*<span class="type">int</span>)(unsafe.Pointer(code.UnsafeAddr())) = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, *p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// name: canaddr = true, canset = true</span></span><br><span class="line"><span class="comment">/// code: canaddr = true, canset = false</span></span><br><span class="line"><span class="comment">/// &#123;Name:Tom code:100&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Value.Pointer</code>和<code>Value.Int</code>等方法类似，将<code>Value.data</code>存储的数据转换为指针，目标必须是指针类型。<br>
而<code>UnsafeAddr</code>返回任何<code>CanAddr Value.data</code>地址（相当于&amp;取地址操作）,比如<code>Elem</code>后的<code>Value</code>, 以及字段成员地址。<br>
以结构体里的指针类型字段为例，<code>Pointer</code>返回该字段所保存的地址，而<code>UnsafeAddr</code>返回该字段本身的地址(结构对象地址+偏移量)</p>
</blockquote>
<p>可通过<code>Interface</code>方法进行类型推断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="type">string</span></span><br><span class="line">		Age <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u := user&#123;</span><br><span class="line">		<span class="string">&quot;q.yuhen&quot;</span>,</span><br><span class="line">		<span class="number">60</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(&amp;u)</span><br><span class="line">	<span class="keyword">if</span> !v.CanInterface() &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;CanInterface: fail.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p, ok := v.Interface().(*user)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;Interface: fail.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.Age++</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// &#123;Name:q.yuhen Age:61&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以直接使用<code>Value.Int</code>、<code>Bool</code>等方法进行类型转换，但失败时会引发<code>panic</code>, 且不支持<code>ok-idiom</code></p>
</blockquote>
<p>复合类型对象设置示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">  v := reflect.ValueOf(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> v.TrySend(reflect.ValueOf(<span class="number">100</span>)) &#123;</span><br><span class="line">    fmt.Println(v.TryRecv())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 100 true</span></span><br></pre></td></tr></table></figure>
<p>接口有两种<code>nil</code>状态，这一致是个潜在麻烦。解决方法是用<code>IsNil</code>判断值是否为<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(a == <span class="literal">nil</span>)</span><br><span class="line">  fmt.Println(b == <span class="literal">nil</span>, reflect.ValueOf(b).IsNil())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false true</span></span><br></pre></td></tr></table></figure>
<p>也可用<code>unsafe</code>转换后直接判断<code>iface.data</code>是否是零值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">  iface := (*[<span class="number">2</span>]<span class="type">uintptr</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">  fmt.Println(iface, iface[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// &amp;[712160 0] true</span></span><br></pre></td></tr></table></figure>
<p>让人很无奈的是, <code>Value</code>里的某些方法并未实现<code>ok-idom</code>或返回<code>error</code>, 所以得自行判断返回的是否为<code>Zero Value</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  v := reflect.ValueOf(<span class="keyword">struct</span>&#123;name <span class="type">string</span>&#125;)</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;name&quot;</span>).IsValid())</span><br><span class="line">  <span class="built_in">println</span>(v.FieldByName(<span class="string">&quot;xxx&quot;</span>).IsValid())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// true</span></span><br><span class="line"><span class="comment">/// false</span></span><br></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<p>动态调用方法，谈不上有多麻烦。只须按<code>In</code>列表准备好所需参数即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Test(x, y <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y, fmt.Errorf(<span class="string">&quot;err: %d&quot;</span>, x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a X</span><br><span class="line">  v := reflect.ValueOf(&amp;a)</span><br><span class="line">  m := MethodByName(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"></span><br><span class="line">  in := []reflect.Value &#123;</span><br><span class="line">    reflect.ValueOf(<span class="number">1</span>),</span><br><span class="line">    reflect.ValueOf(<span class="number">2</span>),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out := m.Call(in)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> out &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="comment">/// err: 3</span></span><br></pre></td></tr></table></figure>
<p>对于变参来书，用<code>CallSlice</code>要更方便一些</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Format(s <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(s, a...)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a X</span><br><span class="line">   v := reflect.ValueOf(&amp;a)</span><br><span class="line">   m := v.MethodByName(<span class="string">&quot;Format&quot;</span>)</span><br><span class="line">   out := m.Call([]reflect.Value&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;x&quot;</span>),</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;100&quot;</span>),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"></span><br><span class="line">   out = m.CallSlice([]reflect.ValueP&#123;</span><br><span class="line">     reflect.ValueOf(<span class="string">&quot;%s = %d&quot;</span>),</span><br><span class="line">     reflect.ValueOf([]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;x&quot;</span>, <span class="number">100</span>&#125;),</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(out)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/// 输出：</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br><span class="line"><span class="comment">/// [x = 100]</span></span><br></pre></td></tr></table></figure>
<h3 id="构建">构建</h3>
<p>反射库提供了内置函数<code>make</code>和<code>new</code>的对应操作，其中最有意思的就是<code>MakeFunc</code>。可用它实现通用模板，使用不同数据类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args []reflect.Value)</span></span> (results []reflect.Value) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret reflect.Value</span><br><span class="line">  <span class="keyword">switch</span> args[<span class="number">0</span>].Kind() &#123;</span><br><span class="line">  <span class="keyword">case</span> reflect.Int:</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">      n += <span class="type">int</span>(a.Int())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = reflect.ValueOf(n)</span><br><span class="line">  <span class="keyword">case</span> reflect.String:</span><br><span class="line">    ss := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> args &#123;</span><br><span class="line">      ss = <span class="built_in">append</span>(ss, s.String())</span><br><span class="line">    &#125;</span><br><span class="line">    ret = reflect.ValueOf(strings.Join(ss, <span class="string">&quot;&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  results = <span class="built_in">append</span>(results, ret)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将函数指针参数指向通用算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAdd</span><span class="params">(fptr <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  fn := reflect.ValueOf(fptr).Elem()</span><br><span class="line">  v := reflect.MakeFunc(fn.Type(), add) <span class="comment">// 这是关键</span></span><br><span class="line">  fn.Set(v) <span class="comment">// 指向通用算法函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> intAdd <span class="function"><span class="keyword">func</span><span class="params">(s, y <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> strAdd <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  makeAdd(&amp;intAdd)</span><br><span class="line">  makeAdd(&amp;strAdd)</span><br><span class="line">  <span class="built_in">println</span>(intAdd(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">  <span class="built_in">println</span>(strAdd(<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot;world!&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 输出:</span></span><br><span class="line"><span class="comment">/// 300</span></span><br><span class="line"><span class="comment">/// hello, world!</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/2020-08-19-%E3%80%8AGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">《Go语言学习笔记》读书笔记(1)测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-19 20:24:47" itemprop="dateCreated datePublished" datetime="2020-08-19T20:24:47+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="11-测试">11. 测试</h2>
<p>标准库自带单元测试框架</p>
<ul>
<li>测试代码须放在当前包以&quot;_test.go&quot;结尾的文件中</li>
<li>测试函数以Test为名称前缀</li>
<li>测试命令(go test) 忽略以&quot;_&quot; 或 “.” 开头的测试文件</li>
<li>正常编译操作(go build/install)会忽略测试文件</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">		x	<span class="type">int</span></span><br><span class="line">		y	<span class="type">int</span></span><br><span class="line">		expect	<span class="type">int</span></span><br><span class="line">	&#125; &#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		actual := add(tt.x, tt.y)</span><br><span class="line">		<span class="keyword">if</span> actual != tt.expect &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;add(%d, %d): expect %d, actual %d&quot;</span>, tt.x, tt.y, tt.expect, actual)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-arg</td>
<td>命令行参数</td>
<td></td>
</tr>
<tr>
<td>-v</td>
<td>输出详细信息</td>
<td></td>
</tr>
<tr>
<td>-parallel</td>
<td>并发执行, 默认执行GOMAXPROCS</td>
<td>-parallel 2</td>
</tr>
<tr>
<td>-run</td>
<td>指定测试函数，正则表达式</td>
<td>-run “Add”</td>
</tr>
<tr>
<td>-timeout</td>
<td>全部测试累计时间超时将引发panic, 默认值为10ms</td>
<td>-timeout 1m30s</td>
</tr>
<tr>
<td>-count</td>
<td>重复测试次数，默认次数为1</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="test-main">test main</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span>&#123;</span><br><span class="line">	<span class="comment">// setup</span></span><br><span class="line">	code := m.Run()	<span class="comment">// 调用测试函数</span></span><br><span class="line">	<span class="comment">// tear down</span></span><br><span class="line">	os.Exit(code)	<span class="comment">// 注意： os.Exit 不会执行defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多测试用例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m * testing.M)</span></span> &#123;</span><br><span class="line">	match := <span class="function"><span class="keyword">func</span><span class="params">(pat, str <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;	<span class="comment">// pat: 命令行参数-run 提供的过滤条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span>	<span class="comment">// str: InternalTest.Name</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tests := []testing.InternalTest &#123;</span><br><span class="line">		&#123;<span class="string">&quot;b&quot;</span>, TestB&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;a&quot;</span>, TestA&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	benchmarks := []testing.InternalBenchmark&#123;&#125;</span><br><span class="line">	examples := []testing.InternalExample&#123;&#125;</span><br><span class="line"></span><br><span class="line">	m = testing.MainStart(match, tests, benchmarks, examples)</span><br><span class="line"></span><br><span class="line">	os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="example">example</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	fmt.Println(add(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// 3</span></span><br><span class="line">	<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果没有output注释，该示例就不会被执行。另外，不能使用内置函数print/printIn, 因为他们输出到stderr</p>
<h3 id="benchmark">benchmark</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go test -bench .</p>
</blockquote>
<p>如果希望仅执行性能测试，那么可以用<code>run=NONE</code>忽略所有测试用例。<br>
性能测试默认以并发方式进行测试，但可用cpu参数设定多个并发限制来观察结果。</p>
<blockquote>
<p>go test -bench . -cpu 1,2,4</p>
</blockquote>
<p>某些耗时的目标，默认循环测试过少，取平均值不足以准确计量性能。可用<code>benchtime</code>设定最小测试时间来增加循环次数，以便返回更准确的结果。</p>
<blockquote>
<p>go test -bench . -benchtime 5s</p>
</blockquote>
<h3 id="timer">timer</h3>
<p>如果在测试函数中要执行一些额外的操作，那么应该临时i组织计时器工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	b.ResetTimer()	<span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">			b.StopTimer()	<span class="comment">// 暂停</span></span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			b.StartTimer()	<span class="comment">// 恢复</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memory">memory</h3>
<p>性能测试查看内存情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heap</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = heap()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go test -bench . -benchmem -gcflags “-N -l” # 禁止内联和优化， 以便观察结果</p>
</blockquote>
<p>也可将测试函数设置为总是输出内存分配信息，无论使用benchmem参数与否</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">BenchmarkHeap</span><span class="params">(b *testing.B)</span> </span>&#123;</span><br><span class="line">	b.<span class="built_in">ReportAllocs</span>()</span><br><span class="line">	b.<span class="built_in">ReportTimer</span>()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = <span class="built_in">heap</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码覆盖率">代码覆盖率</h3>
<blockquote>
<p>go test -cover</p>
</blockquote>
<p>为获取更详细信息，可指定covermode 和coverprofile 参数</p>
<ul>
<li>set: 是否执行</li>
<li>count: 执行次数</li>
<li>atomic: 执行次数，支持并发模式</li>
</ul>
<blockquote>
<p>go test -cover -covermode count -coverprofile cover.out</p>
</blockquote>
<p>还可以在浏览器中查看包括具体的执行次数等信息</p>
<blockquote>
<p>go tool cover -html=cover.out</p>
</blockquote>
<h3 id="性能监控">性能监控</h3>
<p>引发性能问题的原因无外乎执行时间过长、内存占用过多，以及意外阻塞。通过捕获或监控相关执行状态数据，就可定位引发问题的原因，从而针对性改进算法。</p>
<blockquote>
<p>go test -run NONE -bench . -memprofile mem.out -cpuprofile cpu.out net/http</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-cpuprofile</td>
<td>保存执行时间采样到指定文件</td>
<td>-cpuprofile cpu.out</td>
</tr>
<tr>
<td>-memprofile</td>
<td>保存内存分配采样到指定文件</td>
<td>-memprofile mem.out</td>
</tr>
<tr>
<td>-memprofilerate</td>
<td>内存分配采样起始值，默认为512KB</td>
<td>-memprofilerate 1</td>
</tr>
<tr>
<td>-blockprofile</td>
<td>保存阻塞时间采样到指定文件</td>
<td>-blockprofile block.out</td>
</tr>
<tr>
<td>-blockprofilerate</td>
<td>阻塞时间采样起始值，单位为：ns</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果执行性能测试，可能需要设置<code>benchtime</code>参数，以确保有足够的采样时间</p>
<p>可使用交互模式查看，或用命令行直接输出单向结果。</p>
<blockquote>
<p>go tool pprof http.test mem.out<br>
(pprof) top5</p>
</blockquote>
<ul>
<li>flat: 仅当前函数，不包括它调用的其他函数。</li>
<li>sum: 列表前几行所占百分比的总和。</li>
<li>cum: 当前函数调用堆栈累计。</li>
</ul>
<p>top命令可指定排序字段，比如<code>top5 -cum</code><br>
找出需要进一步查看的目标，使用<code>peek</code>命令列出调用来源<br>
也可用list命令输出源码统计样式，以便更直观的定位<br>
除文字模式以外，还可输出svg图形，将其保存或用浏览器查看</p>
<p>在线采集数据须诸如 <code>http/pprof</code>包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用浏览器访问指定路径，就可看到不同的检测项。</p>
<blockquote>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a></p>
</blockquote>
<p>必要时还可抓取数据，进行离线分析。</p>
<blockquote>
<p>curl <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/heap?debug=1">http://localhost:8080/debug/pprof/heap?debug=1</a> &gt; mem.out<br>
go tool pprof test mem.out</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李建聪</p>
  <div class="site-description" itemprop="description">在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiancong Li</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
