<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mercy1101.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jiancong Li&#39;s Blog">
<meta property="og:url" content="https://mercy1101.github.io/page/2/index.html">
<meta property="og:site_name" content="Jiancong Li&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Jiancong Li">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mercy1101.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>Jiancong Li's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jiancong Li's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/27/2023-07-27-AI%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/27/2023-07-27-AI%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">AI 辅助工具探索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-27 09:06:19" itemprop="dateCreated datePublished" datetime="2023-07-27T09:06:19+08:00">2023-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="各类-AI-工具介绍"><a href="#各类-AI-工具介绍" class="headerlink" title="各类 AI 工具介绍"></a>各类 AI 工具介绍</h2><h3 id="问答类产品"><a href="#问答类产品" class="headerlink" title="问答类产品"></a>问答类产品</h3><h4 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a><a target="_blank" rel="noopener" href="https://chat.openai.com/">ChatGPT</a></h4><p>聊天互动式工具（<a target="_blank" rel="noopener" href="https://openai.com/">OpenAI 官网</a>）</p>
<p>该工具是由 <code>OpenAI</code> 公司，基于 <code>GPT-3</code> 模型，开发的一个聊天互动式工具。</p>
<p>目前应用最广的 AI 工具，个人认为回答正确率最高的AI工具。</p>
<p>其分为 ChatGPT-3.5、ChatGPT-4。</p>
<p>ChatGPT-4: ChatGPT-3.5 升级版产品（<a target="_blank" rel="noopener" href="https://openai.com/research/gpt-4">官网介绍</a>)</p>
<p>官方宣传提升了逻辑推理能力，提高了回答正确率（<a target="_blank" rel="noopener" href="https://cdn.openai.com/papers/gpt-4.pdf">GPT-4 Technical Report</a>)</p>
<p>个人体验下来没有感觉到其回答正确率的提升（比如<code>GPT-3.5</code>回答正确率为<code>60%</code>，<code>GPT-4</code>回答正确率类比为<code>70%</code>）</p>
<p>优点：</p>
<ol>
<li>免费使用(ChatGPT-3.5)</li>
<li>回答正确率高</li>
<li>可以提问所有问题</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要翻墙</li>
<li>账号难于注册，账号经常封禁</li>
<li>使用过程中需要反复重新登陆</li>
<li>答案来源不详，无法求证</li>
<li>只能回答 2021年9月前的知识</li>
<li><code>ChatGPT-4</code> 个人使用需要国外信用卡订阅其每月20美元的服务，</li>
<li><code>ChatGPT-4</code> 调用起<code>API</code>进行提问，每个问题约为 0.5元（我曾一周花掉了30美元，但听说最近降价了）</li>
</ol>
<h4 id="chatkit"><a href="#chatkit" class="headerlink" title="chatkit"></a><a target="_blank" rel="noopener" href="https://chatkit.app/">chatkit</a></h4><p><code>ChatGPT</code> 套壳网站（调用 OpenAI 的 api）</p>
<p>优点：</p>
<ol>
<li>无需翻墙，稳定，不存在账号封禁问题</li>
<li>无回答次数限制</li>
<li>可选用多个模型如 <code>ChatGPT-3.5</code>、 <code>ChatGPT-4</code> 或 <code>Claude</code></li>
<li>一次付费永久使用（个人版：30美元，企业版：145美元&#x2F;50台设备）</li>
</ol>
<p>缺点:</p>
<p>使用了3个月，暂无发现缺点，该服务高可用。</p>
<h4 id="New-Bing"><a href="#New-Bing" class="headerlink" title="New Bing"></a><a href="www.bing.com">New Bing</a></h4><p>与 <code>Microsoft Edge</code> 浏览器绑定的类 <code>ChatGPT</code> 工具</p>
<p>优点：</p>
<ol>
<li>提供答案来源链接</li>
<li>使用搜索引擎提供信息，生成答案，具有即时性</li>
<li>免费使用，账号注册简单</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要使用域名转发来规避中国对该网站的封禁</li>
<li>对于编程类问题回答正确率不及 <code>ChatGPT</code> 的一半</li>
<li>必须使用 <code>Microsoft Edge</code> 浏览器打开，或 <code>Chrome</code> 安装插件</li>
</ol>
<h4 id="Google-Bard"><a href="#Google-Bard" class="headerlink" title="Google Bard"></a><a target="_blank" rel="noopener" href="https://bard.google.com/">Google Bard</a></h4><ul>
<li>与 <code>ChatGPT</code> 相同功能的产品</li>
<li>使用过程中，认为没有 <code>ChatGPT</code> 回答正确率高，建议使用 <code>ChatGPT</code> 替代</li>
</ul>
<h4 id="HuggingChat"><a href="#HuggingChat" class="headerlink" title="HuggingChat"></a><a target="_blank" rel="noopener" href="https://huggingface.co/chat/">HuggingChat</a></h4><ul>
<li>与 ChatGPT 相同功能的产品</li>
<li>可以使用中文提问，但回答是英文</li>
</ul>
<h4 id="Claude"><a href="#Claude" class="headerlink" title="Claude"></a><a target="_blank" rel="noopener" href="https://claude.ai/">Claude</a></h4><ul>
<li>与 ChatGPT 相同功能的产品</li>
<li>号称性能远超 ChatGPT (介绍链接： <a target="_blank" rel="noopener" href="https://www.anthropic.com/index/introducing-claude">https://www.anthropic.com/index/introducing-claude</a>)</li>
<li>暂未绕过限制进行访问（被封禁网站）</li>
</ul>
<h4 id="文心一言-https-yiyan-baidu-com-）"><a href="#文心一言-https-yiyan-baidu-com-）" class="headerlink" title="[文心一言]https://yiyan.baidu.com/）"></a>[文心一言]<a target="_blank" rel="noopener" href="https://yiyan.baidu.com/%EF%BC%89">https://yiyan.baidu.com/）</a></h4><ul>
<li>与 ChatGPT 相同功能的产品</li>
<li>之前使用中语意理解上没有 ChatGPT 好</li>
<li>暂未发现其优点</li>
</ul>
<h4 id="通义千问"><a href="#通义千问" class="headerlink" title="通义千问"></a><a target="_blank" rel="noopener" href="https://tongyi.aliyun.com/">通义千问</a></h4><p>与 ChatGPT 相同功能的产品</p>
<p>使用不多，但是比较看好 阿里背后的云平台的算力支撑的AI服务</p>
<h4 id="讯飞星火"><a href="#讯飞星火" class="headerlink" title="讯飞星火"></a><a target="_blank" rel="noopener" href="https://xinghuo.xfyun.cn/">讯飞星火</a></h4><ul>
<li>与 ChatGPT 相同功能的产品</li>
<li>之前被曝出后台调用 ChatGPT 的 API(套壳工具)</li>
<li>回答正确率过低，几乎无法使用</li>
</ul>
<h3 id="工具类-AI-产品"><a href="#工具类-AI-产品" class="headerlink" title="工具类 AI 产品"></a>工具类 AI 产品</h3><h4 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a><a target="_blank" rel="noopener" href="https://github.com/features/copilot">Github Copilot</a></h4><p>代码补全工具。</p>
<p>集成于 VSCode、Vistual Studio 等工具中使用。</p>
<p>用于编程过程中使用，相当于高级的补全工具。</p>
<p>优点：</p>
<ol>
<li>擅长补全通用算法，或开源库接口</li>
<li>可以学习你自己代码的风格，帮你生成代码</li>
<li>可以对于错误的代码给出修正意见</li>
<li>可以对简单函数生成单元测试</li>
<li>可以询问示例代码</li>
</ol>
<p>缺点：</p>
<ol>
<li>对于询问代码，生成单元测试和询问功能，需要通过等待列表，通常需要数周到一个月</li>
<li>业务耦合型代码，它并不擅长</li>
<li>只能询问代码相关问题，不能询问架构或者概念型问题</li>
<li>补全正确率差强人意，仅仅是达到了商用水平</li>
</ol>
<h4 id="ChatPDF"><a href="#ChatPDF" class="headerlink" title="ChatPDF"></a><a target="_blank" rel="noopener" href="https://www.chatpdf.com/">ChatPDF</a></h4><ul>
<li>基于上传文件的信息，来回答你的问题</li>
<li>免费额度，120页、10M以内的PDF，一天 3个文件和50个问题</li>
<li>缺点：</li>
</ul>
<ol>
<li>限制太多</li>
<li>付费需要国外信用卡</li>
<li>答非所问，几乎不可用</li>
</ol>
<h4 id="Chat2Doc"><a href="#Chat2Doc" class="headerlink" title="Chat2Doc"></a><a target="_blank" rel="noopener" href="https://chat2doc.cn/">Chat2Doc</a></h4><ul>
<li>基于上传文件的信息，来回答你的问题，中文支持较好</li>
<li>未试用过无法评价</li>
</ul>
<h3 id="开源类"><a href="#开源类" class="headerlink" title="开源类"></a>开源类</h3><p>开源意味着可本地部署</p>
<h4 id="ChatGLM"><a href="#ChatGLM" class="headerlink" title="ChatGLM"></a><a target="_blank" rel="noopener" href="https://github.com/THUDM/ChatGLM-6B">ChatGLM</a></h4><ul>
<li>开源大语言模型，可本地部署</li>
<li>目前最流行的中文大语言模型，衍生产品有很多</li>
<li>基于中文训练，对中文有较好的性能</li>
<li>使用精简的数据集，本地部署只需6G显存</li>
<li>由于我没有显卡，未尝试过本地部署</li>
</ul>
<h4 id="GPT4ALL"><a href="#GPT4ALL" class="headerlink" title="GPT4ALL"></a><a target="_blank" rel="noopener" href="https://gpt4all.io/index.html">GPT4ALL</a></h4><ul>
<li>可本地部署，不需要显卡</li>
<li>多种模型可选</li>
<li>一键部署，非常轻量化</li>
<li>部分模型不能使用中文提问</li>
<li>试用时，回答速度稍慢，正确率不高，无法使用（后续该技术继续演进，正确率可能得到优化）</li>
</ul>
<h4 id="本草"><a href="#本草" class="headerlink" title="本草"></a><a target="_blank" rel="noopener" href="https://github.com/SCIR-HI/Huatuo-Llama-Med-Chinese">本草</a></h4><p>基于中文医学知识的LLaMA微调模型。</p>
<ul>
<li>医学类问答模型</li>
<li>未试用过</li>
</ul>
<h4 id="ChatLaw"><a href="#ChatLaw" class="headerlink" title="ChatLaw"></a><a target="_blank" rel="noopener" href="https://github.com/PKU-YuanGroup/ChatLaw">ChatLaw</a></h4><p>中文法律问答 AI。</p>
<ul>
<li>法律类问答模型</li>
<li>未试用过</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/24/2023-07-24-GitHub-Copilot%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/24/2023-07-24-GitHub-Copilot%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">GitHub Copilot功能介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-24 10:18:05" itemprop="dateCreated datePublished" datetime="2023-07-24T10:18:05+08:00">2023-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GitHub Copilot是GitHub和OpenAI合作开发的一个人工智能工具，用户在使用Visual Studio Code、Microsoft Visual Studio、Vim、Cursor或JetBrains集成开发环境时可以通过GitHub Copilot自动补全代码。GitHub于2021年6月29日对开公开该软件，GitHub Copilot于技术预览阶段主要面向Python、JavaScript、TypeScript、Ruby和Go等编程语言。</p>
<h2 id="提高编码效率"><a href="#提高编码效率" class="headerlink" title="提高编码效率"></a>提高编码效率</h2><h3 id="按-Tab-键自动补全代码"><a href="#按-Tab-键自动补全代码" class="headerlink" title="按 Tab 键自动补全代码"></a>按 <code>Tab</code> 键自动补全代码</h3><p><img src="/../resource/2023-07-24-Github_Copilot/1-1.gif" alt="1-1"></p>
<h3 id="结构体添加字段后，类内函数补全"><a href="#结构体添加字段后，类内函数补全" class="headerlink" title="结构体添加字段后，类内函数补全"></a>结构体添加字段后，类内函数补全</h3><p><img src="/../resource/2023-07-24-Github_Copilot/1-2.gif" alt="1-2"></p>
<h3 id="C-标准库补全"><a href="#C-标准库补全" class="headerlink" title="C++ 标准库补全"></a>C++ 标准库补全</h3><p><img src="/../resource/2023-07-24-Github_Copilot/1-3.gif" alt="1-3"></p>
<ul>
<li>对比 C++ 标准库手册, 需要阅读繁杂的解释</li>
</ul>
<p><img src="/../resource/2023-07-24-Github_Copilot/Snipaste_2023-07-24_10-48-16.png" alt="image"></p>
<h3 id="使用注释生成补全代码"><a href="#使用注释生成补全代码" class="headerlink" title="使用注释生成补全代码"></a>使用注释生成补全代码</h3><ul>
<li>通用算法</li>
</ul>
<p><img src="/../resource/2023-07-24-Github_Copilot/1-6-1.gif" alt="1-6-1"></p>
<h2 id="为代码生成注释"><a href="#为代码生成注释" class="headerlink" title="为代码生成注释"></a>为代码生成注释</h2><p><img src="/../resource/2023-07-24-Github_Copilot/2-1.gif" alt="2-1"></p>
<p><img src="/../resource/2023-07-24-Github_Copilot/2-1-1.gif" alt="2-1-1"></p>
<h2 id="为函数生成测试用例"><a href="#为函数生成测试用例" class="headerlink" title="为函数生成测试用例"></a>为函数生成测试用例</h2><p><img src="/../resource/2023-07-24-Github_Copilot/1-7.gif" alt="1-7"></p>
<h2 id="开源库学习"><a href="#开源库学习" class="headerlink" title="开源库学习"></a>开源库学习</h2><h3 id="Asio-网络库代码"><a href="#Asio-网络库代码" class="headerlink" title="Asio 网络库代码"></a>Asio 网络库代码</h3><p>文件中包含 <code>asio.hpp</code>, 写出类名即可补全对应开源库的示例代码。</p>
<p><img src="/../resource/2023-07-24-Github_Copilot/1-4-2.gif" alt="1-4-2"></p>
<h3 id="Curl-API-代码"><a href="#Curl-API-代码" class="headerlink" title="Curl API 代码"></a>Curl API 代码</h3><p>使用 <code>Github Copilot</code> 的问答功能可以直接询问代码。</p>
<p><img src="/../resource/2023-07-24-Github_Copilot/1-4-1.gif" alt="1-4-1"></p>
<h2 id="提高代码阅读效率"><a href="#提高代码阅读效率" class="headerlink" title="提高代码阅读效率"></a>提高代码阅读效率</h2><ul>
<li>解释代码</li>
</ul>
<p><img src="/../resource/2023-07-24-Github_Copilot/2-2.gif" alt="2-2"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2022-09-13-C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2022-09-13-C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">C++调试工具函数介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>我们假设人是会出错的，所以我们需要调试找寻 BUG</li>
<li>我们假设框架和流程设计基本正确，所以<strong>找寻问题的时间</strong>远大于<strong>改正问题的时间</strong></li>
<li>我们假设人是懒惰的，所以总是倾向于写更少的代码</li>
</ul>
<p><a href="../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/2022_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA.pptx">PPT</a></p>
<h2 id="调试日志打印类"><a href="#调试日志打印类" class="headerlink" title="调试日志打印类"></a>调试日志打印类</h2><h3 id="转换字符串-to-string"><a href="#转换字符串-to-string" class="headerlink" title="转换字符串 to_string"></a>转换字符串 to_string</h3><p>应用场景: 想要把某种类型转换为字符串</p>
<p>简单的转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br></pre></td></tr></table></figure>

<p>实际中可能用到的转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Integers\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Decimal:\t%i %d %.6i %i %.0i %+i %i\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">-4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hexadecimal:\t%x %x %X %#x\n&quot;</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Octal:\t%o %#o %#o\n&quot;</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Floating point\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Rounding:\t%f %.0f %.32f\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Padding:\t%05.2f %.2f %5.2f\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Scientific:\t%E %e\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hexadecimal:\t%a %A\n&quot;</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure>

<p>因为自己使用占用符可能会出现使用错误(VS 编译检测不出来, g++ 有部分警告), 为了正确和格式的统一现使用统一函数封装</p>
<p>基本类型的重载:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> i)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">short</span> x)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>特殊类型的重载:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 保留两位小数: 输出类似 1.12</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">double</span> d)</span></span>;</span><br><span class="line"><span class="comment">/// 返回字符串: &quot;true&quot; 或 &quot;false&quot;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">bool</span> x)</span></span>;</span><br><span class="line"><span class="comment">/// 重载指针, 输出类似 0x123</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(T* <span class="type">const</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用-string-stream-拼接字符串"><a href="#使用-string-stream-拼接字符串" class="headerlink" title="使用 string_stream 拼接字符串"></a>使用 <code>string_stream</code> 拼接字符串</h3><p>场景: 拼接字符串</p>
<h4 id="C-是如何拼接字符串的"><a href="#C-是如何拼接字符串的" class="headerlink" title="C 是如何拼接字符串的?"></a>C 是如何拼接字符串的?</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ac[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">strcat</span>(ac, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(ac, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(ac, gos::<span class="built_in">to_string</span>(<span class="number">123</span>).<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<h4 id="C-是如何拼接字符串的-1"><a href="#C-是如何拼接字符串的-1" class="headerlink" title="C++ 是如何拼接字符串的?"></a>C++ 是如何拼接字符串的?</h4><p>std::string 怎么实现拼接函数的</p>
<p>&#x2F;&#x2F;&#x2F; 编译错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">str = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;&#x2F; 编译成功</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line"><span class="function">std::string <span class="title">strTemp</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>;</span><br><span class="line">str = <span class="string">&quot;123&quot;</span> + strTemp;</span><br></pre></td></tr></table></figure>

<p>重载 “+” 操作符，实现字符串拼接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string <span class="keyword">operator</span>+(<span class="type">const</span> std::string&amp; strLeft, <span class="type">const</span> std::string&amp; strRight);</span><br></pre></td></tr></table></figure>

<p>调用过程解析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;123&quot;</span> + strTemp;</span><br><span class="line">&lt;=&gt;</span><br><span class="line">str = <span class="keyword">operator</span>+(<span class="string">&quot;123&quot;</span>, strTemp);</span><br><span class="line">&lt;=&gt;</span><br><span class="line">str = <span class="keyword">operator</span>+(std::<span class="built_in">string</span>(<span class="string">&quot;123&quot;</span>), strTemp);</span><br></pre></td></tr></table></figure>

<p>最后的拼接方式为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line"><span class="function">std::string <span class="title">strTemp</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">str = <span class="string">&quot;Hello&quot;</span> + strTemp + gos::<span class="built_in">to_string</span>(i);</span><br><span class="line">&lt;=&gt;</span><br><span class="line">str = (<span class="string">&quot;Hello&quot;</span> + strTemp) + gos::<span class="built_in">to_string</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h4 id="string-stream-是如何拼接字符串的"><a href="#string-stream-是如何拼接字符串的" class="headerlink" title="string_stream 是如何拼接字符串的?"></a><code>string_stream</code> 是如何拼接字符串的?</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gos::string_stream stream;</span><br><span class="line">stream &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;World&quot;</span> &lt;&lt; <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>那么 gos::string_stream 是如何实现的?</p>
<p>查看对象原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string_stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_str += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析调用过程:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gos::string_stream stream;</span><br><span class="line">stream &lt;&lt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&lt;=&gt;</span><br><span class="line">stream.<span class="keyword">operator</span>&lt;&lt;(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="string-stream-对其他复杂类型的处理"><a href="#string-stream-对其他复杂类型的处理" class="headerlink" title="string_stream 对其他复杂类型的处理"></a><code>string_stream</code> 对其他复杂类型的处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 打印 socket 地址</span></span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> SOCKADDR_IN&amp; addr_in);</span><br><span class="line"><span class="comment">/// 打印 PID_T</span></span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> PID_T&amp; stPID);</span><br><span class="line"><span class="comment">/// 打印 vector</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> std::vector&lt;T&gt;&amp; vec);</span><br><span class="line"><span class="comment">/// 打印 二进制数据</span></span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;&amp; vec);</span><br><span class="line"><span class="comment">/// 打印 map</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line">string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> std::map&lt;Key, Value&gt;&amp; map);</span><br></pre></td></tr></table></figure>

<h4 id="string-stream-如何转换为-std-string"><a href="#string-stream-如何转换为-std-string" class="headerlink" title="string_stream 如何转换为 std::string"></a><code>string_stream</code> 如何转换为 std::string</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string_stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-string-stream-打印结构体"><a href="#使用-string-stream-打印结构体" class="headerlink" title="使用 string_stream 打印结构体"></a>使用 <code>string_stream</code> 打印结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以这样打印:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRUCT_T st;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %f&quot;</span>, st.i, st.d);</span><br></pre></td></tr></table></figure>

<p><code>gos::string_stream</code> 如何打印:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; st.i &lt;&lt; st.d;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gos::string_stream stream;</span><br><span class="line">stream &lt;&lt; st;</span><br></pre></td></tr></table></figure>

<p>考虑如下情况:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 该函数是否可行?</span></span><br><span class="line">gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; st.i &lt;&lt; st.d;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; st.i &lt;&lt; st.d;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="string-stream-与-GosLog-的适配"><a href="#string-stream-与-GosLog-的适配" class="headerlink" title="string_stream 与 GosLog 的适配"></a>string_stream 与 GosLog 的适配</h4><h5 id="DBG"><a href="#DBG" class="headerlink" title="DBG"></a><code>DBG</code></h5><p>查看函数定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">format_dbg_string</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> std::string&amp; strName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gos::string_stream stream;</span><br><span class="line">    stream &lt;&lt; strName &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> stream.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* szMsgName = <span class="string">&quot;MsgName&quot;</span>;</span><br><span class="line"><span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;szMsgName: %s&quot;</span>, gos::format_dbg_string(szMsgName, <span class="string">&quot;szMsgName&quot;</span>).<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<p>使用辅助宏定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DBG(x) gos::format_dbg_string(x, std::string(#x)).c_str()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;szMsgName: %s&quot;</span>, gos::format_dbg_string(szMsgName, <span class="string">&quot;szMsgName&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">&lt;=&gt;</span><br><span class="line"><span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;%s&quot;</span>, <span class="built_in">DBG</span>(szMsgName));</span><br></pre></td></tr></table></figure>

<h5 id="DBG-给日志带来的改变"><a href="#DBG-给日志带来的改变" class="headerlink" title="DBG 给日志带来的改变"></a><code>DBG</code> 给日志带来的改变</h5><ol>
<li>省去了输入变量名称的过程, 见下面示例:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GosLog</span>(LOG_ERROR, <span class="string">&quot;CRC error! %s, %s, %s, %s &quot;</span>, <span class="built_in">DBG</span>(ucLocalCRC16_H), <span class="built_in">DBG</span>(ucLocalCRC16_L), <span class="built_in">DBG</span>(ucCRC16_H), <span class="built_in">DBG</span>(ucCRC16_L);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>可以打印任意类型，使用单一占位符<code>%s</code>规避了占位符错误导致的崩溃，见如下示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">1.123456</span>;</span><br><span class="line"><span class="type">char</span>* szMsgName = <span class="string">&quot;AppGetCfgReq&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">GosLog</span>(LOG_ERROR, <span class="string">&quot;%s %s %s %s&quot;</span>, <span class="built_in">DBG</span>(i), <span class="built_in">DBG</span>(d), <span class="built_in">DBG</span>(szMsgName), <span class="built_in">DBG</span>(b));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 输出</span></span><br><span class="line"><span class="number">2022</span><span class="number">-10</span><span class="number">-16</span> <span class="number">0</span>8:<span class="number">0</span>8:<span class="number">43.908</span> [ERROR] [dis] :<span class="built_in">i</span>(<span class="number">123</span>)  <span class="built_in">d</span>(<span class="number">1.12</span>) <span class="built_in">szMsgName</span>(AppGetCfgReq), <span class="built_in">b</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以打印结构体</p>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">STRUCT_T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="keyword">friend</span> gos::string_stream&amp; <span class="keyword">operator</span>&lt;&lt;(gos::string_stream&amp; out, <span class="type">const</span> STRUCT_T&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">&quot;STRUCT_T: &quot;</span> &lt;&lt; <span class="built_in">DBG</span>(&amp;st);</span><br><span class="line">    	out &lt;&lt; <span class="built_in">DBG</span>(st.i);</span><br><span class="line">        out &lt;&lt; <span class="built_in">DBG</span>(st.d);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GosLog</span>(LOG_ERROR,<span class="string">&quot;%s&quot;</span>, <span class="built_in">DBG</span>(st));</span><br><span class="line"><span class="comment">/// 输出</span></span><br><span class="line"><span class="number">2022</span><span class="number">-10</span><span class="number">-16</span> <span class="number">0</span>8:<span class="number">0</span>8:<span class="number">43.908</span> [ERROR] [dis] :STRUCT_T: <span class="number">0x2389472</span> <span class="built_in">i</span>(<span class="number">123</span>)<span class="built_in">d</span>(<span class="number">1.12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="日志流-log-stream"><a href="#日志流-log-stream" class="headerlink" title="日志流 log_stream"></a>日志流 <code>log_stream</code></h3><p>使用 <code>string_stream</code> 实现字符串拼接， 使用析构函数调用打印日志函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">log_stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    log_stream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stream &lt;&lt; data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">log_stream</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_INFO, <span class="string">&quot;%s&quot;</span>, m_stream.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    gos::string_stream m_stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义辅助宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG gos::log_stream() stream</span></span><br><span class="line"></span><br><span class="line">LOG &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure>


<h3 id="异步日志-log-sync"><a href="#异步日志-log-sync" class="headerlink" title="异步日志 log_sync"></a>异步日志 <code>log_sync</code></h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>生产者-消费者模型</p>
<p><a href="../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86.png">异步日志原理</a></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">log_sync</span> : <span class="keyword">public</span> GThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; level, <span class="type">const</span> std::string&amp; strLog)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue.<span class="built_in">push</span>(level, strLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GOS_THREAD_RET <span class="title">ThreadEntry</span><span class="params">(<span class="type">void</span>* pPara)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string strLog = queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">/// 写入文件</span></span><br><span class="line">            <span class="built_in">log_to_file</span>(<span class="string">&quot;%s&quot;</span>, strLog.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><p>测试环境:</p>
<ul>
<li><p>CPU AMD Ryzen 7 PRO 4750U(8核16线程)</p>
</li>
<li><p>16G</p>
</li>
<li><p>固态硬盘</p>
</li>
<li><p>Win11 专业版 22H2</p>
</li>
<li><p>VS2022 C++20 Release</p>
</li>
<li><p>测试框架为 <a target="_blank" rel="noopener" href="https://github.com/google/benchmark">google&#x2F;benchmark</a></p>
</li>
</ul>
<p>在短字符串和4K长度字符串，分别在 1线程、2线程、4线程和8线程下运行结果如下:</p>
<p><code>GosLog</code>:<br><img src="/../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/Benchmark_gos_log.png" alt="gos_log"></p>
<p><code>log_stream</code>:<br><img src="/../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/Benchmark_log_stream.png" alt="log_stream"></p>
<p>性能比较:</p>
<table>
<thead>
<tr>
<th align="center">测试用例</th>
<th align="center">GosLog</th>
<th align="center">log_sync</th>
<th align="center">GosLog&#x2F;log_sync</th>
</tr>
</thead>
<tbody><tr>
<td align="center">短字符串 、 1线程</td>
<td align="center">93.3478k&#x2F;s</td>
<td align="center">20.9662k&#x2F;s</td>
<td align="center">445%</td>
</tr>
<tr>
<td align="center">短字符串 、 2线程</td>
<td align="center">99.8429k&#x2F;s</td>
<td align="center">20.7688k&#x2F;s</td>
<td align="center">408%</td>
</tr>
<tr>
<td align="center">短字符串 、 4线程</td>
<td align="center">47.5319k&#x2F;s</td>
<td align="center">24.1499k&#x2F;s</td>
<td align="center">196%</td>
</tr>
<tr>
<td align="center">短字符串 、 8线程</td>
<td align="center">44.5061k&#x2F;s</td>
<td align="center">23.4319k&#x2F;s</td>
<td align="center">190%</td>
</tr>
<tr>
<td align="center">4K 字符串 、 1线程</td>
<td align="center">35.7577k&#x2F;s</td>
<td align="center">17.9889k&#x2F;s</td>
<td align="center">199%</td>
</tr>
<tr>
<td align="center">4K 字符串 、 2线程</td>
<td align="center">29.3773k&#x2F;s</td>
<td align="center">19.0816k&#x2F;s</td>
<td align="center">153%</td>
</tr>
<tr>
<td align="center">4K 字符串 、 4线程</td>
<td align="center">29.6178k&#x2F;s</td>
<td align="center">17.3948k&#x2F;s</td>
<td align="center">170%</td>
</tr>
<tr>
<td align="center">4K 字符串 、 8线程</td>
<td align="center">32.3738k&#x2F;s</td>
<td align="center">18.317k&#x2F;s</td>
<td align="center">176%</td>
</tr>
</tbody></table>
<p><code>GosLog</code> 在上面测试速度全面领先与 <code>log_steam</code>, 性能高出 <code>1.5</code> 到 <code>4.4</code> 倍。</p>
<p>备注:</p>
<p><img src="/../resource/2021_09_13_C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D_%E6%9D%8E%E5%BB%BA%E8%81%AA/log_stream.png" alt="图片"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点:</p>
<ul>
<li>可以打印大于 4k 的字符串</li>
<li>多线程调用不会串行等待</li>
<li>不会输出到命令行，可以用作详细打印</li>
<li>可以利用 <code>operator&lt;&lt;</code> 打印， 便于快速编写代码</li>
</ul>
<p>缺点:</p>
<ul>
<li>性能远不如 <code>GosLog</code></li>
<li>调用打印和写入文件之间有延迟，在此期间崩溃会导致部分异步日志来不及写入文件</li>
<li>生产者速度过快会导致丢弃部分异步日志</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>详细打印(如结构体内的成员信息), 不会导致 cmd 里刷新过快</li>
<li>所有收发信令打印</li>
<li>数据库数据打印(从数据库中读取到内存时)</li>
<li>渲染视频帧线程打印(不会阻塞当前线程)</li>
</ul>
<h3 id="日志宏"><a href="#日志宏" class="headerlink" title="日志宏"></a>日志宏</h3><h4 id="日志级别辅助宏"><a href="#日志级别辅助宏" class="headerlink" title="日志级别辅助宏"></a>日志级别辅助宏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD gos::log_stream(LOG_DETAIL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI gos::log_stream(LOG_INFO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGW gos::log_stream(LOG_WARN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE gos::log_stream(LOG_ERROR)</span></span><br></pre></td></tr></table></figure>

<h4 id="条件判断日志宏"><a href="#条件判断日志宏" class="headerlink" title="条件判断日志宏"></a>条件判断日志宏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_IF(condition) ((condition) ? (LOG &lt;&lt; #condition &lt;&lt; <span class="string">&quot;, &quot;</span>) : DoNothing()))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">LOG_IF</span>(vec.<span class="built_in">size</span>() &gt; <span class="number">100</span>) &lt;&lt; <span class="string">&quot;vec is too large!&quot;</span>;</span><br><span class="line">&lt;=&gt;</span><br><span class="line"><span class="keyword">if</span>(vec.<span class="built_in">size</span>() &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;vec.size() &gt; 100&quot;</span> &lt;&lt; <span class="string">&quot;vec is too large!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样有日志等级区分:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD_IF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI_IF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGW_IF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE_IF</span></span><br></pre></td></tr></table></figure>

<h4 id="特殊日志宏"><a href="#特殊日志宏" class="headerlink" title="特殊日志宏"></a>特殊日志宏</h4><h5 id="LOG-EVERY-N"><a href="#LOG-EVERY-N" class="headerlink" title="LOG_EVERY_N"></a>LOG_EVERY_N</h5><p>每 N 次打印一次日志</p>
<p>用于一些重复打印，如 ATS 报文每秒钟接收，每一条都打印则日志太多，全不打印则无法从日志中查看当前 ATS 报文是否在正常接收</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 每 60 次打印一次</span></span><br><span class="line"><span class="built_in">LOG_EVERY_N</span>(<span class="number">60</span>) &lt;&lt; <span class="string">&quot;Receive ATS Info!&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="LOG-FIRST-N"><a href="#LOG-FIRST-N" class="headerlink" title="LOG_FIRST_N"></a>LOG_FIRST_N</h5><p>前 N 次打印日志</p>
<p>通常用于程序启动时，确认各个线程是否正常启动，打印前 N 条日志。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 打印前五条日志</span></span><br><span class="line"><span class="built_in">LOG_FIRST_N</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="LOG-ONCE"><a href="#LOG-ONCE" class="headerlink" title="LOG_ONCE"></a>LOG_ONCE</h5><p>只打印第一次的日志</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">While</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 该日志只打印一次</span></span><br><span class="line">    LOG_ONCE &lt;&lt; <span class="string">&quot;Thread is start!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串类与日志类工具函数的演进路线图"><a href="#字符串类与日志类工具函数的演进路线图" class="headerlink" title="字符串类与日志类工具函数的演进路线图"></a>字符串类与日志类工具函数的演进路线图</h3><p>![图片](..&#x2F;resource&#x2F;2021_09_13_C++调试工具函数介绍_李建聪&#x2F;Xmind 1666080438328.png)</p>
<h2 id="时间相关类"><a href="#时间相关类" class="headerlink" title="时间相关类"></a>时间相关类</h2><h3 id="计时器-tick-count"><a href="#计时器-tick-count" class="headerlink" title="计时器 tick_count"></a>计时器 <code>tick_count</code></h3><p>为了更好的记录开始时间和结束时间， 所以封装该对象来记录并获取对应时间间隔的打印。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tick_count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">get_time_string</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 <code>get_time_string()</code> 函数返回 <code>start</code> 到 <code>finish</code> 的间隔时间, 根据时间间隔大小获取的时间单位不同(<code>(s)</code>, <code>(ms)</code>, <code>(us)</code>), 这样打印可以通过搜索 <code>(s)</code> 来快速定位打印了秒级时间的日志。</p>
<h3 id="查看耗时百分比-stop-watch"><a href="#查看耗时百分比-stop-watch" class="headerlink" title="查看耗时百分比 stop_watch"></a>查看耗时百分比 <code>stop_watch</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stop_watch</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">(<span class="type">const</span> std::string&amp; strInfo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/// 在消息容器中，记录信息和时间间隔</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">stop_watch</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        tick.<span class="built_in">finish</span>(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">        <span class="comment">/// 遍历消息容器，并打印其间隔时间和百分比</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用方式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gos::stop_watch sw;</span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">tick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    st.<span class="built_in">tick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    st.<span class="built_in">tick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会出现如下日志:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2022-10-18 16:45:36.796] time:   5 (us), percent:  0.18% info: 1  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] time:   1 (us), percent:  0.04% info: 2  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] time:   2 (ms), percent: 99.74% info: 3  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] time:   1 (us), percent:  0.04% info: finish  &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br><span class="line">[2022-10-18 16:45:36.796] Total Time: 2ms, info: finish &lt;Function: AppRegisterDataManager::OnLoadRegisterInfoRsp, File: AppRegisterDataManager.cpp:17&gt;</span><br></pre></td></tr></table></figure>

<p>根据百分比找出耗时占比最高的代码片段, 为优化提供思路</p>
<h3 id="记录起止时间-interval-time-factory"><a href="#记录起止时间-interval-time-factory" class="headerlink" title="记录起止时间 interval_time_factory"></a>记录起止时间 <code>interval_time_factory</code></h3><p>为了灵活的获取间隔的时间，把 <code>interval_time</code> 做了一个单例用来全局查看时间间隔。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interval_time_factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">const</span> std::string&amp; strKey)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_interval_time.<span class="built_in">insert</span>(gos::<span class="built_in">to_string</span>(p), <span class="built_in">gos_get_uptime_1us</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(<span class="type">const</span> std::string&amp; strKey)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(<span class="string">&quot;%s interval time is %d&quot;</span>, strKey.<span class="built_in">c_str</span>(), m_interval_time[strKey]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// key: 唯一主键, value: 间隔时间记录对象</span></span><br><span class="line">    std::map&lt;std::string, interval_time&gt; m_interval_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    interval_time_factory::<span class="built_in">GetInstance</span>().<span class="built_in">start</span>(gos::<span class="built_in">to_string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    interval_time_factory::<span class="built_in">GetInstance</span>().<span class="built_in">finish</span>(gos::<span class="built_in">to_string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f2</span>();</span><br></pre></td></tr></table></figure>

<p>在日志中即可查看该指针从 <code>new</code> 到 <code>delete</code> 所经过的时间。</p>
<p>应用场景举例:</p>
<p>如视频帧从回调函数进入播放队列，到从队列 <code>pop</code> 后渲染完成后执行 <code>delete</code>, 为了记住该视频帧从回调函数到最终渲染的延迟时间。</p>
<h3 id="对象实例个数-object-counter"><a href="#对象实例个数-object-counter" class="headerlink" title="对象实例个数 object_counter"></a>对象实例个数 <code>object_counter</code></h3><p>用与查看某个对象当前存活的实例有几个.</p>
<p>原理为: 在构造函数中计数加一，析构函数中计数减一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> gos::object_counter</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">object obj0;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; obj<span class="number">0.</span><span class="built_in">get_count</span>();  <span class="comment">///&lt; 1</span></span><br><span class="line">&#123;</span><br><span class="line">    object obj1;</span><br><span class="line">    std::cout &lt;&lt; obj<span class="number">1.</span><span class="built_in">get_count</span>();  <span class="comment">///&lt; 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; obj<span class="number">0.</span><span class="built_in">get_count</span>();  <span class="comment">///&lt; 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对象存活时间-object-live-time"><a href="#对象存活时间-object-live-time" class="headerlink" title="对象存活时间 object_live_time"></a>对象存活时间 <code>object_live_time</code></h3><p>用于查看某个对象，构造函数到析构函数的时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> gos::object_live_time</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    object obj;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">/// obj 在此处调用析构函数</span></span><br></pre></td></tr></table></figure>

<p>在日志中可以查看该对象的存活时间</p>
<h2 id="性能调优类"><a href="#性能调优类" class="headerlink" title="性能调优类"></a>性能调优类</h2><h3 id="判断函数执行时间-PROFILER"><a href="#判断函数执行时间-PROFILER" class="headerlink" title="判断函数执行时间 PROFILER"></a>判断函数执行时间 <code>PROFILER</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT64 iStart = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line">    ...</span><br><span class="line">    INT64 iFinish = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;f is spend time: %lld&quot;</span>, iFinish - iStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">profiler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">profiler</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        INT64 iStart = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">profiler</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        INT64 iFinish = <span class="built_in">gos_get_uptime_1us</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GosLog</span>(LOG_DETAIL, <span class="string">&quot;f is spend time: %lld&quot;</span>, iFinish - iStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    INT64 iStart;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义辅助宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROFILER() profiler(__FILE__, __FUNCTION__, __LINE__)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>PROFILER()</code> 宏定义了一个临时变量，函数析构则该临时变量析构，所以该宏定义计算的是从该宏定义开始，到该函数结束的时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PROFILER</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但同时应注意, 不能在同一作用域调用两次该宏定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PROFILER</span>();</span><br><span class="line">    <span class="built_in">PROFILER</span>(); <span class="comment">///&lt; 编译错误, 重定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断内存泄漏-MEMORY-CHECK"><a href="#判断内存泄漏-MEMORY-CHECK" class="headerlink" title="判断内存泄漏 MEMORY_CHECK"></a>判断内存泄漏 <code>MEMORY_CHECK</code></h3><p>该宏定义依赖于 <code>Windows</code> 的系统函数。(<code>Linux</code> 和 <code>C++ Builder</code> 中无法使用)</p>
<p>具体实现也是在构造函数中记录当前程序使用的内存数， 析构函数中记录内存差值后打印是否内存泄漏。</p>
<h2 id="业务辅助类"><a href="#业务辅助类" class="headerlink" title="业务辅助类"></a>业务辅助类</h2><h3 id="区间求值函数-clamp"><a href="#区间求值函数-clamp" class="headerlink" title="区间求值函数 clamp"></a>区间求值函数 <code>clamp</code></h3><p>实现功能:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">clamp</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value, <span class="type">const</span> <span class="type">int</span>&amp; low, <span class="type">const</span> <span class="type">int</span>&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value &lt; low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 数值小于下界， 返回下界值</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(height &lt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 数值大于上界， 返回上界值</span></span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 返回原始值</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Conf.<span class="built_in">GetValue</span>(<span class="string">&quot;max_timeout&quot;</span>, iMaxTimeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断配置项是否配置超出范围</span></span><br><span class="line"><span class="built_in">LOG_IF</span>(iMaxTimeout != gos::<span class="built_in">clamp</span>(iMaxTimeout, <span class="number">0</span>, <span class="number">3600</span>) &lt;&lt; <span class="string">&quot;config is out of range!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 或者自动限制范围</span></span><br><span class="line">iMaxTimeout = gos::<span class="built_in">clamp</span>(iMaxTimeout, <span class="number">0</span>, <span class="number">3600</span>);</span><br></pre></td></tr></table></figure>

<h3 id="心跳业务类-heartbeat"><a href="#心跳业务类-heartbeat" class="headerlink" title="心跳业务类 heartbeat"></a>心跳业务类 <code>heartbeat</code></h3><p>把心跳业务封装成对象，用于其他业务调用.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">heartbeat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">heartbeat</span>(<span class="type">int</span> max_time_ms);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">live</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">is_live</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 最大超时时间为 3s</span></span><br><span class="line"><span class="function">heartbeat <span class="title">obj</span><span class="params">(<span class="number">3000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// app 心跳消息来了</span></span><br><span class="line">obj.<span class="built_in">live</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// app 心跳消息来了</span></span><br><span class="line">obj.<span class="built_in">live</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在定时器中定期轮询</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">timer</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="built_in">is_live</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超时业务类-timeout"><a href="#超时业务类-timeout" class="headerlink" title="超时业务类 timeout"></a>超时业务类 <code>timeout</code></h3><p>把超时业务封装成对象，用于其他业务调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">timeout</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">timeout</span>(<span class="type">int</span> max_time_ms) : <span class="built_in">m_heartbeat</span>(max_time_ms)</span><br><span class="line">    &#123;</span><br><span class="line">        m_heartbeat.<span class="built_in">live</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_timeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !m_heartbeat.<span class="built_in">is_live</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    gos::heartbeat m_heartbeat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请呼业务呼入时, 定义 60s 超时的对象</span></span><br><span class="line"><span class="function">timeout <span class="title">obj</span><span class="params">(<span class="number">60</span> * <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定时器轮询</span></span><br><span class="line"><span class="keyword">if</span>(obj.<span class="built_in">is_timeout</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模糊比较-approx-与-float-approx"><a href="#模糊比较-approx-与-float-approx" class="headerlink" title="模糊比较 approx 与 float_approx"></a>模糊比较 <code>approx</code> 与 <code>float_approx</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">approx</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">approx</span>(<span class="type">const</span> <span class="type">int64_t</span>&amp; anchor, <span class="type">const</span> <span class="type">int64_t</span>&amp; diff) : <span class="built_in">m_anchor</span>(anchor), <span class="built_in">m_diff</span>(diff) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 判断数值是否与本对象定义的数值相近, 数值在 [m_anchor - m_diff, m_anchor + m_diff] 返回真</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> <span class="type">int64_t</span>&amp; number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">abs</span>(number - m_anchor) &lt;= m_diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int64_t</span> m_anchor;  <span class="comment">///&lt; 用于比较的锚点值</span></span><br><span class="line">    <span class="type">int64_t</span> m_diff;    <span class="comment">///&lt; 浮动的数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gos::tick_count timer;</span><br><span class="line">timer.<span class="built_in">start</span>();  <span class="comment">///&lt; 计时开始</span></span><br><span class="line"><span class="built_in">gos_sleep_ms</span>(<span class="number">20</span>);</span><br><span class="line">timer.<span class="built_in">finish</span>(); <span class="comment">///&lt; 计时结束</span></span><br><span class="line"><span class="type">int</span> time = timer.<span class="built_in">get_ms</span>();</span><br><span class="line"><span class="comment">/// 判断时间间隔是否在 20 正负 1 的范围</span></span><br><span class="line"><span class="keyword">if</span>(gos::<span class="built_in">approx</span>(<span class="number">20</span>, <span class="number">1</span>).<span class="built_in">equal</span>(time))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥量辅助类-lock-guard"><a href="#互斥量辅助类-lock-guard" class="headerlink" title="互斥量辅助类 lock_guard"></a>互斥量辅助类 <code>lock_guard</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lock_guard</span>(gos::mutex&amp; mutex) : <span class="built_in">m_mutex</span>(mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">lock_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    gos::mutex&amp; m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑如下情况:</p>
<ol>
<li>多个函数返回</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gos::mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard</span><span class="params">(mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>返回语句中有被保护数据的读写</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>抛出异常</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard</span><span class="params">(mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        queue.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>多个锁</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gos::mutex mutex1;</span><br><span class="line">gos::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(condition)</span><br><span class="line">   &#123;</span><br><span class="line">   		<span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">std::lock_guard&lt;gos::mutex&gt; <span class="title">guard2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取更新数据的-GetDifferenceBetweenVector"><a href="#获取更新数据的-GetDifferenceBetweenVector" class="headerlink" title="获取更新数据的 GetDifferenceBetweenVector"></a>获取更新数据的 <code>GetDifferenceBetweenVector</code></h3><p>为了比较新旧数据，增加、删除或更新的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           获取新旧两个 vector, 需要添加的元素，需要删除的元素，和重复的元素</span></span><br><span class="line"><span class="comment"> * @param           vecOld    [in]  旧数据</span></span><br><span class="line"><span class="comment"> * @param           vecNew    [in]  新数据</span></span><br><span class="line"><span class="comment"> * @param           vecAdd    [out] 需要添加的元素</span></span><br><span class="line"><span class="comment"> * @param           vecDel    [out] 需要删除的元素</span></span><br><span class="line"><span class="comment"> * @param           vecUnion  [out] 需要更新的元素</span></span><br><span class="line"><span class="comment"> * @return          true</span></span><br><span class="line"><span class="comment"> * @return          false</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @date            2022-06-02 13:50:34</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">GetDifferenceBetweenVector</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; vecOld, <span class="type">const</span> std::vector&lt;T&gt;&amp; vecNew,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       std::vector&lt;T&gt;&amp; vecAdd, std::vector&lt;T&gt;&amp; vecDel, std::vector&lt;T&gt;&amp; vecUnion)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用场景: ATS 数据更新线路图:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetDifferenceBetweenVector</span>(vecOldATS, vecNewATS, vecAdd, vecDel, vecUnion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; vecAdd.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 创建列车图标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; vecDel.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 删除列车图标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; vecUnion.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 更新列车图标位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊字符转义函数-EscapeCharUtility"><a href="#特殊字符转义函数-EscapeCharUtility" class="headerlink" title="特殊字符转义函数 EscapeCharUtility"></a>特殊字符转义函数 <code>EscapeCharUtility</code></h3><p>我们已知 GJson 是无法解析带有， <code>&quot;</code>、<code>\&quot;</code>、<code>,&#125;</code>, 但是保存调度台短信历史的时候，短信内容可能包含这些特殊字符。</p>
<p>如 <code>&quot;</code> 转换为 <code>%quotes;</code>、 <code>\</code> 转换为 <code>%backslash;</code></p>
<p>所以采用把特殊字符转换为特定的字符串，再转换成 json 字符串，到服务器后解析出来再替换回来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 特殊字符转码</span></span><br><span class="line">gos::<span class="built_in">EncodeEscapeChar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 特殊字符解码</span></span><br><span class="line">gos::<span class="built_in">DecodeEscapeChar</span>();</span><br></pre></td></tr></table></figure>

<h3 id="输入字符串检查对象-input-check"><a href="#输入字符串检查对象-input-check" class="headerlink" title="输入字符串检查对象 input_check"></a>输入字符串检查对象 <code>input_check</code></h3><p>使用场景:</p>
<p>用户输入某个字符串，该字符串需要符合某种规则。</p>
<ul>
<li>所有字符是数字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sz != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*sz &lt; <span class="number">0</span> || *sz &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有字符是 <code>a~z</code>、 <code>A~Z</code> 和 <code>0~9</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sz != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(*sz))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如 <code>MAC</code> 地址中可能会出现 十六进制字符的间隔符号可能为 ‘:’、’-‘ 或者 ‘ ‘</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sz != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*sz != <span class="string">&#x27;:&#x27;</span> &amp;&amp; *sz != <span class="string">&#x27;-&#x27;</span> &amp;&amp; *sz != <span class="string">&#x27; &#x27;</span> &amp;&amp; !(*sz &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *sz &lt;= <span class="string">&#x27;f&#x27;</span>) &amp;&amp; !(*sz &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *sz &lt;= <span class="string">&#x27;F&#x27;</span>) &amp;&amp;</span><br><span class="line">            !(*sz &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *sz &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>强密码, 要求字符串中有数字、大小写字母和特殊符号</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">char</span>* sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((遍历一遍，查看是否拥有至少一个数字字符)</span><br><span class="line">        &amp;&amp; (遍历一遍, 查看是否拥有至少一个大写字母)</span><br><span class="line">        &amp;&amp; (遍历一遍, 查看是否拥有至少一个小写字母)</span><br><span class="line">        &amp;&amp; (遍历一遍, 查看是否有至少一个数字字符))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些函数中，抽象出来了集中规则。</p>
<ul>
<li>字符符合某种规则(如数字、十六进制字符)</li>
<li>字符串中所有字符，全部符合、全部不符合和部分符合规则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 假如每个字符都符合特定规则(字符为数字)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all_of</span>(str, IsNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNumber</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FUNC)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, FUNC pF)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = str.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pF</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all_of</span>(str, IsNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsUpcaseLetter</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">any_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, FUNC pF)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 这个字符串有任一大写字母 且 有任一数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any_of</span>(str, IsUpcaseLetter) &amp;&amp; <span class="built_in">any_of</span>(str, IsNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<p><code>input_check</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gos::input_check filter;</span><br><span class="line">    filter.<span class="built_in">AddRules</span>(any_of, IsNumber).<span class="built_in">AddRules</span>(any_of, IsUpcastLetter);</span><br><span class="line">    <span class="keyword">return</span> filter.<span class="built_in">IsValid</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="json-解析对象接口"><a href="#json-解析对象接口" class="headerlink" title="json 解析对象接口"></a><code>json</code> 解析对象接口</h3><p>定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">json_parser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 虚析构函数, 防止内存泄漏</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">json_parser</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 结构体转 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Json 字符串转结构体</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> json_parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::string str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 结构体转 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GJsonParam Param;</span><br><span class="line"></span><br><span class="line">        Param.<span class="built_in">Add</span>(<span class="string">&quot;int&quot;</span>, i);</span><br><span class="line">        Param.<span class="built_in">Add</span>(<span class="string">&quot;string&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">        strJson = Param.<span class="built_in">GetString</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GJson Json;</span><br><span class="line">        <span class="keyword">return</span> Json.<span class="built_in">Parse</span>(str) &amp;&amp; Json.<span class="built_in">GetValue</span>(<span class="string">&quot;int&quot;</span>, i) &amp;&amp; Json.<span class="built_in">GetValue</span>(<span class="string">&quot;string&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">object obj;</span><br><span class="line"></span><br><span class="line">std::string strJson;</span><br><span class="line"><span class="comment">/// 获取 json 字符串</span></span><br><span class="line">obj.<span class="built_in">StructToJson</span>(strJson);</span><br><span class="line"><span class="comment">/// 发送消息</span></span><br><span class="line"><span class="built_in">SendMsg</span>(strJson);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">json_parser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 结构体转 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Json 字符串转结构体</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 转化结构体数组到 Json 字符串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VectorToJson</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt; &amp;vec, std::string &amp;str)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 转换 Json 字符串到结构体数组</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">JsonToVector</span><span class="params">(<span class="type">const</span> std::string &amp;strFormatString, std::vector&lt;T&gt; &amp;vec)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span> : <span class="keyword">public</span> json_parser&lt;object&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">StructToJson</span><span class="params">(std::string &amp;str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">JsonToStruct</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;object&gt; vecObj;</span><br><span class="line"></span><br><span class="line">object ObjTemp;</span><br><span class="line">std::string strJson;</span><br><span class="line"><span class="comment">/// 数组 转换 json</span></span><br><span class="line">ObjTemp.<span class="built_in">VectorToJson</span>(vecObj, strJson);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// json 转换 数组</span></span><br><span class="line">ObjTemp.<span class="built_in">JsonToStruct</span>(strJson, vecObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="附加介绍-智能指针"><a href="#附加介绍-智能指针" class="headerlink" title="附加介绍: 智能指针"></a>附加介绍: 智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : <span class="built_in">pCount</span>(<span class="keyword">new</span> <span class="type">int</span>), <span class="built_in">p</span>(pData)</span><br><span class="line">    &#123;</span><br><span class="line">        *pCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        pCount = stOther.pCount;</span><br><span class="line">        pData = stOther.pData;</span><br><span class="line"></span><br><span class="line">        ++(*pCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        --(*pCount);</span><br><span class="line">        <span class="keyword">if</span>(*pCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> pCount;</span><br><span class="line">            <span class="keyword">delete</span> pData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* pCount;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr obj0; <span class="comment">///&lt; pCount == 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr obj1 = stOther; <span class="comment">///&lt; pCount == 2</span></span><br><span class="line">    &#125; <span class="comment">///&lt; obj1 析构, pCount == 1</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">///&lt;  obj0 析构, pCount 自减为 0, 执行 delete 操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2022-12-23-C++%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2022-12-23-C++%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E6%B1%A0/" class="post-title-link" itemprop="url">C++ 实现高性能内存池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 C&#x2F;C++ 中，内存管理是一个非常棘手的问题，我们在编写一个程序的时候几乎不可避免的要遇到内存的分配逻辑，这时候随之而来的有这样一些问题：是否有足够的内存可供分配? 分配失败了怎么办? 如何管理自身的内存使用情况? 等等一系列问题。在一个高可用的软件中，如果我们仅仅单纯的向操作系统去申请内存，当出现内存不足时就退出软件，是明显不合理的。正确的思路应该是在内存不足的时，考虑如何管理并优化自身已经使用的内存，这样才能使得软件变得更加可用。本次项目我们将实现一个内存池，并使用一个栈结构来测试我们的内存池提供的分配性能。最终，我们要实现的内存池在栈结构中的性能，要远高于使用 <code>std::allocator</code> 和 <code>std::vector</code>.</p>
<ul>
<li>C++ 中的内存分配器 <code>std::allocator</code></li>
<li>内存池技术</li>
<li>手动实现模板链式栈</li>
<li>链式栈和列表栈的性能比较</li>
</ul>
<h3 id="内存池简介"><a href="#内存池简介" class="headerlink" title="内存池简介"></a>内存池简介</h3><p>内存池是池化技术中的一种形式。通常我们在编写程序的时候回使用 <code>new</code> <code>delete</code> 这些关键字来向操作系统申请内存，而这样造成的后果就是每次申请内存和释放内存的时候，都需要和操作系统的系统调用打交道，从堆中分配所需的内存。如果这样的操作太过频繁，就会找成大量的内存碎片进而降低内存的分配性能，甚至出现内存分配失败的情况。</p>
<p>而内存池就是为了解决这个问题而产生的一种技术。从内存分配的概念上看，内存申请无非就是向内存分配方索要一个指针，当向操作系统申请内存时，操作系统需要进行复杂的内存管理调度之后，才能正确的分配出一个相应的指针。而这个分配的过程中，我们还面临着分配失败的风险。</p>
<p>所以，每一次进行内存分配，就会消耗一次分配内存的时间，设这个时间为 T，那么进行 n 次分配总共消耗的时间就是 nT；如果我们一开始就确定好我们可能需要多少内存，那么在最初的时候就分配好这样的一块内存区域，当我们需要内存的时候，直接从这块已经分配好的内存中使用即可，那么总共需要的分配时间仅仅只有 T。当 n 越大时，节约的时间就越多。</p>
<h2 id="二、主函数设计"><a href="#二、主函数设计" class="headerlink" title="二、主函数设计"></a>二、主函数设计</h2><p>我们要设计实现一个高性能的内存池，那么自然避免不了需要对比已有的内存，而比较内存池对内存的分配性能，就需要实现一个需要对内存进行动态分配的结构（比如：链表栈），为此，可以写出如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span>    <span class="comment">// assert()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>      <span class="comment">// clock()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>     <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MemoryPool.hpp&quot;</span>  <span class="comment">// MemoryPool&lt;T&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StackAlloc.hpp&quot;</span>  <span class="comment">// StackAlloc&lt;T, Alloc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMS 10000000</span></span><br><span class="line"><span class="comment">// 重复次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REPS 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 STL 默认分配器</span></span><br><span class="line">    StackAlloc&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; stackDefault;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackDefault.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default Allocator Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存池</span></span><br><span class="line">    StackAlloc&lt;<span class="type">int</span>, MemoryPool&lt;<span class="type">int</span>&gt; &gt; stackPool;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackPool.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackPool.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackPool.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MemoryPool Allocator Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的两段代码中，<code>StackAlloc</code> 是一个链表栈，接受两个模板参数，第一个参数是栈中的元素类型，第二个参数就是栈使用的内存分配器。</p>
<p>因此，这个内存分配器的模板参数就是整个比较过程中唯一的变量，使用默认分配器的模板参数为 <code>std::allocator</code>，而使用内存池的模板参数为 <code>MemoryPool</code>。</p>
<blockquote>
<p>std::allocator 是 C++标准库中提供的默认分配器，他的特点就在于我们在 使用 new 来申请内存构造新对象的时候，势必要调用类对象的默认构造函数，而使用 std::allocator 则可以将内存分配和对象的构造这两部分逻辑给分离开来，使得分配的内存是原始、未构造的。</p>
</blockquote>
<p>下面我们来实现这个链表栈。</p>
<h2 id="三、模板链表栈"><a href="#三、模板链表栈" class="headerlink" title="三、模板链表栈"></a>三、模板链表栈</h2><p>栈的结构非常的简单，没有什么复杂的逻辑操作，其成员函数只需要考虑两个基本的操作：入栈、出栈。为了操作上的方便，我们可能还需要这样一些方法：判断栈是否空、清空栈、获得栈顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode_</span></span><br><span class="line">&#123;</span><br><span class="line">  T data;</span><br><span class="line">  StackNode_* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 为存储的对象类型, Alloc 为使用的分配器, 并默认使用 std::allocator 作为对象的分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = std::allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> StackAlloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 typedef 简化类型名</span></span><br><span class="line">    <span class="keyword">typedef</span> StackNode_&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::<span class="keyword">template</span> rebind&lt;Node&gt;::other allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">StackAlloc</span>() &#123; head_ = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 默认析构</span></span><br><span class="line">    ~<span class="built_in">StackAlloc</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当栈中元素为空时返回 true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (head_ == <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放栈中元素的所有内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (head_-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    allocator allocator_;</span><br><span class="line">    <span class="comment">// 栈顶</span></span><br><span class="line">    Node* head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单的逻辑诸如构造、析构、判断栈是否空、返回栈顶元素的逻辑都非常简单，直接在上面的定义中实现了，下面我们来实现 <code>clear()</code>, <code>push()</code> 和 <code>pop()</code> 这三个重要的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放栈中元素的所有内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node* curr = head_;</span><br><span class="line">  <span class="comment">// 依次出栈</span></span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Node* tmp = curr-&gt;prev;</span><br><span class="line">    <span class="comment">// 先析构, 再回收内存</span></span><br><span class="line">    allocator_.<span class="built_in">destroy</span>(curr);</span><br><span class="line">    allocator_.<span class="built_in">deallocate</span>(curr, <span class="number">1</span>);</span><br><span class="line">    curr = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  head_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为一个节点分配内存</span></span><br><span class="line">  Node* newNode = allocator_.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 调用节点的构造函数</span></span><br><span class="line">  allocator_.<span class="built_in">construct</span>(newNode, <span class="built_in">Node</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  newNode-&gt;data = element;</span><br><span class="line">  newNode-&gt;prev = head_;</span><br><span class="line">  head_ = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 出栈操作 返回出栈元素</span></span><br><span class="line">  T result = head_-&gt;data;</span><br><span class="line">  Node* tmp = head_-&gt;prev;</span><br><span class="line">  allocator_.<span class="built_in">destroy</span>(head_);</span><br><span class="line">  allocator_.<span class="built_in">deallocate</span>(head_, <span class="number">1</span>);</span><br><span class="line">  head_ = tmp;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节我们实现了一个用于测试性能比较的模板链表栈，目前的代码如下。在下一节中，我们开始详细实现我们的高性能内存池。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StackAlloc.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_ALLOC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_ALLOC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode_</span></span><br><span class="line">&#123;</span><br><span class="line">  T data;</span><br><span class="line">  StackNode_* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 为存储的对象类型, Alloc 为使用的分配器,</span></span><br><span class="line"><span class="comment">// 并默认使用 std::allocator 作为对象的分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = std::allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> StackAlloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 typedef 简化类型名</span></span><br><span class="line">    <span class="keyword">typedef</span> StackNode_&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::<span class="keyword">template</span> rebind&lt;Node&gt;::other allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">StackAlloc</span>() &#123; head_ = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 默认析构</span></span><br><span class="line">    ~<span class="built_in">StackAlloc</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当栈中元素为空时返回 true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (head_ == <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放栈中元素的所有内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Node* curr = head_;</span><br><span class="line">      <span class="keyword">while</span> (curr != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        Node* tmp = curr-&gt;prev;</span><br><span class="line">        allocator_.<span class="built_in">destroy</span>(curr);</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(curr, <span class="number">1</span>);</span><br><span class="line">        curr = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      head_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 为一个节点分配内存</span></span><br><span class="line">      Node* newNode = allocator_.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 调用节点的构造函数</span></span><br><span class="line">      allocator_.<span class="built_in">construct</span>(newNode, <span class="built_in">Node</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 入栈操作</span></span><br><span class="line">      newNode-&gt;data = element;</span><br><span class="line">      newNode-&gt;prev = head_;</span><br><span class="line">      head_ = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 出栈操作 返回出栈结果</span></span><br><span class="line">      T result = head_-&gt;data;</span><br><span class="line">      Node* tmp = head_-&gt;prev;</span><br><span class="line">      allocator_.<span class="built_in">destroy</span>(head_);</span><br><span class="line">      allocator_.<span class="built_in">deallocate</span>(head_, <span class="number">1</span>);</span><br><span class="line">      head_ = tmp;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (head_-&gt;data); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    allocator allocator_;</span><br><span class="line">    Node* head_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// STACK_ALLOC_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &quot;MemoryPool.hpp&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StackAlloc.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据电脑性能调整这些值</span></span><br><span class="line"><span class="comment">// 插入元素个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMS 25000000</span></span><br><span class="line"><span class="comment">// 重复次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REPS 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认分配器</span></span><br><span class="line">    StackAlloc&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; stackDefault;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackDefault.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackDefault.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default Allocator Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存池</span></span><br><span class="line">    <span class="comment">// StackAlloc&lt;int, MemoryPool&lt;int&gt; &gt; stackPool;</span></span><br><span class="line">    <span class="comment">// start = clock();</span></span><br><span class="line">    <span class="comment">// for (int j = 0; j &lt; REPS; j++) &#123;</span></span><br><span class="line">    <span class="comment">//     assert(stackPool.empty());</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; ELEMS; i++)</span></span><br><span class="line">    <span class="comment">//       stackPool.push(i);</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; ELEMS; i++)</span></span><br><span class="line">    <span class="comment">//       stackPool.pop();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;MemoryPool Allocator Time: &quot;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; (((double)clock() - start) / CLOCKS_PER_SEC) &lt;&lt; &quot;\n\n&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、设计内存池"><a href="#二、设计内存池" class="headerlink" title="二、设计内存池"></a>二、设计内存池</h2><p>在节中，我们在模板链表栈中使用了默认构造器来管理栈操作中的元素内存，一共涉及到了 <code>rebind::other</code>, <code>allocate()</code>, <code>dealocate()</code>, <code>construct()</code>, <code>destroy()</code>这些关键性的接口。所以为了让代码直接可用，我们同样应该在内存池中设计同样的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MEMORY_POOL_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_POOL_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> BlockSize = <span class="number">4096</span>&gt;</span><br><span class="line"><span class="keyword">class</span> MemoryPool</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 typedef 简化类型书写</span></span><br><span class="line">    <span class="keyword">typedef</span> T*              pointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 rebind&lt;U&gt;::other 接口</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123;</span><br><span class="line">      <span class="keyword">typedef</span> MemoryPool&lt;U&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造, 初始化所有的槽指针</span></span><br><span class="line">    <span class="comment">// C++11 使用了 noexcept 来显式的声明此函数不会抛出异常</span></span><br><span class="line">    <span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">      currentBlock_ = <span class="literal">nullptr</span>;</span><br><span class="line">      currentSlot_ = <span class="literal">nullptr</span>;</span><br><span class="line">      lastSlot_ = <span class="literal">nullptr</span>;</span><br><span class="line">      freeSlots_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁一个现有的内存池</span></span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间只能分配一个对象, n 和 hint 会被忽略</span></span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n = <span class="number">1</span>, <span class="type">const</span> T* hint = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁指针 p 指向的内存区块</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, <span class="type">size_t</span> n = <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用构造函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(U* p, Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁内存池中的对象, 即调用对象的析构函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(U* p)</span> </span>&#123;</span><br><span class="line">      p-&gt;~<span class="built_in">U</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用于存储内存池中的对象槽,</span></span><br><span class="line">    <span class="comment">// 要么被实例化为一个存放对象的槽,</span></span><br><span class="line">    <span class="comment">// 要么被实例化为一个指向存放对象槽的槽指针</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">Slot_</span> &#123;</span><br><span class="line">      T element;</span><br><span class="line">      Slot_* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据指针</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span>* data_pointer_;</span><br><span class="line">    <span class="comment">// 对象槽</span></span><br><span class="line">    <span class="keyword">typedef</span> Slot_ slot_type_;</span><br><span class="line">    <span class="comment">// 对象槽指针</span></span><br><span class="line">    <span class="keyword">typedef</span> Slot_* slot_pointer_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前内存区块</span></span><br><span class="line">    slot_pointer_ currentBlock_;</span><br><span class="line">    <span class="comment">// 指向当前内存区块的一个对象槽</span></span><br><span class="line">    slot_pointer_ currentSlot_;</span><br><span class="line">    <span class="comment">// 指向当前内存区块的最后一个对象槽</span></span><br><span class="line">    slot_pointer_ lastSlot_;</span><br><span class="line">    <span class="comment">// 指向当前内存区块中的空闲对象槽</span></span><br><span class="line">    slot_pointer_ freeSlots_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查定义的内存池大小是否过小</span></span><br><span class="line">    <span class="built_in">static_assert</span>(BlockSize &gt;= <span class="number">2</span> * <span class="built_in">sizeof</span>(slot_type_), <span class="string">&quot;BlockSize too small.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MEMORY_POOL_HPP</span></span></span><br></pre></td></tr></table></figure>

<p>在上面的类设计中可以看到，在这个内存池中，其实是使用链表来管理整个内存池的内存区块的。内存池首先会定义固定大小的基本内存区块(Block)，然后在其中定义了一个可以实例化为存放对象内存槽的对象槽（Slot_）和对象槽指针的一个联合。然后在区块中，定义了四个关键性质的指针，它们的作用分别是：</p>
<ol>
<li><code>currentBlock_</code>: 指向当前内存区块的指针</li>
<li><code>currentSlot_</code>: 指向当前内存区块中的对象槽</li>
<li><code>lastSlot_</code>: 指向当前内存区块中的最后一个对象槽</li>
<li><code>freeSlots_</code>: 指向当前内存区块中所有空闲的对象槽</li>
</ol>
<p>梳理好整个内存池的设计结构之后，我们就可以开始实现关键性的逻辑了。</p>
<h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="MemoryPool-construct-实现"><a href="#MemoryPool-construct-实现" class="headerlink" title="MemoryPool::construct() 实现"></a>MemoryPool::construct() 实现</h3><p><code>MemoryPool::construct()</code> 的逻辑是最简单的，我们需要实现的，仅仅只是调用信件对象的构造函数即可，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用构造函数, 使用 std::forward 转发变参模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(U* p, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (p) <span class="built_in">U</span> (std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MemoryPool-deallocate-实现"><a href="#MemoryPool-deallocate-实现" class="headerlink" title="MemoryPool::deallocate() 实现"></a>MemoryPool::deallocate() 实现</h3><p><code>MemoryPool::deallocate()</code> 是在对象槽中的对象被析构后才会被调用的，主要目的是销毁内存槽。其逻辑也不复杂：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁指针 p 指向的内存区块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, <span class="type">size_t</span> n = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// reinterpret_cast 是强制类型转换符</span></span><br><span class="line">    <span class="comment">// 要访问 next 必须强制将 p 转成 slot_pointer_</span></span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(p)-&gt;next = freeSlots_;</span><br><span class="line">    freeSlots_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MemoryPool-MemoryPool-实现"><a href="#MemoryPool-MemoryPool-实现" class="headerlink" title="MemoryPool::~MemoryPool() 实现"></a>MemoryPool::~MemoryPool() 实现</h3><p>析构函数负责销毁整个内存池，因此我们需要逐个删除掉最初向操作系统申请的内存块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁一个现有的内存池</span></span><br><span class="line">~<span class="built_in">MemoryPool</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// 循环销毁内存池中分配的内存区块</span></span><br><span class="line">  slot_pointer_ curr = currentBlock_;</span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    slot_pointer_ prev = curr-&gt;next;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(curr))</span></span>;</span><br><span class="line">    curr = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MemoryPool-allocate-实现"><a href="#MemoryPool-allocate-实现" class="headerlink" title="MemoryPool::allocate() 实现"></a>MemoryPool::allocate() 实现</h3><p><code>MemoryPool::allocate()</code> 毫无疑问是整个内存池的关键所在，但实际上理清了整个内存池的设计之后，其实现并不复杂。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一时间只能分配一个对象, n 和 hint 会被忽略</span></span><br><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n = <span class="number">1</span>, <span class="type">const</span> T* hint = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有空闲的对象槽，那么直接将空闲区域交付出去</span></span><br><span class="line">  <span class="keyword">if</span> (freeSlots_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    pointer result = <span class="built_in">reinterpret_cast</span>&lt;pointer&gt;(freeSlots_);</span><br><span class="line">    freeSlots_ = freeSlots_-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果对象槽不够用了，则分配一个新的内存区块</span></span><br><span class="line">    <span class="keyword">if</span> (currentSlot_ &gt;= lastSlot_) &#123;</span><br><span class="line">      <span class="comment">// 分配一个新的内存区块，并指向前一个内存区块</span></span><br><span class="line">      data_pointer_ newBlock = <span class="built_in">reinterpret_cast</span>&lt;data_pointer_&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(BlockSize));</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(newBlock)-&gt;next = currentBlock_;</span><br><span class="line">      currentBlock_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(newBlock);</span><br><span class="line">      <span class="comment">// 填补整个区块来满足元素内存区域的对齐要求</span></span><br><span class="line">      data_pointer_ body = newBlock + <span class="built_in">sizeof</span>(slot_pointer_);</span><br><span class="line">      <span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(body);</span><br><span class="line">      <span class="type">size_t</span> bodyPadding = (<span class="built_in">alignof</span>(slot_type_) - result) % <span class="built_in">alignof</span>(slot_type_);</span><br><span class="line">      currentSlot_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(body + bodyPadding);</span><br><span class="line">      lastSlot_ = <span class="built_in">reinterpret_cast</span>&lt;slot_pointer_&gt;(newBlock + BlockSize - <span class="built_in">sizeof</span>(slot_type_) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;pointer&gt;(currentSlot_++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、与-std-vector-的性能对比"><a href="#四、与-std-vector-的性能对比" class="headerlink" title="四、与 std::vector 的性能对比"></a>四、与 std::vector 的性能对比</h2><p>我们知道，对于栈来说，链栈其实并不是最好的实现方式，因为这种结构的栈不可避免的会涉及到指针相关的操作，同时，还会消耗一定量的空间来存放节点之间的指针。事实上，我们可以使用 <code>std::vector</code> 中的 <code>push_back()</code> 和 <code>pop_back()</code> 这两个操作来模拟一个栈，我们不妨来对比一下这个 <code>std::vector</code> 与我们所实现的内存池在性能上谁高谁低，我们在 主函数中加入如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较内存池和 std::vector 之间的性能</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; stackVector;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REPS; j++) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(stackVector.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackVector.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ELEMS; i++)</span><br><span class="line">          stackVector.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Time: &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; (((<span class="type">double</span>)<span class="built_in">clock</span>() - start) / CLOCKS_PER_SEC) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2023-06-27-%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2023-06-27-%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">软件自动化测试方法和技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>软件自动化测试是指利用自动化工具和脚本来执行测试任务和验证软件系统的过程。它通过编写脚本和使用自动化工具来模拟用户操作、执行测试用例、比较预期结果和实际结果，从而自动化执行软件测试过程。</p>
<h2 id="自动化测试目的"><a href="#自动化测试目的" class="headerlink" title="自动化测试目的"></a>自动化测试目的</h2><p>为什么要使用自动化测试？</p>
<ol>
<li>节省人力</li>
<li>质量保障</li>
<li>量化代码质量（代码测试覆盖率）</li>
<li>便于重构</li>
<li>回归测试的快速迭代</li>
</ol>
<h2 id="C-自动化测试框架的选择"><a href="#C-自动化测试框架的选择" class="headerlink" title="C++ 自动化测试框架的选择"></a>C++ 自动化测试框架的选择</h2><table>
<thead>
<tr>
<th align="center">自动化测试框架</th>
<th align="center">GitHub Starts</th>
<th align="center">Standard Support</th>
<th align="center">Header-only</th>
<th align="center">Fixtures</th>
<th align="center">Mock</th>
<th align="center">BDD-style</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/google/googletest">Google Test</a></td>
<td align="center">30.2k</td>
<td align="center">C++14</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/catchorg/Catch2">Catch2</a></td>
<td align="center">16.8k</td>
<td align="center">C++14</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/doctest/doctest">DOCTest</a></td>
<td align="center">5.0k</td>
<td align="center">C++14</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
</tbody></table>
<ul>
<li><code>Google Test</code> 使用人数最多，功能最全面。</li>
<li><code>Catch2</code> 易于集成，支持 <code>BDD-style</code>，但是不支持 <code>Mock</code>。</li>
<li><code>DOCTest</code> 易于集成，不支持 <code>Mock</code>。</li>
</ul>
<h2 id="GoogleTest-简介"><a href="#GoogleTest-简介" class="headerlink" title="GoogleTest 简介"></a>GoogleTest 简介</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retrun i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(f,simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">f</span>(<span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="built_in">f</span>(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 Google Test 框架</span></span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="comment">// 运行所有测试用例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/../resource/auto_test/Snipaste_2023-06-27_18-07-03.png" alt="image"></p>
<ul>
<li>改变函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retrun i<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/../resource/auto_test/Snipaste_2023-06-27_18-21-20.png" alt="image"></p>
<ul>
<li>类推其他复杂函数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void f(std::string str, std::string&amp; out)</span><br><span class="line">&#123;</span><br><span class="line">    out = str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(f, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    std::string in = &quot;Hello world&quot;;</span><br><span class="line">    std::string out;</span><br><span class="line"></span><br><span class="line">    f(in, out);</span><br><span class="line"></span><br><span class="line">    ASSERT_EQ(out, in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../resource/auto_test/Snipaste_2023-07-12_18-54-50.png" alt="image"></p>
<ul>
<li>为失败添加更多说明</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASSERT(st.IsSuccess()) &lt;&lt; &quot;st is not success!&quot;;</span><br><span class="line">ASSERT(st.IsSuccess()) &lt;&lt; DBG(st);</span><br></pre></td></tr></table></figure>

<h2 id="ASSERT-宏说明"><a href="#ASSERT-宏说明" class="headerlink" title="ASSERT 宏说明"></a>ASSERT 宏说明</h2><p><a target="_blank" rel="noopener" href="https://google.github.io/googletest/reference/assertions.html">GoogleTest ASSERT 官方说明</a>{: .btn .btn–success}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ASSERT_TRUE(condition);     <span class="comment">///&lt; true</span></span><br><span class="line">ASSERT_FALSE(condition);    <span class="comment">///&lt; false</span></span><br><span class="line"></span><br><span class="line">ASSERT_EQ(val1,val2);       <span class="comment">///&lt; val1 == val2</span></span><br><span class="line">ASSERT_NE(val1,val2);       <span class="comment">///&lt; val1 != val2</span></span><br><span class="line"></span><br><span class="line">ASSERT_LT(val1,val2);   <span class="comment">///&lt; val1 &lt; val2</span></span><br><span class="line">ASSERT_LE(val1,val2);   <span class="comment">///&lt; val1 &lt;= val2</span></span><br><span class="line">ASSERT_GT(val1,val2);   <span class="comment">///&lt; val1 &gt; val2</span></span><br><span class="line">ASSERT_GE(val1,val2);   <span class="comment">///&lt; val1 &gt;= val2</span></span><br><span class="line"></span><br><span class="line">ASSERT_STRCASEEQ(str1,str2);    <span class="comment">///&lt; str1 == str2(忽略大小写)</span></span><br><span class="line">ASSERT_FLOAT_EQ(val1,val2);     <span class="comment">///&lt; 浮点数比较,误差小于 4ULP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 数值模糊比较，std::abs(val1 - val2) &lt;= abs_error</span></span><br><span class="line">ASSERT_NEAR(val1,val2,abs_error);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 语句 statement 抛出异常，且异常的类型为 exception_type</span></span><br><span class="line">ASSERT_THROW(statement,exception_type);</span><br><span class="line"><span class="comment">/// 语句 statement 抛出异常，但不限定异常类型</span></span><br><span class="line">ASSERT_ANY_THROW(statement);</span><br><span class="line"><span class="comment">/// 语句 statement 不抛出异常</span></span><br><span class="line">ASSERT_NO_THROW(statement);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 验证该语句导致进程以非零退出状态终止，stderr 输出 matcher</span></span><br><span class="line">ASSERT_DEATH(statement,matcher);</span><br></pre></td></tr></table></figure>

<h2 id="测试夹具"><a href="#测试夹具" class="headerlink" title="测试夹具"></a>测试夹具</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    class_name()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 打开数据库链接</span></span><br><span class="line">        m_pDao = <span class="keyword">new</span> <span class="title class_">mysql</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~class_name()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 关闭数据库链接</span></span><br><span class="line">        delete m_pDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CfgDao* m_pDao = nullptr; <span class="comment">///&lt; 数据库实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(class_name, description)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_TRUE(m_pDao-&gt;InsertCallHistory(st));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程测试"><a href="#多线程测试" class="headerlink" title="多线程测试"></a>多线程测试</h2><p>GoogleTest 没有提供，一个测试用例，在多个线程中同时调用，以证明其线程安全。</p>
<p>但其实现原理可以手动实现，代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GosLog</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 本线程先 sleep 2秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">/// 调用一万次函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GosLog</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(f, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    std::deque&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 使用 test_function 创建线程</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(test_function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 等待每个线程结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;thread : threads)</span><br><span class="line">    &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提取出重复的语句做测试夹具</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           多线程测试封装</span></span><br><span class="line"><span class="comment"> * @author          lijiancong</span></span><br><span class="line"><span class="comment"> * @date            2023-01-19 17:27:15</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mt_unittest</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">mt_unittest</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">mt_unittest</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add new work item to the pool</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    ::<span class="function">testing::AssertionResult <span class="title">invoke</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> cpu_thread = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">        <span class="keyword">if</span> (cpu_thread &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 多线程测试要求测试机器， 硬件支持 3 线程以上</span></span><br><span class="line">            <span class="keyword">return</span> ::testing::<span class="built_in">AssertionFailure</span>() &lt;&lt; <span class="string">&quot;cpu_thread is less than 2. &quot;</span></span><br><span class="line">                &lt;&lt; std::<span class="built_in">to_string</span>(cpu_thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> task = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::jthread&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cpu_thread - <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(std::<span class="built_in">jthread</span>(</span><br><span class="line">                [<span class="keyword">this</span>, task]() <span class="keyword">mutable</span></span><br><span class="line">                &#123;</span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">mutex</span>(mutex_);</span><br><span class="line">                    <span class="comment">/// 等待同步开始</span></span><br><span class="line">                    cv_.<span class="built_in">wait</span>(mutex, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> ready_; &#125;);</span><br><span class="line">                    <span class="comment">/// 执行测试函数</span></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; guard&#123;mutex_&#125;;</span><br><span class="line">            ready_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">return</span> ::testing::<span class="built_in">AssertionSuccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="type">bool</span> ready_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_F</span>(mt_unittest, GosLogTest)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">invoke</span>(</span><br><span class="line">        []()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">GosLog</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板函数测试"><a href="#模板函数测试" class="headerlink" title="模板函数测试"></a>模板函数测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           擦除vector中特定值的元素</span></span><br><span class="line"><span class="comment"> * @param           vec      [out]  要操作的vector</span></span><br><span class="line"><span class="comment"> * @param           value    [in]   要擦除的值</span></span><br><span class="line"><span class="comment"> * @return          size_t  擦除元素的个数</span></span><br><span class="line"><span class="comment"> * @author          lijiancong</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">erase</span><span class="params">(Container&amp; vec,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="keyword">typename</span> Container::value_type&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator it =</span><br><span class="line">        std::<span class="built_in">remove</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), value);</span><br><span class="line">    <span class="type">size_t</span> count = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(std::<span class="built_in">distance</span>(it, vec.<span class="built_in">end</span>()));</span><br><span class="line">    vec.<span class="built_in">erase</span>(it, vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gos_erase_test</span> : <span class="keyword">public</span> testing::Test</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TYPED_TEST_SUITE(gos_erase_test, ::testing::Types&lt;</span><br><span class="line">                                 std::vector&lt;<span class="type">char</span>&gt;,</span><br><span class="line">                                 std::deque&lt;<span class="type">char</span>&gt;,</span><br><span class="line">                                 std::string,</span><br><span class="line">                                 std::vector&lt;<span class="type">int</span>&gt;,</span><br><span class="line">                                 std::deque&lt;<span class="type">int</span>&gt;</span><br><span class="line">                                 &gt;);</span><br><span class="line"></span><br><span class="line">TYPED_TEST(gos_erase_test, find_simple_char)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TypeParam</span> <span class="variable">n</span> <span class="operator">=</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    TypeParam cmp&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    ASSERT_EQ(<span class="number">1</span>, gos::erase(n, <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    ASSERT_EQ(<span class="number">2</span>, gos::erase(n, <span class="string">&#x27;b&#x27;</span>));</span><br><span class="line">    ASSERT_EQ(cmp, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mock-简介"><a href="#Mock-简介" class="headerlink" title="Mock 简介"></a>Mock 简介</h2><p><a target="_blank" rel="noopener" href="https://google.github.io/googletest/gmock_for_dummies.html">Mock 入门</a>{: .btn .btn–success}</p>
<p>测试场景</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">TalkRequest</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroupCall</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">TalkRequest</span><span class="params">(<span class="type">int</span> number, SpeakManager&amp; SpeakManager)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SpeakManager-&gt;<span class="built_in">TalkRequest</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(GroupCall, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> SpeakManager;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(Groupcall::<span class="built_in">GI</span>().<span class="built_in">TalkRequest</span>(<span class="number">4106</span>, p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>SpeakManager::TalkRequest()</code>, 依赖于 SDK 的初始化, 依赖于通话存在，所以为单独测试 <code>GroupCall::TalkRequest()</code> 增加了难度。</p>
<p>实现方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include <span class="string">&quot;gtest/gtest.h&quot;</span></span><br><span class="line">#include <span class="string">&quot;gmock/gmock.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManagerBase</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    virtual bool <span class="title function_">TalkRequest</span><span class="params">(<span class="type">int</span> number)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 原业务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManager</span> : <span class="keyword">public</span> SpeakManagerBase</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// virtual bool TalkRequest(int number);</span></span><br><span class="line">    bool <span class="title function_">TalkRequest</span><span class="params">(<span class="type">int</span> number)</span> override;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 模拟类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpeakManagerMock</span> : <span class="keyword">public</span> SpeakManagerBase</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    MOCK_METHOD(bool, TalkRequest, (<span class="type">int</span> number), (override));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroupCall</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> GroupCall&amp; GI()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> GroupCall instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool <span class="title function_">TalkRequest</span><span class="params">(<span class="type">int</span> number, SpeakManagerBase&amp; SpeakManager)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SpeakManager.TalkRequest(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST(GroupCall, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace testing;</span><br><span class="line"></span><br><span class="line">    SpeakManagerMock SpeakManager;</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在任意入参时，将会总是返回 true</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(_)).WillRepeatedly(Return(<span class="literal">true</span>));</span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_TRUE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(GroupCall, simple_test_1)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace testing;</span><br><span class="line"></span><br><span class="line">    SpeakManagerMock SpeakManager;</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在入参为 4106 时，将会总是返回 true</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(<span class="number">4106</span>))</span><br><span class="line">        .WillRepeatedly(Return(<span class="literal">true</span>));</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在入参在大于 4100 并且不等于 4106 的情况下，总是返回 false</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(AllOf(Gt(<span class="number">4100</span>), Ne(<span class="number">4106</span>))))</span><br><span class="line">                                .WillRepeatedly(Return(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_TRUE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_FALSE(GroupCall::GI().TalkRequest(<span class="number">4105</span>, SpeakManager));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(GroupCall, simple_test_2)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace testing;</span><br><span class="line"></span><br><span class="line">    SpeakManagerMock SpeakManager;</span><br><span class="line">    <span class="comment">/// 规定 TalkRequest 在任意入参时，第一次调用返回 true， 第二次返回 false</span></span><br><span class="line">    EXPECT_CALL(SpeakManager, TalkRequest(_))</span><br><span class="line">        .WillOnce(Return(<span class="literal">true</span>))</span><br><span class="line">        .WillOnce(Return(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 进行测试结果</span></span><br><span class="line">    ASSERT_TRUE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line">    ASSERT_FALSE(GroupCall::GI().TalkRequest(<span class="number">4106</span>, SpeakManager));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动化测试场景"><a href="#自动化测试场景" class="headerlink" title="自动化测试场景"></a>自动化测试场景</h2><p>通常自动化测试的测试用例之间不应存在影响，每个测试用例应拆分为最小可测试单元(函数)，测试用例的顺序应互不影响。</p>
<h3 id="工具函数测试"><a href="#工具函数测试" class="headerlink" title="工具函数测试"></a>工具函数测试</h3><ul>
<li>SQL 语句组装类测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TEST(sql_utility, simple)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// insert</span></span><br><span class="line">    gos::sql sql_string;</span><br><span class="line">    std::<span class="type">string</span> <span class="variable">str</span> <span class="operator">=</span> sql_string.insert(<span class="string">&quot;operation_log&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;UUID&quot;</span>, <span class="string">&quot;555&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;Time&quot;</span>, <span class="number">666</span>)</span><br><span class="line">        .bind(<span class="string">&quot;UserType&quot;</span>, <span class="string">&quot;777&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;UserID&quot;</span>, <span class="string">&quot;888&quot;</span>)</span><br><span class="line">        .bind(<span class="string">&quot;LogInfo&quot;</span>, <span class="string">&quot;999&quot;</span>)</span><br><span class="line">        .sql();</span><br><span class="line"></span><br><span class="line">    ASSERT_EQ(str, <span class="string">&quot;INSERT INTO operation_log(UUID, Time, UserType, UserID, LogInfo) VALUES(\&quot;555\&quot;, 666, \&quot;777\&quot;, \&quot;888\&quot;, \&quot;999\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// delete</span></span><br><span class="line">    gos::sql sql;</span><br><span class="line">    std::<span class="type">string</span> <span class="variable">strSQL</span> <span class="operator">=</span> sql.remove(<span class="string">&quot;operation_log&quot;</span>)</span><br><span class="line">                            .where(<span class="string">&quot;Time &lt; :time&quot;</span>)</span><br><span class="line">                            .bind(<span class="string">&quot;time&quot;</span>, <span class="number">55</span>).sql();</span><br><span class="line">    ASSERT_EQ(strSQL, <span class="string">&quot;DELETE FROM operation_log WHERE Time &lt; 55;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间函数测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TEST(gos_sleep_1ms, Simple_Test)</span><br><span class="line">&#123;</span><br><span class="line">    gos::tick_count timer;</span><br><span class="line">    <span class="comment">/// 开始计时</span></span><br><span class="line">    timer.start();</span><br><span class="line">    gos_sleep_1ms(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">/// 结束计时</span></span><br><span class="line">    timer.finish();</span><br><span class="line">    <span class="comment">/// 模糊比较，误差不超过 20ms</span></span><br><span class="line">    ASSERT_TRUE(gos::approx(<span class="number">1000</span>, <span class="number">20</span>).equal(timer.get_ms()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Json-接口函数测试"><a href="#Json-接口函数测试" class="headerlink" title="Json 接口函数测试"></a>Json 接口函数测试</h3><p>在客户端与服务端的通信中，如果使用 <code>json</code> 报文来传递事件，那么就存在 结构体序列化成 <code>json</code> 与 <code>json</code> 反序列化成结构体的过程，现在我们来测试这个过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DC_TO_DIS_LOAD_SDS_HISTORY_C</span> : <span class="keyword">public</span> gos::json_parser&lt;DC_TO_DIS_LOAD_SDS_HISTORY_C&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    std::string strDCLongNum;  <span class="comment">///&lt; M, 发送者长号码</span></span><br><span class="line">    UINT32 ulBeginTime;        <span class="comment">///&lt; M, 开始时间, 秒级时间戳</span></span><br><span class="line">    UINT32 ulEndTime;          <span class="comment">///&lt; M, 结束时间, 秒级时间戳</span></span><br><span class="line">    UINT32 ulCountLimit;       <span class="comment">///&lt; M, 最多回复记录数</span></span><br><span class="line"></span><br><span class="line">    bool operator==(const DC_TO_DIS_LOAD_SDS_HISTORY_C&amp; stOther) const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> strDCLongNum == stOther.strDCLongNum &amp;&amp;</span><br><span class="line">               ulBeginTime == stOther.ulBeginTime &amp;&amp;</span><br><span class="line">               ulEndTime == stOther.ulEndTime &amp;&amp;</span><br><span class="line">               ulCountLimit == stOther.ulCountLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 从 json 报文中解析出数值, 并赋予本结构体</span></span><br><span class="line">    virtual bool <span class="title function_">StructToJson</span><span class="params">(std::string&amp; str)</span> const;</span><br><span class="line">    <span class="comment">/// 从结构体的数值拼装 json 报文</span></span><br><span class="line">    virtual bool <span class="title function_">JsonToStruct</span><span class="params">(const std::string&amp; str)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取一个随机的本结构体</span></span><br><span class="line">    <span class="keyword">static</span> DC_TO_DIS_LOAD_SDS_HISTORY_C <span class="title function_">GetRandomObj</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST(DC_TO_DIS_LOAD_SDS_HISTORY_C, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">auto</span> <span class="variable">st</span> <span class="operator">=</span> DC_TO_DIS_LOAD_SDS_HISTORY_C::GetRandomObj();</span><br><span class="line"></span><br><span class="line">    std::string strJson;</span><br><span class="line">    <span class="comment">/// 序列化</span></span><br><span class="line">    ASSERT(st.StructToJson(strJson));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 反序列化</span></span><br><span class="line">    DC_TO_DIS_LOAD_SDS_HISTORY_C stCmp;</span><br><span class="line">    ASSERT(stCmp.JsonToStruct(strJson));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 判断两个结构体是否相等</span></span><br><span class="line">    ASSERT_EQ(st, strCmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上重复的步骤过多，封装后的测试用例较为整洁，如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEST(DC_TO_DIS_LOAD_SDS_HISTORY_C, simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">auto</span> <span class="variable">st</span> <span class="operator">=</span> DC_TO_DIS_LOAD_SDS_HISTORY_C::GetRandomObj();</span><br><span class="line"></span><br><span class="line">        ASSERT_TRUE(gos::test_json_parser(st));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库层自动化测试"><a href="#数据库层自动化测试" class="headerlink" title="数据库层自动化测试"></a>数据库层自动化测试</h3><p>数据库函数测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CfgDaoTests</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/// 初始化数据库链接</span></span><br><span class="line">    CfgDaoTests();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 释放数据库链接</span></span><br><span class="line">    ~CfgDaoTests() override;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@brief</span>           查询 brd_info 表中是否有记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>           find    [in]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          ::testing::AssertionResult</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>          lijiancong</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>            2022-07-07 16:59:03</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@note</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ::testing::AssertionResult <span class="title function_">HaveRowInBrdInfo</span><span class="params">(const DB_BRD_INFO_C&amp; find)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 查询记录</span></span><br><span class="line">        std::vector&lt;DB_BRD_INFO_C&gt; vec;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_pDao-&gt;QueryBrdInfo(vec, <span class="number">1000</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ::testing::AssertionFailure() &lt;&lt; <span class="string">&quot;QueryBrdInfo failed!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (const auto&amp; element : vec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (element == find)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ::testing::AssertionSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ::testing::AssertionFailure()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;can&#x27;t find struct! &quot;</span> &lt;&lt; DBG(find);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(CfgDaoTests, brd_info_simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 创建随机的结构体</span></span><br><span class="line">    <span class="type">DB_BRD_INFO_C</span> <span class="variable">stDB</span> <span class="operator">=</span> DB_BRD_INFO_C::GetRandomObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 验证没有该条记录</span></span><br><span class="line">    ASSERT_FALSE(HaveRowInBrdInfo(stDB));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 插入</span></span><br><span class="line">    ASSERT_TRUE(m_pDao-&gt;InsertBrdInfo(stDB));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 验证有该条记录</span></span><br><span class="line">    ASSERT_TRUE(HaveRowInBrdInfo(stDB));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 删除该条记录</span></span><br><span class="line">    ASSERT_TRUE(m_pDao-&gt;DeleteBrdInfo(stDB.GetKey()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 验证没有该条记录</span></span><br><span class="line">    ASSERT_FALSE(HaveRowInBrdInfo(stDB));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST_F(CfgDaoTests, call_history_simple_test)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件读取测试"><a href="#配置文件读取测试" class="headerlink" title="配置文件读取测试"></a>配置文件读取测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dc_global_config_manager_test</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">DC_GLOBAL_CONFIG_INFO_C</span> <span class="variable">cfg_</span> <span class="operator">=</span> DC_GLOBAL_CONFIG_INFO_C::GetRandomObj();</span><br><span class="line">    std::<span class="type">string</span> <span class="variable">m_strFile</span> <span class="operator">=</span> <span class="string">&quot;dc_global_config_manager_test.ini&quot;</span>;</span><br><span class="line"></span><br><span class="line">    dc_global_config_manager_test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gos_file_exist(m_strFile.c_str()))</span><br><span class="line">        &#123;</span><br><span class="line">            gos_delete_file(m_strFile.c_str());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 生成配置文件</span></span><br><span class="line">        inifile::IniFile ini_file;</span><br><span class="line"></span><br><span class="line">        ini_file.SetBoolValue(<span class="string">&quot;DCGlobal&quot;</span>, <span class="string">&quot;is_use_link_switch&quot;</span>,</span><br><span class="line">                                cfg_.is_use_link_switch_);</span><br><span class="line">        ini_file.SetIntValue(<span class="string">&quot;DCGlobal&quot;</span>, <span class="string">&quot;ping_interval_time_ms&quot;</span>,</span><br><span class="line">                                cfg_.ping_interval_time_ms_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 保存配置文件</span></span><br><span class="line">        ini_file.SaveAs(m_strFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~dc_global_config_manager_test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gos_file_exist(m_strFile.c_str()))</span><br><span class="line">        &#123;</span><br><span class="line">            gos_delete_file(m_strFile.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(dc_global_config_manager_test, DC_GLOBAL_CONFIG_MANAGER)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_TRUE(dc_global_config_manager::GI().load(m_strFile));</span><br><span class="line"></span><br><span class="line">    <span class="type">auto</span> <span class="variable">cfg</span> <span class="operator">=</span> dc_global_config_manager::GI().get();</span><br><span class="line"></span><br><span class="line">    EXPECT_EQ(cfg_, cfg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端软件集成测试"><a href="#客户端软件集成测试" class="headerlink" title="客户端软件集成测试"></a>客户端软件集成测试</h3><p>对于客户端大致有两个调用流程。</p>
<p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E5%8F%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png" alt="image"></p>
<p>对于回调业务设计:</p>
<p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E5%8F%B0%E5%9B%9E%E8%B0%83%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B.png" alt="image"></p>
<p>对于以上解决方案，需要客户端把业务类与界面类分开。</p>
<p>界面只根据输入数据进行更新显示。而业务类管理所有业务(管理业务信息)。</p>
<h3 id="服务器软件集成测试"><a href="#服务器软件集成测试" class="headerlink" title="服务器软件集成测试"></a>服务器软件集成测试</h3><p>同样对于服务端程序，一样可以做代理类而测试业务。</p>
<p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="image"></p>
<p><img src="/../resource/auto_test/%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9B%9E%E8%B0%83%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B.png" alt="image"></p>
<h3 id="服务器业务函数测试"><a href="#服务器业务函数测试" class="headerlink" title="服务器业务函数测试"></a>服务器业务函数测试</h3><p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VOID TaskAPP::OnAppRequestCallReq(const std::string &amp;app_id,</span><br><span class="line">                                  const APP_TO_DIS_MSG_INFO_C &amp;stAppMsgInfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!AppRegisterManager::GI().HandleAppRequestCallReq(app_id,</span><br><span class="line">                                            stAppMsgInfo, <span class="built_in">this</span>, m_pDao))</span><br><span class="line">    &#123;</span><br><span class="line">        GLOGE(<span class="string">&quot;AppRegisterManager HandleAppRequestCallReq failed! %s&quot;</span>,</span><br><span class="line">                DBG(stAppMsgInfo));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在事件函数中，使用单独的业务函数或业务类，把业务模块(<code>AppRegisterManager</code>)与数据库模块(<code>m_pDao</code>)还有事件调度模块(<code>TaskApp</code>)隔离开后，使用测试普通函数的模式测试该函数。</p>
<h3 id="如何组织工程级别单元测试"><a href="#如何组织工程级别单元测试" class="headerlink" title="如何组织工程级别单元测试"></a>如何组织工程级别单元测试</h3><p>使用 CMake 来组织工程文件。</p>
<h4 id="CMake-简介"><a href="#CMake-简介" class="headerlink" title="CMake 简介"></a>CMake 简介</h4><p>CMake是一个跨平台的自动化构建工具，用于管理软件项目的构建过程。它使用一种类似于脚本的语法（CMakeLists.txt文件）来描述项目的构建配置和依赖关系，并生成适合不同构建系统（如Make、Ninja、Visual Studio等）的构建脚本。<br>{: .notice–info}</p>
<ul>
<li>CMake 使用示例：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure>

<ul>
<li>Windows 下生成的 VS 工程结构</li>
</ul>
<p><img src="/../resource/auto_test/Snipaste_2023-07-14_10-37-45.png" alt="image"></p>
<ul>
<li>Linux 下生成的 Makefile:</li>
</ul>
<p><img src="/../resource/auto_test/Snipaste_2023-07-14_11-01-15.png" alt="image"></p>
<ul>
<li>编译工程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工程全部编译</span></span><br><span class="line">cmake --build .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工程 clean 后单独编译 Release 下的 dis</span></span><br><span class="line">cmake --build . --target dis_wz2 --config=Release --clean-first</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 CMake 命令自动运行单元测试:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMakeLists.txt 中增加如下语句，注册运行的单元测试</span></span><br><span class="line">add_test(NAME GosTest COMMAND gos_unittest)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行运行 Debug 模式下的注册过的所有单元测试</span></span><br><span class="line">ctest . -C Debug</span><br></pre></td></tr></table></figure>

<ul>
<li>VS 中可视化界面运行单元测试</li>
</ul>
<p><img src="/../resource/auto_test/Snipaste_2023-07-14_10-39-31.png" alt="image"></p>
<h4 id="单个文件夹下的文件组织"><a href="#单个文件夹下的文件组织" class="headerlink" title="单个文件夹下的文件组织"></a>单个文件夹下的文件组织</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── cp4_debug.cpp</span><br><span class="line">├── cp4_debug.hpp</span><br><span class="line">└── cp4_debug_unittest.cpp</span><br></pre></td></tr></table></figure>

<p><code>CMakeLists.txt</code>: 工程文件, 其中定义了生成静态库(<code>libcp4_debug.a</code>)，生成测试的可执行文件(<code>cp4_debug_unittest.exe</code>)。</p>
<h4 id="多个文件夹下的文件组织"><a href="#多个文件夹下的文件组织" class="headerlink" title="多个文件夹下的文件组织"></a>多个文件夹下的文件组织</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── db</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── CfgDao.cpp</span><br><span class="line">│   └── CfgDao.h</span><br><span class="line">│   └── CfgDao_unittest.cpp</span><br><span class="line">├── middle</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── ATSManager.cpp</span><br><span class="line">│   ├── ATSManager.h</span><br><span class="line">│   ├── ATSManager_unittest.cpp</span><br><span class="line">├── dis_main.cpp</span><br></pre></td></tr></table></figure>

<p>服务器中，<code>app/</code> 和 <code>cfg/</code> 文件夹会分别生成静态库，然后文件 <code>dis_main.cpp</code> 、 <code>libdb.a</code> 、 <code>libmiddle.a</code> 生成 <code>dis.exe</code>。</p>
<p>也同时生成对应的测试程序。</p>
<h4 id="如何引用第三方库（如：GoogleTest）"><a href="#如何引用第三方库（如：GoogleTest）" class="headerlink" title="如何引用第三方库（如：GoogleTest）"></a>如何引用第三方库（如：<code>GoogleTest</code>）</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── dis/</span><br><span class="line">│   ├── ...</span><br><span class="line">├── thirdparty/</span><br><span class="line">│   ├── googletest/</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">|       ├─- ...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMakeLists.txt 中增加如下语句，引用第三方库</span></span><br><span class="line">add_subdirectory(thirdparty/googletest)</span><br></pre></td></tr></table></figure>

<p>然后需要使用该第三方库的工程，包含第三方库的头文件，并链接该第三方库的 <code>libgtest.a</code> 文件，即可正常使用第三方库。</p>
<h2 id="如何确认测试覆盖率"><a href="#如何确认测试覆盖率" class="headerlink" title="如何确认测试覆盖率"></a>如何确认测试覆盖率</h2><ol>
<li>g++ 编译选项中添加: <code>-fprofile-arcs</code>、 <code>-ftest-coverage</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMakeLists.txt 中添加</span></span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wall -fprofile-arcs -ftest-coverage&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -fprofile-arcs -ftest-coverage&quot;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译并运行单元测试</li>
<li>生成覆盖率信息文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcov &lt;source_file&gt;</span><br></pre></td></tr></table></figure>

<p>直接使用 vim 打开该信息文件 <code>test.c.gcov</code></p>
<p><img src="/../resource/auto_test/Snipaste_2023-07-14_11-46-37.png" alt="image"></p>
<ol start="4">
<li>使用<code>lcov</code>工具处理<code>.gcov</code>文件并生成可读的代码覆盖率报告。使用以下命令：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lcov -c -d &lt;directory&gt; -o coverage.info</span><br><span class="line">genhtml coverage.info -o coverage_report</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>打开 <code>coverage_report/index.html</code> 查看覆盖率报告</li>
</ol>
<p><img src="/../resource/auto_test/Snipaste_2023-07-14_17-33-17.png" alt="image"></p>
<p><img src="/../resource/auto_test/Snipaste_2023-07-14_17-33-48.png" alt="image"></p>
<h2 id="提交代码前的自动化测试"><a href="#提交代码前的自动化测试" class="headerlink" title="提交代码前的自动化测试"></a>提交代码前的自动化测试</h2><p>在提交 <code>push</code> 前，自动生成并运行单元测试， 可以使用 <code>git</code> 自带的 <code>pre-push</code>.</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .git</span><br><span class="line">│   ├── branches</span><br><span class="line">│   ├── COMMIT_EDITMSG</span><br><span class="line">│   ├── config</span><br><span class="line">│   ├── description</span><br><span class="line">│   ├── FETCH_HEAD</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   ├── hooks</span><br><span class="line">│       ├── pre-commit.sample</span><br><span class="line">│       ├── pre-push.sample</span><br></pre></td></tr></table></figure>

<p>在 <code>Linux</code> 下工程目录下, 找到 <code>./.git/hooks/pre-push.sample</code> 文件，复制一份并重命名为 <code>pre-push</code>，然后修改 <code>pre-push</code> 文件内容为如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># An example hook script to verify what is about to be committed.</span></span><br><span class="line"><span class="comment"># Called by &quot;git push&quot; with no arguments.  The hook should</span></span><br><span class="line"><span class="comment"># exit with non-zero status after issuing an appropriate message if</span></span><br><span class="line"><span class="comment"># it wants to stop the push.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To enable this hook, rename this file to &quot;pre-push&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动格式化代码</span></span><br><span class="line">python3 ./ClangFormat.py</span><br><span class="line"><span class="comment"># 添加格式化后的代码</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行单元测试</span></span><br><span class="line">cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> cmake .. ; cmake --build ./build/ ; cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> ctest .. -C Release</span><br><span class="line"></span><br><span class="line"><span class="comment"># If the tests fail, prevent the push</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Tests failed. Push aborted.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>添加内容后，为该脚本文件增加可执行权限。 <code>sudo chmod +x pre_push</code></p>
<p>如果该脚本运行过程中，异常结束则不会推送代码到远端，并提示错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2022-01-05-%E5%AD%97%E8%8A%82%E5%BA%8F%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2022-01-05-%E5%AD%97%E8%8A%82%E5%BA%8F%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">字节序简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>高低位字节区分: 举例<code>0x1234</code>, 高位字节为 <code>0x12</code>, 低位字节为 <code>0x34</code>。</p>
<ul>
<li><strong>小端字节序</strong>：低位字节在低地址，高位字节在高地址，即<code>0x1234</code>以<code>0x3412</code>形式储存。<code>CPU</code>处理速度快。</li>
</ul>
<p><img src="/../resource/%E5%AD%97%E8%8A%82%E5%BA%8F%E4%BB%8B%E7%BB%8D/280px-Little-Endian.svg.png" alt="280px-Little-Endian.svg"></p>
<ul>
<li><strong>大端字节序</strong>：高位字节在低地址，低位字节在高地址，这是人类读写数值的方法。即<code>0x1234</code>以<code>0x1234</code>形式储存。</li>
</ul>
<p><img src="/../resource/%E5%AD%97%E8%8A%82%E5%BA%8F%E4%BB%8B%E7%BB%8D/280px-Big-Endian.svg.png" alt="280px-Big-Endian.svg"></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/../resource/%E5%AD%97%E8%8A%82%E5%BA%8F%E4%BB%8B%E7%BB%8D/Snipaste_2022-01-07_15-57-25.png" alt="Snipaste_2022-01-07_15-57-25"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2022-02-28-%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2022-02-28-%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/" class="post-title-link" itemprop="url">常见颜色与RGB值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>常见颜色与RGB值</p>
<h2 id="豆沙绿"><a href="#豆沙绿" class="headerlink" title="豆沙绿"></a>豆沙绿</h2><p>豆沙绿: 199 237 204 (#C7EDCC)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E8%B1%86%E6%B2%99%E7%BB%BF.png" alt="豆沙绿"></p>
<h2 id="护眼黄"><a href="#护眼黄" class="headerlink" title="护眼黄"></a>护眼黄</h2><p>护眼黄: 250 249 222 (#FAF9DE)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E6%8A%A4%E7%9C%BC%E9%BB%84.png" alt="护眼黄"></p>
<h2 id="灰色"><a href="#灰色" class="headerlink" title="灰色"></a>灰色</h2><p>字灰色: 155 163 178(#9BA3B2)<br>背景灰色: 223 225 230(#DFE1E6)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%81%B0%E8%89%B2.png" alt="字和背景灰色"></p>
<h2 id="蓝色"><a href="#蓝色" class="headerlink" title="蓝色"></a>蓝色</h2><p>字蓝色: 41 97 180(#2961B4)<br>背景蓝色: 222 235 255(#DEEBFF)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E8%93%9D%E8%89%B2.png" alt="字和背景蓝色"></p>
<h2 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h2><p>字绿色: 0 102 100(#006664)<br>背景绿色: 227 252 239(#E3FCEF)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BB%BF%E8%89%B2.png" alt="字和背景绿色"></p>
<p>字绿色: 19 99 53(#136335)<br>背景绿色: 198 239 206(#C6EFCE)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BB%BF%E8%89%B2%E6%96%B9%E6%A1%882.png" alt="字和背景绿色绿色方案2"></p>
<h2 id="红色"><a href="#红色" class="headerlink" title="红色"></a>红色</h2><p>字红色: 255 0 0(#FF0000)<br>背景橙色: 253 233 217(#FDE9D9)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BA%A2%E8%89%B2.png" alt="字和背景红色"></p>
<p>字红色: 128 0 0(#800000)<br>背景橙红色: 255 80 80(#FF5050)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BA%A2%E8%89%B2%E6%96%B9%E6%A1%882.png" alt="字和背景红色方案2"></p>
<p>字红色: 157 38 66(#9D2642)<br>背景红色: 255 199 206(#FFC7CE)</p>
<p><img src="/../resource/%E5%B8%B8%E8%A7%81%E9%A2%9C%E8%89%B2%E4%B8%8ERGB%E5%80%BC/%E5%AD%97%E5%92%8C%E8%83%8C%E6%99%AF%E7%BA%A2%E8%89%B2%E6%96%B9%E6%A1%883.png" alt="字和背景红色方案3"></p>
<h2 id="橙色"><a href="#橙色" class="headerlink" title="橙色"></a>橙色</h2><p>RGB: 255 214 88(#FFD658)</p>
<p>RGB: 248 178 32(#F8B220)</p>
<p>RGB: 255 153 0(#FF9900)</p>
<p>RGB: 245 105 82(#F56952)</p>
<h2 id="绿色-1"><a href="#绿色-1" class="headerlink" title="绿色"></a>绿色</h2><p>RGB: 176 234 101(#B0EA65)</p>
<h2 id="蓝色-1"><a href="#蓝色-1" class="headerlink" title="蓝色"></a>蓝色</h2><p>RGB: 93 209 247(#5DD1F7)</p>
<h2 id="紫色"><a href="#紫色" class="headerlink" title="紫色"></a>紫色</h2><p>RGB: 112 102 243(#7066F3)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2022-06-17-C++%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2022-06-17-C++%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">C++容器的特性与适用场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++容器的特性与适用场景, <a href="../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/C++%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.pptx">PPT</a></p>
<h2 id="容器类别"><a href="#容器类别" class="headerlink" title="容器类别"></a>容器类别</h2><p>首先放上一张来自《C++标准库》中的图片。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/STL_Container_Types.png" alt="STL Container Types"></p>
<h3 id="序列式容器（Sequence-container）"><a href="#序列式容器（Sequence-container）" class="headerlink" title="序列式容器（Sequence container）"></a>序列式容器（Sequence container）</h3><p>这是一种有序(ordered)集合，其内每个元素均有确凿的位置—-取决于插入时机和地点，与元素值无关。如果你以追加方式对一个集和置入6个元素，他们的排列次序将和置入次序一致。STL提供了5个定义好的序列式容器：array、vector、deque、list和forward_list。</p>
<h3 id="关联式容器-Associative-container"><a href="#关联式容器-Associative-container" class="headerlink" title="关联式容器(Associative container)"></a>关联式容器(Associative container)</h3><p>这是一种已排序(sorted)集合，元素位置取决于其value(或key—-如果元素是个key&#x2F;value pair)和给定的某个排序准则。如果将六个元素置入这样的集合中，他们的值将决定他们的次序，和插入次序无关。STL提供了4个关联式容器：set、multiset、map和multimap。</p>
<h3 id="无序容器（Unordered-associative-container）"><a href="#无序容器（Unordered-associative-container）" class="headerlink" title="无序容器（Unordered (associative) container）"></a>无序容器（Unordered (associative) container）</h3><p>这是一种无序集合(unordered collection), 其内每个元素的每个位置无关紧要，唯一重要的是某特定元素是否位于此集合内。元素值或其安插顺序，都不影响元素的位置，而且元素的位置有可能在容器生命周期中被改变。如果你放6个元素到这种集合内，它们的次序不明确，并且可能随时间而改变。STL内含4个预定义的无序容器：unordered_set、unordered_multiset、unordered_map和unordered_multimap。</p>
<ul>
<li><p><strong>Sequence</strong>容器通常被实现为array或linked list</p>
</li>
<li><p><strong>Associative</strong>容器通常被实现为binary tree</p>
</li>
<li><p><strong>Unordered</strong>容器通常被实现为hash table</p>
</li>
</ul>
<h2 id="各种容器使用时机"><a href="#各种容器使用时机" class="headerlink" title="各种容器使用时机"></a>各种容器使用时机</h2><p>  <img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/ContainerSelect.png" alt="ContainerSelect"></p>
<ul>
<li><p>默认情况下应该使用<code>std::vector</code>。<code>std::vector</code>的内部构造最简单，并允许随机访问，所以数据的访问十分方便灵活，数据的处理也够快。</p>
</li>
<li><p>如果经常要在<strong>序列头部和尾部安插和一处元素</strong>，应该采用<code>std::deque</code>。如果你希望元素被移除时，容器能够自动缩减内部用量，那么也该使用<code>std::deque</code>。此外，由于<code>std::vector</code>通常采用一个内存区块来存放元素，而<code>std::deque</code>采用<strong>多个区块</strong>，所以后者可内含更多元素。</p>
</li>
<li><p>如果需要经常<strong>在容器中段执行元素安插、移除和移动</strong>，可考虑使用<code>std::list</code>。<code>std::list</code>提供特殊的成员函数，可在<strong>常量时间内将元素从A容器转移到B容器</strong>。但由于<code>std::list</code><strong>不支持随机访问</strong>，所以如果只知道list的头部却要造访list的中端元素，效能会大打折扣。和所有“以节点为基础”的容器相似，<strong>只要元素仍是容器的一部分，list就不会令指向那些元素的迭代器失效</strong>。<code>std::vector</code>则不然，一旦超过其容量，它的所有<code>iterator</code>、<code>pointer</code>和<code>reference</code>失效。至于<code>std::deque</code>，当它的大小改变，所有<code>iterator</code>、<code>pointer</code>和<code>reference</code>都会失效。</p>
</li>
<li><p>如果你要的容器对异常处理使得“<strong>每次操作若不成功便无任何作用</strong>”，那么应该选用<code>std::list</code>(但是不调用其assignment操作符和sort(), 而且如果元素比较过程中会抛出异常，就不要调用merge()、remove()、remove_if()和unique()，或选用associative&#x2F;unordered容器（但不调用多元素安插动作，而且<strong>如果比较准则的复制&#x2F;赋值动作可能抛出异常，就不要调用swap()或erase()</strong>）)。</p>
</li>
<li><p>如果你经常需要根据某个准则<strong>查找元素</strong>，应当使用“依据该准则进行hash”的<code>std::unordered_set</code> 或<code>std::multiset</code>。然而，hash容器内是无序的，所以如果你必须以来元素的次序(order),应该使用<code>std::set</code>或<code>std::multiset</code>，他们根据查找准则对元素排序。</p>
</li>
<li><p>如果想处理key&#x2F;value pair，请采用<code>unordered_map</code>或<code>std::unordered_multimap</code>。如果元素次序很重要，可采用<code>std::map</code>或<code>std::multimap</code>。</p>
</li>
<li><p>如果需要关联式数组(associative array), 应采用unordered map。如果元素次序很重要，可采用 <code>std::map</code>。</p>
</li>
<li><p>如果需要字典结构，应采用<code>unordered std::multimap</code>。如果元素次序很重要，可采用<code>std::multimap</code>。</p>
</li>
</ul>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/ContainerTypes.png" alt="ContainerTypes"></p>
<table>
<thead>
<tr>
<th></th>
<th>Array</th>
<th>Vector</th>
<th>Dequeue</th>
<th>List</th>
<th>Forward List</th>
<th>关联容器</th>
<th>无序容器</th>
</tr>
</thead>
<tbody><tr>
<td>可用标准</td>
<td>TR1</td>
<td>C++98</td>
<td>C++98</td>
<td>C++11</td>
<td>C++98</td>
<td>C++98</td>
<td>TR1</td>
</tr>
<tr>
<td>数据结构</td>
<td>静态数组</td>
<td>动态数组</td>
<td>数组的数组</td>
<td>双向链表</td>
<td>单向链表</td>
<td>二叉树</td>
<td>哈希表</td>
</tr>
<tr>
<td>元素类型</td>
<td>value</td>
<td>value</td>
<td>value</td>
<td>value</td>
<td>value</td>
<td>set: value <br> map: key&#x2F;value</td>
<td>set: value <br> map: key&#x2F;value</td>
</tr>
<tr>
<td>是否允许重复</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>只有 <code>multiset</code> 和 <code>multimap</code> 允许重复</td>
<td>只有 <code>multiset</code> 和 <code>multimap</code> 允许重复</td>
</tr>
<tr>
<td>迭代器类型</td>
<td>随机访问</td>
<td>随机访问</td>
<td>随机访问</td>
<td>双向迭代器</td>
<td>单向迭代器</td>
<td>双向迭代器</td>
<td>单向迭代器</td>
</tr>
<tr>
<td>增长&#x2F;缩小方式</td>
<td>不会增长&#x2F;缩小</td>
<td>在一端末尾增长</td>
<td>在两端末尾增长</td>
<td>到处增长</td>
<td>到处增长</td>
<td>到处增长</td>
<td>到处增长</td>
</tr>
<tr>
<td>是否可以随机访问</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>差不多</td>
</tr>
<tr>
<td>查找元素</td>
<td>慢</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>非常慢</td>
<td>快</td>
<td>非常快</td>
</tr>
<tr>
<td>添加和删除操作是否会使迭代器无效</td>
<td>-</td>
<td>在重新申请内存时无效</td>
<td>总是无效</td>
<td>从不</td>
<td>从不</td>
<td>从不</td>
<td>在重新哈希时</td>
</tr>
<tr>
<td>添加和删除操作是否会使引用或指针无效</td>
<td>-</td>
<td>在重新申请内存时无效</td>
<td>总是无效</td>
<td>从不</td>
<td>从不</td>
<td>从不</td>
<td>从不</td>
</tr>
<tr>
<td>是否允许保留内存</td>
<td>-</td>
<td>是</td>
<td>否</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>移除元素时释放内存</td>
<td>-</td>
<td>只有在<code>shrink_to_fit()</code>时释放内存</td>
<td>有时</td>
<td>总是</td>
<td>总是</td>
<td>总是</td>
<td>又是</td>
</tr>
<tr>
<td>事务安全(成功或没有影响)</td>
<td>No</td>
<td>在尾部<code>push</code>&#x2F;<code>pop</code>事务安全</td>
<td>在头部和尾部<code>push</code>&#x2F;<code>pop</code>安全</td>
<td>所有的插入和擦除</td>
<td>所有的插入和擦除</td>
<td>假如比较函数没有出现异常，那么单个元素的插入和所有擦除操作都是事务安全的</td>
<td>假如比较函数和哈希函数没有出现异常，那么单个元素的插入和所有擦除操作都是事务安全的</td>
</tr>
</tbody></table>
<h2 id="容器的共同能力"><a href="#容器的共同能力" class="headerlink" title="容器的共同能力"></a>容器的共同能力</h2><ol>
<li>所有容器提供的都是 “value 语义” 而非 “reference 语义”。容器进行元素的安插动作是，内部实施的是 <code>copy</code> 和&#x2F;或 <code>move</code> 动作, 而不是管理元素的 <code>reference</code>。 如果不想要复制，那么只能使用 <code>std::move</code> 或 保存元素指针(不能使用引用来规避复制)。</li>
<li>元素在容器内有其特定顺序。每一种容器会提供若干返回迭代器的操作函数，这些迭代器可以用来遍历各个元素。如果你在元素之间迭代多次，你会获得相同的次序(不调用增删函数)</li>
<li>一般而言，各项操作并非绝对安全，也就是说他们不会检查每一个可能发生的错误。调用者必须确保传给操作函数的实参符合条件。</li>
<li>都提供如下成员函数</li>
</ol>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">注解</th>
</tr>
</thead>
<tbody><tr>
<td align="center">default construct</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">copy construct</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">destructor</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">begin()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">cbegin()</td>
<td align="center">after C++11</td>
</tr>
<tr>
<td align="center">cend()</td>
<td align="center">after C++11</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">swap()</td>
<td align="center">std::array: O(n), 其他容器: O(1)</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">empty() 的实现可能比 size() &#x3D;&#x3D; 0 更有效率，尽可能使用该函数</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">max_size()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">operator&#x3D;&#x3D;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">operator!&#x3D;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">operator&lt;</td>
<td align="center">除了无序容器</td>
</tr>
<tr>
<td align="center">operator&lt;&#x3D;</td>
<td align="center">除了无序容器</td>
</tr>
<tr>
<td align="center">operator&gt;</td>
<td align="center">除了无序容器</td>
</tr>
<tr>
<td align="center">operator&gt;&#x3D;</td>
<td align="center">除了无序容器</td>
</tr>
</tbody></table>
<h2 id="容器遍历方式"><a href="#容器遍历方式" class="headerlink" title="容器遍历方式"></a>容器遍历方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// After C++11</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> element : container)</span><br><span class="line">&#123;</span><br><span class="line">    element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只对拥有随机访问迭代器的容器使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; container.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    container[i]/container.<span class="built_in">at</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 所有元素通用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = container.<span class="built_in">begin</span>(); it != container.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-0-与-empty"><a href="#size-0-与-empty" class="headerlink" title="size() &#x3D;&#x3D; 0 与 empty()"></a>size() &#x3D;&#x3D; 0 与 empty()</h3><p>在 <code>C++11</code> 之前 <code>std::list::empty()</code> 函数的时间复杂度可能是 <code>O(n)</code> 也可能是 <code>O(1)</code>.</p>
<div STYLE="page-break-after: always;"></div>

<h2 id="std-array-C-11"><a href="#std-array-C-11" class="headerlink" title="std::array C++11"></a><code>std::array</code> C++11</h2><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/array_base.png" alt="array"></p>
<ul>
<li>随机访问</li>
<li>固定大小, 编译期确定</li>
<li>大小可为零</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 作为返回值返回</span></span><br><span class="line"><span class="function">std::array&lt;<span class="type">int</span>, 5&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 作为入参时确定入参大小，不会降级为指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a.<span class="built_in">size</span>())&#123;&#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">5</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 搭配模板灵活使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> std::array&lt;<span class="type">int</span>, N&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a.<span class="built_in">size</span>())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 6&gt; a;</span><br><span class="line"><span class="built_in">f2</span>(a);</span><br></pre></td></tr></table></figure>

<div STYLE="page-break-after: always;"></div>

<h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a><code>std::vector</code></h2><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/vector_base.png" alt="vector"></p>
<h3 id="迭代器示意"><a href="#迭代器示意" class="headerlink" title="迭代器示意"></a>迭代器示意</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/iterator.png" alt="iterator"></p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/reverse_iterator.png" alt="reserve_iterator"></p>
<h3 id="at-与-operator"><a href="#at-与-operator" class="headerlink" title="at() 与 operator[]"></a>at() 与 operator[]</h3><p><code>at()</code> 成员函数提供边界检查，超出边界时会抛出异常 <code>std::out_of_range</code></p>
<h3 id="size-与-capacity"><a href="#size-与-capacity" class="headerlink" title="size() 与 capacity()"></a>size() 与 capacity()</h3><p>size() 查看当前有几个元素</p>
<p>capacity() 查看预分配几个元素的空间</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/size()%E4%B8%8Ecapacity().png" alt="size"></p>
<h3 id="resize-与-reserve"><a href="#resize-与-reserve" class="headerlink" title="resize() 与 reserve()"></a>resize() 与 reserve()</h3><h4 id="resize-count"><a href="#resize-count" class="headerlink" title="resize(count)"></a>resize(count)</h4><blockquote>
<p>重设容器大小以容纳 count 个元素。</p>
<p>若当前大小大于 count ，则减小容器为其首 count 个元素。</p>
<p>若当前大小小于 count ，</p>
<ol>
<li>则后附额外的默认插入的元素</li>
<li>则后附额外的 value 的副本</li>
</ol>
</blockquote>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/resize.png" alt="resize"></p>
<h4 id="reserve-new-cap"><a href="#reserve-new-cap" class="headerlink" title="reserve(new_cap)"></a>reserve(new_cap)</h4><blockquote>
<p>增加 vector 的容量到大于或等于 new_cap 的值。若 new_cap 大于当前的 capacity() ，则分配新存储，否则该方法不做任何事。</p>
<p>reserve() 不更改 vector 的 size 。</p>
<p>若 new_cap 大于 capacity() ，则所有迭代器，包含尾后迭代器和所有到元素的引用都被非法化。否则，没有迭代器或引用被非法化。</p>
</blockquote>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/reserve.png" alt="reserve"></p>
<h3 id="shrink-to-fit-C-11"><a href="#shrink-to-fit-C-11" class="headerlink" title="shrink_to_fit() (C++11)"></a>shrink_to_fit() (C++11)</h3><blockquote>
<p>请求移除未使用的容量。</p>
<p>它是减少 capacity() 到 size()非强制性请求。请求是否达成依赖于实现。</p>
<p>若发生重分配，则所有迭代器，包含尾后迭代器，和所有到元素的引用都被非法化。若不发生重分配，则没有迭代器或引用被非法化。</p>
</blockquote>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/shrink_to_fit.png" alt="shrink_to_fit"></p>
<p>C++11 之前可以使用如下方式，缩减空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShrinkCapacity</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">tmp</span><span class="params">(v)</span></span>;</span><br><span class="line">    v.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="push-back-与-push-front"><a href="#push-back-与-push-front" class="headerlink" title="push_back() 与 push_front()"></a>push_back() 与 push_front()</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/push_back.png" alt="push_back()"></p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/push_front.png" alt="push_front()"></p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/insert.png" alt="insert()"></p>
<h3 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/erase.png" alt="erase()"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">/// 下面这句话为错误</span></span><br><span class="line">        <span class="comment">/// vec.erase(it++);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h3><blockquote>
<p>返回指向作为元素存储工作的底层数组的指针。指针满足范围 [data(); data() + size()) 始终是合法范围，即使容器为空（该情况下 data() 不可解引用）。</p>
</blockquote>
<p>拷贝 <code>vector</code> 中的数据到缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> auc[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// unsigned char 数组转换为 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">vec</span><span class="params">(auc, auc+<span class="keyword">sizeof</span>(auc))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// vector 转换为 unsigned char 数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* puc = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[vec.<span class="built_in">size</span>()];</span><br><span class="line"><span class="built_in">memcpy</span>(puc, vec.<span class="built_in">data</span>(), vec.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<h3 id="std-vector-bool"><a href="#std-vector-bool" class="headerlink" title="std::vector &lt; bool &gt;"></a>std::vector &lt; bool &gt;</h3><p>该容器不是 布尔类型的 <code>std::vector</code>, 而是有单独的实现，不应看作普通的 <code>std::vector</code> 使用。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol>
<li>如果 <code>push_back()</code> 安插元素时发生异常，函数将不会产生效用。</li>
<li>如果元素的 <code>copy/move</code> 操作(包括构造函数和赋值运算符)不抛出异常，这意味着 <code>insert()</code>、<code>emplace()</code>、<code>emplace_back()</code>、<code>push_back()</code>要么成功，要么什么也不发生。</li>
<li><code>pop_back()</code> 不会抛出任何异常</li>
<li>如果元素的 <code>copy/move</code> 的操作(包括构造函数和赋值运算符)不抛出异常, <code>erase()</code> 就不抛出异常</li>
<li><code>swap()</code> 和 <code>clear()</code> 不抛出异常</li>
<li>如果元素的 <code>copy/move</code> 操作(包括构造函数和赋值运算符)不抛出异常, 那么所有操作不是成功就是不产生效用。这类元素可能是 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/146452/what-are-pod-types-in-c">POD</a>。</li>
</ol>
<p>以上所有保证都基于一个条件: 析构函数不得抛出异常。</p>
<div STYLE="page-break-after: always;"></div>

<h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a><code>std::deque</code></h2><p>提供随机访问，接口与 <code>std::vector</code> 几乎一致。可以在首尾快速安插和删除。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/deque_base0.png" alt="deque_base"></p>
<p>通常实现为一组独立的区块，第一区块往一个方向发展，最末的区块往另一个方向发展。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/deque_base1.png" alt="deque_base"></p>
<h3 id="std-deque-与-std-vector-比较"><a href="#std-deque-与-std-vector-比较" class="headerlink" title="std::deque 与 std::vector 比较"></a><code>std::deque</code> 与 <code>std::vector</code> 比较</h3><h4 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h4><ul>
<li>在中段安插、移除元素的速度相对较慢，因为所有元素都需移动以腾出或填补空间。</li>
<li>迭代器属于随机访问迭代器，可以使用 <code>operator[]</code> \ <code>at()</code></li>
</ul>
<h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ul>
<li><code>std::deque</code> 可在常量时间内快速在首尾增删元素。 <code>std::vector</code> 只能在尾部。</li>
<li>访问元素时， <code>std::deque</code> 多了一个跳转的过程(在各个区块跳转)</li>
<li><code>std::deque</code> 的迭代器不是原始指针(因为各个区块之间不连续), 更没有 <code>data</code> 的成员函数</li>
<li><code>std::deque</code> 不支持对容量和内存分配时机的控制。</li>
<li><code>std::deque</code> 在首尾两端增删元素导致所有元素的迭代器失效(指针和引用仍有效)，其他所有增删操作都会导致所有元素的指针、引用和迭代器失效。</li>
<li><code>std::deque</code> 的内存分配优于 <code>std::vector</code>, <code>std::deque</code> 不必在内存分配时复制所有元素。</li>
<li><code>std::deque</code> 会释放不再使用的内存区块。 <code>std::deque</code> 的内存大小是可缩减的, 但要不要这么做，以及如何做，由实现决定。</li>
<li><code>std::deque</code> 不提供容量操作 <code>capacity()</code> 和 <code>reserve()</code></li>
<li>在内存区块大小有限制的系统中, <code>std::deque</code> 的 <code>max_size()</code> 可能比 <code>std::vector</code> 的 <code>max_size()</code> 要大。 因为 <code>std::deque</code> 使用的不止一块内存。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>需要在两端安插和移除元素</li>
<li>无须指向容器内的元素</li>
<li>要求使用内存会自动缩小</li>
</ul>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p>原则上 <code>std::deque</code> 提供的异常处理和 <code>std::vector</code> 提供的一样</p>
<ul>
<li><code>push_front()</code> 和 <code>push_back()</code> 安插元素时发生异常，则该操作不带来任何效应。</li>
<li><code>pop_front()</code> 和 <code>pop_back()</code> 不会抛出任何异常。</li>
</ul>
<h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a><code>std::list</code></h2><p>双向链表。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/list_base.png" alt="list"></p>
<p><code>std::list</code> 的内部结构完全迥异于 <code>std::array</code>、<code>std::vector</code>、<code>std::deque</code>。 <code>std::list</code> 自身提供了两个指针，分别指向第一个元素和最后一个元素，如果操纵对应的指针即可。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/list_insert.png" alt="list_insert"></p>
<p>成员函数 <code>splice</code> 示意</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/list_splice.png" alt="list_splice"></p>
<h3 id="容器特性"><a href="#容器特性" class="headerlink" title="容器特性"></a>容器特性</h3><ul>
<li>提供 <code>front()</code>、<code>push_front()</code>、<code>pop_front()</code>、<code>back()</code>、<code>push_back()</code>和<code>pop_back()</code> 等操作函数。</li>
<li>不提供 <code>operator[]</code> 或 <code>at()</code></li>
<li>不支持随机访问。O(n)</li>
<li>在任何位置插入元素非常快。O(1), 只是改变了指针指向。</li>
<li>迭代器永久有效。插入和删除动作并不会造成指向其他元素的指针、引用和迭代器失效。</li>
<li>异常安全 <code>std::list</code> 的异常处理为: 要么操作成功、要么什么都不发生。</li>
<li>事务安全。 只要不调用赋值操作或 <code>sort()</code>, 并保证元素相互比较时不抛出异常那么<code>std::list</code>可以成为事务安全</li>
<li>空间最优。没有空间重新分配和预分配内存, 没有冗余内存占用</li>
<li>拥有较多的特殊成员函数，相较于 <code>STL</code> 中通用的同名函数，更具有效率。如 <code>merge</code>、<code>splice</code>、<code>remove</code>、<code>reverse</code>、<code>unique</code>、<code>sort</code>。</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>特性: 前向迭代器</p>
<ul>
<li>排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">list.<span class="built_in">sort</span>();</span><br><span class="line"><span class="comment">/// 错误用法: std::sort(list.begin(), list.end());</span></span><br></pre></td></tr></table></figure>

<ul>
<li>特殊的排序后显示</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::reference_wrapper&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">Observer</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(Observer.<span class="built_in">begin</span>(), Observer.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>特性: 迭代器永不失效</p>
<ul>
<li>双键结构</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">LEFT_KEY</span>, <span class="keyword">class</span> <span class="title class_">RIGHT_KEY</span>, <span class="keyword">class</span> <span class="title class_">VALUE</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bimap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;VALUE&gt; m_Value;                     <span class="comment">///&lt; 用于存放值</span></span><br><span class="line">    std::map&lt;LEFT_KEY, iterator&gt; m_LeftKeyMap;    <span class="comment">///&lt; 用于保存左键与值得映射关系的map</span></span><br><span class="line">    std::map&lt;RIGHT_KEY, iterator&gt; m_RightKeyMap;  <span class="comment">///&lt; 用于保存右键与值得映射关系的map</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div STYLE="page-break-after: always;"></div>

<h2 id="std-forward-list-C-11"><a href="#std-forward-list-C-11" class="headerlink" title="std::forward_list (C++11)"></a><code>std::forward_list</code> (C++11)</h2><p>标准描述</p>
<blockquote>
<p><code>std::forward_list</code> 是支持从容器中的任何位置快速插入和移除元素的容器。不支持快速随机访问。它实现为单链表，且实质上与其在 <code>C</code> 中实现相比无任何开销。与 <code>std::list</code> 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储。</p>
</blockquote>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/forward_list_base.png" alt="forward_list"></p>
<h3 id="与-std-list-比较"><a href="#与-std-list-比较" class="headerlink" title="与 std::list 比较"></a>与 <code>std::list</code> 比较</h3><ul>
<li><code>std::forward_list</code> 只提供前向迭代器，而不是双向迭代器。没有成员函数<code>rbegin()</code>、<code>rend()</code>、<code>crbegin()</code>和<code>crend()</code></li>
<li><code>std::forward_list</code> 不提供成员函数 <code>size()</code>。</li>
<li><code>std::forward_list</code> 没有指向最末元素的指针。所以没有成员函数如<code>back()</code>、<code>push_back()</code>和<code>pop_back()</code></li>
<li>对于所有令元素被安插在或删除于的某特定位置上的成员函数， <code>std::forward_list</code> 都提供特殊版本。原因是你必须传递第一个被处理元素的前一位置，前向迭代器不能回头。</li>
<li><code>insert_after()</code> 代替 <code>insert()</code>, 也额外提供 <code>before_begin()</code> 和 <code>cbefore_begin()</code></li>
</ul>
<h3 id="在起始处安插元素"><a href="#在起始处安插元素" class="headerlink" title="在起始处安插元素"></a>在起始处安插元素</h3><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/forward_insert_begin.png" alt="forward_insert_begin"></p>
<div STYLE="page-break-after: always;"></div>

<h2 id="std-set-和-std-multiset"><a href="#std-set-和-std-multiset" class="headerlink" title="std::set 和 std::multiset"></a><code>std::set</code> 和 <code>std::multiset</code></h2><p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/set_base.png" alt="set"></p>
<p><code>std::set</code> 和 <code>std::multiset</code> 会根据特定的排序准则，自动将元素排序。两者不同之处在于 <code>std::multiset</code> 允许元素重复而 <code>std::set</code> 不允许。</p>
<p>如果没有传入某个排序准则，就采用默认准则 <code>std::less</code> 以 <code>operator&lt;</code> 对元素进行比较。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/set_datastruct.png" alt="set"></p>
<h3 id="排序准则符合-严格弱序"><a href="#排序准则符合-严格弱序" class="headerlink" title="排序准则符合: 严格弱序"></a>排序准则符合: 严格弱序</h3><h4 id="详细定义"><a href="#详细定义" class="headerlink" title="详细定义"></a>详细定义</h4><blockquote>
<ol>
<li><p>必须是<strong>非对称的</strong>（antisymmetric）。</p>
<p> 对<code>operator&lt; </code>而言， 如果x &lt; y为true， 则y &lt; x为false。</p>
<p> 对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true，则op(y, x)为false。</p>
</li>
<li><p>必须是<strong>可传递的</strong>（transitive）。</p>
</li>
</ol>
<p>  对<code>operator&lt; </code>而言，如果x &lt; y 为true且y &lt; z为true， 则x &lt; z 为false。</p>
<p>  对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true且op(y, z)为tru，则op(x, z)为true。</p>
<ol start="3">
<li><p>必须是<strong>非自反的</strong>（irreflexive）</p>
<p> 对<code>operator&lt; </code>而言，x &lt; x 永远是false</p>
<p> 对判断式(predicate) <code>op()</code>而言，op(x, x)永远是false。</p>
</li>
<li><p>必须有<strong>等效传递性</strong>（transitivity of equivalence）</p>
</li>
</ol>
<p>对<code>operator&lt; </code>而言，假如 !(a&lt;b) &amp;&amp; !(b&lt;a) 为true且 !(b&lt;c) &amp;&amp; !(c&lt;b) 为 true<br>那么!(a&lt;c) &amp;&amp; !(c&lt;a) 也为true.<br>对判断式(predicate) <code>op()</code>而言， 假如 op(a,b), op(b,a), op(b,c), 和op(c,b) 都为<br>false, 那么op(a,c) and op(c,a) 也为false.</p>
</blockquote>
<p><strong>简单的来说就是a&lt;b返回true，a&#x3D;b和a&gt;b返回false。</strong></p>
<h4 id="定制排序规则-operator"><a href="#定制排序规则-operator" class="headerlink" title="定制排序规则 operator&lt;"></a>定制排序规则 <code>operator&lt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CALL_INFO_C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> CALL_INFO_C&amp; stOther) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; stOther.x || (x == stOther.x &amp;&amp; y &lt; stOther.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::set&lt;CALL_INFO_C&gt; set;</span><br></pre></td></tr></table></figure>

<p>其中 <code>std::multiset</code> 的等效元素的次序是随机但稳定的。(C++11以后标准保证新插入的元素，会被放在等效元素群的末尾)</p>
<h3 id="std-set-和-std-multiset-的能力"><a href="#std-set-和-std-multiset-的能力" class="headerlink" title="std::set 和 std::multiset 的能力"></a><code>std::set</code> 和 <code>std::multiset</code> 的能力</h3><ul>
<li>通常以平衡二叉树完成。</li>
<li>自动排序的主要优点在于令二叉树于查找元素时拥有良好的性能。其查找函数具有 <code>O(logn)</code> 的时间复杂度。</li>
<li>不能随意改变元素值，因为这会打乱原本正确的顺序。</li>
<li>如果要改变元素值，必须先删除旧元素，再插入新元素。</li>
<li>不提供任何操作函数可以直接访问底层元素</li>
<li>通过迭代器进行元素间接访问，有一个限制: 从迭代器的角度看，元素值是常量.(例如不能使用: <code>std::remove()</code>)</li>
<li>其迭代器是双向迭代器(不能使用 <code>std::sort()</code>)</li>
</ul>
<div STYLE="page-break-after: always;"></div>

<h2 id="std-map-和-std-multimap"><a href="#std-map-和-std-multimap" class="headerlink" title="std::map 和 std::multimap"></a><code>std::map</code> 和 <code>std::multimap</code></h2><p><code>std::map</code> 和 <code>std::multimap</code> 将 <code>key/value pair</code> 当作元素进行管理。它们可根据 <code>key</code> 的排序准则自动为元素排序。 <code>std::multimap</code> 允许重复元素, <code>std::map</code> 不允许。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/map_base.png" alt="map"></p>
<p>同样 <code>key</code> 需要可比较且遵循严格弱序。</p>
<p><code>std::map</code> 和 <code>std::multimap</code> 通常以平衡二叉树完成。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/map_datastruct.png" alt="map"></p>
<p><code>std::map</code> 和 <code>std::multimap</code> 也无法改变 <code>key</code> 的值。只能删除再插入。</p>
<h3 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h3><p>若<code>key</code>不存在, 构造该元素后，返回元素的引用<br>若<code>key</code>存在, 返回元素的引用</p>
<p>所以要警惕如下语句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line">std::cout &lt;&lt; map[<span class="string">&quot;string&quot;</span>]; <span class="comment">///&lt; 这里会默认插入一个元素 (&quot;string&quot;, 0)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line">map[<span class="string">&quot;string&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="string">&quot;string&quot;</span>] = <span class="number">2</span>;  <span class="comment">///&lt; 会覆盖前面的值</span></span><br></pre></td></tr></table></figure>

<p>也可以利用这一特性用来计数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    map[str.<span class="built_in">at</span>(i)]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div STYLE="page-break-after: always;"></div>

<h2 id="无序容器-Unordered-Container-C-11"><a href="#无序容器-Unordered-Container-C-11" class="headerlink" title="无序容器 (Unordered Container) C++11"></a>无序容器 (Unordered Container) C++11</h2><p>C++11 之前因为标准库中没有哈希表类的数据结构，所以很多程序库自己实现了诸如 <code>hash_set</code>、<code>hash_multiset</code>、<code>hash_map</code>、<code>hash_multimap</code>。</p>
<p>为了避免名称冲突，C++11 标准采用了不一样的名称，使用统一前缀 <code>unordered_</code>, 即<code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>、<code>unordered_multimap</code>。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/unordered_map_base.png" alt="unordered_map"></p>
<p><code>unordered_set</code>、 <code>unordered_multiset</code>、<code>unordered_map</code>、<code>unordered_multimap</code> 底层实现都是哈希表，所以 <code>key</code> 需要可哈希。</p>
<p>但是在链表是单链还是双链(意味着其迭代器可能不是双向迭代器)，重新哈希的时机这些都没有指定，根据实现而定。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/unordered_map_datastruct.png" alt="unordered_map"></p>
<h3 id="定制哈希示例"><a href="#定制哈希示例" class="headerlink" title="定制哈希示例"></a>定制哈希示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MY_HASH</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> CALL_INFO_C&amp; st)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;CALL_INFO_C, <span class="type">int</span>, MY_HASH&gt; map;</span><br></pre></td></tr></table></figure>


<h3 id="容器特性-1"><a href="#容器特性-1" class="headerlink" title="容器特性"></a>容器特性</h3><p>安插、删除、查找元素大部分是 O(1), 但偶尔发生的重新哈希时间复杂度变为 O(n)</p>
<p>由于其迭代器只保证至少为前向迭代器，因此不提供包括 <code>rbegin()</code>、 <code>rend()</code>以及不能使用要求双向迭代器的的 STL 函数如<code>std::sort()</code>、<code>std::binary_search()</code></p>
<p>你可以手动强制重新哈希。</p>
<p>重新哈希可能发生在以下调用之后: <code>insert()</code>、<code>rehash()</code>、<code>rehash()</code> 或 <code>clear()</code>。</p>
<p><code>erase()</code> 函数并不会令指向其他元素的指针、引用和迭代器失效。</p>
<p><code>insert()</code> 和 <code>emplace()</code> 可能令所有迭代器失效。但不会影响引用的有效性。</p>
<p>当重新哈希过程发生，元素的引用仍然有效。</p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>假如缓存中，我们缓存若干最近访问和删除的记录至内存用于快速访问，使得插入记录和读取最近的记录的时间复杂度为 <code>O(1)</code>。</p>
<ul>
<li>LRU (Least recently used)</li>
</ul>
<p>设计接口</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该擦除最久未使用的关键字。</li>
<li>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</li>
</ul>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/put.jpg" alt="put"></p>
<p>设计思路:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; KEY_VALUE;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::list&lt;KEY_VALUE&gt;::iterator&gt; map;</span><br><span class="line">std::list&lt;KEY_VALUE&gt; list;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>std::unordered_map</code> 特性: 单向迭代器, 增删元素 O(1), 增删元素后迭代器可能失效</p>
<p><code>std::list</code> 特性: 迭代器永不失效，任意位置插入常量时间 O(1), 访问首尾元素 O(1)</p>
<p>完整代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">max_size</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (res != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            list.<span class="built_in">splice</span>(list.<span class="built_in">begin</span>(), list, res-&gt;second);</span><br><span class="line">            <span class="keyword">return</span> res-&gt;second-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = map.<span class="built_in">find</span>(key);</span><br><span class="line">        list.<span class="built_in">push_front</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        <span class="keyword">if</span> (res != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            list.<span class="built_in">erase</span>(res-&gt;second);</span><br><span class="line">            map.<span class="built_in">erase</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        map[key] = list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 检查是否超出了最大数量</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">size</span>() &gt; max_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> last = list.<span class="built_in">end</span>();</span><br><span class="line">            --last;</span><br><span class="line">            map.<span class="built_in">erase</span>(last-&gt;first);</span><br><span class="line">            list.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; KEY_VALUE;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::list&lt;KEY_VALUE&gt;::iterator&gt; map;</span><br><span class="line">    std::list&lt;KEY_VALUE&gt; list;</span><br><span class="line">    <span class="type">int</span> max_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div STYLE="page-break-after: always;"></div>

<h2 id="特殊容器"><a href="#特殊容器" class="headerlink" title="特殊容器"></a>特殊容器</h2><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a><code>std::string</code></h3><p>其被定义为: <code>std::basic_string&lt;char&gt;</code></p>
<p>其中模板入参 <code>char</code> 可以换为 <code>unsigned char</code> 或 <code>wchar</code></p>
<h3 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a><code>std::stack</code></h3><p>后进先出</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/stack_base.png" alt="stack"></p>
<p><code>std::stack</code> 定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack;</span><br></pre></td></tr></table></figure>

<p>其底层类型默认为 <code>std::deque</code></p>
<p>之所以不选择 <code>std::vector</code> 是因为在内存管理上 <code>std::deque</code> 比 <code>std::vector</code> 更有效率。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/stack_base1.png" alt="stack"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="built_in">top</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_deque.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">push_front</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container m_deque;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div STYLE="page-break-after: always;"></div>

<h3 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a><code>std::queue</code></h3><p>先进先出</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/queue_base.png" alt="queue"></p>
<p>底层实现默认采用 <code>std::queue</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue;</span><br></pre></td></tr></table></figure>

<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/queue_base1.png" alt="queue"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="built_in">top</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_deque.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container m_deque;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div STYLE="page-break-after: always;"></div>

<h3 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a><code>std::priority_queue</code></h3><p>实现出一个队列，其中的元素按优先级存储。</p>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/priority_queue_base.png" alt="queue"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Container = vector&lt;T&gt;,</span><br><span class="line"><span class="keyword">typename</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>

<p>应用实例:</p>
<p>求数据流中的中位数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mi.<span class="built_in">push</span>(num);</span><br><span class="line">            num = mi.<span class="built_in">top</span>();</span><br><span class="line">            mi.<span class="built_in">pop</span>();</span><br><span class="line">            mx.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mx.<span class="built_in">push</span>(num);</span><br><span class="line">            num = mx.<span class="built_in">top</span>();</span><br><span class="line">            mx.<span class="built_in">pop</span>();</span><br><span class="line">            mi.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)mx.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span> (mx.<span class="built_in">top</span>() + mi.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::less&lt;<span class="type">int</span>&gt; &gt; mx;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; mi;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h3 id="std-bitset"><a href="#std-bitset" class="headerlink" title="std::bitset"></a><code>std::bitset</code></h3><p><code>std::bitset</code> 内含一个元素值为 <code>bit</code> 或 <code>bool</code> 值且大小固定的 <code>array</code>。当你需要管理各式<code>flag</code>, 并以 <code>flag</code> 的任意组合来表现变量时, 就可运用 <code>std::bitset</code>。</p>
<p>可容纳任意个数的标志位(编译期确定数量)</p>
<p><code>std::bitset</code> 编译期确定大小 <code>std::vector&lt;bool&gt;</code> 可动态增长。</p>
<h4 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h4><p>给 1000 个数字排序, 数字范围 [0, 99]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a[<span class="number">1000</span>] = &#123;<span class="number">10</span>, <span class="number">99</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">std::bitset&lt;100&gt; bitset;</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> pos = a[i];</span><br><span class="line">    bitset.<span class="built_in">set</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; bitset.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitset[i])</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给 40 亿个 <code>unsigned</code> 数字([0, 99])中寻找不存在的数值</p>
<h4 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a></h4><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。多用于数据传输中的差错控制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 0 &lt;= x, y &lt;= 2^31 - 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;32&gt; <span class="title">temp</span><span class="params">(x^y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div STYLE="page-break-after: always;"></div>

<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p><code>Iterator</code>(迭代器)是一种”能够迭代某序列内所有元素”的对象，可通过改变自寻常pointer的一致性接口来完成工作。<code>Iterator</code>奉行一个纯抽象概念：任何东西，只要行为类似iterator，就是一种iterator。然而不同的的iterator具有不同的行进能力。</p>
<h3 id="迭代器种类"><a href="#迭代器种类" class="headerlink" title="迭代器种类"></a>迭代器种类</h3><table>
<thead>
<tr>
<th>迭代器种类</th>
<th>能力</th>
<th>提供者</th>
</tr>
</thead>
<tbody><tr>
<td>Output 迭代器</td>
<td>向前写入</td>
<td>Ostream,inserter</td>
</tr>
<tr>
<td>Input 迭代器</td>
<td>向前读取一次</td>
<td>Istream</td>
</tr>
<tr>
<td>Forward 迭代器</td>
<td>向前读取</td>
<td>Forward list、unordered containers</td>
</tr>
<tr>
<td>Bidirectional 迭代器</td>
<td>向前和向后读取</td>
<td>List、set、multiset、map、multimap</td>
</tr>
<tr>
<td>Random-access 迭代器</td>
<td>以随机访问方式读取</td>
<td>Array、vector、deque、string、C-style array</td>
</tr>
</tbody></table>
<p><img src="/../resource/%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/iterator_base.png" alt="iterator"></p>
<p>Output迭代器允许一步一步前行并搭配write动作。因此你可以一个一个元素地赋值，不能使用output迭代器对同一区间迭代两次。事实上，甚至不保证你可以将一个value复制两次而其迭代器不累进。我们的目标是将一个value以下列形式写入一个黑洞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">  *pos = ...;</span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output 迭代器无需比较操作。你无法检验output迭代器是否有效，或写入是否成功。你唯一可做的就是写入。通常，一批写入动作是以一个”额外条件定义出”的”特定output迭代器”作为结束。<br>见下表Output迭代器操作</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>*iter &#x3D; val</td>
<td>将val写至迭代器所指的位置</td>
</tr>
<tr>
<td>++iter</td>
<td>向前步进(step forward), 返回新位置</td>
</tr>
<tr>
<td>iter++</td>
<td>向前步进(step forward), 返回旧位置</td>
</tr>
<tr>
<td>TYPE(iter)</td>
<td>复制迭代器(copy 构造函数)</td>
</tr>
</tbody></table>
<h3 id="Input迭代器"><a href="#Input迭代器" class="headerlink" title="Input迭代器"></a>Input迭代器</h3><p>Input迭代器只能一次一个以前行方向读取元素，按此顺序一个个返回元素值。</p>
<p>Input迭代器的各项操作</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>*iter</td>
<td>读取实际元素</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>读取实际元素的成员(如果有的话)</td>
</tr>
<tr>
<td>++iter</td>
<td>向前步进(step forward), 返回新位置</td>
</tr>
<tr>
<td>iter++</td>
<td>向前步进(step forward), 返回旧位置</td>
</tr>
<tr>
<td>iter1 &#x3D;&#x3D; iter2</td>
<td>判断两个迭代器是否相等</td>
</tr>
<tr>
<td>iter1 !&#x3D; iter2</td>
<td>判断两个迭代器是否不相等</td>
</tr>
<tr>
<td>TYPE(iter)</td>
<td>复制迭代器(copy 构造函数)</td>
</tr>
</tbody></table>
<p>Input迭代器只能读取元素一次。如果你复制input迭代器, 并令原input迭代器和新产生的拷贝都向前读取, 可能会遍历到不同的值。<br><strong>所有的迭代器都具备input迭代器的能力，而且往往更强。</strong><code>Pure input</code>迭代器的典型例子就是”从标准输入设备读取数据”。同一个值不会被读取两次。一旦从<code>input stream</code>读入一个字(离开input缓冲区), 下次读取时就会返回另一个字。</p>
<p>对于input迭代器, 操作符&#x3D;&#x3D;和!&#x3D;只用来检查”某个迭代器是否等于一个past-the-end迭代器(指指向最末元素的下一个位置)”.这有其必要, 因为处理input迭代器的操作函数通常会有以下行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputIterator pos, end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos != end) &#123;</span><br><span class="line">  ... <span class="comment">// read-only access using *pos</span></span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>没有任何保证说，两个迭代器如果都不是past-the-end迭代器, 且指向不同位置，他们的比较结果会不相等</strong>(这个条件是和forward迭代器搭配引入的)。</p>
<p>也请注意, input迭代器的后置式递增操作符(<code>++iter</code>)不一定会返回什么东西。不过通常它会返回旧位置。<br>你应该尽可能优先先选用前置式递增操作符(<code>++iter</code>)而非后置式递增操作符(<code>iter++</code>), 因为前者效能更好。因为后者会返回一个临时对象。</p>
<h3 id="Forward-前向-迭代器"><a href="#Forward-前向-迭代器" class="headerlink" title="Forward(前向)迭代器"></a>Forward(前向)迭代器</h3><p>Forward迭代器是一种input迭代器且在前进读取时提供额外保证。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>*iter</td>
<td>访问实际元素</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>访问实际元素的成员</td>
</tr>
<tr>
<td>++iter</td>
<td>向前步进(返回新位置)</td>
</tr>
<tr>
<td>iter++</td>
<td>向前步进(返回旧位置)</td>
</tr>
<tr>
<td>iter1 &#x3D;&#x3D; iter2</td>
<td>判断两个迭代器是否相等</td>
</tr>
<tr>
<td>iter1 !&#x3D; iter2</td>
<td>判断两个迭代器是否不等</td>
</tr>
<tr>
<td>TYPE()</td>
<td>创建迭代器(default构造函数)</td>
</tr>
<tr>
<td>TYPE(iter)</td>
<td>复制迭代器(拷贝构造函数)</td>
</tr>
<tr>
<td>iter1 &#x3D; iter2</td>
<td>对迭代器赋值(assign)</td>
</tr>
<tr>
<td>和input迭代器不同的是, 两个forward迭代器如果指向同一元素, <code>operator==</code>会获得<code>true</code>, 如果两者都递增, 会再次指向同一元素。</td>
<td></td>
</tr>
<tr>
<td>例如：</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ForwardIterator pos1, pos2;</span><br><span class="line"></span><br><span class="line">pos1 = pos2 = begin; <span class="comment">/// both iterator refer to the same element</span></span><br><span class="line"><span class="keyword">if</span>(pos1 != end) &#123;</span><br><span class="line">  ++pos1; <span class="comment">/// pos1 is one element ahead</span></span><br><span class="line">  <span class="keyword">while</span>(pos1 != end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(*pos1 == *pos2) &#123;</span><br><span class="line">      ... <span class="comment">// precess adjacent duplicates</span></span><br><span class="line">      ++pos1;</span><br><span class="line">      ++pos2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Forward迭代器由以下对象和类型提供：</p>
<ul>
<li>Class<forward_list></li>
<li>Unordered container<br>然而标准库也允许<code>unordered</code>容器的实现提供<code>bidirectional</code>迭代器。<br>如果forward迭代器履行了output迭代器应有的条件, 那么它就是一个mutable forward迭代器, 即可用于读取，也可用于涂写。</li>
</ul>
<h3 id="Random-Access-随机访问-迭代器"><a href="#Random-Access-随机访问-迭代器" class="headerlink" title="Random-Access(随机访问)迭代器"></a>Random-Access(随机访问)迭代器</h3><p><code>Random-access</code>迭代器在<code>bidirectional</code>迭代器的基础上增加了随机访问能里。因此它必须提供<code>iterator</code>算数运算。也就是说，它能增减某个偏移量、<br>计算距离(<code>difference</code>), 并运用诸如&lt;和&gt;等管理操作符(<code>relational operator</code>)进行比较。</p>
<p>随机访问迭代器的新增操作:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>iter[n]</td>
<td>访问索引位置为n的元素</td>
</tr>
<tr>
<td>iter+&#x3D;n</td>
<td>前进n个元素(如果n是负数, 则改为回退)</td>
</tr>
<tr>
<td>iter-&#x3D;n</td>
<td>回退n个元素(如果n是负数, 则改为前进)</td>
</tr>
<tr>
<td>iter+n</td>
<td>返回iter之后的第n个元素</td>
</tr>
<tr>
<td>n+iter</td>
<td>返回iter之后的第n个元素</td>
</tr>
<tr>
<td>iter-n</td>
<td>返回iter之前的第n个元素</td>
</tr>
<tr>
<td>iter1-iter2</td>
<td>返回iter1和iter2之间的距离</td>
</tr>
<tr>
<td>iter1 &lt; iter2</td>
<td>判断iter1是否在iter2之前</td>
</tr>
<tr>
<td>iter1 &gt; iter2</td>
<td>判断iter1是否在iter2之后</td>
</tr>
<tr>
<td>iter1 &lt;&#x3D; iter2</td>
<td>判断iter1是否不在iter2之后</td>
</tr>
<tr>
<td>iter1 &gt;&#x3D; iter2</td>
<td>判断iter1是否不在iter2之前</td>
</tr>
</tbody></table>
<p><code>Random-access</code>迭代器由以下对象和类型提供:</p>
<ul>
<li>可随机访问的容器(<code>array</code>、<code>vector</code>、<code>deque</code>)</li>
<li>String(<code>string</code>、<code>wstring</code>)</li>
<li>寻常的C-Style(<code>pointer</code>)</li>
</ul>
<div STYLE="page-break-after: always;"></div>

<h3 id="迭代器应用"><a href="#迭代器应用" class="headerlink" title="迭代器应用"></a>迭代器应用</h3><p>判断字符串是否为回文。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="type">const</span> std::string_view&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">equal</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>()/<span class="number">2</span>, s.<span class="built_in">rbegin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">is_palindrome</span>(<span class="string">&quot;1000000000个字符&quot;</span>); <span class="comment">///&lt; 时间复杂度: O(1)</span></span><br><span class="line"><span class="built_in">is_palindrome</span>(str); <span class="comment">///&lt; 时间复杂度: O(n)。 n = str.size();</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">equal</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>()/<span class="number">2</span>, s.<span class="built_in">rbegin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器失效场景"><a href="#迭代器失效场景" class="headerlink" title="迭代器失效场景"></a>迭代器失效场景</h3><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container">迭代器非法化</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2021-12-02-%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2021-12-02-%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">网课《从零开始学架构》摘录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>innodb_buffer_pool_size、sync_binlog、innodb_log_file_size</p>
<p>PPC 与 TPC、Reactor 与 Proactor</p>
<p>幸运的是，最近我在学习的时候，无意中在网络上找到一份非常详尽的关于 Linux 服务器网络模型的详细系列文章。作者通过连载的方式，将 iterative、forking（对应专栏的 PPC 模式）、preforked（对应专栏的 prefork 模式）、threaded（对应专栏的 TPC 模式）、prethreaded（对应专栏的 prethread 模式）、poll、epoll（对应专栏的 Reactor 模式）共 7 种模式的实现原理、实现代码、性能对比都详尽地进行了阐述，完美地弥补了专栏内容没有实际数据对比的遗憾。</p>
<p><a target="_blank" rel="noopener" href="https://unixism.net/2019/04/linux-applications-performance-introduction/">Linux Applications Performance: Introduction</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZdNEgn1gxyat9PeOeycHTg">一文读懂「中台」的前世今生</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100006601?tab=catalog">从 0 开始学架构</a></p>
<h2 id="25-高可用存储架构：双机架构"><a href="#25-高可用存储架构：双机架构" class="headerlink" title="25 | 高可用存储架构：双机架构"></a>25 | 高可用存储架构：双机架构</h2><p>存储高可用方案的本质都是通过将数据复制到多个存储设备，通过数据冗余的方式来实现高可用，其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致问题。<br>因此，对任何一个高可用存储方案，我们需要从以下几个方面去进行思考和分析：</p>
<ul>
<li>数据如何复制？</li>
<li>各个节点的职责是什么？</li>
<li>如何应对复制延迟？</li>
<li>如何应对复制中断？</li>
</ul>
<p>双机解决方案:<br>主备、主从、主备 &#x2F; 主从切换和主主。</p>
<h2 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h2><p>主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等。</p>
<p>下面是标准的主备方案结构图：</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6.png" alt="主备复制"></p>
<p>其整体架构比较简单，主备架构中的“备机”主要还是起到一个备份作用，并不承担实际的业务读写操作，如果要把备机改为主机，需要人工操作。</p>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>主备复制架构的优点就是简单，表现有：</p>
<ul>
<li>对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。</li>
<li>对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。</li>
</ul>
<p>主备复制架构的缺点主要有：</p>
<ul>
<li>备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。</li>
<li>故障后需要人工干预，无法自动恢复。人工处理的效率是很低的，可能打电话找到能够操作的人就耗费了 10 分钟，甚至如果是深更半夜，出了故障都没人知道。人工在执行恢复操作的过程中也容易出错，因为这类操作并不常见，可能 1 年就 2、3 次，实际操作的时候很可能遇到各种意想不到的问题。</li>
</ul>
<p>综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制和主备复制只有一字之差，“从”意思是“随从、仆从”，“备”的意思是备份。我们可以理解为仆从是要帮主人干活的，这里的干活就是承担“读”的操作。也就是说，主机负责读写操作，从机只负责读操作，不负责写操作。</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="主从复制"></p>
<p>优缺点分析</p>
<p>主从复制与主备复制相比，优点有：</p>
<ul>
<li>主从复制在主机故障时，读操作相关的业务可以继续运行。</li>
<li>主从复制架构的从机提供读操作，发挥了硬件的性能。</li>
</ul>
<p>缺点有：</p>
<ul>
<li>主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。</li>
<li>主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。</li>
<li>故障时需要人工干预。</li>
</ul>
<p>综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。</p>
<h2 id="双机切换"><a href="#双机切换" class="headerlink" title="双机切换"></a>双机切换</h2><ol>
<li>设计关键<br>主备复制和主从复制方案存在两个共性的问题：</li>
</ol>
<ul>
<li>主机故障后，无法进行写操作。</li>
<li>如果主机无法恢复，需要人工指定新的主机角色。</li>
</ul>
<p>双机切换就是为了解决这两个问题而产生的，包括主备切换和主从切换两种方案。<br>简单来说，这两个方案就是在原有方案的基础上增加“切换”功能，即系统自动决定主机角色，并完成角色切换。<br>由于主备切换和主从切换在切换的设计上没有差别，我接下来以主备切换为例，一起来看看双机切换架构是如何实现的。<br>要实现一个完善的切换方案，必须考虑这几个关键的设计点：</p>
<p>主备间状态判断</p>
<p>主要包括两方面：状态传递的渠道，以及状态检测的内容。</p>
<p><strong>状态传递的渠道</strong>：是相互间互相连接，还是第三方仲裁？</p>
<p><strong>状态检测的内容</strong>：例如机器是否掉电、进程是否存在、响应是否缓慢等。</p>
<p>切换决策</p>
<p>主要包括几方面：切换时机、切换策略、自动程度。</p>
<p><strong>切换时机</strong>：什么情况下备机应该升级为主机？是机器掉电后备机才升级，还是主机上的进程不存在就升级，还是主机响应时间超过 2 秒就升级，还是 3 分钟内主机连续重启 3 次就升级等。</p>
<p><strong>切换策略</strong>：原来的主机故障恢复后，要再次切换，确保原来的主机继续做主机，还是原来的主机故障恢复后自动成为新的备机？</p>
<p><strong>自动程度</strong>：切换是完全自动的，还是半自动的？例如，系统判断当前需要切换，但需要人工做最终的确认操作（例如，单击一下“切换”按钮）。</p>
<p>数据冲突解决</p>
<p>当原有故障的主机恢复后，新旧主机之间可能存在数据冲突。</p>
<p>例如，用户在旧主机上新增了一条 ID 为 100 的数据，这个数据还没有复制到旧的备机，此时发生了切换，旧的备机升级为新的主机，用户又在新的主机上新增了一条 ID 为 100 的数据，当旧的故障主机恢复后，这两条 ID 都为 100 的数据，应该怎么处理？</p>
<p>以上设计点并没有放之四海而皆准的答案，不同的业务要求不一样，所以切换方案比复制方案不只是多了一个切换功能那么简单，而是复杂度上升了一个量级。形象点来说，如果复制方案的代码是 1000 行，那么切换方案的代码可能就是 10000 行，多出来的那 9000 行就是用于实现上面我所讲的 3 个设计点的。</p>
<h3 id="常见架构"><a href="#常见架构" class="headerlink" title="常见架构"></a>常见架构</h3><p>根据状态传递渠道的不同，常见的主备切换架构有三种形式：互连式、中介式和模拟式。</p>
<h4 id="互连式"><a href="#互连式" class="headerlink" title="互连式"></a>互连式</h4><p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E5%8F%8C%E6%9C%BA%E5%88%87%E6%8D%A2%E4%BA%92%E8%81%94%E5%BC%8F.png" alt="双机切换互联式"></p>
<p>你可以看到，在主备复制的架构基础上，主机和备机多了一个“状态传递”的通道，这个通道就是用来传递状态信息的。这个通道的具体实现可以有很多方式：</p>
<ul>
<li>可以是网络连接（例如，各开一个端口），也可以是非网络连接（用串口线连接）。</li>
<li>可以是主机发送状态给备机，也可以是备机到主机来获取状态信息。</li>
<li>可以和数据复制通道共用，也可以独立一条通道。</li>
<li>状态传递通道可以是一条，也可以是多条，还可以是不同类型的通道混合（例如，网络 + 串口）。</li>
</ul>
<p>为了充分利用切换方案能够自动决定主机这个优势，客户端这里也会有一些相应的改变，常见的方式有：</p>
<ul>
<li>为了切换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。例如虚拟 IP，主机需要绑定这个虚拟的 IP。</li>
<li>客户端同时记录主备机的地址，哪个能访问就访问哪个；备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是“备机不对外提供服务”。</li>
</ul>
<p>互连式主备切换主要的缺点在于：</p>
<ul>
<li>如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。</li>
<li>虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。</li>
</ul>
<h4 id="中介式"><a href="#中介式" class="headerlink" title="中介式"></a>中介式</h4><p>中介式指的是在主备两者之外引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息，其架构图如下：</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E5%8F%8C%E6%9C%BA%E5%88%87%E6%8D%A2%E4%B8%AD%E4%BB%8B%E5%BC%8F.png" alt="双机切换中介式"></p>
<p>连接管理更简单：主备机无须再建立和管理多种类型的状态传递连接通道，只要连接到中介即可，实际上是降低了主备机的连接管理复杂度。</p>
<p>例如，互连式要求主机开一个监听端口，备机来获取状态信息；或者要求备机开一个监听端口，主机推送状态信息到备机；如果还采用了串口连接，则需要增加串口连接管理和数据读取。采用中介式后，主备机都只需要把状态信息发送给中介，或者从中介获取对方的状态信息。无论是发送还是获取，主备机都是作为中介的客户端去操作，复杂度会降低。</p>
<p>状态决策更简单：主备机的状态决策简单了，无须考虑多种类型的连接通道获取的状态信息如何决策的问题，只需要按照下面简单的算法即可完成状态决策。</p>
<ul>
<li>无论是主机还是备机，初始状态都是备机，并且只要与中介断开连接，就将自己降级为备机，因此可能出现双备机的情况。</li>
<li>主机与中介断连后，中介能够立刻告知备机，备机将自己升级为主机。</li>
<li>如果是网络中断导致主机与中介断连，主机自己会降级为备机，网络恢复后，旧的主机以新的备机身份向中介上报自己的状态。</li>
<li>如果是掉电重启或者进程重启，旧的主机初始状态为备机，与中介恢复连接后，发现已经有主机了，保持自己备机状态不变。</li>
<li>主备机与中介连接都正常的情况下，按照实际的状态决定是否进行切换。例如，主机响应时间超过 3 秒就进行切换，主机降级为备机，备机升级为主机即可。</li>
</ul>
<p>虽然中介式架构在状态传递和状态决策上更加简单，但并不意味着这种优点是没有代价的，其关键代价就在于如何实现中介本身的高可用。如果中介自己宕机了，整个系统就进入了双备的状态，写操作相关的业务就不可用了。这就陷入了一个递归的陷阱：为了实现高可用，我们引入中介，但中介本身又要求高可用，于是又要设计中介的高可用方案……如此递归下去就无穷无尽了。</p>
<p>幸运的是，开源方案已经有比较成熟的中介式解决方案，例如 ZooKeeper 和 Keepalived。ZooKeeper 本身已经实现了高可用集群架构，因此已经帮我们解决了中介本身的可靠性问题，在工程实践中推荐基于 ZooKeeper 搭建中介式切换架构。</p>
<h4 id="模拟式"><a href="#模拟式" class="headerlink" title="模拟式"></a>模拟式</h4><p>模拟式指主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。其基本架构如下：</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E5%8F%8C%E6%9C%BA%E5%88%87%E6%8D%A2%E6%A8%A1%E6%8B%9F%E5%BC%8F.png" alt="双机切换模拟式"></p>
<p>模拟式切换与互连式切换相比，优点是实现更加简单，因为省去了状态传递通道的建立和管理工作。</p>
<p>简单既是优点，同时也是缺点。因为模拟式读写操作获取的状态信息只有响应信息（例如，HTTP 404，超时、响应时间超过 3 秒等），没有互连式那样多样（除了响应信息，还可以包含 CPU 负载、I&#x2F;O 负载、吞吐量、响应时间等），基于有限的状态来做状态决策，可能出现偏差。</p>
<h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><p>主主复制指的是两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作，下面是基本架构图。</p>
<p>相比主备切换架构，主主复制架构具有如下特点：</p>
<ul>
<li>两台都是主机，不存在切换的概念。</li>
<li>客户端无须区分不同角色的主机，随便将读写操作发送给哪台主机都可以。</li>
</ul>
<p>从上面的描述来看，主主复制架构从总体上来看要简单很多，无须状态信息传递，也无须状态决策和状态切换。然而事实上主主复制架构也并不简单，而是有其独特的复杂性，具体表现在：如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的。</p>
<ul>
<li>用户注册后生成的用户 ID，如果按照数字增长，那就不能双向复制，否则就会出现 X 用户在主机 A 注册，分配的用户 ID 是 100，同时 Y 用户在主机 B 注册，分配的用户 ID 也是 100，这就出现了冲突。</li>
<li>库存不能双向复制。例如，一件商品库存 100 件，主机 A 上减了 1 件变成 99，主机 B 上减了 2 件变成 98，然后主机 A 将库存 99 复制到主机 B，主机 B 原有的库存 98 被覆盖，变成了 99，而实际上此时真正的库存是 97。类似的还有余额数据。</li>
</ul>
<p>因此，主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。例如，用户登录产生的 session 数据（可以重新登录生成）、用户行为的日志数据（可以丢失）、论坛的草稿数据（可以丢失）等。</p>
<h2 id="27-如何设计计算高可用架构？"><a href="#27-如何设计计算高可用架构？" class="headerlink" title="27 | 如何设计计算高可用架构？"></a>27 | 如何设计计算高可用架构？</h2><p>计算高可用的主要设计目标是当出现部分硬件损坏时，计算任务能够继续正常运行。因此计算高可用的本质是通过冗余来规避部分故障的风险，单台服务器是无论如何都达不到这个目标的。所以计算高可用的设计思想很简单：通过增加更多服务器来达到计算高可用。</p>
<p>计算高可用架构的设计复杂度主要体现在任务管理方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行。因此，计算高可用架构设计的关键点有下面两点。</p>
<ol>
<li>哪些服务器可以执行任务</li>
</ol>
<p>第一种方式和计算高性能中的集群类似，每个服务器都可以执行任务。例如，常见的访问网站的某个页面。</p>
<p>第二种方式和存储高可用中的集群类似，只有特定服务器（通常叫“主机”）可以执行任务。当执行任务的服务器故障后，系统需要挑选新的服务器来执行任务。例如，ZooKeeper 的 Leader 才能处理写操作请求。</p>
<ol start="2">
<li>任务如何重新执行</li>
</ol>
<p>第一种策略是对于已经分配的任务即使执行失败也不做任何处理，系统只需要保证新的任务能够分配到其他非故障服务器上执行即可。</p>
<p>第二种策略是设计一个任务管理器来管理需要执行的计算任务，服务器执行完任务后，需要向任务管理器反馈任务执行结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行。</p>
<p>需要注意的是：“任务分配器”是一个逻辑的概念，并不一定要求系统存在一个独立的任务分配器模块。例如：</p>
<ul>
<li><p>Nginx 将页面请求发送给 Web 服务器，而 CSS&#x2F;JS 等静态文件直接读取本地缓存。这里的 Nginx 角色是反向代理系统，但是承担了任务分配器的职责，而不需要 Nginx 做反向代理，后面再来一个任务分配器。</p>
</li>
<li><p>对于一些后台批量运算的任务，可以设计一个独立的任务分配系统来管理这些批处理任务的执行和分配。</p>
</li>
<li><p>ZooKeeper 中的 Follower 节点，当接收到写请求时会将请求转发给 Leader 节点处理，当接收到读请求时就自己处理，这里的 Follower 就相当于一个逻辑上的任务分配器。</p>
</li>
</ul>
<p>常见的计算高可用架构：主备、主从和集群</p>
<h3 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h3><p>主备架构是计算高可用最简单的架构，和存储高可用的主备复制架构类似，但是要更简单一些，因为计算高可用的主备架构无须数据复制，其基本的架构示意图如下：</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%BB%E5%A4%87.png" alt="高可用主备"></p>
<p>主备方案的详细设计：</p>
<p>主机执行所有计算任务。例如，读写数据、执行操作等。</p>
<ul>
<li>当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务发送给备机，此时系统处于不可用状态。</li>
<li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续将任务发送给主机。</li>
<li>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机（即原来的备机）；同时，为了继续保持主备架构，需要人工增加新的机器作为备机。</li>
</ul>
<p>根据备机状态的不同，主备架构又可以细分为冷备架构和温备架构。</p>
<ul>
<li>冷备：备机上的程序包和配置文件都准备好，但备机上的业务系统没有启动（注意：备机的服务器是启动的），主机故障后，需要人工手工将备机的业务系统启动，并将任务分配器的任务请求切换发送给备机。</li>
<li>温备：备机上的业务系统已经启动，只是不对外提供服务，主机故障后，人工只需要将任务分配器的任务请求切换发送到备机即可。冷备可以节省一定的能源，但温备能够大大减少手工操作时间，因此一般情况下推荐用温备的方式。</li>
</ul>
<p>主备架构的优点就是简单，主备机之间不需要进行交互，状态判断和切换操作由人工执行，系统实现很简单。而缺点正好也体现在“人工操作”这点上，因为人工操作的时间不可控，可能系统已经发生问题了，但维护人员还没发现，等了 1 个小时才发现。发现后人工切换的操作效率也比较低，可能需要半个小时才完成切换操作，而且手工操作过程中容易出错。例如，修改配置文件改错了、启动了错误的程序等。<br>和存储高可用中的主备复制架构类似，计算高可用的主备架构也比较适合与内部管理系统、后台管理系统这类使用人数不多、使用频率不高的业务，不太适合在线的业务。</p>
<h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>和存储高可用中的主从复制架构类似，计算高可用的主从架构中的从机也是要执行任务的。任务分配器需要将任务进行分类，确定哪些任务可以发送给主机执行，哪些任务可以发送给备机执行，其基本的架构示意图如下：</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%BB%E4%BB%8E.png" alt="高可用主从"></p>
<p>主从方案详细设计：</p>
<ul>
<li>正常情况下，主机执行部分计算任务（如图中的“计算任务 A”），备机执行部分计算任务（如图中的“计算任务 B”）。</li>
<li>当主机故障（例如，主机宕机）时，任务分配器不会自动将原本发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功。</li>
<li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续按照原有的设计策略分配任务，即计算任务 A 发送给主机，计算任务 B 发送给从机。</li>
<li>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将原来的从机升级为主机（一般只是修改配置即可），增加新的机器作为从机，新的从机准备就绪后，任务分配器继续按照原有的设计策略分配任务。</li>
</ul>
<p>主从架构与主备架构相比，优缺点有：</p>
<ul>
<li>优点：主从架构的从机也执行任务，发挥了从机的硬件性能。</li>
<li>缺点：主从架构需要将任务分类，任务分配器会复杂一些。</li>
</ul>
<h2 id="31-如何应对接口级的故障？"><a href="#31-如何应对接口级的故障？" class="headerlink" title="31 | 如何应对接口级的故障？"></a>31 | 如何应对接口级的故障？</h2><p>解决接口级故障的核心思想：优先保证核心业务和优先保证绝大部分用户。</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。例如，论坛可以降级为只能看帖子，不能发帖子；也可以降级为只能看帖子和评论，不能发评论；而 App 的日志上传接口，可以完全停掉一段时间，这段时间内 App 都不能上传日志。</p>
<p>降级的核心思想就是丢车保帅，优先保证核心业务。例如，对于论坛来说，90% 的流量是看帖子，那我们就优先保证看帖的功能；对于一个 App 来说，日志上传接口只是一个辅助的功能，故障时完全可以停掉。</p>
<p>常见的实现降级的方式有：</p>
<ul>
<li>系统后门降级</li>
</ul>
<p>简单来说，就是系统预留了后门用于降级操作。例如，系统提供一个降级 URL，当访问这个 URL 时，就相当于执行降级指令，具体的降级指令通过 URL 的参数传入即可。这种方案有一定的安全隐患，所以也会在 URL 中加入密码这类安全措施。</p>
<p>系统后门降级的方式实现成本低，但主要缺点是如果服务器数量多，需要一台一台去操作，效率比较低，这在故障处理争分夺秒的场景下是比较浪费时间的。</p>
<ul>
<li>独立降级系统</li>
</ul>
<p>为了解决系统后门降级方式的缺点，将降级操作独立到一个单独的系统中，可以实现复杂的权限管理、批量操作等功能。其基本架构如下：</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E9%99%8D%E7%BA%A7.png" alt="降级"></p>
<h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。</p>
<p>假设一个这样的场景：A 服务的 X 功能依赖 B 服务的某个接口，当 B 服务的接口响应很慢的时候，A 服务的 X 功能响应肯定也会被拖慢，进一步导致 A 服务的线程都被卡在 X 功能处理上，此时 A 服务的其他功能都会被卡住或者响应非常慢。这时就需要熔断机制了，即：A 服务不再请求 B 服务的这个接口，A 服务内部只要发现是请求 B 服务的这个接口就立即返回错误，从而避免 A 服务整个被拖慢甚至拖死。</p>
<p>熔断机制实现的关键是需要有一个统一的 API 调用层，由 API 调用层来进行采样或者统计，如果接口调用散落在代码各处就没法进行统一处理了。</p>
<p>熔断机制实现的另外一个关键是阈值的设计，例如 1 分钟内 30% 的请求响应时间超过 1 秒就熔断，这个策略中的“1 分钟”“30%”“1 秒”都对最终的熔断效果有影响。实践中一般都是先根据分析确定阈值，然后上线观察效果，再进行调优。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。</p>
<p>限流一般都是系统内实现的，常见的限流方式可以分为两类：基于请求限流和基于资源限流。</p>
<ul>
<li>基于请求限流</li>
</ul>
<p>基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。</p>
<p>限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，每秒请求峰值最高为 10 万。</p>
<p>无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值，例如系统设定了 1 分钟 10000 个用户，但实际上 6000 个用户的时候系统就扛不住了；也可能达到 1 分钟 10000 用户后，其实系统压力还不大，但此时已经开始丢弃用户访问了。</p>
<p>即使找到了合适的阈值，基于请求限流还面临硬件相关的问题。例如一台 32 核的机器和 64 核的机器处理能力差别很大，阈值是不同的，可能有的技术人员以为简单根据硬件指标进行数学运算就可以得出来，实际上这样是不可行的，64 核的机器比 32 核的机器，业务处理性能并不是 2 倍的关系，可能是 1.5 倍，甚至可能是 1.1 倍。</p>
<p>为了找到合理的阈值，通常情况下可以采用性能压测来确定阈值，但性能压测也存在覆盖场景有限的问题，可能出现某个性能压测没有覆盖的功能导致系统压力很大；另外一种方式是逐步优化，即：先设定一个阈值然后上线观察运行情况，发现不合理就调整阈值。</p>
<p>基于上述的分析，根据阈值来限制访问量的方式更多的适应于业务功能比较简单的系统，例如负载均衡系统、网关系统、抢购系统等。</p>
<ul>
<li>基于资源限流</li>
</ul>
<p>基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，即：找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列等。</p>
<p>例如，采用 Netty 来实现服务器，每个进来的请求都先放入一个队列，业务线程再从队列读取请求进行处理，队列长度最大值为 10000，队列满了就拒绝后面的请求；也可以根据 CPU 的负载或者占用率进行限流，当 CPU 的占用率超过 80% 的时候就开始拒绝新的请求。</p>
<p>基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实践中设计也面临两个主要的难点：如何确定关键资源，如何确定关键资源的阈值。通常情况下，这也是一个逐步调优的过程，即：设计的时候先根据推断选择某个关键资源和阈值，然后测试验证，再上线观察，如果发现不合理，再进行优化。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间，全世界最有名的排队当属 12306 网站排队了。排队虽然没有直接拒绝用户，但用户等了很长时间后进入系统，体验并不一定比限流好。</p>
<p>由于排队需要临时缓存大量的业务请求，单个系统内部无法缓存这么多数据，一般情况下，排队需要用独立的系统去实现，例如使用 Kafka 这类消息队列来缓存用户请求。</p>
<h2 id="49-谈谈App架构的演进"><a href="#49-谈谈App架构的演进" class="headerlink" title="49 | 谈谈App架构的演进"></a>49 | 谈谈App架构的演进</h2><p>架构设计理念，可以提炼为下面几个关键点：</p>
<ul>
<li>架构是系统的顶层结构。</li>
<li>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</li>
<li>架构设计需要遵循三个主要原则：合适原则、简单原则、演化原则。</li>
<li>架构设计首先要掌握业界已经成熟的各种架构模式，然后再进行优化、调整、创新。</li>
</ul>
<h2 id="架构设计文档模板"><a href="#架构设计文档模板" class="headerlink" title="架构设计文档模板"></a>架构设计文档模板</h2><p>备选方案模板</p>
<h3 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h3><p>[需求介绍主要描述需求的背景、目标、范围等]</p>
<p>随着前浪微博业务的不断发展，业务上拆分的子系统越来越多，目前系统间的调用都是同步调用，由此带来几个明显的系统问题：</p>
<p>性能问题：当用户发布了一条微博后，微博发布子系统需要同步调用“统计子系统”“审核子系统”“奖励子系统”等共 8 个子系统，性能很低。<br>耦合问题：当新增一个子系统时，例如如果要增加“广告子系统”，那么广告子系统需要开发新的接口给微博发布子系统调用。<br>效率问题：每个子系统提供的接口参数和实现都有一些细微的差别，导致每次都需要重新设计接口和联调接口，开发团队和测试团队花费了许多重复工作量。</p>
<p>基于以上背景，我们需要引入消息队列进行系统解耦，将目前的同步调用改为异步通知。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>[需求分析主要全方位地描述需求相关的信息]</p>
<h4 id="5W"><a href="#5W" class="headerlink" title="5W"></a>5W</h4><p>5W 指 Who、When、What、Why、Where。</p>
<ul>
<li>Who：需求利益干系人，包括开发者、使用者、购买者、决策者等。</li>
<li>When：需求使用时间，包括季节、时间、里程碑等。</li>
<li>What：需求的产出是什么，包括系统、数据、文件、开发库、平台等。</li>
<li>Where：需求的应用场景，包括国家、地点、环境等，例如测试平台只会在测试环境使用。</li>
<li>Why：需求需要解决的问题，通常和需求背景相关</li>
</ul>
<p>消息队列的 5W 分析如下：</p>
<ul>
<li>Who：消息队列系统主要是业务子系统来使用，子系统发送消息或者接收消息。</li>
<li>When：当子系统需要发送异步通知的时候，需要使用消息队列系统。</li>
<li>What：需要开发消息队列系统。</li>
<li>Where：开发环境、测试环境、生产环境都需要部署。</li>
<li>Why：消息队列系统将子系统解耦，将同步调用改为异步通知。</li>
</ul>
<h4 id="1H"><a href="#1H" class="headerlink" title="1H"></a>1H</h4><p>这里的 How 不是设计方案也不是架构方案，而是关键业务流程。<br>消息队列系统这部分内容很简单，但有的业务系统 1H 就是具体的用例了，有兴趣的同学可以尝试写写 ATM 机取款的业务流程。如果是复杂的业务系统，这部分也可以独立成“用例文档”</p>
<p>消息队列有两大核心功能：业务子系统发送消息给消息队列。业务子系统从消息队列获取消息。</p>
<h4 id="8C"><a href="#8C" class="headerlink" title="8C"></a>8C</h4><p>8C 指的是 8 个约束和限制，即 Constraints，包括性能 Performance、成本 Cost、时间 Time、可靠性 Reliability、安全性 Security、合规性 Compliance、技术性 Technology、兼容性 Compatibility</p>
<p>注：需求中涉及的性能、成本、可靠性等仅仅是利益关联方提出的诉求，不一定准确；如果经过分析有的约束没有必要，或成本太高、难度太大，这些约束是可以调整的。</p>
<ul>
<li>性能：需要达到 Kafka 的性能水平。</li>
<li>成本：参考 XX 公司的设计方案，不超过 10 台服务器。</li>
<li>时间：期望 3 个月内上线第一个版本，在两个业务尝试使用。</li>
<li>可靠性：按照业务的要求，消息队列系统的可靠性需要达到 99.99%。</li>
<li>安全性：消息队列系统仅在生产环境内网使用，无需考虑网络安全；如消息中有敏感信息，消息发送方需要自行进行加密，消息队列系统本身不考虑通用的加密。</li>
<li>合规性：消息队列系统需要按照公司目前的 DevOps 规范进行开发。</li>
<li>技术性：目前团队主要研发人员是 Java，最好用 Java 开发。</li>
<li>兼容性：之前没有类似系统，无需考虑兼容性。</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>[分析需求的复杂度，复杂度常见的有高可用、高性能、可扩展等，具体请参考专栏第 10 期的分析]</p>
<p>注：文档的内容省略了分析过程，实际操作的时候每个约束和限制都要有详细的逻辑推导，避免完全拍脑袋式决策。</p>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>对于微博子系统来说，如果消息丢了，导致没有审核，然后触犯了国家法律法规，则是非常严重的事情；<br>对于等级子系统来说，如果用户达到相应等级后，系统没有给他奖品和专属服务，则 VIP 用户会很不满意，导致用户流失从而损失收入，虽然也比较关键，但没有审核子系统丢消息那么严重。<br>综合来看，消息队列需要高可用性，包括消息写入、消息存储、消息读取都需要保证高可用性。</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>前浪微博系统用户每天发送 1000 万条微博，那么微博子系统一天会产生 1000 万条消息，平均一条消息有 10 个子系统读取，那么其他子系统读取的消息大约是 1 亿次。<br>将数据按照秒来计算，一天内平均每秒写入消息数为 115 条，每秒读取的消息数是 1150 条；<br>再考虑系统的读写并不是完全平均的，设计的目标应该以峰值来计算。峰值一般取平均值的 3 倍，那么消息队列系统的 TPS 是 345，QPS 是 3450，考虑一定的性能余量。<br>由于现在的基数较低，为了预留一定的系统容量应对后续业务的发展，我们将设计目标设定为峰值的 4 倍，因此最终的性能要求是：TPS 为 1380，QPS 为 13800。<br>TPS 为 1380 并不高，但 QPS 为 13800 已经比较高了，因此高性能读取是复杂度之一。</p>
<h4 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h4><p>消息队列的功能很明确，基本无须扩展，因此可扩展性不是这个消息队列的关键复杂度。</p>
<h3 id="备选方案"><a href="#备选方案" class="headerlink" title="备选方案"></a>备选方案</h3><p>[备选方案设计，至少 3 个备选方案，每个备选方案需要描述关键的实现，无须描述具体的实现细节。此处省略具体方案描述，详细请参考专栏第 11 期]</p>
<p>备选方案 1：</p>
<p>直接引入开源 Kafka[此处省略方案描述]</p>
<p>备选方案 2：</p>
<p>集群 + MySQL 存储[此处省略方案描述]</p>
<p>备选方案 3：</p>
<p>集群 + 自研存储[此处省略方案描述]</p>
<h3 id="备选方案评估"><a href="#备选方案评估" class="headerlink" title="备选方案评估"></a>备选方案评估</h3><p>[备选方案 360 度环评，详细请参考专栏第 12 期。注意备选方案评估的内容会根据评估会议的结果进行修改，也就是说架构师首先给出自己的备选方案评估，然后举行备选方案评估会议，再根据会议结论修改备选方案文档]</p>
<h3 id="架构设计模板"><a href="#架构设计模板" class="headerlink" title="架构设计模板"></a>架构设计模板</h3><h4 id="总体方案"><a href="#总体方案" class="headerlink" title="总体方案"></a>总体方案</h4><p>[总体方案需要从整体上描述方案的结构，其核心内容就是架构图，以及针对架构图的描述，包括模块或者子系统的职责描述、核心流程]</p>
<h4 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h4><p>[架构总览给出架构图以及架构的描述]</p>
<p><img src="/..%5Cresource%5C%E7%BD%91%E8%AF%BE%E3%80%8A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E3%80%8B%5C%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="架构总览"></p>
<p>架构关键设计点：</p>
<ul>
<li>采用数据分散集群的架构，集群中的服务器进行分组，每个分组存储一部分消息数据。</li>
<li>每个分组包含一台主 MySQL 和一台备 MySQL，分组内主备数据复制，分组间数据不同步。</li>
<li>正常情况下，分组内的主服务器对外提供消息写入和消息读取服务，备服务器不对外提供服务；主服务器宕机的情况下，备服务器对外提供消息读取的服务。</li>
<li>客户端采取轮询的策略写入和读取消息。</li>
</ul>
<h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><ul>
<li>消息发送流程</li>
</ul>
<p>[此处省略流程描述]</p>
<ul>
<li>消息读取流程</li>
</ul>
<p>[此处省略流程描述]</p>
<h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><h5 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h5><ul>
<li>消息发送可靠性</li>
</ul>
<p>业务服务器中嵌入消息队列系统提供的 SDK，SDK 支持轮询发送消息，当某个分组的主服务器无法发送消息时，SDK 挑选下一个分组主服务器重发消息，依次尝试所有主服务器直到发送成功；如果全部主服务器都无法发送，SDK 可以缓存消息，也可以直接丢弃消息，具体策略可以在启动 SDK 的时候通过配置指定。</p>
<p>如果 SDK 缓存了一些消息未发送，此时恰好业务服务器又重启，则所有缓存的消息将永久丢失，这种情况 SDK 不做处理，业务方需要针对某些非常关键的消息自己实现永久存储的功能。</p>
<ul>
<li>消息存储可靠性</li>
</ul>
<p>消息存储在 MySQL 中，每个分组有一主一备两台 MySQL 服务器，MySQL 服务器之间复制消息以保证消息存储高可用。如果主备间出现复制延迟，恰好此时 MySQL 主服务器宕机导致数据无法恢复，则部分消息会永久丢失，这种情况不做针对性设计，DBA 需要对主备间的复制延迟进行监控，当复制延迟超过 30 秒的时候需要及时告警并进行处理。</p>
<ul>
<li>消息读取可靠性</li>
</ul>
<p>每个分组有一主一备两台服务器，主服务器支持发送和读取消息，备服务器只支持读取消息，当主服务器正常的时候备服务器不对外提供服务，只有备服务器判断主服务器故障的时候才对外提供消息读取服务。</p>
<p>主备服务器的角色和分组信息通过配置指定，通过 ZooKeeper 进行状态判断和决策。主备服务器启动的时候分别连接到 ZooKeeper，在 &#x2F;MQ&#x2F;Server&#x2F;[group]目录下建立 EPHEMERAL 节点，假设分组名称为 group1，则主服务器节点为 &#x2F;MQ&#x2F;Server&#x2F;group1&#x2F;master，备服务器的节点为 &#x2F;MQ&#x2F;Server&#x2F;group1&#x2F;slave。节点的超时时间可以配置，默认为 10 秒。</p>
<h5 id="高性能设计"><a href="#高性能设计" class="headerlink" title="高性能设计"></a>高性能设计</h5><p>[此处省略具体设计]</p>
<h5 id="可扩展设计"><a href="#可扩展设计" class="headerlink" title="可扩展设计"></a>可扩展设计</h5><p>[此处省略具体设计。如果方案不涉及，可以简单写上“无”，表示设计者有考虑但不需要设计；否则如果完全不写的话，方案评审的时候可能会被认为是遗漏了设计点]</p>
<h5 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h5><p>消息队列系统需要提供权限控制功能，权限控制包括两部分：身份识别和队列权限控制。</p>
<ul>
<li>身份识别</li>
</ul>
<p>消息队列系统给业务子系统分配身份标识和接入 key，SDK 首先需要建立连接并进行身份校验，消息队列服务器会中断校验不通过的连接。因此，任何业务子系统如果想接入消息队列系统，都必须首先申请身份标识和接入 key，通过这种方式来防止恶意系统任意接入。</p>
<ul>
<li>队列权限</li>
</ul>
<p>某些队列信息可能比较敏感，只允许部分子系统发送或者读取，消息队列系统将队列权限保存在配置文件中，当收到发送或者读取消息的请求时，首先需要根据业务子系统的身份标识以及配置的权限信息来判断业务子系统是否有权限，如果没有权限则拒绝服务。</p>
<ul>
<li>其他设计</li>
</ul>
<p>[其他设计包括上述以外的其他设计考虑点，例如指定开发语言、符合公司的某些标准等，如果篇幅较长，也可以独立进行描述]</p>
<p>消息队列系统需要接入公司已有的运维平台，通过运维平台发布和部署。<br>消息队列系统需要输出日志给公司已有的监控平台，通过监控平台监控消息队列系统的健康状态，包括发送消息的数量、发送消息的大小、积压消息的数量等，详细监控指标在后续设计方案中列出。</p>
<h5 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h5><p>[部署方案主要包括硬件要求、服务器部署方式、组网方式等]</p>
<p>消息队列系统的服务器和数据库服务器采取混布的方式部署，即：一台服务器上，部署同一分组的主服务器和主 MySQL，或者备服务器和备 MySQL。因为消息队列服务器主要是 CPU 密集型，而 MySQL 是磁盘密集型的，所以两者混布互相影响的几率不大。</p>
<p>硬件的基本要求：32 核 48G 内存 512G SSD 硬盘，考虑到消息队列系统动态扩容的需求不高，且对性能要求较高，因此需要使用物理服务器，不采用虚拟机。</p>
<h4 id="架构演进规划"><a href="#架构演进规划" class="headerlink" title="架构演进规划"></a>架构演进规划</h4><p>[通常情况下，规划和设计的需求比较完善，但如果一次性全部做完，项目周期可能会很长，因此可以采取分阶段实施，即：第一期做什么、第二期做什么，以此类推]</p>
<p>整个消息队列系统分三期实现：</p>
<ul>
<li>第一期：实现消息发送、权限控制功能，预计时间 3 个月。</li>
<li>第二期：实现消息读取功能，预计时间 1 个月。</li>
<li>第三期：实现主备基于 ZooKeeper 切换的功能，预计时间 2 周。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2021-12-09-C++%E5%85%B3%E4%BA%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%AC%A6%E6%9E%84%E9%80%A0%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2021-12-09-C++%E5%85%B3%E4%BA%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%AC%A6%E6%9E%84%E9%80%A0%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">C++ 关于强制转换符构造临时对象的探索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="验证背景"><a href="#验证背景" class="headerlink" title="验证背景"></a>验证背景</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TO_STR(x)   ((AnsiString)x).c_str()</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Dict::GetID</span><span class="params">(TcxComboBox *cb, UINT32 *pulID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHAR *szValue = <span class="built_in">TO_STR</span>(cb-&gt;Text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetID</span>(szValue, pulID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中 <code>TO_STR(x)</code> 宏定义，我理解为通过 <code>x</code> 构造出一个临时 <code>AnsiString</code> 的对象, 并对该临时对象调用成员函数 <code>c_str()</code> 获得指向其内部的 <code>const char *</code>。<br>由于匿名的临时对象的生命周期是该行结束即结束，所以获取到的 <code>const char *</code> 指针不可使用。<br>为了探究这个问题，使用以下代码来验证我的想法。</p>
<h2 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h2><p>由于 UnicodeString 不是标准库的对象，其源码繁杂且找不到手册，所以猜测 <code>UnicodeString</code> 与 <code>AnsiString</code> 的实现，分为两种:</p>
<ul>
<li><code>分别单独实现</code></li>
<li><code>UnicodeString</code> 继承自 <code>AnsiString</code></li>
</ul>
<h3 id="分别单独实现"><a href="#分别单独实现" class="headerlink" title="分别单独实现"></a>分别单独实现</h3><p>代码实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gos</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">const</span> T* dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> acText[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(acText, <span class="string">&quot;0x%X&quot;</span>, (<span class="type">size_t</span>)dec);</span><br><span class="line">    <span class="keyword">return</span> acText;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnsiString1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>(<span class="type">const</span> AnsiString1&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        <span class="built_in">sprintf</span>(str, obj.str);</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 拷贝构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, new str(&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~AnsiString1 析构函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, delete str(&quot;</span>&lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnicodeString1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;UnicodeString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~UnicodeString1 析构函数&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">AnsiString1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;operator AnsiString1(): &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AnsiString1 m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>C++ Builder</code> 运行结果</strong>:</p>
<p>不会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x19FE64, str: 0xA926560</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x19FE64</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0x19FE64</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x19FE60, new str(0xA926520)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x19FE5C, new str(0xA926510)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x19FE5C, delete str(0xA926510)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x19FE60, delete str(0xA926520)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串: 0xA926510</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; E2238 Multiple declaration for &#x27;obj&#x27;</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj; ///&lt; E2357 Reference initialized with &#x27;AnsiString1&#x27;, needs lvalue of type &#x27;AnsiString1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>VS2010</code> 运行结果</strong>:</p>
<p>不会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0xC3F914, str: 0x31A9F30</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0xC3F914</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0xC3F914</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F4FC, new str(0x31AA5B8)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F4F0, new str(0x31AA600)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xC3F4F0, delete str(0x31AA600)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xC3F4FC, delete str(0x31AA5B8)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x31AA600</span></span><br><span class="line">    AnsiString1&amp; r = (AnsiString1)obj;</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0xC3F914</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F518, new str(0x31AA5B8)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xC3F8F0, new str(0x31AA600)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xC3F518, delete str(0x31AA5B8)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz1 = r.<span class="built_in">c_str</span>();    <span class="comment">///&lt; warning C4239: 使用了非标准扩展:“初始化”: 从“AnsiString1”转换到“AnsiString1 &amp;” 非常量引用只能绑定到左值</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz1: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz1: 0x31AA600</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不通过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>VS2019</code> 运行结果</strong>:</p>
<p>不会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x8FFDF0, str: 0xA42310</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x8FFDF0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0x8FFDF0</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x8FFD0C, new str(0xA42498)</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x8FFD18, new str(0xA42070)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x8FFD18, delete str(0xA42070)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x8FFD0C, delete str(0xA42498)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0xA42070</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不通过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj;  ///&lt; error C2440: “初始化”: 无法从“AnsiString1”转换为“AnsiString1 &amp;”, 非常量引用只能绑定到左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>g++</code> 运行结果</strong></p>
<p>不会崩溃</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x53EDAFC0, str: 0x9C2010</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x53EDAFC0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// operator AnsiString1(): 0x53EDAFC0</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x53EDAFC8, new str(0x9C2090)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x53EDAFC8, delete str(0x9C2090)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x9C2090~UnicodeString1 析构函数0x53EDAFC0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UnicodeString-继承自-AnsiString"><a href="#UnicodeString-继承自-AnsiString" class="headerlink" title="UnicodeString 继承自 AnsiString"></a><code>UnicodeString</code> 继承自 <code>AnsiString</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gos</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">const</span> T* dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> acText[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(acText, <span class="string">&quot;0x%X&quot;</span>, (<span class="type">size_t</span>)dec);</span><br><span class="line">    <span class="keyword">return</span> acText;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnsiString1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">AnsiString1</span>(<span class="type">const</span> AnsiString1&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">        <span class="built_in">sprintf</span>(str, obj.str);</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;AnsiString1 拷贝构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, new str(&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 析构函数</span></span><br><span class="line">    ~<span class="built_in">AnsiString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~AnsiString1 析构函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&quot;, delete str(&quot;</span>&lt;&lt; gos::<span class="built_in">to_string</span>(str) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnicodeString1</span> : <span class="keyword">public</span> AnsiString1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;UnicodeString1 构造函数 this: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UnicodeString1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;~UnicodeString1 析构函数&quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">AnsiString1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOG &lt;&lt; <span class="string">&quot;operator AnsiString1(): &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> *(AnsiString1*)<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>C++ Builder</code> 运行结果</strong>:</p>
<p>不会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x19FE64, str: 0xA966560</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x19FE64</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x19FE60, new str(0xA966520)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x19FE60, delete str(0xA966520)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串: 0xA966520</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; E2238 Multiple declaration for &#x27;obj&#x27;</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj; ///&lt; E2357 Reference initialized with &#x27;AnsiString1&#x27;, needs lvalue of type &#x27;AnsiString1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>VS2010</code> 运行结果</strong>:</p>
<p>不会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0xCFFA1C, str: 0x2C49F30</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0xCFFA1C</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xCFF610, new str(0x2C4A5B8)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xCFF610, delete str(0x2C4A5B8)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x2C4A5B8</span></span><br><span class="line">    AnsiString1&amp; r = (AnsiString1)obj; <span class="comment">///&lt; warning C4239: 使用了非标准扩展:“初始化”: 从“AnsiString1”转换到“AnsiString1 &amp;” 非常量引用只能绑定到左值</span></span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xCFF9F8, new str(0x2C4A5B8)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz1 = r.<span class="built_in">c_str</span>();</span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz1: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz1: 0x2C4A5B8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>VS2019</code> 运行结果</strong>:</p>
<p>不会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0x3AFCD0, str: 0x682428</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0x3AFCD0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0x3AFBF8, new str(0x6823F0)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0x3AFBF8, delete str(0x6823F0)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x6823F0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 编译不过的代码</span></span><br><span class="line">    <span class="comment">/// AnsiString1&amp; r = (AnsiString1)obj;  ///&lt; error C2440: “初始化”: 无法从“AnsiString1”转换为“AnsiString1 &amp;”, 非常量引用只能绑定到左值</span></span><br><span class="line">    <span class="comment">/// AnsiString1(obj);  ///&lt; error C2371: “obj”: 重定义；不同的基类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>g++</code> 运行结果</strong></p>
<p>不会崩溃</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnicodeString1 obj;</span><br><span class="line">    <span class="comment">/// AnsiString1 构造函数 this: 0xB512D870, str: 0x1D17010</span></span><br><span class="line">    <span class="comment">/// UnicodeString1 构造函数 this: 0xB512D870</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sz = ((AnsiString1)obj).<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">/// AnsiString1 拷贝构造函数 this: 0xB512D878, new str(0x1D17090)</span></span><br><span class="line">    <span class="comment">/// ~AnsiString1 析构函数 this: 0xB512D878, delete str(0x1D17090)</span></span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;使用字符串 sz: &quot;</span> &lt;&lt; gos::<span class="built_in">to_string</span>(sz) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/// 使用字符串 sz: 0x1D17090</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><p>如果按照我们设想的 <code>UnicodeString</code> 的两种实现方式, 使用强制转换符， 在编译器 <code>C++ Builder</code>、<code>VS2010</code>、 <code>VS2019</code> 和 <code>g++</code> <strong>都会构造临时对象</strong>。</p>
</li>
<li><p>该临时对象在该行结束后马上析构。所以使用从临时对象中获取的指针可能会有问题，但<code>C++ Builder</code>、<code>VS2010</code>、 <code>VS2019</code> 和 <code>g++</code> <strong>没有出现编译警告和运行崩溃</strong>。</p>
</li>
<li><p>获取临时对象的引用在 <code>C++ Builder</code> 和 <code>VS2010</code> 中会有编译警告。在 <code>VS2019</code>、<code>g++</code> 中会直接编译错误。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiancong Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiancong Li</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
