<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mercy1101.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jiancong Li&#39;s Blog">
<meta property="og:url" content="https://mercy1101.github.io/page/2/index.html">
<meta property="og:site_name" content="Jiancong Li&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Jiancong Li">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mercy1101.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>Jiancong Li's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jiancong Li's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2020-12-15-C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">C++ 指针与引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-指针与引用"><a href="#C-指针与引用" class="headerlink" title="C++指针与引用"></a>C++指针与引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>可以为空（万恶之首）</li>
<li>可以做指针的偏移操作</li>
<li>可以用做修改一个变量</li>
<li>可以用来用来快速传递一个对象，没有复制的成本(只有指针复制的成本)<br>见下面代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* i)</span> </span>&#123;</span><br><span class="line">  *i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">f1</span>(&amp;num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num为2</span></span><br><span class="line">  <span class="built_in">f2</span>(num);</span><br><span class="line">  std::cout &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">///&lt; 此处num仍为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>引用同指针一样可以直接修改对象本身，减少传递对象的复制成本</li>
<li>引用不可为空，即创建必须初始化</li>
<li>引用不能同指针一样，进行四则运算</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> &amp;r = i;</span><br><span class="line">  r = <span class="number">1</span>;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为1</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为1</span></span><br><span class="line">  <span class="built_in">f1</span>(r);</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">///&lt; i这里为100</span></span><br><span class="line">  std::cout &lt;&lt; r &lt;&lt; std::endl;  <span class="comment">///&lt; r这里为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详情可见<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++?
</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/21/2020-12-14-%20%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/" class="post-title-link" itemprop="url">《Effective Modern C++》读书笔记(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-21 13:28:45" itemprop="dateCreated datePublished" datetime="2023-07-21T13:28:45+08:00">2023-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《Effective-Modern-C-》读书笔记-2"><a href="#《Effective-Modern-C-》读书笔记-2" class="headerlink" title="《Effective Modern C++》读书笔记(2)"></a>《Effective Modern C++》读书笔记(2)</h1><ol>
<li><p>裸指针在声明中并没有指出，裸指针指涉到的是单个对象还是一个数组。</p>
</li>
<li><p>裸指针在声明中也没有提示在使用完指涉到的对象以后，是否需要析构它。换言之，你从声明中看不出来指针是否拥有其指涉的对象。</p>
</li>
<li><p>即使知道需要析构指针所指涉的对象，也不可能知道如何析构才是适当的。是应该使用<code>delete</code>运算符，还是有其他用途。</p>
</li>
<li><p>即使知道了使用<code>delete</code>运算符，还是会发生到底应该用的那个对象形式（<code>delete</code>）还是数组形式（<code>delete[]</code>）。</p>
</li>
<li><p>即启用够确信，指针拥有其指涉对象，并且也确知应该如何析构，要保证析构在所有代码路径上都仅执行一次（包括那些异常导致的路径）仍然困难重重。只要少在一条路径上执行，就会导致资源泄露。而如果析构在一条路径上执行了多次，则会导致未定义行为。</p>
</li>
<li><p>没有什么正规的方式能检测出指针是否空悬，也就是说，它指涉的内存是否已经不再持有指针本应该指涉的对象。如果一个对象已经被析构了，而某些指针仍然指涉到它，就会产生空悬指针。</p>
</li>
</ol>
<p>在创建对象时注意区分<code>()</code>和<code>&#123;&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;  <span class="comment">///&lt; 调用默认构造函数</span></span><br><span class="line">Widget w2 = w1; <span class="comment">///&lt; 调用复制构造函数</span></span><br><span class="line">w1 = w2;  <span class="comment">///&lt; 赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>大括号可以用来为非静态成员指定默认初始化值，却不能使用小括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 不可行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不可复制的对象可以采用大括号和小括号来进行初始化，却不能使用<code>=</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;; <span class="comment">///&lt; 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">///&lt; 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">///&lt; 不可行</span></span><br></pre></td></tr></table></figure>
<p>大括号适用所有场合。<br>大括号初始化有一项新特性，就是它禁止内建型别之间进行隐式窄化型别转换。而采用小括号和<code>=</code>的初始化则不会进行窄化型别转换检查，因为如果那样的化就会破坏太多的遗留代码了。</p>
<p>大括号初始化的另一项值得一提的特征是，它对于C++最令人苦恼之解析语法免疫。C++规定：任何能够解析为声明的都要解析为声明。本来想要以默认方式构造一个对象，结果却一不小心声明了一个函数。这个错误的根本原因构造函数调用语法。<br>当你想要以传参的方式调用构造函数时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">///&lt; 调用Widget的构造函数，传入形参10</span></span><br></pre></td></tr></table></figure>
<p>但你如果试图用相同的语法构造一个没有形参的Widget的话，结果却变成了声明了一个函数而非对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;  <span class="comment">///&lt; 最令人苦恼之解析语法现身</span></span><br></pre></td></tr></table></figure>
<p>由于函数声明不能使用大括号来指定形参列表，所以使用大括号来完成对象的默认构造上面这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;  <span class="comment">///&lt; 调用没有形参的Widget构造函数</span></span><br></pre></td></tr></table></figure>

<p>大括号初始化的缺陷在于伴随它有时会出现的意外行为。这种行为源于大括号初始化物、<code>std::initializer_list</code>以及构造函数重载决议之间的纠结。</p>
<p>如果一个或多个构造函数声明了任何一个具备<code>std::initializer_list</code>型别的形参那么采用了大括号初始化语法的调用语句会强烈地优先选用带有<code>std::initializer_list</code>型别形参的重载版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;  <span class="comment">///&lt; 调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;  <span class="comment">///&lt; 使用最后一个构造函数, 10, true 被强制转化为long double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你的确想要调用一个带有<code>std::initializer_list</code>型别形参的构造函数，并传入一个空的<code>std::initializer_list</code>的话，你可以通过把空大括号对作为构造函数实参的方式实现这个目的，即把一对空大括号放入一对小括号或大括号的方式来清楚地表明你传递地是什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;  <span class="comment">///&lt; 带有std::initializer_list型别形参地构造函数</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;  <span class="comment">///&lt; 同上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有十个元素，每个元素值都为20的vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">///&lt; 创建了一个拥有两个元素，值分别为10、20 的vector</span></span><br></pre></td></tr></table></figure>

<p><code>std::make_unique</code>和<code>std::make_shared</code>在函数内部使用的小括号，作为其接口的一部分。</p>
<ul>
<li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫</li>
<li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有<code>std::initializer_list</code>型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li>
<li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个<code>std::vector&lt;数值型别&gt;</code>对象。</li>
<li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li>
</ul>
<h2 id="理解特种成员函数的生成机制"><a href="#理解特种成员函数的生成机制" class="headerlink" title="理解特种成员函数的生成机制"></a>理解特种成员函数的生成机制</h2><p>两种复制操作是彼此独立的：声明了其中一个，并不会阻止编译器生成另外一个。如果你生成了一个复制构造函数，同时未声明复制赋值运算符，并撰写了要求复制赋值的代码，则编译器会为你生成复制赋值运算符。反过来一样。</p>
<p>两种移动操作并不彼此独立：声明了其中一个就会阻止编译器生成另外一个。假设你声明了一个移动构造函数，你实际上表明了移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。综上声明一个移动构造函数会阻止编译器去生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器去生成移动构造函数。</p>
<p>一旦显式声明了赋值操作，这个类也就不再会生成移动操作了。依据在于，声明复制操作的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。从而判定既然按成员复制不适用于赋值操作，则按成员移动极有可能也不适用于移动操作。<br>一旦声明了移动操作，编译器就会删除复制操作。</p>
<p>三大律：如果你声明了复制构造函数、复制复制运算符，或析构函数中的任何一个，你就得同时声明所有这三个。<br>如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：1. 在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行。 2. 该类的析构函数也会参与到该资源的管理之中。</p>
<p>大三律的一个推论是，如果存在用户声明的析构函数，则平凡的按成员赋值也不适用于该类。如果声明了析构函数，则复制操作就不该被自动生成，因为他们呢的行为不可能正确。所以在C++11中：只要用户声明了析构函数，就不会生成移动操作。</p>
<p>移动操作的生成条件（如果需要生成）仅当以下三者同时成立：</p>
<ul>
<li>该类未声明任何复制操作</li>
<li>该类未声明任何移动操作</li>
<li>该类未声明任何析构操作</li>
</ul>
<p>总而言之， C++11中， 支配特种成员函数的机制如下：</p>
<ul>
<li>默认构造函数： 仅当类中不包含用户声明的构造函数时才生成</li>
<li>析构函数：与C++98中基本相同，唯一的区别在于析构函数默认为<code>noexcept</code>.仅当基类的析构函数为虚的，派生类析构函数才是虚的。</li>
<li>复制构造函数： 按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为。</li>
<li>移动构造函数和移动赋值运算符<br>都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</li>
</ul>
<p>成员函数模板的存在会阻止编译器生成任何特种成员函数。</p>
<ul>
<li><p>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成</p>
</li>
<li><p>复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数时才生成，复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</p>
</li>
<li><p>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</p>
</li>
<li><p>auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别少打一些字</p>
</li>
<li><p>在模板推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</p>
</li>
<li><p>对万能引用形参进行推导时，左值实参会进行特殊处理。</p>
</li>
<li><p>对按值传递的形参进行推导时，若实参型别中带有<code>const</code>或<code>volatile</code>饰词，则它们还是会被当作不带<code>const</code>或<code>volatile</code>饰词的型别来处理。</p>
</li>
<li><p>在模板型别推导过程中， 数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</p>
</li>
<li><p>在一般情况下，auto型别推导和模板型推导是一模一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>, 但模板型别推导却不会。</p>
</li>
<li><p>在函数返回值或lambda式的形参中使用auto， 意思是使用模板型别推导而非auto型推导。</p>
</li>
<li><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的型别而不做任何修改</p>
</li>
<li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，<code>decltype</code>总是得出型别<code>T&amp;</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/2020-12-15-C++nullptr%E4%B8%8ENULL/" class="post-title-link" itemprop="url">C++ nullptr与NULL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-15 18:58:39" itemprop="dateCreated datePublished" datetime="2020-12-15T18:58:39+08:00">2020-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NULL与nullptr的区别"><a href="#NULL与nullptr的区别" class="headerlink" title="NULL与nullptr的区别"></a>NULL与nullptr的区别</h1><p>NULL为宏定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure>

<p>NULL的类型不明显，而一下情况会出现函数重载不明确的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">NULL</span>); <span class="comment">///&lt; 调用函数不确定，编译器警告或报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>nullptr</code>是一个特殊类型(<code>nullptr_t</code>)专门用来指代空指针。见下面代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;  <span class="comment">///&lt; #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;&#125; <span class="comment">///&lt; #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="literal">nullptr</span>); <span class="comment">///&lt; 明确调用#2函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/2020-12-13-%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%20/" class="post-title-link" itemprop="url">《Effective Modern C++》读书笔记(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-13 10:19:33" itemprop="dateCreated datePublished" datetime="2020-12-13T10:19:33+08:00">2020-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">c++ 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《Effective-Modern-C-》读书笔记-1"><a href="#《Effective-Modern-C-》读书笔记-1" class="headerlink" title="《Effective Modern C++》读书笔记(1)"></a>《Effective Modern C++》读书笔记(1)</h1><p>在运行期， <code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>(); <span class="comment">///&lt; 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; 非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span>  <span class="comment">///&lt; 右值引用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span> <span class="comment">///&lt; 非右值引用</span></span></span><br></pre></td></tr></table></figure>

<p><code>T&amp;&amp;</code>有两种不同的含义</p>
<ol>
<li>右值引用</li>
<li>表示既可以是右值引用也可以是左值引用</li>
</ol>
<p>万能引用会在两个地方现身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">///&lt; param是个万能引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">///&lt; var2是个万能引用</span></span><br></pre></td></tr></table></figure>

<p>而不涉及型别推导<code>&amp;&amp;</code>就是右值引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">///&lt; 不涉及型别推导</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>关键字也可以确定<code>const T&amp;&amp;</code>是右值引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在一个模板中的<code>T&amp;&amp;</code>也不一定是万能引用， 见下面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为<code>push_back</code>是<code>vector</code>的成员函数， 如果<code>vector</code>实例存在的话就一定有确定的类型，所以并不存在型别推导。</p>
<p>另外，声明<code>auto&amp;&amp;</code>都是万能引用。</p>
<p>针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></p>
<p>当转发右值引用给其他函数是，应当对其实施向右值的无条件强制型别转换(通过<code>std::move</code>)，因为它们一定绑定到右值，而当转发万能引用时，应当对其实施向右值的有条件强制型别转换(通过<code>std::forward</code>), 因为它们不一定绑定到右值。<br>应当避免针对右值引用实施<code>std::forward</code>。而另一方面，针对万能引用使用<code>std::move</code>的想法更为糟糕，因为那样做的后果是某些左值会遭到意外改动(例如某些临时变量)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(newName);  <span class="comment">///&lt; 可以编译但糟糕透顶</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;  <span class="comment">///&lt; 工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>(); <span class="comment">///&lt; n是个局部变量</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">setName</span>(n); <span class="comment">///&lt; 将n移入了w</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">///&lt; n的值变得未知了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ... <span class="comment">///&lt; 对w进行操作</span></span><br><span class="line">  <span class="keyword">return</span> w; <span class="comment">///&lt; 没有任何东西被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(w);  <span class="comment">///&lt; 将w移入返回值, 千万不要这么做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RVO</code>(return value optimization): 编译器若要在一个按值返回的函数里省略对局部对象的复制（或者移动）, 则需要满足两个前提条件： 1. 局部对象型别和函数返回值型别相同. 2. 返回的就是局部对象本身。即使实施<code>RVO</code>的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。当<code>RVO</code>的前提条件允许时，要么发生复制省略，要么<code>std::move</code>隐式地被实施于返回的局部对象。</p>
<ul>
<li>针对右值引用的最后一次使用实施<code>std::move</code>, 针对万能引用的最后一次使用实施<code>std::forward</code>。</li>
<li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行动。</li>
<li>若局部对象可能适用于返回值优化，则请勿针对其实施<code>std::move</code>或<code>std::forward</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::<span class="built_in">is_integral</span>&lt;T&gt;());  <span class="comment">///&lt; std::is_integral不够正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::is_integral&lt;&gt;</code>不够正确是因为如果传给万能引用<code>name</code>实参是个左值，那么<code>T</code>就会被推导为左值引用。因为<code>int&amp;</code>不是<code>int</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完美转发的含义是我们不仅转发对象，还转发其显著特征：型别、左值还是右值，以及是否带有<code>const</code>和<code>volation</code>饰词等等。</p>
<p>大括号初始化物<br>假设<code>f</code>的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std:vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在此情况下，以大括号初始化物调用<code>f</code>可以通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>但如果把同一大括号初始化物的运用，就是一种完美转发失败的情形。编译器采用推导的手法来取得传递给<code>fwd</code>实参的型别结果，而后它会比较推导型别结果和<code>f</code>声明的形参型别。完美转发会在下面两个条件中的任何一个成立时失败：</p>
<ul>
<li>编译器无法为一个或多个<code>fwd</code>的形参推导出型别结果。编译器无法编译通过。</li>
<li>编译器为一个或多个<code>fwd</code>的形参推导出了”错误的”型别结果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(Widget::MinVals); <span class="comment">///&lt; 没问题, 当f(28)处理</span></span><br><span class="line"><span class="built_in">fwd</span>(Widget::MinVals); <span class="comment">///&lt; 错误，无法链接</span></span><br></pre></td></tr></table></figure>
<p>无法链接的原因是，完美转发，转发的是入参(<code>Widget::MinVals</code>)的引用，而引用在编译器底层是指针实现的。由于<code>static</code>变量并没有被分配实际的地址，所以产生了链接错误。</p>
<p>完美转发的失败情形还包括：重载的函数名字和模板名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">///&lt; 一个接受函数指针入参的函数f</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 然后调用</span></span><br><span class="line"><span class="built_in">f</span>(processVal);</span><br></pre></td></tr></table></figure>
<p>上面在调用函数<code>f</code>的时候，其中<code>processVal</code>仅仅只是函数的名字，但编译器知道匹配的是单入参版本的函数。</p>
<p>而使用完美转发时，编译器是无法知道使用的是什么版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(processVal);  <span class="comment">///&lt; 编译不过</span></span><br></pre></td></tr></table></figure>

<p>最后一种完美转发失败的情形是位域被用作函数实参的时候。<br>标准中：非<code>const</code>引用不得绑定到位域。既然没有办法创建指涉到任意比特的指针(C++标准规定，可以指涉的最小实体是单个char)，那自然没有办法把引用绑定到任意比特上了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPV4Header</span> &#123;</span><br><span class="line">  std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">  IHL:<span class="number">4</span>,</span><br><span class="line">  DSCP:<span class="number">6</span>,</span><br><span class="line">  ECN:<span class="number">2</span>,</span><br><span class="line">  totalLength:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength); <span class="comment">///&lt; 没问题</span></span><br><span class="line"><span class="built_in">fwd</span>(h.totalLength); <span class="comment">///&lt; 错误！</span></span><br></pre></td></tr></table></figure>
<p>把位域传递给完美转发函数的关键，就是利用转发目的函数接收的总是位域值的副本这一事实。可以自己复制一份，并以该副本调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"><span class="built_in">fwd</span>(length);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/2020-07-05-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">C++字符串分割与解析代码学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-05 15:19:05" itemprop="dateCreated datePublished" datetime="2020-07-05T15:19:05+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26328793/how-to-split-string-with-delimiter-using-c">源码链接</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           把字符串前后的字符串给去除</span></span><br><span class="line"><span class="comment"> * @param           s       [in]    要剪切的字符串</span></span><br><span class="line"><span class="comment"> * @param           chars   [in]    要去除什么的字符串</span></span><br><span class="line"><span class="comment"> * @return          std::string&amp; 剪切后的字符串</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::string&amp; <span class="title">strip</span><span class="params">(std::string&amp; s, <span class="type">const</span> std::string&amp; chars = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(chars.<span class="built_in">c_str</span>()));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(chars.<span class="built_in">c_str</span>()) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief           以特定符号为分隔符，切分字符串并放入vector里</span></span><br><span class="line"><span class="comment"> * @param           s           [in]    原字符串</span></span><br><span class="line"><span class="comment"> * @param           tokens      [out]   剪切后的子字符串</span></span><br><span class="line"><span class="comment"> * @param           delimiters  [in]    分隔符</span></span><br><span class="line"><span class="comment"> * @author          lijiancong(lijiancong@gbcom.com.cn)</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">const</span> std::string&amp; s, std::vector&lt;std::string&gt;&amp; tokens,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> std::string&amp; delimiters = <span class="string">&quot; &quot;</span>)</span> </span>&#123;</span><br><span class="line">  std::string::size_type lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, <span class="number">0</span>);</span><br><span class="line">  std::string::size_type pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  <span class="keyword">while</span> (std::string::npos != pos || std::string::npos != lastPos) &#123;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(lastPos, pos - lastPos));</span><br><span class="line">    lastPos = s.<span class="built_in">find_first_not_of</span>(delimiters, pos);</span><br><span class="line">    pos = s.<span class="built_in">find_first_of</span>(delimiters, lastPos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">parse</span><span class="params">(std::string&amp; s, std::map&lt;std::string, std::string&gt;&amp; items)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; elements;</span><br><span class="line">  s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &#123;&quot;</span>));</span><br><span class="line">  s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;&#125; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">split</span>(s, elements, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : elements) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; kv;</span><br><span class="line">    <span class="built_in">split</span>(iter, kv, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (kv.<span class="built_in">size</span>() != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    items[<span class="built_in">strip</span>(kv[<span class="number">0</span>], <span class="string">&quot; \&quot;&quot;</span>)] = <span class="built_in">strip</span>(kv[<span class="number">1</span>], <span class="string">&quot; \&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string data =</span><br><span class="line">      <span class="string">&quot;  &#123;  \&quot;key1\&quot;  :  \&quot;data1\&quot;  ,  \&quot;key2\&quot;  :  \&quot;data2\&quot;    &#125;  &quot;</span>;</span><br><span class="line">  std::map&lt;std::string, std::string&gt; items;</span><br><span class="line">  <span class="built_in">parse</span>(data, items);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iter:items)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key=&quot;</span> &lt;&lt; iter.first &lt;&lt; <span class="string">&quot;,value=&quot;</span> &lt;&lt; iter.second &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/2020-07-04-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">C++异常处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-04 11:11:05" itemprop="dateCreated datePublished" datetime="2020-07-04T11:11:05+08:00">2020-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>​<strong>异常处理</strong>（<code>exception handling</code>）机制允许程序独立开发的部分能够在运行时就出现问题<strong>进行通信</strong>并作出<strong>相应的处理</strong>。异常是的我们能够将问题的检测和解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无需知道问题处理模块的所有细节，反之亦然。</p>
<h2 id="1-抛出异常"><a href="#1-抛出异常" class="headerlink" title="1. 抛出异常"></a>1. 抛出异常</h2><p>​在C++语言中，我们通过<strong>抛出</strong>(<code>throwing</code>)一条表达式来<strong>引发</strong>(<code>raised</code>)一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段<strong>处理代码</strong>(<code>handler</code>)将被用来处理该异常。被选中的处理代码实在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分会告知异常处理部分到底发生了什么错误。</p>
<p>​当执行一个<code>throw</code>时，跟在<code>throw</code>后面的语句将不再被执行。相反，程序的控制权从<code>throw</code>转移到与之匹配的<code>catch</code>模块。该<code>catch</code><strong>可能是同一函数中</strong>的局部<code>catch</code>，<strong>也可能位于直接或间接调用了发生异常的函数的另一个函数中</strong>。控制权从一处转移到另一处，这有两个重要的含义：</p>
<ul>
<li><strong>沿着调用链的函数可能会提早退出</strong>。</li>
<li><strong>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁</strong>。</li>
</ul>
<p>因为跟在<code>throw</code>后面的语句将不再被执行，所以<code>throw</code>语句的有类似于<code>return</code>语句：它通常作为条件语句的一部分或者作为某个函数的最后(或者唯一)一条语句。</p>
<h3 id="1-1-栈展开"><a href="#1-1-栈展开" class="headerlink" title="1.1 栈展开"></a>1.1 栈展开</h3><p>​<strong>当抛出一个异常后</strong>，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的<code>catch</code>子句。</p>
<ul>
<li><p>当<code>throw</code>出现在一个<strong>try语句块</strong>(<code>try block</code>)内时，检查与该<code>try</code>块关联的<code>catch</code>子句。</p>
</li>
<li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p>
</li>
<li><p>如果这一步<strong>没找到匹配</strong>的<code>catch</code><strong>且该<code>try</code>语句嵌套在其他<code>try</code>块中</strong>，则<strong>继续检查与外层<code>try</code>匹配的<code>catch</code>子句</strong>。</p>
</li>
<li><p>如果<strong>还是找不到匹配</strong>的<code>catch</code>，则<strong>退出当前函数</strong>，在调<strong>用当前函数的外层函数中</strong>继续寻找。</p>
</li>
<li><p>如果对抛出异常的函数的调用语句位于一个<code>try</code>语句块内，则检查与该<code>try</code>块关联的<code>catch</code>子句。</p>
</li>
<li><p>如果找到了匹配的<code>catch</code>，就使用该<code>catch</code>处理异常。</p>
</li>
<li><p>否则，如果该<code>try</code>语句嵌套在其他<code>try</code>块中，则继续检查与外层<code>try</code>匹配的<code>catch</code>子句。</p>
</li>
<li><p>如果仍然没找到匹配的<code>catch</code>，则退出当前这个主调函数，继续在调用刚刚退出的这个函数的其他函数中寻找，以此类推。</p>
</li>
</ul>
<p>​上述过程被称为<strong>栈展开</strong>(<code>stack unwinding</code>)过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的<code>catch</code>子句为止；或者也可能一致没找到匹配的<code>catch</code>，则退出主函数后过程中止。</p>
<p>​假设找到了一个匹配的<code>catch</code>子句，则程序进入该子句并执行其中代码。当执行完这个<code>catch</code>子句后，找到与<code>try</code>块关联的最后一个<code>catch</code>子句后的点，并从这里继续执行。</p>
<p>​<strong>如果没有找到匹配的<code>catch</code>子句，程序将退出</strong>。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的<code>catch</code>时，程序将调用标准库函数<code>terminate</code>，顾名思义，<code>terminate</code>负责中止程序的执行过程。</p>
<h3 id="1-2-栈展开过程中对象被自动销毁"><a href="#1-2-栈展开过程中对象被自动销毁" class="headerlink" title="1.2 栈展开过程中对象被自动销毁"></a>1.2 栈展开过程中对象被自动销毁</h3><p>​在栈展开过程中，位于调用链上的语句块可能会提前退出。如果在<strong>栈展开过程中</strong>退出了某个块，编译器将负责确保在这个块中<strong>创建的对象都能被正确的销毁</strong>。如果某个局部对象的类型是<strong>类类型</strong>，则<strong>该对象的析构函数将被自动调用</strong>。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。</p>
<p>​如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经开始初始化了，而另外一些成员在异常发生前也许还没有开始初始化。即使某个对象只构造了一部分，我们也要<strong>确保构造的成员能被正确的销毁</strong>（否则会发生内存泄露）。</p>
<p>​类似的，异常也可能发生在<strong>数组</strong>或<strong>标准库容器的元素初始化过程</strong>中。与之前类似，如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确的销毁。</p>
<h3 id="1-3-析构函数与异常"><a href="#1-3-析构函数与异常" class="headerlink" title="1.3 析构函数与异常"></a>1.3 析构函数与异常</h3><p>​析构函数总是会被执行的，但是函数中负责释放资源的代码却可能会被跳过。如果一个块分配了资源，并且在<strong>负责释放这些资源的代码前面发生了异常</strong>，则释放资源的代码将<strong>不会被执行</strong>。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。（<code>RAII</code>的思想，在构造函数中获取资源(i.e <code>new</code>)，在析构函数中释放资源(i.e <code>delete</code>)。）</p>
<p>​所以出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，<strong>如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理</strong>（如果不这样做的话，程序会马上被终止）。</p>
<blockquote>
<p> 注：所有标准库类型都能保证它们的析构函数不会引发异常。</p>
</blockquote>
<h3 id="1-4-异常对象"><a href="#1-4-异常对象" class="headerlink" title="1.4 异常对象"></a>1.4 异常对象</h3><p><strong>异常对象</strong>（<code>exception object</code>）是一种特殊的对象，编译器使用<strong>异常抛出表达式</strong>来对<strong>异常对象</strong>进行<strong>拷贝初始化</strong>。因此<code>throw</code>语句中的表达式必须拥有<strong>完整类型</strong>。而且如果该表达式是<strong>类类型</strong>的话，则相应的类必须含有一个<strong>可访问的析构函数</strong>和一个<strong>可访问的拷贝或移动构造函数</strong>。如果该表达式是<strong>数组类型</strong>或<strong>函数类型</strong>，则表达式将被<strong>转换成</strong>与之对应的<strong>指针类型</strong>。</p>
<p>​异常对象位于有编译器管理的空间中，编译器确保无论调用哪个<code>catch</code>子句都能访问该空间。异常处理完毕后，异常对象被销毁。</p>
<p>​当一个异常被抛出是，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向<strong>局部对象的指针</strong>几乎肯定是一种<strong>错误</strong>行为。如果指针所指的对象位于某个块中，而该块在<code>catch</code>语句之前就已经退出了，则意味着在执行<code>catch</code>语句之前局部对象已经被销毁了。</p>
<p>​当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条<code>throw</code>表达式<strong>解引用一个基类指针</strong>，而该指针<strong>实际指向的是派生类对象</strong>，则<strong>抛出的对象将被切掉一部分，只有基类部分被抛出</strong>。</p>
<blockquote>
<p>注： 抛出指针要求在任何对应处理代码存在的地方，指针所指的对象都必须存在。</p>
</blockquote>
<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p><code>catch</code>子句（<code>catch clause</code>）中的一场声明（<code>exception declaration</code>）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果<code>catch</code>无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>
<p>声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，不能是右值引用。当进入一个<code>catch</code>语句后，入参通过异常对象初始化异常声明中的参数。和函数的参数类似，如果<code>catch</code>的参数类型是非引用类型，则该参数是异常对象的一个副本，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名。</p>
<p>如果<code>catch</code>的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果<code>catch</code>的参数是非引用类型，则异常对象将被切掉一部分，如果<code>catch</code>的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。</p>
<p>最后一点需要注意的是，异常声明的静态类型将决定<code>catch</code>语句所能执行的操作。如果<code>catch</code>的参数是基类类型，则<code>catch</code>无法使用派生类特有的任何成员。</p>
<blockquote>
<p>Tips: 通常情况下，如果<code>catch</code>接收的异常与某个继承体系有关，则最好将该<code>catch</code>的参数定义成引用类型。</p>
</blockquote>
<h3 id="2-1-查找匹配的处理代码"><a href="#2-1-查找匹配的处理代码" class="headerlink" title="2.1 查找匹配的处理代码"></a>2.1 查找匹配的处理代码</h3><p>​在搜寻<code>catch</code>语句的过程中，我们最终找到的<code>catch</code>未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的<code>catch</code>语句。因此，越是专门的<code>catch</code>越应该置于整个<code>catch</code>列表的前端。</p>
<p>​因为<code>catch</code>语句是按照其出现的顺序逐一匹配的，所以当程序员使用具有继承关系的多个异常时必须对<code>catch</code>语句的顺序进行组织管理，是的派生类异常的处理代码出现在基类异常的处理代码异常之前。</p>
<p>​与实参和形参的匹配规则相比，异常和<code>catch</code>异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和<code>catch</code>声明的类型时精确匹配的：</p>
<ul>
<li>允许从非常量的类型转换，也就是说一条非常量对象的<code>throw</code>语句可以匹配一个接受常量引用的<code>catch</code>语句</li>
<li>允许从派生类向基类的类型转换。</li>
<li>数组被转换成指向数组（元素）类型的指针，函数被转化成指向该函数类型的指针。</li>
</ul>
<p>除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用。</p>
<blockquote>
<p>如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最低端的类（<code>most derived type</code>）放在前面，而将继承链最顶端的类（<code>least derived type</code>）放在后面。</p>
</blockquote>
<h3 id="2-2-重新抛出"><a href="#2-2-重新抛出" class="headerlink" title="2.2 重新抛出"></a>2.2 重新抛出</h3><p>​一个单独的<code>catch</code>语句不能完整的处理某个异常。在执行了某些校正操作之后，当前的<code>catch</code>可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出的操作将异常传递给另外一个<code>catch</code>语句。这里的重新抛出仍然是一条<code>throw</code>语句，只不过不包含任何表达式: <code>throw;</code></p>
<p>​空的<code>throw</code>语句只能出现在<code>catch</code>语句或<code>catch</code>语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空<code>throw</code>语句，编译器将调用<code>terminate</code>。</p>
<p>​一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。</p>
<p>​很多时候，catch语句会改变其参数内容。如果在改变了参数的内容后catch语句重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所作的改变才会被保留并继续传播。</p>
<h3 id="2-3-捕获所有异常的处理代码"><a href="#2-3-捕获所有异常的处理代码" class="headerlink" title="2.3 捕获所有异常的处理代码"></a>2.3 捕获所有异常的处理代码</h3><p>​为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常的处理代码，形如<code>catch(...)</code>.</p>
<p>​<code>catch(...)</code>通常与重新抛出语句一起使用，其中<code>catch</code>执行当前局部能完成的工作，随后重新抛出异常。</p>
<blockquote>
<p>Tips: 如果<code>catch(...)</code>与其他几个<code>catch</code>语句一起出现，则<code>catch(...)</code>必须在最后的位置。出现在捕获所有一场语句后面的<code>catch</code>语句将永远不会被匹配。</p>
</blockquote>
<h2 id="3-函数try语句块与构造函数"><a href="#3-函数try语句块与构造函数" class="headerlink" title="3. 函数try语句块与构造函数"></a>3. 函数try语句块与构造函数</h2><p>​通常情况下，程序执行的任何时刻都可能发生异常，特别是一场可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的<code>try</code>语句块还未生效，所以构造函数体内的<code>catch</code>语句无法处理构造函数初始值列表抛出的异常。</p>
<p>​要想处理构造函数初始值抛出的异常，我们必须将构造函数写成<strong>函数try语句块</strong>（<code>function try block</code>）的形式。函数<code>try</code>语句使得一组<code>catch</code>语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"> : <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;<span class="comment">/** ... */</span>&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">handle_out_of_memory</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-noexcept-异常说明"><a href="#4-noexcept-异常说明" class="headerlink" title="4. noexcept 异常说明"></a>4. noexcept 异常说明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span></span>;           <span class="comment">/** 可能会抛出异常 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数应该在函数的尾置返回类型之前。</p>
</li>
<li><p>我们也可以在函数指针的声明和定义中指定<code>noexcept</code>。</p>
</li>
<li><p>在typedef或类型别名中则不能出现<code>noexcept</code>。</p>
</li>
<li><p>在成员函数中，<code>noexcept</code>说明符需要跟在<code>const</code>及引用限定符之后，而在<code>final</code>、<code>override</code>或虚函数<code>=0</code>之前。</p>
</li>
</ul>
<h3 id="4-1-违反异常说明"><a href="#4-1-违反异常说明" class="headerlink" title="4.1 违反异常说明"></a>4.1 违反异常说明</h3><p>​编译器并不会在编译时检查<code>noexcept</code>说明。实际上，如果一个函数说明了<code>noexcept</code>的同时又含有<code>throw</code>语句或者调用了可能抛出异常的其他函数，编译器将顺利通过，并不会因为这种违反异常说明的情况而报错。</p>
<p>​因此可能会出现一种情况：尽管函数说明了它不会抛出异常，但实际上还是抛出了。一旦一个<code>noexcept</code>函数抛出异常，程序就会调用<code>terminate</code>以确保遵守不在运行时抛出异常的承诺。</p>
<p>​上述过程是执行栈展开未作约定，因此<code>noexcept</code>可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。</p>
<h3 id="4-2-noexcept运算符"><a href="#4-2-noexcept运算符" class="headerlink" title="4.2 noexcept运算符"></a>4.2 noexcept运算符</h3><p>​<code>noexcept</code>说明符接受一个可选实参，该实参必须能转换为<code>bool</code>类型：如果实参是<code>true</code>，则函数不会抛出异常；如果实参是<code>false</code>，则函数可能抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;	<span class="comment">/** 不会抛出异常 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;	<span class="comment">/** 可能抛出异常 */</span></span><br></pre></td></tr></table></figure>

<p>​<code>noexcept</code>说明符的实参常常与<code>noexcept</code>运算符混合使用。<code>noexcept</code>运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和<code>sizeof</code>类似，<code>noexcept</code>也不会求其运算对象的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">noexcept</span>(<span class="built_in">recoup</span>())	<span class="comment">/** 如果recoup不跑出异常则结果为true；否则结果为false */</span></span><br><span class="line"><span class="built_in">noexcept</span>(e)	<span class="comment">/** 等价于上一句 */</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用noexcept运算符得到如下的异常说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>;	<span class="comment">// f 和 g的异常说明一致</span></span><br></pre></td></tr></table></figure>

<p>如果函数<code>g()</code>承诺了不会抛出异常，则f也不会抛出异常；如果<code>g()</code>没有异常说明符，或者g虽然有异常说明符但是允许抛出异常，则<code>f()</code>也可能抛出异常。</p>
<blockquote>
<p><code>noexcept</code>有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为<code>noexcept</code>异常说明的<code>bool</code>实参出现时，它是一个运算符。</p>
</blockquote>
<h3 id="4-3-异常说明与指针、虚函数和拷贝控制"><a href="#4-3-异常说明与指针、虚函数和拷贝控制" class="headerlink" title="4.3 异常说明与指针、虚函数和拷贝控制"></a>4.3 异常说明与指针、虚函数和拷贝控制</h3><p>​<strong>函数指针及该指针所指的函数必须具有一致的异常说明</strong>。也就是说我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以。</p>
<p>​如果<strong>虚函数</strong>承诺了它<strong>不会抛出异常</strong>，则后续派生出来的<strong>虚函数</strong>也必须做出<strong>同样的承诺</strong>；与之相反如果<strong>基类的虚函数允许抛出异常</strong>，则派<strong>生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。</strong></p>
<p>​当编译器<strong>合成拷贝控制成员</strong>时，同时也<strong>生成一个异常说明</strong>。如果对<strong>所有成员</strong>和<strong>基类的所有操作</strong>都承诺了不会抛出异常，则合成的成员是<code>noexcept</code>的。如果合成成员调用的<strong>任意一个函数可能抛出异常</strong>，则合成的成员是<code>noexcept(false)</code>。而且如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将于假设有编译器为类合成析构函数时所得的异常说明一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/2020-07-04-C++20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E7%AC%A6/" class="post-title-link" itemprop="url">C++20三路比较符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-04 11:05:05" itemprop="dateCreated datePublished" datetime="2020-07-04T11:05:05+08:00">2020-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="三路比较符（C-20）"><a href="#三路比较符（C-20）" class="headerlink" title="三路比较符（C++20）"></a>三路比较符（C++20）</h1><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/utility/compare/compare_three_way">官网解释</a></p>
<p><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/">微软技术博客介绍</a></p>
<p><a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1186r3.html">When do you actually use <code>&lt;=&gt;</code>?</a></p>
<p>例子1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rational_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> den; <span class="comment">// &gt; 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> std::weak_ordering <span class="built_in">operator</span>&lt;=&gt;(Rational_2 lhs, Rational_2 rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.num * rhs.den &lt;=&gt; rhs.num * lhs.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::weak_ordering value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;equal\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;less\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;greater\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rational_2 c&#123;<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Rational_2 d&#123;<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(c &lt;=&gt; d);</span><br><span class="line">    <span class="built_in">print</span>(std::compare_three_way&#123;&#125;(c,d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basics</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Basics&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">  <span class="type">int</span> ai[<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> ac[<span class="number">2</span>];</span><br><span class="line">  <span class="type">float</span> af[<span class="number">3</span>];</span><br><span class="line">  <span class="type">double</span> ad[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Arrays&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bases</span> : Basics, Arrays &#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Bases&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases a = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> Bases b = &#123; &#123; <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1.f</span>, <span class="number">1.</span> &#125;,</span><br><span class="line">                        &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125;, &#123; <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span> &#125;, &#123; &#123; <span class="number">1.</span>, <span class="number">2.</span> &#125;, &#123; <span class="number">3.</span>, <span class="number">4.</span> &#125; &#125; &#125; &#125;;</span><br><span class="line">  <span class="built_in">static_assert</span>(a == b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a != b));</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &lt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &lt;= b);</span><br><span class="line">  <span class="built_in">static_assert</span>(!(a &gt; b));</span><br><span class="line">  <span class="built_in">static_assert</span>(a &gt;= b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/2020-07-04-C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">C++严格弱序的介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-04 10:51:05" itemprop="dateCreated datePublished" datetime="2020-07-04T10:51:05+08:00">2020-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="严格弱序（strict-weak-ordering）"><a href="#严格弱序（strict-weak-ordering）" class="headerlink" title="严格弱序（strict weak ordering）"></a>严格弱序（strict weak ordering）</h1><p>关联式容器（<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>）的排序准则的定义，和std::sort的排序准则定义必须遵守严格弱序，详细描述见官方解释(<a href="/resource/C++%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D/strict_weak_ordering.pdf">strict weak ordering.pdf</a>)。</p>
<p><strong>严格弱序的定义</strong>：</p>
<p><strong>简单的来说就是a&lt;b返回true，a&#x3D;b和a&gt;b返回false。</strong></p>
<p>详细定义：</p>
<blockquote>
<ol>
<li><p>必须是<strong>非对称的</strong>（antisymmetric）。</p>
<p> 对<code>operator&lt; </code>而言， 如果x &lt; y为true， 则y &lt; x为false。</p>
<p> 对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true，则op(y, x)为false。</p>
</li>
<li><p>必须是<strong>可传递的</strong>（transitive）。</p>
</li>
</ol>
<p>  对<code>operator&lt; </code>而言，如果x &lt; y 为true且y &lt; z为true， 则x &lt; z 为false。</p>
<p>  对判断式(predicate) <code>op()</code>而言，如果op(x, y)为true且op(y, z)为tru，则op(x, z)为true。</p>
<ol start="3">
<li><p>必须是<strong>非自反的</strong>（irreflexive）</p>
<p> 对<code>operator&lt; </code>而言，x &lt; x 永远是false</p>
<p> 对判断式(predicate) <code>op()</code>而言，op(x, x)永远是false。</p>
</li>
<li><p>必须有<strong>等效传递性</strong>（transitivity of equivalence）</p>
</li>
</ol>
<p>对<code>operator&lt; </code>而言，假如 !(a&lt;b) &amp;&amp; !(b&lt;a) 为true且 !(b&lt;c) &amp;&amp; !(c&lt;b) 为 true<br>那么!(a&lt;c) &amp;&amp; !(c&lt;a) 也为true.<br>对判断式(predicate) <code>op()</code>而言， 假如 op(a,b), op(b,a), op(b,c), 和op(c,b) 都为<br>false, 那么op(a,c) and op(c,a) 也为false.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个定义std::set&lt;struct&gt;的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ORDERING_EXAMPLE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 重载遵循严格弱序的运算符&lt;</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> ORDERING_EXAMPLE&amp; OtherStruct) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;x &lt; OtherStruct.x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.x &lt; <span class="keyword">this</span>-&gt;x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x == x则比较y</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;y &lt; OtherStruct.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (OtherStruct.y &lt; <span class="keyword">this</span>-&gt;y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// y == y则比较z</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;z &lt; OtherStruct.z)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;ORDERING_EXAMPLE&gt; setOrderingExample;</span><br><span class="line"></span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample0 = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample1 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    ORDERING_EXAMPLE stOrderingExample3 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample0);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample1);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample2);</span><br><span class="line">    setOrderingExample.<span class="built_in">insert</span>(stOrderingExample3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面举一个会崩溃的例子对二维数组排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">5</span>, temp);</span><br><span class="line">  std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;l, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;r) &#123;</span><br><span class="line">              <span class="keyword">if</span> (l.<span class="built_in">size</span>() == r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; l.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (l.<span class="built_in">at</span>(i) == r.<span class="built_in">at</span>(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> l.<span class="built_in">at</span>(i) &lt; r.<span class="built_in">at</span>(i);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/// 这里会崩溃，改为false则不会而不会崩溃(遵循严格弱序)</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> l.<span class="built_in">size</span>() &lt; r.<span class="built_in">size</span>();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个参数的重载符号简单示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">key</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> key&amp; stOther)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; stOther.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; stOther.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/" class="post-title-link" itemprop="url">C++关于乘法溢出的判断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-03 21:22:47" itemprop="dateCreated datePublished" datetime="2020-07-03T21:22:47+08:00">2020-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先我们对于乘法溢出的判断，先写测试用例：</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715337389.png" alt="1592715337389"></p>
<p>由上图我们简化测试用例：</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592715602260.png" alt="1592715602260"></p>
<p>我们可以这样设计乘法溢出函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们添加测试用例</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727579022.png" alt="1592727579022"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">      <span class="keyword">return</span> x &gt; INT_MAX/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; INT_MIN/-y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况稍等补上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来为特殊数值来添加判断：</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592727736048.png" alt="1592727736048"></p>
<p>添加异号情况的判断：</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730284047.png" alt="1592730284047"></p>
<p>把函数改为模板，一并添加测试用例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断两入参相乘是否溢出，溢出返回true，否则返回false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_multi_overflow</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value,</span><br><span class="line">                <span class="string">&quot;is_multi_overflow need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot; is_multi_overflow need integral type!&quot;</span>);</span><br><span class="line">  <span class="type">int</span> num_max = std::numeric_limits&lt;T1&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> num_min = std::numeric_limits&lt;T1&gt;::<span class="built_in">min</span>();</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">1</span> || y == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y == num_min;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x == num_min;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为正号</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; num_max / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// 同为负号</span></span><br><span class="line">    <span class="keyword">if</span> (y == num_min &amp;&amp; x &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / -y;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> || (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/// 异号的情况</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &lt; num_min / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  <span class="type">int</span> min_num = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #1</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span> + max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 1 #2</span></span><br><span class="line">  x = <span class="number">7</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = max_num - <span class="number">1</span>;</span><br><span class="line">  y = max_num / x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #1</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 2 #2</span></span><br><span class="line">  x = <span class="number">-7</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num + <span class="number">1</span>;</span><br><span class="line">  y = min_num / -x;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 3</span></span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = min_num;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 4</span></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = INT_MIN;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 5</span></span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = max_num;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  x = <span class="number">-1</span>;</span><br><span class="line">  y = min_num;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// case 6</span></span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  y = <span class="number">-1</span> + min_num / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(x, y));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_multi_overflow</span>(y, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后附上完整测试用例：</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A4%E6%96%AD/1592730393076.png" alt="1592730393076"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我们既然有了判断乘法溢出的函数，我们可以借此封装一个带有检查溢出的乘法函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">std::optional&lt;T1&gt; <span class="title">multiplies_s</span><span class="params">(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;T1, T2&gt;::value, <span class="string">&quot;Multiplies_s need same type!&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_integral&lt;T1&gt;::value,</span><br><span class="line">                <span class="string">&quot;Multiplies_s need integral type!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_multi_overflow</span>(x, y)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">multiplies_s</span>(x, y).<span class="built_in">value_or</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiancong Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiancong Li's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/03/2020-07-03-C++%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++关于虚析构函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-03 20:21:05" itemprop="dateCreated datePublished" datetime="2020-07-03T20:21:05+08:00">2020-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-28 14:29:44" itemprop="dateModified" datetime="2023-10-28T14:29:44+08:00">2023-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="虚析构函数问题"><a href="#虚析构函数问题" class="headerlink" title="虚析构函数问题"></a>虚析构函数问题</h2><blockquote>
<p>引用标准中原文：  一条有用的方针，是任何基类的析构函数必须为公开且虚， 或受保护且非虚。</p>
</blockquote>
<p>虚析构这个概念被设计出来就是<strong>为了解决基类指针指向派生类实例的析构问题</strong>，当一个基类指针指向派生类实例然后进行delete该指针时，只会执行基类析构函数而派生类的析构函数不会被执行，这将导致派生类构造的资源不会被正确释放，造成内存泄漏。如下示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/// 该析构函数为错误示例，严禁这样写.</span></span><br><span class="line">     ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug.png" alt="Virtual DeConstruct Debug"></p>
<p>可以看到派生类没有被析构，如要解决该问题在基类析构函数处加上<strong>virtual</strong>关键字即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">     <span class="comment">/** 正确写法： 加上关键字virtual， 后面函数体可写可不写，或者直接使用=default都行。 */</span></span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>()   &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Construct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Deconstruct!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">/// 或者 virtual ~Derived() override &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 使用基类指针指向派生类实例 */</span></span><br><span class="line">        Base* BasePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">        <span class="keyword">delete</span> BasePtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/resource/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/Virtual_DeConstruct_Debug_Correct.png" alt="Virtual DeConstruct Debug Correct"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiancong Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiancong Li</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
