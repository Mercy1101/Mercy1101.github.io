<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mercy1101.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="假设我们使用的是多核 CPU，且无法避免使用多线程。站在产品的稳定性和性能优化的角度，对线程知识进行简介。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++线程知识简介">
<meta property="og:url" content="https://mercy1101.github.io/2024/03/27/2024-03-19-C++%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/index.html">
<meta property="og:site_name" content="李建聪的博客">
<meta property="og:description" content="假设我们使用的是多核 CPU，且无法避免使用多线程。站在产品的稳定性和性能优化的角度，对线程知识进行简介。">
<meta property="og:locale">
<meta property="og:image" content="https://mercy1101.github.io/resource/2024-03-19-thread/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B-%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png">
<meta property="og:image" content="https://mercy1101.github.io/2024/03/27/2024-03-19-C++%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/resource/2024-03-19-thread/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B-%E6%B5%81%E7%A8%8B%E5%9B%BE-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9C%BA.drawio.png">
<meta property="article:published_time" content="2024-03-27T09:06:47.611Z">
<meta property="article:modified_time" content="2025-01-22T07:04:01.975Z">
<meta property="article:author" content="李建聪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mercy1101.github.io/resource/2024-03-19-thread/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B-%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png">

<link rel="canonical" href="https://mercy1101.github.io/2024/03/27/2024-03-19-C++%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'cn'
  };
</script>

  <title>C++线程知识简介 | 李建聪的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李建聪的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://mercy1101.github.io/2024/03/27/2024-03-19-C++%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李建聪">
      <meta itemprop="description" content="在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李建聪的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++线程知识简介
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-03-27 17:06:47" itemprop="dateCreated datePublished" datetime="2024-03-27T17:06:47+08:00">2024-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-01-22 15:04:01" itemprop="dateModified" datetime="2025-01-22T15:04:01+08:00">2025-01-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>假设我们使用的是多核 CPU，且无法避免使用多线程。站在产品的稳定性和性能优化的角度，对线程知识进行简介。</p>
<span id="more"></span>
<h2 id="目的">目的</h2>
<p>假设我们使用的是多核 CPU，且无法避免使用多线程。站在产品的稳定性和性能优化的角度，对线程知识进行简介。</p>
<h2 id="范围">范围</h2>
<p>为了在多线程的编程环境中，更好发挥多核CPU的性能，并对多线程相关的缺陷加以了解并进行规避。着重于讲<code>并行</code>而非<code>并发</code>的情况。</p>
<p>并行(<code>Parallel</code>)与并发(<code>Concurrent</code>):</p>
<ul>
<li>并行: 单线程。</li>
<li>并发: 多线程。</li>
</ul>
<p>并发:</p>
<table>
<thead>
<tr>
<th style="text-align:center">任务1</th>
<th style="text-align:center">任务2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">执行语句1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">执行语句2</td>
</tr>
<tr>
<td style="text-align:center">执行语句3</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">执行语句4</td>
</tr>
</tbody>
</table>
<p>并行:</p>
<table>
<thead>
<tr>
<th style="text-align:center">任务1</th>
<th style="text-align:center">任务2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">执行语句1</td>
<td style="text-align:center">执行语句2</td>
</tr>
</tbody>
</table>
<h2 id="热身">热身</h2>
<ol>
<li>一个数据如果一个时刻是只读的，那么在这个时刻该数据是线程安全的。</li>
<li>一个数据被多个线程同时读写，那么该数据是线程不安全的。</li>
<li>在同一个线程中，对一个普通互斥量加锁两次，会发生死锁。</li>
<li><code>int</code>、<code>unsigned</code>、<code>char</code>、<code>double</code> 等基本类型，均为线程不安全的。</li>
<li>互斥量的创建、加锁和解锁操作本身，并不耗时。</li>
</ol>
<h2 id="场景">场景</h2>
<h3 id="线程间共享数据">线程间共享数据</h3>
<p>场景举例:</p>
<ol>
<li><img src="/resource/2024-03-19-thread/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B-%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png" alt=""></li>
<li>通信线程之间同步消息序列号。</li>
<li>ATS线程写入列车信息，其他线程读取。</li>
</ol>
<ul>
<li>C++ STL 互斥量版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">....</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>C++ STL 读写锁版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_mutex mutex;</span><br><span class="line"><span class="type">int</span> sharedData = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readerThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writerThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    sharedData += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">写入线程</th>
<th style="text-align:center">读取线程1</th>
<th style="text-align:center">读取线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">readerThread()</td>
<td style="text-align:center">readerThread()</td>
</tr>
<tr>
<td style="text-align:center">writerThread()</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li>C++ STL 原子变量版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 线程安全</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 线程安全</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Windows API 版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hMutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建互斥量</span></span><br><span class="line">hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hMutex == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭互斥量</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hMutex);</span><br></pre></td></tr></table></figure>
<ul>
<li>Windows 临界区版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"><span class="comment">// 初始化临界区</span></span><br><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="comment">// 删除临界区</span></span><br><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure>
<p>注: <code>EnterCriticalSection</code> 和 <code>WaitForSingleObject</code> 的区别:</p>
<ol>
<li><code>WaitForSingleObject</code> 因为涉及到 用户态和内核态的切换，更慢。</li>
<li><code>WaitForSingleObject</code> 可以用于进程间的同步，而 <code>EnterCriticalSection</code> 不能。</li>
<li><code>WaitForSingleObject</code> 可以达到超时等待的效果，而 <code>EnterCriticalSection</code> 会一直等待。</li>
<li>在同一线程中多次调用 <code>WaitForSingleObject</code> 和 <code>EnterCriticalSection</code> 都不会产生死锁。</li>
</ol>
<ul>
<li>pthread 版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br></pre></td></tr></table></figure>
<ul>
<li>注:<code>pthread_mutex_t</code> 默认是不可被同一线程加锁两次的，即不可重入。如果想要可以重入则需要设置属性。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line"><span class="built_in">pthread_mutexattr_init</span>(&amp;mutex_attr);</span><br><span class="line"><span class="built_in">pthread_mutexattr_settype</span>(&amp;mutex_attr, PTHREAD_MUTEX_RECURSIVE); <span class="comment">// 设置为可重入</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex, &amp;mutex_attr); <span class="comment">// 使用属性，初始化互斥量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>gos 库版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HANDLE mutex_ = <span class="built_in">gos_mutex_init</span>();</span><br><span class="line"><span class="built_in">gos_mutex</span>(mutex_);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">gos_unmutex</span>(mutex_);</span><br><span class="line"><span class="built_in">gos_mutex_free</span>(mutex_);</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ol>
<li>gos 库版本的互斥量，在 <code>window</code> 下是可重入的, 在 <code>linux</code> 下是不可重入的。</li>
</ol>
<h3 id="后台运行周期性任务">后台运行周期性任务</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NTPClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 进行NTP同步, 后台线程周期运行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ntp_sync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/// 获取NTP是否成功, 业务线程调用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get_ntp_valid</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++ STL 标准库版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NTPClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntp_sync_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        client.<span class="built_in">ntp_sync</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(ntp_sync_thread)</span></span>;</span><br><span class="line"><span class="comment">/// 分离线程</span></span><br><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread 版本:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span>      stAttr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设置 pthread 属性</span></span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;stAttr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;stAttr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化线程</span></span><br><span class="line"><span class="type">pthread_t</span> thread_id;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;thread_id, <span class="literal">NULL</span>, threadFunction, &amp;client);</span><br></pre></td></tr></table></figure>
<ul>
<li>windows 版本:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 1. Windows API:</span></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, threadFunction, &amp;client, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 分离线程</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2. Vistual C++ CRT 版本</span></span><br><span class="line"><span class="type">uintptr_t</span> hThread = _beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, threadFunction, &amp;client, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>为什么选择 <code>_beginthreadex</code> 而不是 <code>CreateThread</code>?</p>
<p><code>_beginthreadex</code> 为每个线程分配自己的<code>tiddata</code>内存结构, 其中保存了 C 语言中的全局变量, 如 <code>errno</code>。</p>
<p>参考资料: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022036.html">windows 多线程： CreateThread、_beginthread、_beginthreadex、AfxBeginThread 的区别</a></p>
<ul>
<li>gos 库版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NTPClientThread</span>: <span class="keyword">public</span> GThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">NTPClientThread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> GOS_THREAD_RET <span class="title">ThreadEntry</span><span class="params">(<span class="type">void</span>* pPara)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            client.<span class="built_in">ntp_sync</span>();</span><br><span class="line">            GThread::<span class="built_in">Sleep</span>(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NTPClient client;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后台运行耗时任务-一次性任务">后台运行耗时任务(一次性任务)</h3>
<p>场景举例:</p>
<ol>
<li>耗时函数放到后台运行，结果想要获取时再主动获取。</li>
<li>两个执行时间非常长的函数，并行执行可节省时间。</li>
<li>等待打印机打印的同时，继续执行其他任务。</li>
</ol>
<p>实现思路:</p>
<ol>
<li>启动一个线程，运行一个函数，函数运行结束，线程退出。</li>
<li>业务线程: 创建后台线程。</li>
<li>后台线程: 运行函数，函数结束后退出。</li>
<li>业务线程: 等待后台线程结束后，取得函数结果。</li>
</ol>
<ul>
<li>C++ STL 标准库版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([&amp;i]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    i = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++ STL 异步版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::async 在后台执行函数并获取结果</span></span><br><span class="line"><span class="keyword">auto</span> future = std::<span class="built_in">async</span>(std::launch::async, [&amp;i]() &#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束并获取结果</span></span><br><span class="line">i = future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>Windows API 版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">f</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, f, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程句柄</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread 版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> t;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;t, <span class="literal">NULL</span>, f, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待后台线程结束</span></span><br><span class="line"><span class="built_in">pthread_join</span>(t, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程函数结果</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="线程主动停止与资源释放">线程主动停止与资源释放</h2>
<p>线程正在运行时，对线程进行销毁(free, delete)，可能会访问到已经被释放的内存，导致程序崩溃。</p>
<p>因此，线程停止时需要等待线程结束后再释放资源。</p>
<p>对于 <code>joinable</code> 的线程，需要调用 <code>join</code> 函数等待线程结束后再释放资源。</p>
<p>但对于 <code>detach</code> 的线程，如何知晓线程函数执行完毕。</p>
<p>场景举例: 视频播放线程的主动停止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPlayAndRec</span> : <span class="keyword">public</span> GThread</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">ThreadPlayAndRec* p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">p-&gt;<span class="built_in">Start</span>();</span><br><span class="line">...</span><br><span class="line">p-&gt;<span class="built_in">Stop</span>();</span><br><span class="line"><span class="comment">/// 通知线程结束后需要等待多久，线程函数才会结束</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>解决办法: 设置结束标识位来判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ThreadPlayAndRec::Free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ulThreadState = THREAD_STATE_CLOSING;</span><br><span class="line">    <span class="built_in">Stop</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_ulThreadState == THREAD_STATE_FREE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">gos_sleep_1ms</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPlayAndRec* p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">p-&gt;<span class="built_in">Start</span>(); <span class="comment">///&lt; 通知线程开始</span></span><br><span class="line">...</span><br><span class="line">p-&gt;<span class="built_in">Stop</span>(); <span class="comment">///&lt; 通知线程结束</span></span><br><span class="line">p-&gt;<span class="built_in">Free</span>(); <span class="comment">///&lt; 阻塞等待线程结束</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p><img src="resource/2024-03-19-thread/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B-%E6%B5%81%E7%A8%8B%E5%9B%BE-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9C%BA.drawio.png" alt=""></p>
<p>温州S2项目对 GThread 的改动:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">p-&gt;<span class="built_in">Start</span>(); <span class="comment">///&lt; 通知线程开始</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">///&lt; 等待线程结束后, 释放资源</span></span><br></pre></td></tr></table></figure>
<h2 id="线程唤醒（线程池）">线程唤醒（线程池）</h2>
<p>场景举例: 线程池中的线程，在任务队列出现任务时，唤醒一个线程进行处理。</p>
<ul>
<li>Linux 信号量举例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 初始化</span></span><br><span class="line"><span class="built_in">sem_init</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 等待信号量唤醒</span></span><br><span class="line"><span class="built_in">sem_wait</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 信号量唤醒</span></span><br><span class="line"><span class="built_in">sem_post</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 回收资源</span></span><br><span class="line"><span class="built_in">sem_destroy</span>()</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">生产者线程</th>
<th style="text-align:center">业务线程1</th>
<th style="text-align:center">业务线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始化 sem_init()</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">等待唤醒 sem_wait()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">等待唤醒 sem_wait()</td>
</tr>
<tr>
<td style="text-align:center">消息入列 sem_post()</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">被唤醒后, 取出消息并处理</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">回收资源 sem_destroy()</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li>pthread 条件变量版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunction</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread received signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, threadFunction, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 主线程等待一段时间后发送信号</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 唤醒线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++ STL 风格代码举例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="comment">/// 这个封装好的函数放入任务列表中</span></span><br><span class="line">    tasks.<span class="built_in">emplace</span>(&amp;f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通知一个阻塞中的线程，任务队列中有任务了</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">    <span class="comment">/// 阻塞等待直到函数返回 true</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">    <span class="comment">/// 从任务队列中拿出来一个任务</span></span><br><span class="line">    task = <span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">生产者线程</th>
<th style="text-align:center">业务线程1</th>
<th style="text-align:center">业务线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">条件变量阻塞等待(<code>wait()</code>)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">条件变量阻塞等待(<code>wait()</code>)</td>
</tr>
<tr>
<td style="text-align:center">消息入列</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">唤醒线程(<code>notify_one()</code>)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">被唤醒(条件变量停止阻塞)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">获取消息并执行业务</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="线程安全中所涉及的问题">线程安全中所涉及的问题</h2>
<h3 id="死锁">死锁</h3>
<ul>
<li>情况1:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取互斥量1</td>
<td style="text-align:center">获取互斥量2</td>
</tr>
<tr>
<td style="text-align:center">获取互斥量2</td>
<td style="text-align:center">获取互斥量1</td>
</tr>
</tbody>
</table>
<p>解决办法：</p>
<ol>
<li>一次只获取一个互斥量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 STL 的语法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mutex1, mutex2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread acquired locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>情况2:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取互斥量1</td>
</tr>
<tr>
<td style="text-align:center">获取互斥量1</td>
</tr>
</tbody>
</table>
<p>解决办法:</p>
<ol>
<li>使用带有可重入属性的互斥量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// STL</span></span><br><span class="line">std::recursive_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// pthread</span></span><br><span class="line"><span class="built_in">pthread_mutexattr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_mutexattr_settype</span>(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// window API</span></span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure>
<ul>
<li>情况3:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">等待线程2 join</td>
<td style="text-align:center">等待线程1 join</td>
</tr>
</tbody>
</table>
<p>解决办法:</p>
<ol>
<li>在同一线程创建其他线程，也在同一线程进行 join。</li>
</ol>
<h3 id="ABA问题">ABA问题</h3>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">查询余额, 并存储进变量 i</td>
<td style="text-align:center">查询余额, 并存储进变量 i</td>
</tr>
<tr>
<td style="text-align:center">if(i &gt;= 50)</td>
<td style="text-align:center">if(i &gt;= 50)</td>
</tr>
<tr>
<td style="text-align:center">i = i - 50;</td>
<td style="text-align:center">i = i - 50;</td>
</tr>
<tr>
<td style="text-align:center">更新余额为 50</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">更新余额为 50</td>
</tr>
</tbody>
</table>
<p>解决办法:</p>
<ol>
<li>串行执行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">|          线程<span class="number">1</span>           |          线程<span class="number">2</span>           |</span><br><span class="line">| :----------------------: | :----------------------: |</span><br><span class="line">|     获取互斥量 mtx1      |     获取互斥量 mtx1      |</span><br><span class="line">|      获取互斥量成功      |                          |</span><br><span class="line">| 查询余额, 并存储进变量 i |                          |</span><br><span class="line">|       <span class="keyword">if</span>(i &gt;= <span class="number">50</span>)        |                          |</span><br><span class="line">|       i = i - <span class="number">50</span>;        |                          |</span><br><span class="line">|      更新余额为 <span class="number">50</span>       |                          |</span><br><span class="line">|        释放互斥量        |                          |</span><br><span class="line">|                          |      获取互斥量成功      |</span><br><span class="line">|                          | 查询余额, 并存储进变量 i |</span><br><span class="line">|                          |       <span class="keyword">if</span>(i &gt;= <span class="number">100</span>)       |</span><br><span class="line">|                          |       i = i - <span class="number">50</span>;        |</span><br><span class="line">|                          |      更新余额为 <span class="number">50</span>       |</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 使用 <span class="built_in">CAS</span>(Compare And Swap) 的方法</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">|                        线程<span class="number">1</span>                         |                        线程<span class="number">2</span>                         |</span><br><span class="line">| :--------------------------------------------------: | :--------------------------------------------------: |</span><br><span class="line">|               查询余额, 并存储进变量 i               |               查询余额, 并存储进变量 i               |</span><br><span class="line">|                     <span class="keyword">if</span>(i == <span class="number">100</span>)                     |                     <span class="keyword">if</span>(i == <span class="number">100</span>)                     |</span><br><span class="line">|                     i = i - <span class="number">50</span>;                      |                     i = i - <span class="number">50</span>;                      |</span><br><span class="line">| 如果当前值为 <span class="number">100</span> 则更新约为 <span class="number">50</span>(compare_and_exchange) |                                                      |</span><br><span class="line">|                  更新成功，事务结束                  |                                                      |</span><br><span class="line">|                                                      | 如果当前值为 <span class="number">100</span> 则更新约为 <span class="number">50</span>(compare_and_exchange) |</span><br><span class="line">|                                                      |                  更新失败，事务结束                  |</span><br></pre></td></tr></table></figure>
<h3 id="初始化单例">初始化单例</h3>
<p>C++11之前以下全局变量，线程不安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec g_ThreadPlayAndRec; <span class="comment">///&lt; 全局变量,在程序启动时线程不安全</span></span><br></pre></td></tr></table></figure>
<ul>
<li>错误的做法1:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">if(!p)</td>
<td style="text-align:center">if(!p)</td>
</tr>
<tr>
<td style="text-align:center">new ThreadPlayAndRec();</td>
<td style="text-align:center">new ThreadPlayAndRec();</td>
</tr>
<tr>
<td style="text-align:center">p 被赋值</td>
<td style="text-align:center">p 被赋值</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">if(!p)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">new ThreadPlayAndRec();</td>
<td style="text-align:center">if(!p)</td>
</tr>
<tr>
<td style="text-align:center">p 被赋值</td>
<td style="text-align:center">new ThreadPlayAndRec();</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">p 被赋值</td>
</tr>
</tbody>
</table>
<ul>
<li>错误的做法2:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p) <span class="comment">// 第一次检查</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="comment">// 第二次检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常流程:</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">if(!p)  第一次检查</td>
<td style="text-align:center">if(!p)  第一次检查</td>
</tr>
<tr>
<td style="text-align:center">尝试获取互斥量</td>
<td style="text-align:center">尝试获取互斥量</td>
</tr>
<tr>
<td style="text-align:center">获取互斥量成功</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">if(!p) 再次判断是否为空</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">new ThreadPlayAndRec();</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">p 被赋值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">释放互斥量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">获取互斥量成功</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">if(!p) 再次判断是否为空</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">p 不为空，流程结束</td>
</tr>
</tbody>
</table>
<p>错误流程:</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">if(!p)  第一次检查</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">尝试获取互斥量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">获取互斥量成功</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">if(!p) 再次判断是否为空</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">new ThreadPlayAndRec();</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">p 被赋值</td>
<td style="text-align:center">if(!p)  第一次检查</td>
</tr>
</tbody>
</table>
<p>最后一步产生了读写竞争。</p>
<ul>
<li>解决办法:</li>
</ul>
<ol>
<li>在 C++11 标准下使用 全局/静态变量。</li>
<li>使用 C++11 中提供的 <code>std::call_once</code> 保证初始化函数只被调用一次。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::once_flag flag;</span><br><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line">std::<span class="built_in">call_once</span>(flag, []() &#123; p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>(); &#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用互斥量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPlayAndRec* p = <span class="literal">NULL</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">ThreadPlayAndRec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在 C++11 之前，使用 <code>Linux API</code> 或者 <code>Windows API</code> 函数。</li>
</ol>
<p>linux:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialization function executed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只会执行一次</span></span><br><span class="line"><span class="built_in">pthread_once</span>(&amp;once_control, init_function);</span><br></pre></td></tr></table></figure>
<p>windows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line"><span class="keyword">if</span> (!initialized)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init_function</span>();</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>
<p>不管, 成本最低也是最适合我们的方法。</p>
</li>
<li>
<p>使用 <code>gos::singleton</code>, 其实现思路是 C++11 之前使用 double-check lock 的方法， C++11 之后使用 <code>std::call_once</code>。</p>
</li>
</ol>
<h3 id="多个线程同时开始">多个线程同时开始</h3>
<p>测试线程需要被测试函数同时并行执行。</p>
<ul>
<li>C++ STL 条件变量实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex_;</span><br><span class="line">std::condition_variable cv_;</span><br><span class="line"><span class="type">bool</span> ready_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::jthread <span class="title">j</span><span class="params">([<span class="keyword">this</span>]() <span class="keyword">mutable</span></span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::unique_lock&lt;std::mutex&gt; mutex(mutex_);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">/// 等待同步开始</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    cv_.wait(mutex, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> ready_; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">/// 执行函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    f();</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;)</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 锁定互斥量，以修改 ready_</span></span><br><span class="line">mutex_.<span class="built_in">lock</span>();</span><br><span class="line">ready_ = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/// 发送给所有的线程，可以开始运行</span></span><br><span class="line">cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">mutex_.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<h3 id="隐藏的多线程问题">隐藏的多线程问题</h3>
<ul>
<li>
<p>场景1: 在通信线程，直接使用修改界面的语句。<br>
注: 界面有自己的线程调度，如果在其他线程中直接修改界面，可能会导致界面崩溃。</p>
</li>
<li>
<p>场景2: 在回调函数中使用共享变量(全局、静态或类成员变量)。<br>
注: 回调函数一定在其他线程中执行，如果在回调函数中使用共享变量，可能会导致线程不安全。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/09/2023-11-09-Issue%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%AE/" rel="prev" title="Issue 规范化建议">
      <i class="fa fa-chevron-left"></i> Issue 规范化建议
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/01/22/2025-01-22-%E5%8D%9A%E5%AE%A2%E5%93%81%E6%8E%A7%E6%89%8B%E5%86%8C/" rel="next" title="博客品控手册">
      博客品控手册 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4"><span class="nav-number">2.</span> <span class="nav-text">范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%83%AD%E8%BA%AB"><span class="nav-number">3.</span> <span class="nav-text">热身</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF"><span class="nav-number">4.</span> <span class="nav-text">场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">4.1.</span> <span class="nav-text">线程间共享数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.2.</span> <span class="nav-text">后台运行周期性任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1-%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.3.</span> <span class="nav-text">后台运行耗时任务(一次性任务)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%BB%E5%8A%A8%E5%81%9C%E6%AD%A2%E4%B8%8E%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="nav-number">5.</span> <span class="nav-text">线程主动停止与资源释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%94%A4%E9%86%92%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">线程唤醒（线程池）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%AD%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">线程安全中所涉及的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">7.1.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-number">7.2.</span> <span class="nav-text">ABA问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E4%BE%8B"><span class="nav-number">7.3.</span> <span class="nav-text">初始化单例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E5%BC%80%E5%A7%8B"><span class="nav-number">7.4.</span> <span class="nav-text">多个线程同时开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="nav-number">7.5.</span> <span class="nav-text">隐藏的多线程问题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李建聪</p>
  <div class="site-description" itemprop="description">在不断开放的世界中，我们的力量来源于我们能构建的连接，而非单一的智慧。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiancong Li</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
